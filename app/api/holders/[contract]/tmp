async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState) {
  if (!contractAddress) throw new Error('Contract address missing');
  if (!abi) throw new Error(`${contractKey} ABI missing`);

  const requiredFunctions = contractKey === 'ascendant' ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute'] : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
  const missingFunctions = requiredFunctions.filter(fn => !abi.some(item => item.name === fn));
  if (missingFunctions.length > 0) throw new Error(`Missing ABI functions: ${missingFunctions.join(', ')}`);

  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const holdersMap = new Map();
  let totalBurned = 0;
  let nonExistentCount = 0;
  let burnedCount = 0;
  const errorLog = [];

  cacheState.progressState.step = 'fetching_supply';
  await saveCacheStateContract(contractKey, cacheState);

  let currentBlock;
  try {
    currentBlock = await client.getBlockNumber();
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (contractKey === 'ascendant') {
    // Ascendant-specific logic (unchanged)
    const owners = await retry(() => getOwnersForContract(contractAddress, abi));
    cacheState.progressState.totalNfts = owners.length;
    cacheState.progressState.totalTiers = owners.length;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    const filteredOwners = owners.filter(owner => owner.ownerAddress.toLowerCase() !== burnAddress);
    const tokenOwnerMap = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      if (!owner.ownerAddress) return;
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenId = Number(owner.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });

    cacheState.progressState.step = 'fetching_tiers';
    await saveCacheStateContract(contractKey, cacheState);

    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi,
      functionName: 'getNFTAttribute',
      args: [BigInt(tokenId)],
    }));
    const recordCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi,
      functionName: 'userRecords',
      args: [BigInt(tokenId)],
    }));

    const [tierResults, recordResults] = await Promise.all([
      retry(() => batchMulticall(tierCalls, config.alchemy.batchSize)),
      retry(() => batchMulticall(recordCalls, config.alchemy.batchSize)),
    ]);

    cacheState.progressState.step = 'fetching_shares';
    await saveCacheStateContract(contractKey, cacheState);

    const totalSharesRaw = await retry(() => client.readContract({ address: contractAddress, abi, functionName: 'totalShares' }));
    const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

    const toDistributeDay8Raw = await retry(() => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] }));
    const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

    const toDistributeDay28Raw = await retry(() => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] }));
    const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

    const toDistributeDay90Raw = await retry(() => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] }));
    const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

    const maxTier = Math.max(...Object.keys(config.contractTiers[contractKey]).map(Number));
    const walletTokenIds = new Map();
    allTokenIds.forEach(tokenId => {
      const wallet = tokenOwnerMap.get(tokenId);
      if (!wallet) return;
      if (!walletTokenIds.has(wallet)) walletTokenIds.set(wallet, []);
      walletTokenIds.get(wallet).push(tokenId);
    });

    const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
      address: contractAddress,
      abi,
      functionName: 'batchClaimableAmount',
      args: [tokenIds.map(id => BigInt(id))],
    }));

    const claimableResults = await retry(() => batchMulticall(claimableCalls, config.alchemy.batchSize));

    allTokenIds.forEach((tokenId, i) => {
      const wallet = tokenOwnerMap.get(tokenId);
      if (!wallet) return;
      if (!holdersMap.has(wallet)) {
        holdersMap.set(wallet, {
          wallet,
          total: 0,
          multiplierSum: 0,
          tiers: Array(maxTier + 1).fill(0),
          shares: 0,
          lockedAscendant: 0,
          pendingDay8: 0,
          pendingDay28: 0,
          pendingDay90: 0,
          claimableRewards: 0,
          percentage: 0,
          rank: 0,
          displayMultiplierSum: 0,
        });
      }
      const holder = holdersMap.get(wallet);

      const tierResult = tierResults[i];
      let tier;
      if (tierResult?.status === 'success') {
        if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
          tier = Number(tierResult.result[1]);
        } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
          tier = Number(tierResult.result.tier);
        }
      }
      if (tier >= 1 && tier <= maxTier) {
        holder.tiers[tier] += 1;
        holder.total += 1;
        holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
      }

      const recordResult = recordResults[i];
      if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
        const sharesRaw = recordResult.result[0] || '0';
        const lockedAscendantRaw = recordResult.result[1] || '0';
        holder.shares += parseFloat(formatUnits(sharesRaw, 18));
        holder.lockedAscendant += parseFloat(formatUnits(lockedAscendantRaw, 18));
      }
    });

    let claimableIndex = 0;
    for (const [wallet, _tokenIds] of walletTokenIds.entries()) {
      const holder = holdersMap.get(wallet);
      if (!holder) {
        claimableIndex++;
        continue;
      }
      if (claimableResults[claimableIndex]?.status === 'success') {
        holder.claimableRewards = parseFloat(formatUnits(claimableResults[claimableIndex].result || '0', 18));
      }
      claimableIndex++;
    }

    const holders = Array.from(holdersMap.values());
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
    const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
    const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

    holders.forEach(holder => {
      holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
      holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
      holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.rank = 0;
      holder.displayMultiplierSum = holder.multiplierSum;
    });

    holders.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => (holder.rank = index + 1));

    cacheState.totalOwners = holders.length;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = cacheState.progressState.totalNfts;
    cacheState.progressState.processedTiers = cacheState.progressState.totalTiers;
    cacheState.progressState.error = null;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    return { holdersMap, totalBurned: owners.length - totalTokens, lastBlock: Number(currentBlock), totalShares, toDistributeDay8, toDistributeDay28, toDistributeDay90, pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90 };
  } else {
    // Standard logic (Element280, Element369, Stax, E280)
    const totalSupply = await retry(
      async () => {
        const result = await client.readContract({
          address: contractAddress,
          abi,
          functionName: 'totalSupply',
        });
        if (result === null || result === undefined) throw new Error('totalSupply returned null');
        return Number(result);
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );

    const burnedCountContract = await retry(
      async () => {
        const result = await client.readContract({
          address: contractAddress,
          abi,
          functionName: 'totalBurned',
        });
        if (result === null || result === undefined) throw new Error('totalBurned returned null');
        return Number(result);
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );

    totalBurned = burnedCountContract || 0;
    cacheState.progressState.totalNfts = totalSupply || 0;
    cacheState.progressState.totalTiers = totalSupply || 0;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    if (totalSupply === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheStateContract(contractKey, cacheState);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
    }

    cacheState.progressState.step = 'fetching_owners';
    await saveCacheStateContract(contractKey, cacheState);

    const batchSize = config.alchemy.batchSize || 10;
    const tokenIds = Array.from({ length: totalSupply }, (_, i) => i + 1);
    for (let i = 0; i < tokenIds.length; i += batchSize) {
      const batchTokenIds = tokenIds.slice(i, i + batchSize);
      const ownerPromises = batchTokenIds.map(tokenId =>
        limit(() =>
          retry(
            async () => {
              try {
                const result = await client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'ownerOf',
                  args: [tokenId],
                });
                return result.toLowerCase() === burnAddress.toLowerCase() ? null : result;
              } catch (error) {
                if (error.message.includes('OwnerQueryForNonexistentToken')) {
                  nonExistentCount++;
                  return null;
                }
                errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_owner', tokenId, error: error.message });
                throw error;
              }
            },
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          )
        )
      );
      const owners = await Promise.all(ownerPromises);
      owners.forEach((owner, index) => {
        if (owner === null) {
          burnedCount++;
        } else if (owner) {
          const current = holdersMap.get(owner) || { wallet: owner, tokenIds: [], tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0), total: 0, multiplierSum: 0 };
          current.tokenIds.push(batchTokenIds[index]);
          current.total += 1;
          holdersMap.set(owner, current);
        }
      });
      cacheState.progressState.processedNfts = Math.min(i + batchSize, totalSupply);
      await setCache(`${contractKey.toLowerCase()}_holders_partial`, { holders: Array.from(holdersMap.values()), totalBurned, timestamp: Date.now() }, 0, contractKey.toLowerCase());
      await saveCacheStateContract(contractKey, cacheState);
    }

    cacheState.progressState.step = 'fetching_tiers';
    cacheState.progressState.processedTiers = 0;
    await saveCacheStateContract(contractKey, cacheState);

    const allTokenIds = Array.from(holdersMap.values()).flatMap(h => h.tokenIds);
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));

    if (tierCalls.length > 0) {
      const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 100;
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        try {
          const tierResults = await batchMulticall(chunk);
          tierResults.forEach((result, index) => {
            const tokenId = allTokenIds[i + index];
            let owner;
            for (const h of holdersMap.values()) {
              if (h.tokenIds.includes(tokenId)) {
                owner = h.wallet;
                break;
              }
            }
            if (!owner) return;

            const holder = holdersMap.get(owner);
            if (result.status === 'success') {
              const tier = Number(result.result);
              const maxTier = Object.keys(config.contractTiers[contractKey]).length;
              if (tier >= 1 && tier <= maxTier) {
                holder.tiers[tier - 1]++;
                holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
              } else {
                logger.warn(contractKey, `Invalid tier ${tier} for token ${tokenId}`);
              }
            } else {
              logger.error(contractKey, `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, error: result.error || 'unknown error' });
            }
          });
          cacheState.progressState.processedTiers += chunk.length;
          await saveCacheStateContract(contractKey, cacheState);
        } catch (error) {
          logger.error(contractKey, `Tier batch ${i / chunkSize + 1} failed: ${error.message}`, { stack: error.stack });
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier_batch', error: error.message });
        }
      }
    }

    // Element369-specific rewards
    if (contractKey === 'element369' && vaultAddress && vaultAbi) {
      cacheState.progressState.step = 'fetching_rewards';
      await saveCacheStateContract(contractKey, cacheState);

      const holders = Array.from(holdersMap.values());
      logger.debug(contractKey, `Fetching rewards for ${holders.length} holders`);

      // Process reward calls in smaller batches
      const rewardBatchSize = config.alchemy.batchSize || 5;
      let processedHolders = 0;
      for (let i = 0; i < holders.length; i += rewardBatchSize) {
        const batchHolders = holders.slice(i, i + rewardBatchSize);
        const rewardCalls = batchHolders.map(holder => {
          const tokenIds = holder.tokenIds;
          return {
            address: vaultAddress,
            abi: vaultAbi,
            functionName: 'getRewards',
            args: [tokenIds.map(id => BigInt(id)), holder.wallet, false],
          };
        });

        logger.debug(contractKey, `Processing reward batch ${i / rewardBatchSize + 1} with ${rewardCalls.length} calls`);

        try {
          const rewardsResults = await retry(() => batchMulticall(rewardCalls, rewardBatchSize), {
            retries: config.alchemy.maxRetries,
            delay: config.alchemy.batchDelayMs,
          });

          batchHolders.forEach((holder, j) => {
            const result = rewardsResults[j];
            if (result?.status === 'success' && result.result) {
              const [, , infernoPool, fluxPool, e280Pool] = result.result;
              holder.infernoRewards = Number(infernoPool || 0) / 1e18;
              holder.fluxRewards = Number(fluxPool || 0) / 1e18;
              holder.e280Rewards = Number(e280Pool || 0) / 1e18;
              logger.debug(contractKey, `Rewards for wallet ${holder.wallet}: inferno=${holder.infernoRewards}, flux=${holder.fluxRewards}, e280=${holder.e280Rewards}`);
            } else {
              holder.infernoRewards = 0;
              holder.fluxRewards = 0;
              holder.e280Rewards = 0;
              const errorMsg = result?.error || 'Unknown error';
              logger.error(contractKey, `Failed to fetch rewards for wallet ${holder.wallet}: ${errorMsg}`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', wallet: holder.wallet, error: errorMsg });
            }
            holdersMap.set(holder.wallet, holder);
          });

          processedHolders += batchHolders.length;
          cacheState.progressState.processedNfts = processedHolders;
          cacheState.progressState.processedTiers = processedHolders; // Reuse for rewards progress
          await saveCacheStateContract(contractKey, cacheState);
          logger.debug(contractKey, `Processed ${processedHolders}/${holders.length} holders for rewards`);
        } catch (error) {
          logger.error(contractKey, `Reward batch ${i / rewardBatchSize + 1} failed: ${error.message}`, { stack: error.stack });
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards_batch', batch: i / rewardBatchSize + 1, error: error.message });
          // Continue to next batch instead of failing
        }
      }
    }

    // Element280 or Stax rewards
    if ((contractKey === 'element280' || contractKey === 'stax') && vaultAddress && vaultAbi) {
      cacheState.progressState.step = 'fetching_rewards';
      await saveCacheStateContract(contractKey, cacheState);

      const holders = Array.from(holdersMap.values());
      const rewardCalls = holders.flatMap(holder =>
        holder.tokenIds.map(tokenId => ({
          address: vaultAddress,
          abi: vaultAbi,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], holder.wallet],
        }))
      );

      const rewardResults = await batchMulticall(rewardCalls);
      let resultIndex = 0;
      holders.forEach(holder => {
        let totalRewards = 0n;
        holder.tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          }
        });
        holder.claimableRewards = Number(totalRewards) / 1e18;
        if (isNaN(holder.claimableRewards)) {
          holder.claimableRewards = 0;
        }
      });
    }

    // Compute metrics
    cacheState.progressState.step = 'calculating_metrics';
    await saveCacheStateContract(contractKey, cacheState);

    const holders = Array.from(holdersMap.values());
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
    });

    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => (holder.rank = index + 1));

    cacheState.totalOwners = holders.length;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = cacheState.progressState.totalNfts;
    cacheState.progressState.processedTiers = cacheState.progressState.totalTiers;
    cacheState.progressState.error = null;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
  }
}