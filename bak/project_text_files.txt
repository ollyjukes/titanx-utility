-e 
---
File: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};-e 
---
File: ./.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI-e 
---
File: ./app/layout.js

// app/layout.js
'use client';
import './layout.css';
import { Inter } from 'next/font/google';
import Navbar from '../components/Navbar';
import ClientProvider from './ClientProvider';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={`${inter.className} bg-gray-900 text-white`}>
        <ClientProvider>
          <Navbar />
          <main className="pt-16">{children}</main>
        </ClientProvider>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-gray-300">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
// app/nft/layout.js
'use client';
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(contractDetails).map((key) => ({
    name: contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    const cachedData = getCache(contractKey);
    if (cachedData) {
      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
      return cachedData;
    }

    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }

    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];
    let allHolders = [];
    let totalTokens = 0;
    let totalLockedAscendant = 0;
    let totalShares = 0;
    let toDistributeDay8 = 0;
    let toDistributeDay28 = 0;
    let toDistributeDay90 = 0;
    let pendingRewards = 0;
    let page = 0;
    let totalPages = Infinity;

    try {
      while (page < totalPages) {
        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);
        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
          signal: AbortSignal.timeout(30000),
        });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);
        }
        const json = await res.json();
        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders.length}`);
        allHolders = allHolders.concat(json.holders || []);
        totalTokens = json.totalTokens || totalTokens;
        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
        totalShares = json.totalShares || totalShares;
        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
        pendingRewards = json.pendingRewards || pendingRewards;
        totalPages = json.totalPages || 1;
        page++;
        if (!json.holders || json.holders.length === 0) break;
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
      });
      let uniqueHolders = Array.from(uniqueHoldersMap.values());
      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
      uniqueHolders.forEach((holder, index) => {
        holder.rank = index + 1;
        holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      });

      const result = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalMultiplierSum,
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);
      const errorResult = { holders: [], totalTokens: 0, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map(nft => 
        fetchCollectionData(nft.apiKey)
          .then(data => ({ apiKey: nft.apiKey, data }))
          .catch(err => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            // Include totalShares for Ascendant to calculate Shares %
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`px-6 py-2 rounded-md font-semibold transition-colors ${
              selectedChain === chain.id
                ? 'bg-orange-500 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) => (
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            )
          ))}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl">{children}</div>
    </div>
  );
}-e 
---
File: ./app/nft/page.js
// app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="text-center text-white">
      <p className="text-lg">Select a collection above to view details.</p>
    </div>
  );
}-e 
---
File: ./app/nft/ETH/Stax/page.js
// app/nft/ETH/Stax/page.js
import NFTPage from '@/components/NFTPage';

export default function StaxPage() {
  return <NFTPage contractKey="staxNFT" />;
}-e 
---
File: ./app/nft/ETH/Element280/page.js
// app/nft/ETH/Element280/page.js
import NFTPage from '@/components/NFTPage';

export default function Element280Page() {
  return <NFTPage contractKey="element280" />;
}-e 
---
File: ./app/nft/ETH/Element369/page.js
// app/nft/ETH/Element369/page.js
import NFTPage from '@/components/NFTPage';
export default function Element369Page() {
  return <NFTPage contractKey="element369" />;
}-e 
---
File: ./app/nft/ETH/Ascendant/page.js
// app/nft/ETH/Ascendant/page.js
import NFTPage from '@/components/NFTPage';

export default function AscendantPage() {
  return <NFTPage contractKey="ascendantNFT" />;
}-e 
---
File: ./app/nft/BASE/E280/page.js
// app/nft/BASE/E280/page.js
import NFTPage from '@/components/NFTPage';

export default function E280Page() {
  return <NFTPage contractKey="e280" />;
}-e 
---
File: ./app/store.js
// app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          I'd like to add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/api/holders/Stax/route.js
// app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

const settings = {
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  network: Network.ETH_MAINNET,
};
const alchemy = new Alchemy(settings);

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

function log(message) {
  console.log(`[PROD_DEBUG] staxNFT - ${message}`);
}

async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    const batchResults = await client.multicall({ contracts: batch });
    results.push(...batchResults);
  }
  return results;
}

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.staxNFT;
  const tiers = contractTiers.staxNFT;
  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);

  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {
    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");
    throw new Error("Server configuration error: Missing Alchemy API key");
  }
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest', // Dynamic supply
    withTokenBalances: true,
  });
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier].multiplier || 0;
        holder.tiers[tier] += 1;
      }
    }
  });

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum; // No division for Stax
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  return {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] StaxNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/E280/route.js
// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Data not available yet');
  return NextResponse.json({ message: 'E280 data will go live after deployment' });
}-e 
---
File: ./app/api/holders/Element280/route.js
// app/api/holders/Element280/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, nftAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';
let cache = {};
let tokenCache = new Map();

async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 1000) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getAllHolders: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`getAllHolders start: ${contractName} at ${contractAddress}, page=${page}, pageSize=${pageSize}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true });
  log(`${contractName} - Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`${contractName} - Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`${contractName} - Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`${contractName} - Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = [];
  paginatedTokenIds.forEach((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    if (owner && owner !== burnAddress) {
      validTokenIds.push(tokenId);
      tokenCache.set(cacheKey, owner);
    } else {
      tokenCache.set(cacheKey, null);
    }
  });
  log(`${contractName} - Valid token IDs after ownerOf: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    log(`${contractName} - No valid tokens found in this page`);
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(allTokenIds.length / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  log(`${contractName} - Starting tier multicall for ${tierCalls.length} tokens`);
  const tierResults = await batchMulticall(tierCalls);
  log(`${contractName} - Tier results length: ${tierResults.length}`);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalNftsHeld = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractName} - Undefined tier result at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }

        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        totalNftsHeld += 1;
      } else {
        log(`${contractName} - Invalid tier ${tier} for token ${tokenId}`);
      }
    } else {
      log(`${contractName} - Failed tier fetch at index ${i}, tokenId: ${validTokenIds[i]}`);
    }
  });
  log(`${contractName} - Total NFTs held after tier check: ${totalNftsHeld}`);

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum / 10; // Element280 specific adjustment
  });

  const sortFn = (a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total;
  holders.sort(sortFn);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(allTokenIds.length / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractName} - Final holders count: ${holders.length}`);
  return result;
}

async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getHolderData: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  log(`getHolderData start: wallet=${wallet}, contract=${contractAddress}`);
  const nfts = await alchemy.nft.getNftsForOwner(wallet, { contractAddresses: [contractAddress] });
  log(`${contractAddress} - Initial NFTs for ${wallet}: ${nfts.totalCount}`);

  if (nfts.totalCount === 0) return null;

  const walletLower = wallet.toLowerCase();
  const tokenIds = nfts.ownedNfts.map(nft => BigInt(nft.tokenId));
  const ownerOfCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = tokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    tokenCache.set(cacheKey, owner);
    return owner === walletLower;
  });
  log(`${contractAddress} - Valid token IDs for ${wallet}: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) return null;

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractAddress} - Undefined tier result for wallet ${wallet} at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tier = Number(result.result);
      const tokenId = validTokenIds[i];
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);
      if (tier >= 1 && tier <= maxTier) {
        tiersArray[tier] += 1;
        total += 1;
        multiplierSum += tiers[tier]?.multiplier || 0;
      }
    }
  });
  log(`${contractAddress} - Total NFTs for ${wallet} after tier check: ${total}`);

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 1000);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const percentage = totalMultiplierSum > 0 ? (multiplierSum / totalMultiplierSum) * 100 : 0;
  const holder = allHolders.holders.find(h => h.wallet === walletLower) || { rank: allHolders.holders.length + 1 };

  const result = {
    wallet: walletLower,
    rank: holder.rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum / 10, // Element280 specific adjustment
    percentage,
    tiers: tiersArray,
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractAddress} - Final data for ${wallet}: total=${total}, multiplierSum=${multiplierSum}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  const address = contractAddresses['element280']; // Hardcoded for this endpoint
  if (!address) {
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers['element280']);
      return NextResponse.json({ holders: holderData ? [holderData] : [] });
    }

    const result = await getAllHolders(address, contractTiers['element280'], page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    log(`Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element369/route.js
// app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

const settings = {
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  network: Network.ETH_MAINNET,
};
const alchemy = new Alchemy(settings);

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

function log(message) {
  console.log(`[PROD_DEBUG] element369 - ${message}`);
}

async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    const batchResults = await client.multicall({ contracts: batch });
    results.push(...batchResults);
  }
  return results;
}

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.element369;
  const tiers = contractTiers.element369;
  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);

  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {
    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");
    throw new Error("Server configuration error: Missing Alchemy API key");
  }
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest',
    withTokenBalances: true,
  });
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier].multiplier || 0;
        holder.tiers[tier] += 1;
      }
    }
  });

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  return {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] Element369 API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Ascendant/route.js
// app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, ascendantAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

let cache = {};
let tokenCache = new Map();

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.ascendantNFT;
  const tiers = contractTiers.ascendantNFT;
  const contractName = 'ascendantNFT';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest',
    withTokenBalances: true,
  });
  log(`Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    const result = { 
      holders: [], 
      totalTokens, 
      totalLockedAscendant: 0, 
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page, 
      pageSize, 
      totalPages: Math.ceil(totalTokens / pageSize) 
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'getNFTAttribute',
    args: [tokenId],
  }));
  const recordCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'userRecords',
    args: [tokenId],
  }));

  const [tierResults, recordResults] = await Promise.all([
    batchMulticall(tierCalls),
    batchMulticall(recordCalls),
  ]);

  const totalShares = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'totalShares',
  }));
  const toDistributeDay8 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [0], // POOLS.DAY8
  }));
  const toDistributeDay28 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [1], // POOLS.DAY28
  }));
  const toDistributeDay90 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [2], // POOLS.DAY90
  }));
  const rewardPerShare = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'rewardPerShare',
  }));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result[1]);
      const record = recordResults[i]?.status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];
      const shares = Number(record[0]);
      const lockedAscendant = Number(record[1]);
      const rewardDebt = Number(record[2]);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
            shares: 0,
            lockedAscendant: 0,
            rewardDebt: 0,
            pendingDay8: 0,
            pendingDay28: 0,
            pendingDay90: 0,
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        holder.shares += shares;
        holder.lockedAscendant += lockedAscendant;
        holder.rewardDebt += rewardDebt;
        totalLockedAscendant += lockedAscendant;
      }
    }
  });

  // Calculate pending rewards per wallet
  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach(holder => {
    const currentRewardPerShare = rewardPerShare + pendingRewardPerShareDay8 + pendingRewardPerShareDay28 + pendingRewardPerShareDay90;
    const totalPending = holder.shares * (currentRewardPerShare - holder.rewardDebt / holder.total);
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  const result = {
    holders,
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`Returning: holders=${holders.length}, totalTokens=${totalTokens}, totalLockedAscendant=${totalLockedAscendant}, totalShares=${totalShares}, pendingRewards=${result.pendingRewards}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] AscendantNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils.js
// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

export const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

export const ascendantAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)",
  "function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)",
  "function totalShares() view returns (uint256)",
  "function toDistribute(uint8 pool) view returns (uint256)",
  "function rewardPerShare() view returns (uint256)",
  "error NonExistentToken(uint256 tokenId)"
]);

export const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export function log(message) {
  console.log(`[PROD_DEBUG] ${message}`);
}

export async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);
    } catch (error) {
      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);
      results.push(...batch.map(() => ({ status: 'failure', result: null })));
    }
  }
  log(`batchMulticall: Completed with ${results.length} results`);
  return results;
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
'use client';
import { useFlareROI } from '../../lib/auctions/flare';

export default function AuctionsPage() {
  const { 
    currentFlarePerTitanX, 
    marketFlareTitanXPrice, 
    marketFlarePerX28, 
    marketX28PerTitanX, 
    roi, 
    isLoading, 
    hasError,
    currentMarketValue1BTitanX,
    flareDerivedFromAuction1BTitanX,
    marketValueFlareReceived,
    profitBasedROI,
    currentMarketValue1BTitanXUSD,
    flareDerivedFromAuction1BTitanXUSD,
  } = useFlareROI();

  if (isLoading) return <div>Loading...</div>;
  if (hasError) return <div>Error loading data</div>;

  return (
    <div>
      <h1>[Flare Auction]</h1>
      <p>https://example.com/flare-auction</p>
      <p>ROI: {roi}%</p>
      <p>Auction: {currentFlarePerTitanX?.toFixed(2)} FLARE/TX</p>
      <p>Market FLARE/TITANX Price: {marketFlareTitanXPrice?.toFixed(2)} FLARE/TX</p>
      <p>Market FLARE/X28: {marketFlarePerX28?.toFixed(2)} FLARE/X28</p>
      <p>Market X28/TITANX: {marketX28PerTitanX?.toFixed(4)} X28/TX</p>
      <p>Current Market Value of 1B TITANX: {currentMarketValue1BTitanX?.toLocaleString(undefined, { maximumFractionDigits: 2 })} FLARE</p>
      <p>Equivalent FLARE Derived from Auction (1B TITANX): {flareDerivedFromAuction1BTitanX?.toLocaleString(undefined, { maximumFractionDigits: 2 })} FLARE</p>
      <p>Market Value of FLARE Received: {marketValueFlareReceived?.toLocaleString(undefined, { maximumFractionDigits: 2 })} TITANX</p>
      <p>Profit-Based ROI (1B TITANX): {profitBasedROI}%</p>
      <p>1B TITANX Market Value in USD: ${currentMarketValue1BTitanXUSD?.toLocaleString(undefined, { maximumFractionDigits: 2 })}</p>
      <p>Projected FLARE Tokens ({flareDerivedFromAuction1BTitanX?.toLocaleString(undefined, { maximumFractionDigits: 0 })} FLARE) Value in USD: ${flareDerivedFromAuction1BTitanXUSD?.toLocaleString(undefined, { maximumFractionDigits: 2 })}</p>
    </div>
  );
}-e 
---
File: ./app/nft-contracts.js
// app/nft-contracts.js
export const nftContracts = {
  element280: {
    name: "Element 280",
    symbol: "ELMNT",
    address: "0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9",
    deploymentBlock: "20945304",
    tiers: {
      1: { name: "Common", multiplier: 10, allocation: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 12, allocation: "100000000000000000000000000" },
      3: { name: "Rare", multiplier: 100, allocation: "1000000000000000000000000000" },
      4: { name: "Rare Amped", multiplier: 120, allocation: "1000000000000000000000000000" },
      5: { name: "Legendary", multiplier: 1000, allocation: "10000000000000000000000000000" },
      6: { name: "Legendary Amped", multiplier: 1200, allocation: "10000000000000000000000000000" },
    },
    description:
      "Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.",
  },
  element369: {
    name: "Element 369",
    symbol: "E369",
    address: "0x024D64E2F65747d8bB02dFb852702D588A062575",
    deploymentBlock: "21224418",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      3: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
    },
    description:
      "Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.",
  },
  staxNFT: {
    name: "Stax",
    symbol: "STAX",
    address: "0x74270Ca3a274B4dbf26be319A55188690CACE6E1",
    deploymentBlock: "21452667",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 1.2, price: "100000000000000000000000000", amplifier: "10000000000000000000000000" },
      3: { name: "Common Super", multiplier: 1.4, price: "100000000000000000000000000", amplifier: "20000000000000000000000000" },
      4: { name: "Common LFG", multiplier: 2, price: "100000000000000000000000000", amplifier: "50000000000000000000000000" },
      5: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      6: { name: "Rare Amped", multiplier: 12, price: "1000000000000000000000000000", amplifier: "100000000000000000000000000" },
      7: { name: "Rare Super", multiplier: 14, price: "1000000000000000000000000000", amplifier: "200000000000000000000000000" },
      8: { name: "Rare LFG", multiplier: 20, price: "1000000000000000000000000000", amplifier: "500000000000000000000000000" },
      9: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
      10: { name: "Legendary Amped", multiplier: 120, price: "10000000000000000000000000000", amplifier: "1000000000000000000000000000" },
      11: { name: "Legendary Super", multiplier: 140, price: "10000000000000000000000000000", amplifier: "2000000000000000000000000000" },
      12: { name: "Legendary LFG", multiplier: 200, price: "10000000000000000000000000000", amplifier: "5000000000000000000000000000" },
    },
    description:
      "Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.",
  },
  ascendantNFT: {
    name: "Ascendant",
    symbol: "ASCNFT",
    address: "0x9da95c32c5869c84ba2c020b5e87329ec0adc97f",
    deploymentBlock: "21112535",
    tiers: {
      1: { name: "Tier 1", price: "7812500000000000000000", multiplier: 1.01 },
      2: { name: "Tier 2", price: "15625000000000000000000", multiplier: 1.02 },
      3: { name: "Tier 3", price: "31250000000000000000000", multiplier: 1.03 },
      4: { name: "Tier 4", price: "62500000000000000000000", multiplier: 1.04 },
      5: { name: "Tier 5", price: "125000000000000000000000", multiplier: 1.05 },
      6: { name: "Tier 6", price: "250000000000000000000000", multiplier: 1.06 },
      7: { name: "Tier 7", price: "500000000000000000000000", multiplier: 1.07 },
      8: { name: "Tier 8", price: "1000000000000000000000000", multiplier: 1.08 },
    },
    description:
      "Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.",
  },
  e280: {
    name: "E280",
    symbol: "E280",
    address: null, // Not deployed yet
    deploymentBlock: null,
    tiers: {}, // Define if applicable
    description: "E280 NFTs on BASE chain. Contract not yet deployed.",
  },
};

export const contractAddresses = {
  element280: nftContracts.element280.address,
  element369: nftContracts.element369.address,
  staxNFT: nftContracts.staxNFT.address,
  ascendantNFT: nftContracts.ascendantNFT.address,
  e280: nftContracts.e280.address,
};

export const deploymentBlocks = {
  element280: nftContracts.element280.deploymentBlock,
  element369: nftContracts.element369.deploymentBlock,
  staxNFT: nftContracts.staxNFT.deploymentBlock,
  ascendantNFT: nftContracts.ascendantNFT.deploymentBlock,
  e280: nftContracts.e280.deploymentBlock,
};

export const contractTiers = {
  element280: nftContracts.element280.tiers,
  element369: nftContracts.element369.tiers,
  staxNFT: nftContracts.staxNFT.tiers,
  ascendantNFT: nftContracts.ascendantNFT.tiers,
  e280: nftContracts.e280.tiers,
};

export const contractDetails = {
  element280: {
    name: nftContracts.element280.name,
    totalTokens: 8209, // Update with actual value if needed
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element280',
  },
  element369: {
    name: nftContracts.element369.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element369',
  },
  staxNFT: {
    name: nftContracts.staxNFT.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Stax',
  },
  ascendantNFT: {
    name: nftContracts.ascendantNFT.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Ascendant',
  },
  e280: {
    name: nftContracts.e280.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/E280',
  },
};

export function getContractDetails(contractName) {
  return nftContracts[contractName] || null;
}-e 
---
File: ./app/ClientProvider.js
// app/ClientProvider.js
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider, createConfig, http } from 'wagmi';
import { mainnet } from 'wagmi/chains';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 60 * 1000, // 30 minutes
      cacheTime: 60 * 60 * 1000, // 1 hour
    },
  },
});

const config = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http(`https://eth-mainnet.alchemyapi.io/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
  },
});

export default function ClientProvider({ children }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.

const config = {
  plugins: ["tailwindcss"],
};
export default config;-e 
---
File: ./next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
-e 
---
File: ./README.md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
-e 
---
File: ./components/HolderTable.js
// components/HolderTable.js
import { memo } from 'react'; // Add memo import
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  // Filter out null/undefined holders and those without a wallet property
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {Object.keys(contractTiers[contract] || {})
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                          {contractTiers[contract][tier].name}
                        </th>
                      ))}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md}px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(tiers)
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {tiers[tier].name}
                    </th>
                  ))}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total}</td>
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : 'N/A'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.shares / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay8 / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay28 / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay90 / 1e18).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.percentage.toFixed(2)}%</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.displayMultiplierSum.toFixed(2)}</td>
                  {Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                        {holder.tiers?.[tier] || 0}
                      </td>
                    ))}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// Export as memoized component to reduce unnecessary re-renders
export default memo(HolderTable);-e 
---
File: ./components/AuctionCard.js
// components/AuctionCard.js
'use client';
import { useState } from 'react';

export default function AuctionCard({ name, url, roiData }) {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const openModal = () => setIsModalOpen(true);
  const closeModal = () => setIsModalOpen(false);
  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) closeModal();
  };

  return (
    <>
      <div
        className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
          transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
      >
        <button
          onClick={openModal}
          className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
            transition-colors duration-200 text-left w-full"
        >
          {name} Auction
        </button>
        <p className="text-gray-400 mt-2 text-sm">
          <span className="hover:underline">{url}</span>
        </p>
        {roiData && (
          <div className="mt-2 text-sm text-orange-400">
            {roiData.isLoading ? (
              <p>Calculating ROI...</p>
            ) : roiData.hasError ? (
              <p>ROI: Error</p>
            ) : (
              <>
                <p>{roiData.roi !== null ? `ROI: ${roiData.roi}%` : 'ROI: N/A'}</p>
                <p>
                  {roiData.currentFlarePerTitanX !== null
                    ? `Auction: ${roiData.currentFlarePerTitanX.toFixed(2)} FLARE/TX`
                    : 'Auction: N/A'}
                </p>
                <p>
                  {roiData.marketFlareTitanXPrice !== null
                    ? `Market FLARE/TITANX Price: ${roiData.marketFlareTitanXPrice.toFixed(2)} FLARE/TX`
                    : 'Market FLARE/TITANX Price: N/A'}
                </p>
                <p>
                  {roiData.marketFlarePerX28 !== null
                    ? `Market FLARE/X28: ${roiData.marketFlarePerX28.toFixed(2)} FLARE/X28`
                    : 'Market FLARE/X28: N/A'}
                </p>
                <p>
                  {roiData.marketX28PerTitanX !== null
                    ? `Market X28/TITANX: ${roiData.marketX28PerTitanX.toFixed(4)} X28/TX`
                    : 'Market X28/TITANX: N/A'}
                </p>
              </>
            )}
          </div>
        )}
      </div>

      {isModalOpen && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{name} Auction</h2>
            {roiData && (
              <div className="text-gray-300 mb-4">
                {roiData.isLoading ? (
                  <p>Calculating data...</p>
                ) : roiData.hasError ? (
                  <p>Error loading data</p>
                ) : (
                  <>
                    <p>
                      <strong>Current FLARE/TITANX Ratio (Auction):</strong>{' '}
                      {roiData.currentFlarePerTitanX !== null ? `${roiData.currentFlarePerTitanX.toFixed(2)} FLARE` : 'N/A'}
                    </p>
                    <p>
                      <strong>Market FLARE/TITANX Price:</strong>{' '}
                      {roiData.marketFlareTitanXPrice !== null ? `${roiData.marketFlareTitanXPrice.toFixed(2)} FLARE/TX` : 'N/A'}
                    </p>
                    <p>
                      <strong>Market FLARE/X28 Price:</strong>{' '}
                      {roiData.marketFlarePerX28 !== null ? `${roiData.marketFlarePerX28.toFixed(2)} FLARE/X28` : 'N/A'}
                    </p>
                    <p>
                      <strong>Market X28/TITANX Price:</strong>{' '}
                      {roiData.marketX28PerTitanX !== null ? `${roiData.marketX28PerTitanX.toFixed(4)} X28/TX` : 'N/A'}
                    </p>
                    <p>
                      <strong>ROI:</strong>{' '}
                      {roiData.roi !== null ? `${roiData.roi}%` : 'N/A'}
                    </p>
                  </>
                )}
              </div>
            )}
            <iframe
              src={url}
              className="w-full h-[calc(100%-8rem)] border-0 rounded"
              title={`${name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </>
  );
}-e 
---
File: ./components/LoadingIndicator.js
// app/components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status }) {
  return (
    <div className="flex flex-col items-center justify-center gap-3 animate-fade-in w-full flex-1">
      <motion.svg
        className="h-6 w-6 sm:h-8 sm:w-8 text-blue-400"
        animate={{ scale: [1, 1.2, 1], rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </motion.svg>
      <p className="text-sm sm:text-base text-gray-300">{status}</p>
    </div>
  );
}-e 
---
File: ./components/NFTPage.js
// components/NFTPage.js
'use client';
import { useState, useEffect } from 'react';
import HolderTable from '@/components/HolderTable';
import LoadingIndicator from '@/components/LoadingIndicator';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTPage({ contractKey }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const { name, apiEndpoint } = contractDetails[contractKey] || {};
  const { getCache, setCache } = useNFTStore();

  useEffect(() => {
    async function fetchAllHolders() {
      if (!apiEndpoint) {
        setError('Invalid contract configuration');
        setLoading(false);
        return;
      }

      const cachedData = getCache(contractKey);
      if (cachedData) {
        setData(cachedData);
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        console.log(`[NFTPage] Starting fetch for ${contractKey} at ${apiEndpoint}`);
        let allHolders = [];
        let totalTokens = 0;
        let totalLockedAscendant = 0;
        let totalShares = 0;
        let toDistributeDay8 = 0;
        let toDistributeDay28 = 0;
        let toDistributeDay90 = 0;
        let pendingRewards = 0;
        let page = 0;
        let totalPages = Infinity;
        const pageSize = 1000;

        while (page < totalPages) {
          let attempts = 0;
          const maxAttempts = 3;
          let success = false;

          while (attempts < maxAttempts && !success) {
            try {
              console.log(`[NFTPage] Fetching ${contractKey} page ${page}`);
              const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
                signal: AbortSignal.timeout(30000),
              });
              if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
              }

              const json = await res.json();
              allHolders = allHolders.concat(json.holders || []);
              totalTokens = json.totalTokens || totalTokens;
              totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
              totalShares = json.totalShares || totalShares;
              toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
              toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
              toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
              pendingRewards = json.pendingRewards || pendingRewards;
              totalPages = json.totalPages || 1;
              page++;
              success = true;
              if (!json.holders || json.holders.length === 0) break;
            } catch (err) {
              attempts++;
              if (err.message.includes('Rate limit') || err.name === 'TimeoutError') {
                console.log(`[NFTPage] Retry ${attempts} for ${contractKey} page ${page} due to: ${err.message}`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
              } else {
                throw err;
              }
            }
          }
          if (!success) {
            throw new Error(`Failed to fetch page ${page} for ${contractKey} after ${maxAttempts} attempts`);
          }
        }

        const uniqueHoldersMap = new Map();
        allHolders.forEach(holder => {
          if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
        });
        const uniqueHolders = Array.from(uniqueHoldersMap.values());
        console.log(`[NFTPage] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

        const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
        if (!totalTokens && uniqueHolders.length > 0) {
          totalTokens = uniqueHolders.reduce((sum, h) => sum + (h.total || 0), 0);
        }

        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });

        const fetchedData = {
          holders: uniqueHolders,
          totalTokens,
          totalLockedAscendant,
          totalShares,
          toDistributeDay8,
          toDistributeDay28,
          toDistributeDay90,
          pendingRewards,
          totalMultiplierSum,
        };

        setCache(contractKey, fetchedData);
        setData(fetchedData);
        setLoading(false);
      } catch (err) {
        console.error('[NFTPage] Fetch Error:', err);
        setError(`Failed to load ${name} holders: ${err.message}. Try refreshing later (Alchemy limit possible).`);
        setLoading(false);
      }
    }

    fetchAllHolders();
  }, [contractKey, name, apiEndpoint, getCache, setCache]);

  const renderSummary = () => {
    if (!data) return null;

    const totalMultiplierSum = data.totalMultiplierSum || 0;
    const totalTokens = data.totalTokens || 0;

    if (contractKey === 'ascendantNFT') {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Locked Ascendant: <span className="font-bold">{(data.totalLockedAscendant / 1e18 || 0).toLocaleString()}</span></p>
          <p>Total Shares: <span className="font-bold">{(data.totalShares / 1e18 || 0).toLocaleString()}</span></p>
          <p>Total Pending DragonX Rewards: <span className="font-bold">{(data.pendingRewards / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY8 Rewards: <span className="font-bold">{(data.toDistributeDay8 / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY28 Rewards: <span className="font-bold">{(data.toDistributeDay28 / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY90 Rewards: <span className="font-bold">{(data.toDistributeDay90 / 1e18 || 0).toLocaleString()}</span></p>
        </>
      );
    } else {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Multiplier Sum: <span className="font-bold">{totalMultiplierSum.toLocaleString()}</span></p>
        </>
      );
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      {loading ? (
        <LoadingIndicator status={`Loading all ${name || 'contract'} holders...`} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractKey}
            loading={loading}
            totalShares={contractKey === 'ascendantNFT' ? data.totalShares : undefined}
          />
          <div className="mt-8">
            <h3 className="text-xl font-bold mb-2">Raw Data:</h3>
            <pre className="text-sm bg-gray-700 p-4 rounded max-h-96 overflow-auto border-2 border-red-500">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
// components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import HolderTable from './HolderTable';

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      onClick={handleBackgroundClick}
    >
      <motion.div
        className="bg-gray-800 text-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Search Results for {searchAddress}</h2>
          <button onClick={closeModal} className="text-gray-400 hover:text-white text-2xl">
            &times;
          </button>
        </div>

        {Object.keys(searchResult).length === 0 ? (
          <p className="text-gray-400">No results available.</p>
        ) : (
          Object.entries(searchResult).map(([contract, data]) => (
            <div key={contract} className="mb-6">
              <h3 className="text-xl font-semibold mb-2">{contractDetails[contract]?.name || contract}</h3>
              {data === null ? (
                <p className="text-gray-400">Wallet not found in this collection.</p>
              ) : data.error ? (
                <p className="text-red-500">Error: {data.error}</p>
              ) : data.message ? (
                <p className="text-gray-400">{data.message}</p>
              ) : (
                <HolderTable
                  holders={[data]}
                  contract={contract}
                  loading={false}
                  totalShares={data.totalShares} // Pass totalShares from search result
                />
              )}
            </div>
          ))
        )}
      </motion.div>
    </div>
  );
}

const contractDetails = {
  element280: { name: 'Element280' },
  element369: { name: 'Element369' },
  staxNFT: { name: 'Stax' },
  ascendantNFT: { name: 'Ascendant' },
  e280: { name: 'E280' },
};-e 
---
File: ./components/Navbar.jsx
// components/Navbar.jsx
'use client';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10 },
    visible: { opacity: 1, y: 0 },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0 },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining' },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [
            { name: 'E280', href: '/nft/BASE/E280' },
          ],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="bg-gradient-to-r from-gray-900 to-gray-800 text-white p-4 sticky top-0 z-50 shadow-md">
      <div className="max-w-7xl mx-auto flex justify-between items-center">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="text-2xl font-bold"
        >
          <Link href="/">TitanXUtils</Link>
        </motion.div>

        {/* Desktop Links */}
        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative text-gray-300 hover:text-white transition-colors duration-200 group"
              whileHover={{ scale: 1.1, color: '#f97316' }}
              whileTap={{ scale: 0.95 }}
            >
              {item.external ? (
                <a href={item.href} target="_blank" rel="noopener noreferrer">
                  {item.name}
                </a>
              ) : (
                <Link href={item.href}>{item.name}</Link>
              )}
              {item.subItems && (
                <motion.div
                  className="absolute left-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg hidden group-hover:block"
                  variants={dropdownVariants}
                  initial="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white">
                        {subItem.href ? (
                          <Link href={subItem.href}>{subItem.name}</Link>
                        ) : (
                          <span>{subItem.name}</span>
                        )}
                      </div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <div
                              key={nestedItem.name}
                              className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white"
                            >
                              <Link href={nestedItem.href}>
                                {nestedItem.name}
                              </Link>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
        </div>

        {/* Mobile Menu Toggle */}
        <button
          className="md:hidden p-2 focus:outline-none"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      {/* Mobile Menu */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="block py-2 px-4 text-gray-300 hover:text-white hover:bg-gray-700 rounded-md transition-colors duration-200"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      {item.name}
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2">
                              {subItem.href ? (
                                <Link href={subItem.href} onClick={() => setIsOpen(false)}>
                                  {subItem.name}
                                </Link>
                              ) : (
                                <span>{subItem.name}</span>
                              )}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <div
                                    key={nestedItem.name}
                                    className="py-2"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    <Link href={nestedItem.href}>
                                      {nestedItem.name}
                                    </Link>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : item.external ? (
                  <a
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={() => setIsOpen(false)}
                  >
                    {item.name}
                  </a>
                ) : (
                  <Link href={item.href} onClick={() => setIsOpen(false)}>
                    {item.name}
                  </Link>
                )}
              </motion.div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts-e 
---
File: ./lib/token_contracts.js
// lib/token_contracts.js
export const tokenContracts = {
  FLARE: {
    name: 'Flare',
    address: '0x34a4FE5397bf2768189EDe14FE4adAD374B993B8',
    chainId: 1,
    type: 'token',
  },
  FLARE_AUCTION: {
    name: 'Flare Auction',
    address: '0x58aD6ef28BfB092635454D02303aDbd4D87b503C',
    chainId: 1,
    type: 'auction',
  },
  TITANX: {
    name: 'TitanX',
    address: '0xF19308F923582A6f7c465e5CE7a9Dc1BEC6665B1',
    chainId: 1,
    type: 'token',
  },
  X28: {
    name: 'X28',
    address: '0x5c47902c8C80779CB99235E42C354E53F38C3B0d',
    chainId: 1,
    type: 'token',
  },
  ETH: {
    name: 'Ethereum',
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH
    chainId: 1,
    type: 'token',
    isNativeWrapper: true,
  },
  WETH: {
    name: 'Wrapped Ether',
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    chainId: 1,
    type: 'token',
  },
  USDC: {
    name: 'USD Coin',
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    chainId: 1,
    type: 'token',
  },
  VOLT: {
    name: 'Volt',
    address: '0x66b5228CfD34d9f4d9f03188d67816286C7c0b74',
    chainId: 1,
    type: 'token',
  },
  BLAZE: {
    name: 'Blaze',
    address: '0xfcd7cceE4071aA4ecFAC1683b7CC0aFeCAF42A36',
    chainId: 1,
    type: 'token',
  },
  SHOGUN: {
    name: 'Shogun',
    address: '0xfD4cB1294dF23920e683e046963117cAe6C807D9',
    chainId: 1,
    type: 'token',
  },
  ASCEND: {
    name: 'Ascendant',
    address: '0x0943D06A5Ff3B25ddC51642717680c105AD63c01',
    chainId: 1,
    type: 'token',
  },
  DRAGONX: {
    name: 'DragonX',
    address: '0x96a5399D07896f757Bd4c6eF56461F58DB951862',
    chainId: 1,
    type: 'token',
  },
  FLUX: {
    name: 'Flux',
    address: '0xBFDE5ac4f5Adb419A931a5bF64B0f3BB5a623d06',
    chainId: 1,
    type: 'token',
  },
  VYPER: {
    name: 'Vyper',
    address: '0xd7fa4cFC22eA07DfCeD53033fbE59d8b62B8Ee9E',
    chainId: 1,
    type: 'token',
  },
  HYDRA: {
    name: 'Hydra',
    address: '0xCC7ed2ab6c3396DdBc4316D2d7C1b59ff9d2091F',
    chainId: 1,
    type: 'token',
  },
  HYPER: {
    name: 'Hyper',
    address: '0xE2cfD7a01ec63875cd9Da6C7c1B7025166c2fA2F',
    chainId: 1,
    type: 'token',
  },
};

export const uniswapPools = {
  FLARE_X28_03: {
    name: 'Flare/X28 0.3%',
    address: '0x05b7Cc21A11354778Cf0D7faf159f1a99724ccFd',
    chainId: 1,
    token0: tokenContracts.FLARE.address,
    token1: tokenContracts.X28.address,
    fee: 3000,
  },
  TITANX_WETH_03: {
    name: 'TitanX/WETH 0.3%',
    address: '0xc45A81BC23A64eA556ab4CdF08A86B61cdcEEA8b',
    chainId: 1,
    token0: tokenContracts.WETH.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  WETH_USDC_03: {
    name: 'WETH/USDC 0.3%',
    address: '0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640',
    chainId: 1,
    token0: tokenContracts.USDC.address,
    token1: tokenContracts.WETH.address,
    fee: 3000,
  },
  VOLT_TITANX: {
    name: 'Volt/TitanX 0.3%',
    address: '0x3F1A36B6C946E406f4295A89fF06a5c7d62F2fe2',
    chainId: 1,
    token0: tokenContracts.VOLT.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  BLAZE_TITANX: {
    name: 'Blaze/TitanX 0.3%',
    address: '0x4D3A10d4792Dd12ececc5F3034C8e264B28485d1',
    chainId: 1,
    token0: tokenContracts.BLAZE.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  SHOGUN_TITANX: {
    name: 'Shogun/TitanX 0.3%',
    address: '0x79bd712f876c364Aa5e775A1eD40dE1FfdB2a50',
    chainId: 1,
    token0: tokenContracts.SHOGUN.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  ASCEND_DRAGONX: {
    name: 'Ascend/DragonX 0.3%',
    address: '0xe8cC60F526bec8C663C6eEc5A65eFAe9d89Ee6aD',
    chainId: 1,
    token0: tokenContracts.ASCEND.address,
    token1: tokenContracts.DRAGONX.address,
    fee: 3000,
  },
  VYPER_DRAGONX: {
    name: 'Vyper/DragonX 0.3%',
    address: '0x214CAD3f7FbBe66919968Fa3a1b16E84cFcd457F',
    chainId: 1,
    token0: tokenContracts.VYPER.address,
    token1: tokenContracts.DRAGONX.address,
    fee: 3000,
  },
  DRAGONX_TITANX: {
    name: 'DragonX/TitanX 0.3%',
    address: '0x25215d9ba4403b3DA77ce50606b54577a71b7895',
    chainId: 1,
    token0: tokenContracts.DRAGONX.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  HYPER_TITANX: {
    name: 'Hyper/TitanX 0.3%',
    address: '0x14d725edB1299fF560d96f42462f0234B65B00AF',
    chainId: 1,
    token0: tokenContracts.HYPER.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  X28_TITANX: {
    name: 'X28/TitanX 0.3%',
    address: '0x99f60479da6A49D55eBA34893958cdAACc710eE9',
    chainId: 1,
    token0: tokenContracts.X28.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  FLUX_TITANX: {
    name: 'Flux/TitanX 0.3%',
    address: '0x2278012E61c0fB38DaE1579bD41a87A59A5954c2',
    chainId: 1,
    token0: tokenContracts.FLUX.address,
    token1: tokenContracts.TITANX.address,
    fee: 3000,
  },
  HYDRA_DRAGONX: {
    name: 'Hydra/DragonX 0.3%',
    address: '0xF8F0Ef9f6A12336A1e035adDDbD634F3B0962F54',
    chainId: 1,
    token0: tokenContracts.HYDRA.address,
    token1: tokenContracts.DRAGONX.address,
    fee: 3000,
  },
};

// ABIs and utility functions remain unchanged
export const auctionABI = [
  {
    name: 'dailyStats',
    type: 'function',
    inputs: [{ name: 'day', type: 'uint32' }],
    outputs: [
      { name: 'flareEmitted', type: 'uint128' },
      { name: 'titanXDeposited', type: 'uint128' },
    ],
    stateMutability: 'view',
  },
  {
    name: 'startTimestamp',
    type: 'function',
    inputs: [],
    outputs: [{ type: 'uint32' }],
    stateMutability: 'view',
  },
];

export const uniswapPoolABI = [
  {
    name: 'slot0',
    type: 'function',
    inputs: [],
    outputs: [
      { name: 'sqrtPriceX96', type: 'uint160' },
      { name: 'tick', type: 'int24' },
      { name: '', type: 'uint16' },
      { name: '', type: 'uint16' },
      { name: '', type: 'uint16' },
      { name: '', type: 'uint8' },
      { name: '', type: 'bool' },
    ],
    stateMutability: 'view',
  },
  {
    name: 'token0',
    type: 'function',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];

export const uniswapV2PoolABI = [
  {
    name: 'getReserves',
    type: 'function',
    inputs: [],
    outputs: [
      { name: '_reserve0', type: 'uint112' },
      { name: '_reserve1', type: 'uint112' },
      { name: '_blockTimestampLast', type: 'uint32' },
    ],
    stateMutability: 'view',
  },
  {
    name: 'token0',
    type: 'function',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];

export const flareTokenABI = [
  {
    name: 'x28FlarePool',
    type: 'function',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];

export function getTokenContract(tokenName) {
  return tokenContracts[tokenName.toUpperCase()] || null;
}

export function getUniswapPool(poolName) {
  return uniswapPools[poolName] || null;
}-e 
---
File: ./lib/auctions/flare.js
// lib/auctions/flare.js
import { useReadContract } from 'wagmi';
import { formatEther } from 'viem';
import { tokenContracts, uniswapPools, auctionABI, uniswapV2PoolABI, flareTokenABI, uniswapPoolABI } from '../token_contracts';

export function useFlareROI() {
  console.log("[FlareROI] Hook initialized");

  const auctionConfig = { address: tokenContracts.FLARE_AUCTION.address, abi: auctionABI, chainId: 1 };
  const flareTokenConfig = { address: tokenContracts.FLARE.address, abi: flareTokenABI, chainId: 1 };
  const x28TitanXConfig = { address: uniswapPools.X28_TITANX.address, abi: uniswapPoolABI, chainId: 1 };
  const titanXWethConfig = { address: uniswapPools.TITANX_WETH_03.address, abi: uniswapPoolABI, chainId: 1 };
  const wethUsdcConfig = { address: uniswapPools.WETH_USDC_03.address, abi: uniswapPoolABI, chainId: 1 };

  const { data: flareX28PoolAddress, isLoading: flareX28PoolLoading, isError: flareX28PoolError } = useReadContract({ ...flareTokenConfig, functionName: 'x28FlarePool' });
  const flareX28PoolConfig = { address: flareX28PoolAddress, abi: uniswapV2PoolABI, chainId: 1 };
  const { data: startTimestamp, isLoading: startLoading, isError: startError } = useReadContract({ ...auctionConfig, functionName: 'startTimestamp' });
  const currentDay = startTimestamp ? Math.floor((Date.now() / 1000 - Number(startTimestamp)) / (24 * 60 * 60)) + 1 : 0;
  const { data: dailyStats, isLoading: statsLoading, isError: statsError } = useReadContract({ ...auctionConfig, functionName: 'dailyStats', args: [currentDay] });
  const { data: flareX28Reserves, isLoading: flareX28ReservesLoading, isError: flareX28ReservesError } = useReadContract({ ...flareX28PoolConfig, functionName: 'getReserves' });
  const { data: flareX28Token0, isLoading: flareX28Token0Loading, isError: flareX28Token0Error } = useReadContract({ ...flareX28PoolConfig, functionName: 'token0' });
  const { data: x28TitanXSlot0, isLoading: x28TitanXSlot0Loading, isError: x28TitanXSlot0Error } = useReadContract({ ...x28TitanXConfig, functionName: 'slot0', cacheTime: 0 });
  const { data: x28TitanXToken0, isLoading: x28TitanXToken0Loading, isError: x28TitanXToken0Error } = useReadContract({ ...x28TitanXConfig, functionName: 'token0' });
  const { data: titanXWethSlot0, isLoading: titanXWethSlot0Loading, isError: titanXWethSlot0Error } = useReadContract({ ...titanXWethConfig, functionName: 'slot0', cacheTime: 0 });
  const { data: titanXWethToken0, isLoading: titanXWethToken0Loading, isError: titanXWethToken0Error } = useReadContract({ ...titanXWethConfig, functionName: 'token0' });
  const { data: wethUsdcSlot0, isLoading: wethUsdcSlot0Loading, isError: wethUsdcSlot0Error } = useReadContract({ ...wethUsdcConfig, functionName: 'slot0', cacheTime: 0 });
  const { data: wethUsdcToken0, isLoading: wethUsdcToken0Loading, isError: wethUsdcToken0Error } = useReadContract({ ...wethUsdcConfig, functionName: 'token0' });

  const purchasePrice = dailyStats && dailyStats[1] > 0n ? Number(formatEther(BigInt(dailyStats[1]))) / Number(formatEther(BigInt(dailyStats[0]))) : null;

  const getPoolPrice = (reservesOrSlot0, token0Address, token1Address, poolAddress, isV3 = false) => {
    console.log("[FlareROI] getPoolPrice called with:", { reservesOrSlot0, token0Address, token1Address, poolAddress, isV3 });
    if (!isV3 && Array.isArray(reservesOrSlot0) && reservesOrSlot0.length === 3) {
      const reserve0 = Number(formatEther(BigInt(reservesOrSlot0[0])));
      const reserve1 = Number(formatEther(BigInt(reservesOrSlot0[1])));
      const price = reserve1 / reserve0; // token1/token0
      console.log("[FlareROI] V2 Price Calculated:", { price, reserve0, reserve1 });
      return { price, description: `${token1Address}/${token0Address} from ${poolAddress}` };
    } else if (isV3 && Array.isArray(reservesOrSlot0) && reservesOrSlot0.length >= 1) {
      const sqrtPriceX96 = BigInt(reservesOrSlot0[0]);
      const sqrtPrice = Number(sqrtPriceX96) / (2 ** 96);
      let price = sqrtPrice * sqrtPrice; // token1/token0
      const isToken0USDC = token0Address.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
      const isToken1USDC = token1Address.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
      if (isToken0USDC) {
        price = price * (10 ** 12); // USDC (6 decimals) to WETH (18 decimals)
      } else if (isToken1USDC) {
        price = price / (10 ** 12); // WETH to USDC
      }
      console.log("[FlareROI] V3 Price Debug for", poolAddress, { sqrtPriceX96: sqrtPriceX96.toString(), rawPrice: price });
      return { price, description: `${token1Address}/${token0Address} from ${poolAddress}` };
    }
    console.log("[FlareROI] getPoolPrice: No valid data");
    return { price: null, description: 'No data available' };
  };

  const validateMarketPrice = (calculatedMarketFlare, flareX28Price, x28TitanXPrice) => {
    console.log("[FlareROI] Price Validation:", {
      flareX28Price: flareX28Price.price,
      flareX28Source: flareX28Price.description,
      x28TitanXPrice: x28TitanXPrice.price,
      x28TitanXSource: x28TitanXPrice.description,
      calculatedMarketFlarePerTitanX: calculatedMarketFlare,
    });
  };

  let marketPrice = null;
  let auctionFlarePerTitanX = null;
  let marketFlarePerTitanX = null;
  let flarePerX28 = null;
  let x28PerTitanX = null;
  let titanxAmount = 1000000000; // 1 billion TITANX
  let currentMarketValue1BTitanX = null;
  let flareDerivedFromAuction1BTitanX = null;
  let marketValueFlareReceived = null;
  let profitBasedROI = null;
  let currentMarketValue1BTitanXUSD = null;
  let flareDerivedFromAuction1BTitanXUSD = null;

  const coreLoading = startLoading || statsLoading || flareX28ReservesLoading || flareX28Token0Loading || x28TitanXSlot0Loading || x28TitanXToken0Loading || flareX28PoolLoading;
  const usdLoading = titanXWethSlot0Loading || titanXWethToken0Loading || wethUsdcSlot0Loading || wethUsdcToken0Loading;
  const coreError = startError || statsError || flareX28ReservesError || flareX28Token0Error || x28TitanXSlot0Error || x28TitanXToken0Error || flareX28PoolError;
  const usdError = titanXWethSlot0Error || titanXWethToken0Error || wethUsdcSlot0Error || wethUsdcToken0Error;

  const isLoading = coreLoading || usdLoading;
  const hasError = coreError && usdError;

  if (!coreLoading && !coreError && flareX28Reserves && flareX28Reserves[0] && flareX28Reserves[1] && flareX28Token0 &&
      x28TitanXSlot0 && x28TitanXSlot0[0] && x28TitanXToken0 && dailyStats && flareX28PoolAddress) {
    console.log("[FlareROI] Core conditions met, calculating prices");

    const isFlareToken0 = flareX28Token0.toLowerCase() === tokenContracts.FLARE.address.toLowerCase();
    const flareX28PriceInfo = getPoolPrice(flareX28Reserves, flareX28Token0, tokenContracts.X28.address, flareX28PoolAddress, false);
    flarePerX28 = isFlareToken0 ? flareX28PriceInfo.price : 1 / flareX28PriceInfo.price; // X28/FLARE

    const isX28Token0 = x28TitanXToken0.toLowerCase() === tokenContracts.X28.address.toLowerCase();
    const x28TitanXPriceInfo = getPoolPrice(x28TitanXSlot0, x28TitanXToken0, tokenContracts.TITANX.address, x28TitanXConfig.address, true);
    x28PerTitanX = isX28Token0 ? 1 / x28TitanXPriceInfo.price : x28TitanXPriceInfo.price; // X28/TITANX (fixed inversion)

    marketFlarePerTitanX = (1 / flarePerX28) * x28PerTitanX; // FLARE/TITANX
    marketPrice = 1 / marketFlarePerTitanX; // TITANX/FLARE

    const flareEmitted = Number(formatEther(BigInt(dailyStats[0])));
    const titanXDeposited = Number(formatEther(BigInt(dailyStats[1])));
    auctionFlarePerTitanX = flareEmitted / titanXDeposited;

    currentMarketValue1BTitanX = titanxAmount * marketFlarePerTitanX;
    const totalTitanXAfterDeposit = titanXDeposited + titanxAmount;
    const newAuctionRate = flareEmitted / totalTitanXAfterDeposit;
    flareDerivedFromAuction1BTitanX = titanxAmount * newAuctionRate;
    marketValueFlareReceived = flareDerivedFromAuction1BTitanX / marketFlarePerTitanX;
    profitBasedROI = ((marketValueFlareReceived - titanxAmount) / titanxAmount) * 100;

    console.log('[FlareROI] Core Debug:', {
      dailyStats: [flareEmitted, titanXDeposited],
      marketFlarePerTitanX,
      auctionFlarePerTitanX,
      currentMarketValue1BTitanX,
      flareDerivedFromAuction1BTitanX,
      marketValueFlareReceived,
      profitBasedROI,
    });

    validateMarketPrice(marketFlarePerTitanX, flareX28PriceInfo, x28TitanXPriceInfo);
  } else {
    console.log("[FlareROI] Core conditions not met:", {
      coreLoading,
      coreError,
      flareX28Reserves: !!flareX28Reserves,
      flareX28Token0: !!flareX28Token0,
      x28TitanXSlot0: !!x28TitanXSlot0,
      x28TitanXToken0: !!x28TitanXToken0,
      dailyStats: !!dailyStats,
      flareX28PoolAddress: !!flareX28PoolAddress,
    });
  }

  if (!usdLoading && !usdError && titanXWethSlot0 && titanXWethSlot0[0] && titanXWethToken0 && wethUsdcSlot0 && wethUsdcSlot0[0] && wethUsdcToken0) {
    console.log("[FlareROI] USD conditions met, calculating USD prices");

    const isWethToken0TitanX = titanXWethToken0.toLowerCase() === tokenContracts.WETH.address.toLowerCase();
    const titanXWethPriceInfo = getPoolPrice(titanXWethSlot0, titanXWethToken0, tokenContracts.TITANX.address, titanXWethConfig.address, true);
    const wethPerTitanX = isWethToken0TitanX ? 1 / titanXWethPriceInfo.price : titanXWethPriceInfo.price; // WETH/TITANX

    const isUsdcToken0 = wethUsdcToken0.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
    const wethUsdcPriceInfo = getPoolPrice(wethUsdcSlot0, wethUsdcToken0, tokenContracts.WETH.address, wethUsdcConfig.address, true);
    const usdcPerWeth = isUsdcToken0 ? 1 / wethUsdcPriceInfo.price : wethUsdcPriceInfo.price; // USDC/WETH (fixed)

    const usdcPerTitanX = usdcPerWeth * wethPerTitanX; // USD/TITANX
    currentMarketValue1BTitanXUSD = titanxAmount * usdcPerTitanX;
    flareDerivedFromAuction1BTitanXUSD = flareDerivedFromAuction1BTitanX ? (flareDerivedFromAuction1BTitanX * usdcPerTitanX / marketFlarePerTitanX) : null;

    console.log('[FlareROI] USD Debug:', {
      wethPerTitanX,
      usdcPerWeth,
      usdcPerTitanX,
      currentMarketValue1BTitanXUSD,
      flareDerivedFromAuction1BTitanXUSD,
    });
  } else {
    console.log("[FlareROI] USD conditions not met:", {
      usdLoading,
      usdError,
      titanXWethSlot0: !!titanXWethSlot0,
      titanXWethToken0: !!titanXWethToken0,
      wethUsdcSlot0: !!wethUsdcSlot0,
      wethUsdcToken0: !!wethUsdcToken0,
    });
  }

  const roi = auctionFlarePerTitanX && marketFlarePerTitanX ? ((auctionFlarePerTitanX / marketFlarePerTitanX) * 100).toFixed(2) : null;
  const marketFlarePerX28Inverted = flarePerX28 ? 1 / flarePerX28 : null;

  console.log('[FlareROI] Final:', { 
    currentFlarePerTitanX: auctionFlarePerTitanX,
    marketFlareTitanXPrice: marketFlarePerTitanX,
    marketFlarePerX28: marketFlarePerX28Inverted,
    marketX28PerTitanX: x28PerTitanX,
    roi: roi,
    isLoading,
    hasError,
    purchasePrice,
    currentDay,
    currentMarketValue1BTitanX,
    flareDerivedFromAuction1BTitanX,
    marketValueFlareReceived,
    profitBasedROI: profitBasedROI?.toFixed(2),
    currentMarketValue1BTitanXUSD,
    flareDerivedFromAuction1BTitanXUSD,
  });

  return { 
    currentFlarePerTitanX: auctionFlarePerTitanX,
    marketFlareTitanXPrice: marketFlarePerTitanX,
    marketFlarePerX28: marketFlarePerX28Inverted,
    marketX28PerTitanX: x28PerTitanX,
    roi: roi,
    isLoading,
    hasError,
    currentMarketValue1BTitanX,
    flareDerivedFromAuction1BTitanX,
    marketValueFlareReceived,
    profitBasedROI: profitBasedROI?.toFixed(2),
    currentMarketValue1BTitanXUSD,
    flareDerivedFromAuction1BTitanXUSD,
  };
}-e 
---
File: ./eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [...compat.extends("next/core-web-vitals")];

export default eslintConfig;
