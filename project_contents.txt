
---
File: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
---

---
File: ./.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
---

---
File: ./app/layout.js
// app/layout.js
'use client';
import './layout.css';
import { Inter } from 'next/font/google';
import Navbar from '../components/Navbar';
import ClientProvider from './ClientProvider';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={`${inter.className} bg-gray-900 text-white`}>
        <ClientProvider>
          <Navbar />
          <main className="pt-16">{children}</main>
        </ClientProvider>
      </body>
    </html>
  );
}
---

---
File: ./app/page.js
// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { useFlareAuctionStore } from '../lib/store';
import { useFlareAuctionState } from '../lib/auctions/flare';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);
  const { setFlareAuctionDay } = useFlareAuctionStore();
  const { startTimestamp, startLoading, getAuctionDayStatus } = useFlareAuctionState();

  useEffect(() => {
    setIsLoaded(true);

    // Initialize Flare auction state
    if (!startLoading && startTimestamp) {
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const { isAuction, nextFlareAuctionStart } = getAuctionDayStatus(currentTimestamp);
      setFlareAuctionDay(isAuction, nextFlareAuctionStart);

      // Schedule daily update at 2 PM UTC
      const scheduleNextUpdate = () => {
        const now = new Date();
        const next2PMUTC = new Date(Date.UTC(
          now.getUTCFullYear(),
          now.getUTCMonth(),
          now.getUTCDate() + (now.getUTCHours() >= 14 ? 1 : 0),
          14, // 2 PM UTC
          0,
          0
        ));
        const timeUntilNext = next2PMUTC - now;

        setTimeout(() => {
          const newTimestamp = Math.floor(Date.now() / 1000);
          const { isAuction: newIsAuction, nextFlareAuctionStart: newNextStart } = getAuctionDayStatus(newTimestamp);
          setFlareAuctionDay(newIsAuction, newNextStart);
          scheduleNextUpdate();
        }, timeUntilNext);
      };
      scheduleNextUpdate();
    }
  }, [startLoading, startTimestamp, setFlareAuctionDay]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-gray-300">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}
---

---
File: ./app/nft/layout.js
// app/nft/layout.js
'use client';
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(contractDetails).map((key) => ({
    name: contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    const cachedData = getCache(contractKey);
    if (cachedData) {
      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
      return cachedData;
    }

    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }

    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];
    let allHolders = [];
    let totalTokens = 0;
    let totalLockedAscendant = 0;
    let totalShares = 0;
    let toDistributeDay8 = 0;
    let toDistributeDay28 = 0;
    let toDistributeDay90 = 0;
    let pendingRewards = 0;
    let page = 0;
    let totalPages = Infinity;

    try {
      while (page < totalPages) {
        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);
        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
          signal: AbortSignal.timeout(30000),
        });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);
        }
        const json = await res.json();
        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders.length}`);
        allHolders = allHolders.concat(json.holders || []);
        totalTokens = json.totalTokens || totalTokens;
        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
        totalShares = json.totalShares || totalShares;
        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
        pendingRewards = json.pendingRewards || pendingRewards;
        totalPages = json.totalPages || 1;
        page++;
        if (!json.holders || json.holders.length === 0) break;
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
      });
      let uniqueHolders = Array.from(uniqueHoldersMap.values());
      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
      uniqueHolders.forEach((holder, index) => {
        holder.rank = index + 1;
        holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      });

      const result = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalMultiplierSum,
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);
      const errorResult = { holders: [], totalTokens: 0, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map(nft => 
        fetchCollectionData(nft.apiKey)
          .then(data => ({ apiKey: nft.apiKey, data }))
          .catch(err => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            // Include totalShares for Ascendant to calculate Shares %
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`px-6 py-2 rounded-md font-semibold transition-colors ${
              selectedChain === chain.id
                ? 'bg-orange-500 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) => (
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            )
          ))}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl">{children}</div>
    </div>
  );
}
---

---
File: ./app/nft/page.js
// app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="text-center text-white">
      <p className="text-lg">Select a collection above to view details.</p>
    </div>
  );
}
---

---
File: ./app/nft/ETH/Stax/page.js
// app/nft/ETH/Stax/page.js
import NFTPage from '@/components/NFTPage';

export default function StaxPage() {
  return <NFTPage contractKey="staxNFT" />;
}
---

---
File: ./app/nft/ETH/Element280/page.js
// app/nft/ETH/Element280/page.js
import NFTPage from '@/components/NFTPage';

export default function Element280Page() {
  return <NFTPage contractKey="element280" />;
}
---

---
File: ./app/nft/ETH/Element369/page.js
// app/nft/ETH/Element369/page.js
import NFTPage from '@/components/NFTPage';
export default function Element369Page() {
  return <NFTPage contractKey="element369" />;
}
---

---
File: ./app/nft/ETH/Ascendant/page.js
// app/nft/ETH/Ascendant/page.js
import NFTPage from '@/components/NFTPage';

export default function AscendantPage() {
  return <NFTPage contractKey="ascendantNFT" />;
}
---

---
File: ./app/nft/BASE/E280/page.js
// app/nft/BASE/E280/page.js
import NFTPage from '@/components/NFTPage';

export default function E280Page() {
  return <NFTPage contractKey="e280" />;
}
---

---
Backup: ./app/token_contracts.js to token_contracts_backup.js

---

---
File: ./app/token_contracts.js
// app/token_contracts.js
export const tokenContracts = {
  // Ascendant
  ASCENDANT: {
    name: 'Ascendant Token',
    address: '0x0943D06A5Ff3B25ddC51642717680c105AD63c01',
    chainId: 1,
    type: 'token',
  },
  ASCENDANT_AUCTION: {
    name: 'Ascendant Auction',
    address: '0x592daEb53eB1cef8aa96305588310E997ec58c0c',
    chainId: 1,
    type: 'auction',
  },
  ASCENDANT_BUY_AND_BURN: {
    name: 'Ascendant Buy and Burn',
    address: '0x27D21C4Fa62F063B5f005c5BD87cffEa62e348D1',
    chainId: 1,
    type: 'buyAndBurn',
  },
  ASCENDANT_DRAGONX: {
    name: 'ASCENDANT/DRAGONX Pool',
    address: '0xe8cC60F526bec8C663C6eEc5A65eFAe9d89Ee6aD',
    chainId: 1,
    type: 'uniswapV3Pool',
  },
  ASCENDANT_NFT_MARKETPLACE: {
    name: 'Ascendant NFT Marketplace',
    address: '0x2a7156295E85991A3861e2FAB09Eef6AcAC94717',
    chainId: 1,
    type: 'marketplace',
  },
  ASCENDANT_NFT_MINTING: {
    name: 'Ascendant NFT Minting',
    address: '0x9dA95C32C5869c84Ba2C020B5e87329eC0aDC97f',
    chainId: 1,
    type: 'minting',
  },
  ASCENDANT_PRIDE: {
    name: 'Ascendant Pride',
    address: '0x1B7C257ee2D1f30E1be2F90968258F13eD961c82',
    chainId: 1,
    type: 'special',
  },

  // Blaze
  BLAZE: {
    name: 'Blaze Token',
    address: '0xfcd7cceE4071aA4ecFAC1683b7CC0aFeCAF42A36',
    chainId: 1,
    type: 'token',
  },
  BLAZE_AUCTION: {
    name: 'Blaze Auction',
    address: '0x200ed69de20Fe522d08dF5d7CE3d69aba4e02e74',
    chainId: 1,
    type: 'auction',
  },
  BLAZE_BONFIRE: {
    name: 'Blaze Bonfire',
    address: '0x72AB9dcAc1BE635e83D0E458D2aA1FbF439B44f7',
    chainId: 1,
    type: 'bonfire',
  },
  BLAZE_BUY_AND_BURN: {
    name: 'Blaze Buy and Burn',
    address: '0x27D80441831252950C528343a4F5CcC6b1E0EA95',
    chainId: 1,
    type: 'buyAndBurn',
  },
  BLAZE_STAKING: {
    name: 'Blaze Staking',
    address: '0xBc0043bc5b0c394D9d05d49768f9548F8CF9587b',
    chainId: 1,
    type: 'staking',
  },
  BLAZE_TITANX: {
    name: 'BLAZE/TITANX Pool',
    address: '0x4D3A10d4792Dd12ececc5F3034C8e264B28485d1',
    chainId: 1,
    type: 'uniswapV2Pool',
  },

  // Bonfire
  BONFIRE: {
    name: 'Bonfire Token',
    address: '0x7d51174B02b6242D7b4510Cd988d24bC39d026c3',
    chainId: 1,
    type: 'token',
  },
  BONFIRE_BUY_AND_BURN: {
    name: 'Bonfire Buy and Burn',
    address: '0xe871fEB86093809F1c9555a83B292419BB23F699',
    chainId: 1,
    type: 'buyAndBurn',
  },
  BONFIRE_X28: {
    name: 'BONFIRE/X28 Pool',
    address: '0x2DF1230D9Bd024A9d4EdB53336165Eb27AaBc7Fd',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // DragonX
  DRAGONX: {
    name: 'DragonX Token',
    address: '0x96a5399D07896f757Bd4c6eF56461F58DB951862',
    chainId: 1,
    type: 'token',
  },
  DRAGONX_BURN_PROXY: {
    name: 'DragonX Burn Proxy',
    address: '0x1d59429571d8Fde785F45bf593E94F2Da6072Edb',
    chainId: 1,
    type: 'proxy',
  },
  DRAGONX_BUY_AND_BURN: {
    name: 'DragonX Buy and Burn',
    address: '0x1A4330EAf13869D15014abcA69516FC6AB36E54D',
    chainId: 1,
    type: 'buyAndBurn',
  },
  DRAGONX_BUY_TITANS: {
    name: 'DragonX Buy Titans',
    address: '0x1A4330EAf13869D15014abcA69516FC6AB36E54D',
    chainId: 1,
    type: 'buyAndBurn',
  },
  DRAGONX_HYBRID: {
    name: 'DragonX Hybrid',
    address: '0x619321771d67d9D8e69A3503683FcBa0678D2eF3',
    chainId: 1,
    type: 'hybrid',
  },
  DRAGONX_TITANX: {
    name: 'DRAGONX/TITANX Pool',
    address: '0x25215d9ba4403b3DA77ce50606b54577a71b7895',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // E280
  E280_BASE: {
    name: 'E280 Token (Base)',
    address: '0x058E7b30200d001130232e8fBfDF900590E0bAA9',
    chainId: 8453,
    type: 'token',
  },
  E280_ETH: {
    name: 'E280 Token (Ethereum)',
    address: '0x058E7b30200d001130232e8fBfDF900590E0bAA9',
    chainId: 1,
    type: 'token',
  },
  E280_BUY_AND_BURN: {
    name: 'E280 Buy and Burn',
    address: '0x6E83D86841C70CCA0f16bf653A22899d06935Ee2',
    chainId: 1,
    type: 'buyAndBurn',
  },
  E280_LP_DEPOSITOR: {
    name: 'E280 LP Depositor',
    address: '0xB302fbF6c9836557371a79012b540303Cc758BB3',
    chainId: 1,
    type: 'depositor',
  },
  E280_REWARD_DEPOSITOR: {
    name: 'E280 Reward Depositor',
    address: '0xD8f842150511e8F501050E8a4c6878104312d82C',
    chainId: 1,
    type: 'depositor',
  },
  E280_TAX_DEPOSITOR: {
    name: 'E280 Tax Depositor',
    address: '0x55F643B0B7b8d8B824c2b33eC392023AbefF0a52',
    chainId: 1,
    type: 'depositor',
  },
  E280_TAX_DISTRIBUTOR: {
    name: 'E280 Tax Distributor',
    address: '0x1b25cc7461a9EE4a4c8f9dA82c828D8a39ea73e4',
    chainId: 1,
    type: 'distributor',
  },
  STAX_ELEMENT280: {
    name: 'STAX/ELEMENT280 Pool',
    address: '0x190BD81780e46124245d39774776be939bB8595B',
    chainId: 1,
    type: 'uniswapV2Pool',
  },

  // Eden
  EDEN: {
    name: 'Eden Token',
    address: '0x31b2c59d760058cfe57e59472E7542f776d987FB',
    chainId: 1,
    type: 'token',
  },
  EDEN_BLOOM_POOL: {
    name: 'Eden Bloom Pool',
    address: '0xe5Da018596D0e60d704b09d0E43734266e280e05',
    chainId: 1,
    type: 'pool',
  },
  EDEN_BUY_AND_BURN: {
    name: 'Eden Buy and Burn',
    address: '0x1681EB21026104Fa63121fD517e065cEc21A4b4C',
    chainId: 1,
    type: 'buyAndBurn',
  },
  EDEN_MINING: {
    name: 'Eden Mining',
    address: '0x890B015ECA83a6CA03b436a748969976502B7c0c',
    chainId: 1,
    type: 'mining',
  },
  EDEN_STAKING: {
    name: 'Eden Staking',
    address: '0x32C611b0a96789BaA3d6bF9F0867b7E1b9d049Be',
    chainId: 1,
    type: 'staking',
  },

  // Element
  ELEMENT: {
    name: 'Element Token',
    address: '0xe9A53C43a0B58706e67341C4055de861e29Ee943',
    chainId: 1,
    type: 'token',
  },
  ELEMENT_BUY_AND_BURN: {
    name: 'Element Buy and Burn',
    address: '0x3F2b113d180ecb1457e450b9EfcAC3df1Dd29AD3',
    chainId: 1,
    type: 'buyAndBurn',
  },
  ELEMENT_BUY_AND_BURN_V2: {
    name: 'Element Buy and Burn V2',
    address: '0x88BB363b333a6291Cf7CF5931eFe7a1E2D978325',
    chainId: 1,
    type: 'buyAndBurn',
  },
  ELEMENT_HOLDER_VAULT: {
    name: 'Element Holder Vault',
    address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
    chainId: 1,
    type: 'vault',
  },
  ELEMENT_NFT: {
    name: 'Element NFT',
    address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
    chainId: 1,
    type: 'nft',
  },

  // Element369
  ELEMENT369_FLUX_HUB: {
    name: 'Element369 Flux Hub',
    address: '0x6067487ee98B6A830cc3E5E7F57Dc194044D1F1D',
    chainId: 1,
    type: 'hub',
  },
  ELEMENT369_HOLDER_VAULT: {
    name: 'Element369 Holder Vault',
    address: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',
    chainId: 1,
    type: 'vault',
  },
  ELEMENT369_NFT: {
    name: 'Element369 NFT',
    address: '0x024D64E2F65747d8bB02dFb852702D588A062575',
    chainId: 1,
    type: 'nft',
  },

  // Flare
  FLARE: {
    name: 'Flare Token',
    address: '0x34a4FE5397bf2768189EDe14FE4adAD374B993B8',
    chainId: 1,
    type: 'token',
  },
  FLARE_AUCTION: {
    name: 'Flare Auction',
    address: '0x58aD6ef28BfB092635454D02303aDbd4D87b503C',
    chainId: 1,
    type: 'auction',
  },
  FLARE_AUCTION_BUY_AND_BURN: {
    name: 'Flare Auction Buy and Burn',
    address: '0x17d8258eC7fA1EfC9CA4c6C15f3417bF30564048',
    chainId: 1,
    type: 'buyAndBurn',
  },
  FLARE_AUCTION_TREASURY: {
    name: 'Flare Auction Treasury',
    address: '0x744D402674006f2711a3D6E4a80cc749C7915545',
    chainId: 1,
    type: 'treasury',
  },
  FLARE_BUY_AND_BURN: {
    name: 'Flare Buy and Burn',
    address: '0x6A12392C7dc5ddAA7d59007B329BFED35af092E6',
    chainId: 1,
    type: 'buyAndBurn',
  },
  FLARE_MINTING: {
    name: 'Flare Minting',
    address: '0x9983eF6Af4DE8fE58C45f6DC54Cf5Ad349431A82',
    chainId: 1,
    type: 'minting',
  },
  FLARE_X28: {
    name: 'FLARE/X28 Pool',
    address: '0x05b7Cc21A11354778Cf0D7faf159f1a99724ccFd',
    chainId: 1,
    type: 'uniswapV2Pool',
  },

  // Flux
  FLUX: {
    name: 'Flux Token',
    address: '0xBFDE5ac4f5Adb419A931a5bF64B0f3BB5a623d06',
    chainId: 1,
    type: 'token',
  },
  FLUX_777: {
    name: 'Flux 777',
    address: '0x52ca28e311f200d1CD47C06996063e14eC2d6aB1',
    chainId: 1,
    type: 'special',
  },
  FLUX_AUCTION: {
    name: 'Flux Auction',
    address: '0x36e5a8105f000029d4B3B99d0C3D0e24aaA52adF',
    chainId: 1,
    type: 'auction',
  },
  FLUX_BUY_AND_BURN: {
    name: 'Flux Buy and Burn',
    address: '0xaE14148F726E7C3AA5C0c992D044bE113b32292C',
    chainId: 1,
    type: 'buyAndBurn',
  },
  FLUX_STAKING: {
    name: 'Flux Staking',
    address: '0xd605a87187563C94c577a6E57e4a36eC8433B9aE',
    chainId: 1,
    type: 'staking',
  },
  FLUX_TITANX: {
    name: 'FLUX/TITANX Pool',
    address: '0x2278012E61c0fB38DaE1579bD41a87A59A5954c2',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // GoatX
  GOATX: {
    name: 'GoatX Token',
    address: '0x4Eca7761a516F8300711cbF920C0b85555261993',
    chainId: 1,
    type: 'token',
  },
  GOATX_AUCTION: {
    name: 'GoatX Auction',
    address: '0x059511B0BED706276Fa98877bd00ee0dD7303D32',
    chainId: 1,
    type: 'auction',
  },
  GOATX_BUY_AND_BURN: {
    name: 'GoatX Buy and Burn',
    address: '0xE6Cf4Cb42A6c37729c4546b4B9E83b97a05cE950',
    chainId: 1,
    type: 'buyAndBurn',
  },
  GOATX_MINING: {
    name: 'GoatX Mining',
    address: '0x4E83d6911bc1E191Bd207920737149B8FC060c8D',
    chainId: 1,
    type: 'mining',
  },

  // Helios
  HELIOS: {
    name: 'Helios Token',
    address: '0x2614f29C39dE46468A921Fd0b41fdd99A01f2EDf',
    chainId: 1,
    type: 'token',
  },
  HELIOS_BUY_AND_BURN: {
    name: 'Helios Buy and Burn',
    address: '0x9bff9f810d19cdb4bf7701c9d5ad101e91cda08d',
    chainId: 1,
    type: 'buyAndBurn',
  },
  HELIOS_TITANX: {
    name: 'HELIOS/TITANX Pool',
    address: '0x2C83C54C5612BfD62a78124D4A0eA001278a689c',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // Hyper
  HYPER: {
    name: 'Hyper Token',
    address: '0xE2cfD7a01ec63875cd9Da6C7c1B7025166c2fA2F',
    chainId: 1,
    type: 'token',
  },
  HYPER_BUY_AND_BURN: {
    name: 'Hyper Buy and Burn',
    address: '0x15Bec83b642217814dDAeB6F8A74ba7E0D6D157E',
    chainId: 1,
    type: 'buyAndBurn',
  },
  HYPER_TITANX: {
    name: 'HYPER/TITANX Pool',
    address: '0x14d725edB1299fF560d96f42462f0234B65B00AF',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // Hydra
  HYDRA: {
    name: 'Hydra Token',
    address: '0xCC7ed2ab6c3396DdBc4316D2d7C1b59ff9d2091F',
    chainId: 1,
    type: 'token',
  },
  HYDRA_BUY_AND_BURN: {
    name: 'Hydra Buy and Burn',
    address: '0xfEF10De0823F58DF4f5F24856aB4274EdeDa6A5c',
    chainId: 1,
    type: 'buyAndBurn',
  },
  HYDRA_DRAGONX: {
    name: 'HYDRA/DRAGONX Pool',
    address: '0xF8F0Ef9f6A12336A1e035adDDbD634F3B0962F54',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // Matrix
  MATRIX: {
    name: 'Matrix Token',
    address: '0xF2Fc894381792Ded27a7f08D9F0F246363cBe1ea',
    chainId: 1,
    type: 'token',
  },
  MATRIX_AUCTION: {
    name: 'Matrix Auction',
    address: '0x9f29E5b2d67C4a7315c5D6AbD448C45f9dD51CAF',
    chainId: 1,
    type: 'auction',
  },
  MATRIX_BUY_AND_BURN: {
    name: 'Matrix Buy and Burn',
    address: '0x50371D550e1eaB5aeC08d2D79B77B14b79dCC57E',
    chainId: 1,
    type: 'buyAndBurn',
  },
  MATRIX_HYPER: {
    name: 'MATRIX/HYPER Pool',
    address: '0x9dA4aCd7d87e7396901d92671173296bf9845c53',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // ORX
  ORX: {
    name: 'ORX Token',
    address: '0xd536e7a9543cf9867a580b45cec7f748a1fe11ec',
    chainId: 1,
    type: 'token',
  },
  ORX_MINTER: {
    name: 'ORX Minter',
    address: '0x4C93D6380D22C44850Bdfa569Df5dD96e278622B',
    chainId: 1,
    type: 'minter',
  },
  ORX_MULTISIG: {
    name: 'ORX Multisig',
    address: '0x54FDAcea0af4026306A665E9dAB635Ef5fF2963f',
    chainId: 1,
    type: 'multisig',
  },
  ORX_STAKING: {
    name: 'ORX Staking',
    address: '0xE293DFD4720308c048B63AfE885F5971E135Eb1e',
    chainId: 1,
    type: 'staking',
  },
  ORX_TITANX: {
    name: 'ORX/TITANX Pool',
    address: '0x2A216495584E406C39582d3ee583aEDA937beba6',
    chainId: 1,
    type: 'uniswapV3Pool',
  },
  USDX: {
    name: 'USDx Stable',
    address: '0xDDF73eAcB2218377FC38679aD14dfce51B651Dd1',
    chainId: 1,
    type: 'stablecoin',
  },

  // Phoenix
  PHOENIX: {
    name: 'Phoenix Token',
    address: '0xfe3F988a90dEa3eE537BB43eC1aCa7337A15D002',
    chainId: 1,
    type: 'token',
  },
  PHOENIX_AUCTION: {
    name: 'Phoenix Auction',
    address: '0xF41b5c99b8B6b88cF1Bd0320cB57e562EaF17DE1',
    chainId: 1,
    type: 'auction',
  },
  PHOENIX_BLAZE_STAKING_VAULT: {
    name: 'Phoenix Blaze Staking Vault',
    address: '0xBbe51Ee30422cb9a92D93363d2921A330813b598',
    chainId: 1,
    type: 'stakingVault',
  },
  PHOENIX_BUY_AND_BURN: {
    name: 'Phoenix Buy and Burn',
    address: '0x97eBd4f9FfCFE0cBC8F63A4e0B296FbB54f0a185',
    chainId: 1,
    type: 'buyAndBurn',
  },
  PHOENIX_FLUX_STAKING_VAULT: {
    name: 'Phoenix Flux Staking Vault',
    address: '0x3F1BFcd2a04a829ff4106217F8EB8eFa1C31e89b',
    chainId: 1,
    type: 'stakingVault',
  },
  PHOENIX_MINTING: {
    name: 'Phoenix Minting',
    address: '0xAaE97688F2c28c3E391dFddC7B26276D8445B199',
    chainId: 1,
    type: 'minting',
  },
  PHOENIX_TITANX_STAKING_VAULT: {
    name: 'Phoenix TitanX Staking Vault',
    address: '0x6B59b8E9635909B7f0FF2C577BB15c936f32619A',
    chainId: 1,
    type: 'stakingVault',
  },

  // Shogun
  SHOGUN: {
    name: 'Shogun Token',
    address: '0xfD4cB1294dF23920e683e046963117cAe6C807D9',
    chainId: 1,
    type: 'token',
  },
  SHOGUN_BUY_AND_BURN: {
    name: 'Shogun Buy and Burn',
    address: '0xF53D4f2E79d66605aE7c2CAdc0A40A1e7CbE973A',
    chainId: 1,
    type: 'buyAndBurn',
  },
  SHOGUN_TITANX: {
    name: 'SHOGUN/TITANX Pool',
    address: '0x79bd712f876c364Aa5e775A1eD40dE1FfdB2a50',
    chainId: 1,
    type: 'uniswapV2Pool',
  },

  // Stax
  STAX: {
    name: 'Stax Token',
    address: '0x4bd0F1886010253a18BBb401a788d8972c155b9d',
    chainId: 1,
    type: 'token',
  },
  STAX_BANK: {
    name: 'Stax Bank',
    address: '0x1b15e269D07986F0b8751872C16D9F47e1582402',
    chainId: 1,
    type: 'bank',
  },
  STAX_BLAZE: {
    name: 'Stax Blaze',
    address: '0x03a48BaadAe6A0474aDc6F39111428BaDbfb54D1',
    chainId: 1,
    type: 'staking',
  },
  STAX_BUY_AND_BURN: {
    name: 'Stax Buy and Burn',
    address: '0x1698a3e248FF7F0f1f91FE82Eedaa3F1212D1F7F',
    chainId: 1,
    type: 'buyAndBurn',
  },
  STAX_EDEN: {
    name: 'Stax Eden',
    address: '0x5d91C1180f063c66DC0a08CE136AeC92B97f8F87',
    chainId: 1,
    type: 'staking',
  },
  STAX_FLUX: {
    name: 'Stax Flux',
    address: '0xC3379750B254977f195BA60D096BBcCfe6b81ce8',
    chainId: 1,
    type: 'staking',
  },
  STAX_HELIOS: {
    name: 'Stax Helios',
    address: '0xCd5fd72664f5A4dB62E44e9c778E9dAeB01F2bB2',
    chainId: 1,
    type: 'staking',
  },
  STAX_HELIOS_V2: {
    name: 'Stax Helios V2',
    address: '0x3A50Cc9740DE6143c8d53Df44ece96Eeb07318E8',
    chainId: 1,
    type: 'staking',
  },
  STAX_HOLDER_VAULT: {
    name: 'Stax Holder Vault',
    address: '0x5D27813C32dD705404d1A78c9444dAb523331717',
    chainId: 1,
    type: 'vault',
  },
  STAX_HYPER: {
    name: 'Stax Hyper',
    address: '0xa23f149f10f415c56b1629Fe07bf94278c808271',
    chainId: 1,
    type: 'staking',
  },
  STAX_NFT: {
    name: 'Stax NFT',
    address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
    chainId: 1,
    type: 'nft',
  },
  STAX_ORX: {
    name: 'Stax ORX',
    address: '0xF1b7081Cab015ADB3c1B8D3A8732763dBc87B744',
    chainId: 1,
    type: 'staking',
  },
  STAX_TITANX: {
    name: 'Stax TitanX',
    address: '0x802974Ea9362b46a6eeAb4431E030D17dF6613E8',
    chainId: 1,
    type: 'staking',
  },

  // TitanX
  TITANX: {
    name: 'TitanX Token',
    address: '0xF19308F923582A6f7c465e5CE7a9Dc1BEC6665B1',
    chainId: 1,
    type: 'token',
  },
  TITANX_BUY_AND_BURN_V1: {
    name: 'TitanX Buy and Burn V1',
    address: '0x1393ad734EA3c52865b4B541cf049dafd25c23a5',
    chainId: 1,
    type: 'buyAndBurn',
  },
  TITANX_BUY_AND_BURN_V2: {
    name: 'TitanX Buy and Burn V2',
    address: '0x410e10C33a49279f78CB99c8d816F18D5e7D5404',
    chainId: 1,
    type: 'buyAndBurn',
  },
  TITANX_TREASURY: {
    name: 'TitanX Treasury',
    address: '0xA2d21205Aa7273BadDFC8E9551e05E23bB49ce46',
    chainId: 1,
    type: 'treasury',
  },
  TITANX_WETH: {
    name: 'TITANX/WETH Pool',
    address: '0xc45A81BC23A64eA556ab4CdF08A86B61cdcEEA8b',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // USDC
  USDC: {
    name: 'USDC Token',
    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
    chainId: 1,
    type: 'stablecoin',
  },

  // Volt
  VOLT: {
    name: 'Volt Token',
    address: '0x66b5228CfD34d9f4d9f03188d67816286C7c0b74',
    chainId: 1,
    type: 'token',
  },
  VOLT_AUCTION: {
    name: 'Volt Auction',
    address: '0xb3f2bE29BA969588E07bF7512e07008D6fdeB17B',
    chainId: 1,
    type: 'auction',
  },
  VOLT_BUY_AND_BURN: {
    name: 'Volt Buy and Burn',
    address: '0x2801592e5Cdd85aC4e462DB2abC80951705cf601',
    chainId: 1,
    type: 'buyAndBurn',
  },
  VOLT_TITANX: {
    name: 'VOLT/TITANX Pool',
    address: '0x3F1A36B6C946E406f4295A89fF06a5c7d62F2fe2',
    chainId: 1,
    type: 'uniswapV3Pool',
  },
  VOLT_TREASURY: {
    name: 'Volt Treasury',
    address: '0xb638BFB7BC3B8398bee48569CFDAA6B3Bb004224',
    chainId: 1,
    type: 'treasury',
  },

  // Vyper
  VYPER: {
    name: 'Vyper Token',
    address: '0xd7fa4cFC22eA07DfCeD53033fbE59d8b62B8Ee9E',
    chainId: 1,
    type: 'token',
  },
  VYPER_BOOST_AUCTION: {
    name: 'Vyper Boost Auction',
    address: '0x4D994F53FE2d8BdBbF64dC2e53C58Df00b84e713',
    chainId: 1,
    type: 'auction',
  },
  VYPER_BOOST_TREASURY: {
    name: 'Vyper Boost Treasury',
    address: '0x637dfBB5db0cf7B4062cb577E24cfB43c67d72BA',
    chainId: 1,
    type: 'treasury',
  },
  VYPER_CLASSIC_AUCTION: {
    name: 'Vyper Classic Auction',
    address: '0xC1da113c983b26aa2c3f4fFD5f10b47457FC3397',
    chainId: 1,
    type: 'auction',
  },
  VYPER_CLASSIC_TREASURY: {
    name: 'Vyper Classic Treasury',
    address: '0xeb103eb39375077c5Afaa04150B4D334df69128A',
    chainId: 1,
    type: 'treasury',
  },
  VYPER_DRAGONX: {
    name: 'VYPER/DRAGONX Pool',
    address: '0x214CAD3f7FbBe66919968Fa3a1b16E84cFcd457F',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // WETH
  WETH: {
    name: 'Wrapped Ether',
    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    chainId: 1,
    type: 'token',
  },

  // WETH/USDC Pool
  WETH_USDC: {
    name: 'WETH/USDC Pool',
    address: '0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640',
    chainId: 1,
    type: 'uniswapV3Pool',
  },

  // X28
  X28: {
    name: 'X28 Omnichain Token',
    address: '0x5c47902c8C80779CB99235E42C354E53F38C3B0d',
    chainId: 1,
    type: 'token',
  },
  X28_BUY_AND_BURN: {
    name: 'X28 Buy and Burn',
    address: '0xa3144E7FCceD79Ce6ff6E14AE9d8DF229417A7a2',
    chainId: 1,
    type: 'buyAndBurn',
  },
  X28_TITANX: {
    name: 'X28/TITANX Pool',
    address: '0x99f60479da6A49D55eBA34893958cdAACc710eE9',
    chainId: 1,
    type: 'uniswapV3Pool',
  },
};

export const auctionABI = [
  {
    type: 'function',
    name: 'startTimestamp',
    inputs: [],
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
  },
  {
    type: 'function',
    name: 'dailyStats',
    inputs: [{ name: 'day', type: 'uint32' }],
    outputs: [
      { name: 'titanXDeposited', type: 'uint256' },
      { name: 'ethDeposited', type: 'uint256' },
      { name: 'flareEmitted', type: 'uint256' },
      { name: 'depositsLocked', type: 'bool' },
    ],
    stateMutability: 'view',
  },
];

export const flareTokenABI = [
  {
    type: 'function',
    name: 'x28FlarePool',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];

export const uniswapPoolABI = [
  {
    type: 'function',
    name: 'slot0',
    inputs: [],
    outputs: [
      { name: 'sqrtPriceX96', type: 'uint160' },
      { name: 'tick', type: 'int24' },
      { name: 'observationIndex', type: 'uint16' },
      { name: 'observationCardinality', type: 'uint16' },
      { name: 'observationCardinalityNext', type: 'uint16' },
      { name: 'feeProtocol', type: 'uint8' },
      { name: 'unlocked', type: 'bool' },
    ],
    stateMutability: 'view',
  },
  {
    type: 'function',
    name: 'token0',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
  {
    type: 'function',
    name: 'token1',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];

export const uniswapV2PoolABI = [
  {
    type: 'function',
    name: 'getReserves',
    inputs: [],
    outputs: [
      { name: '_reserve0', type: 'uint112' },
      { name: '_reserve1', type: 'uint112' },
      { name: '_blockTimestampLast', type: 'uint32' },
    ],
    stateMutability: 'view',
  },
  {
    type: 'function',
    name: 'token0',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
  {
    type: 'function',
    name: 'token1',
    inputs: [],
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
  },
];
---

---
File: ./app/store.js
// app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));
---

---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          I'd like to add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}
---

---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}
---

---
File: ./app/api/holders/Stax/route.js
// app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

const settings = {
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  network: Network.ETH_MAINNET,
};
const alchemy = new Alchemy(settings);

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

function log(message) {
  console.log(`[PROD_DEBUG] staxNFT - ${message}`);
}

async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    const batchResults = await client.multicall({ contracts: batch });
    results.push(...batchResults);
  }
  return results;
}

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.staxNFT;
  const tiers = contractTiers.staxNFT;
  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);

  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {
    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");
    throw new Error("Server configuration error: Missing Alchemy API key");
  }
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest', // Dynamic supply
    withTokenBalances: true,
  });
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier].multiplier || 0;
        holder.tiers[tier] += 1;
      }
    }
  });

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum; // No division for Stax
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  return {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] StaxNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
---

---
File: ./app/api/holders/E280/route.js
// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Data not available yet');
  return NextResponse.json({ message: 'E280 data will go live after deployment' });
}
---

---
File: ./app/api/holders/Element280/route.js
// app/api/holders/Element280/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, nftAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';
let cache = {};
let tokenCache = new Map();

async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 1000) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getAllHolders: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`getAllHolders start: ${contractName} at ${contractAddress}, page=${page}, pageSize=${pageSize}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true });
  log(`${contractName} - Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`${contractName} - Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`${contractName} - Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`${contractName} - Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = [];
  paginatedTokenIds.forEach((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    if (owner && owner !== burnAddress) {
      validTokenIds.push(tokenId);
      tokenCache.set(cacheKey, owner);
    } else {
      tokenCache.set(cacheKey, null);
    }
  });
  log(`${contractName} - Valid token IDs after ownerOf: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    log(`${contractName} - No valid tokens found in this page`);
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(allTokenIds.length / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  log(`${contractName} - Starting tier multicall for ${tierCalls.length} tokens`);
  const tierResults = await batchMulticall(tierCalls);
  log(`${contractName} - Tier results length: ${tierResults.length}`);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalNftsHeld = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractName} - Undefined tier result at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }

        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        totalNftsHeld += 1;
      } else {
        log(`${contractName} - Invalid tier ${tier} for token ${tokenId}`);
      }
    } else {
      log(`${contractName} - Failed tier fetch at index ${i}, tokenId: ${validTokenIds[i]}`);
    }
  });
  log(`${contractName} - Total NFTs held after tier check: ${totalNftsHeld}`);

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum / 10; // Element280 specific adjustment
  });

  const sortFn = (a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total;
  holders.sort(sortFn);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(allTokenIds.length / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractName} - Final holders count: ${holders.length}`);
  return result;
}

async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getHolderData: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  log(`getHolderData start: wallet=${wallet}, contract=${contractAddress}`);
  const nfts = await alchemy.nft.getNftsForOwner(wallet, { contractAddresses: [contractAddress] });
  log(`${contractAddress} - Initial NFTs for ${wallet}: ${nfts.totalCount}`);

  if (nfts.totalCount === 0) return null;

  const walletLower = wallet.toLowerCase();
  const tokenIds = nfts.ownedNfts.map(nft => BigInt(nft.tokenId));
  const ownerOfCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = tokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    tokenCache.set(cacheKey, owner);
    return owner === walletLower;
  });
  log(`${contractAddress} - Valid token IDs for ${wallet}: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) return null;

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractAddress} - Undefined tier result for wallet ${wallet} at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tier = Number(result.result);
      const tokenId = validTokenIds[i];
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);
      if (tier >= 1 && tier <= maxTier) {
        tiersArray[tier] += 1;
        total += 1;
        multiplierSum += tiers[tier]?.multiplier || 0;
      }
    }
  });
  log(`${contractAddress} - Total NFTs for ${wallet} after tier check: ${total}`);

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 1000);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const percentage = totalMultiplierSum > 0 ? (multiplierSum / totalMultiplierSum) * 100 : 0;
  const holder = allHolders.holders.find(h => h.wallet === walletLower) || { rank: allHolders.holders.length + 1 };

  const result = {
    wallet: walletLower,
    rank: holder.rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum / 10, // Element280 specific adjustment
    percentage,
    tiers: tiersArray,
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractAddress} - Final data for ${wallet}: total=${total}, multiplierSum=${multiplierSum}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  const address = contractAddresses['element280']; // Hardcoded for this endpoint
  if (!address) {
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers['element280']);
      return NextResponse.json({ holders: holderData ? [holderData] : [] });
    }

    const result = await getAllHolders(address, contractTiers['element280'], page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    log(`Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
---

---
File: ./app/api/holders/Element369/route.js
// app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

const settings = {
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  network: Network.ETH_MAINNET,
};
const alchemy = new Alchemy(settings);

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

function log(message) {
  console.log(`[PROD_DEBUG] element369 - ${message}`);
}

async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    const batchResults = await client.multicall({ contracts: batch });
    results.push(...batchResults);
  }
  return results;
}

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.element369;
  const tiers = contractTiers.element369;
  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);

  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {
    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");
    throw new Error("Server configuration error: Missing Alchemy API key");
  }
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest',
    withTokenBalances: true,
  });
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier].multiplier || 0;
        holder.tiers[tier] += 1;
      }
    }
  });

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  return {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] Element369 API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
---

---
File: ./app/api/holders/Ascendant/route.js
// app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, ascendantAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

let cache = {};
let tokenCache = new Map();

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.ascendantNFT;
  const tiers = contractTiers.ascendantNFT;
  const contractName = 'ascendantNFT';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest',
    withTokenBalances: true,
  });
  log(`Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    const result = { 
      holders: [], 
      totalTokens, 
      totalLockedAscendant: 0, 
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page, 
      pageSize, 
      totalPages: Math.ceil(totalTokens / pageSize) 
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'getNFTAttribute',
    args: [tokenId],
  }));
  const recordCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'userRecords',
    args: [tokenId],
  }));

  const [tierResults, recordResults] = await Promise.all([
    batchMulticall(tierCalls),
    batchMulticall(recordCalls),
  ]);

  const totalShares = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'totalShares',
  }));
  const toDistributeDay8 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [0], // POOLS.DAY8
  }));
  const toDistributeDay28 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [1], // POOLS.DAY28
  }));
  const toDistributeDay90 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [2], // POOLS.DAY90
  }));
  const rewardPerShare = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'rewardPerShare',
  }));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result[1]);
      const record = recordResults[i]?.status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];
      const shares = Number(record[0]);
      const lockedAscendant = Number(record[1]);
      const rewardDebt = Number(record[2]);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
            shares: 0,
            lockedAscendant: 0,
            rewardDebt: 0,
            pendingDay8: 0,
            pendingDay28: 0,
            pendingDay90: 0,
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        holder.shares += shares;
        holder.lockedAscendant += lockedAscendant;
        holder.rewardDebt += rewardDebt;
        totalLockedAscendant += lockedAscendant;
      }
    }
  });

  // Calculate pending rewards per wallet
  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach(holder => {
    const currentRewardPerShare = rewardPerShare + pendingRewardPerShareDay8 + pendingRewardPerShareDay28 + pendingRewardPerShareDay90;
    const totalPending = holder.shares * (currentRewardPerShare - holder.rewardDebt / holder.total);
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  const result = {
    holders,
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`Returning: holders=${holders.length}, totalTokens=${totalTokens}, totalLockedAscendant=${totalLockedAscendant}, totalShares=${totalShares}, pendingRewards=${result.pendingRewards}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] AscendantNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
---

---
File: ./app/api/holders/Ascendant/route copy.js
// app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, ascendantAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';

let cache = {};
let tokenCache = new Map();

async function getAllHolders(page = 0, pageSize = 1000) {
  const contractAddress = contractAddresses.ascendantNFT;
  const tiers = contractTiers.ascendantNFT;
  const contractName = 'ascendantNFT';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);
  if (!contractAddress) {
    log("Missing contract address");
    throw new Error("Contract address not found");
  }
  if (!tiers) {
    log("Missing tiers configuration");
    throw new Error("Tiers configuration not found");
  }

  log(`Using contract address: ${contractAddress}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
    block: 'latest',
    withTokenBalances: true,
  });
  log(`Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    const result = { 
      holders: [], 
      totalTokens, 
      totalLockedAscendant: 0, 
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page, 
      pageSize, 
      totalPages: Math.ceil(totalTokens / pageSize) 
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'getNFTAttribute',
    args: [tokenId],
  }));
  const recordCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'userRecords',
    args: [tokenId],
  }));

  const [tierResults, recordResults] = await Promise.all([
    batchMulticall(tierCalls),
    batchMulticall(recordCalls),
  ]);

  const totalShares = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'totalShares',
  }));
  const toDistributeDay8 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [0], // POOLS.DAY8
  }));
  const toDistributeDay28 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [1], // POOLS.DAY28
  }));
  const toDistributeDay90 = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'toDistribute',
    args: [2], // POOLS.DAY90
  }));
  const rewardPerShare = Number(await client.readContract({
    address: contractAddress,
    abi: ascendantAbi,
    functionName: 'rewardPerShare',
  }));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  tierResults.forEach((result, i) => {
    if (result?.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result[1]);
      const record = recordResults[i]?.status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];
      const shares = Number(record[0]);
      const lockedAscendant = Number(record[1]);
      const rewardDebt = Number(record[2]);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
            shares: 0,
            lockedAscendant: 0,
            rewardDebt: 0,
            pendingDay8: 0,
            pendingDay28: 0,
            pendingDay90: 0,
          });
        }
        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        holder.shares += shares;
        holder.lockedAscendant += lockedAscendant;
        holder.rewardDebt += rewardDebt;
        totalLockedAscendant += lockedAscendant;
      }
    }
  });

  // Calculate pending rewards per wallet
  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach(holder => {
    const currentRewardPerShare = rewardPerShare + pendingRewardPerShareDay8 + pendingRewardPerShareDay28 + pendingRewardPerShareDay90;
    const totalPending = holder.shares * (currentRewardPerShare - holder.rewardDebt / holder.total);
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));
  log(`Final holders count: ${holders.length}`);

  const result = {
    holders,
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`Returning: holders=${holders.length}, totalTokens=${totalTokens}, totalLockedAscendant=${totalLockedAscendant}, totalShares=${totalShares}, pendingRewards=${result.pendingRewards}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`Received request: page=${page}, pageSize=${pageSize}`);

  try {
    const result = await getAllHolders(page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    console.error(`[PROD_ERROR] AscendantNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
---

---
File: ./app/api/utils.js
// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

export const nftAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNftTier(uint256 tokenId) view returns (uint8)",
]);

export const ascendantAbi = parseAbi([
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)",
  "function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)",
  "function totalShares() view returns (uint256)",
  "function toDistribute(uint8 pool) view returns (uint256)",
  "function rewardPerShare() view returns (uint256)",
  "error NonExistentToken(uint256 tokenId)"
]);

export const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export function log(message) {
  console.log(`[PROD_DEBUG] ${message}`);
}

export async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);
    } catch (error) {
      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);
      results.push(...batch.map(() => ({ status: 'failure', result: null })));
    }
  }
  log(`batchMulticall: Completed with ${results.length} results`);
  return results;
}
---

---
File: ./app/api/auctions/flare/route.js
// app/api/auctions/flare/route.js
import { NextResponse } from 'next/server';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { tokenContracts, auctionABI, flareMintingABI, uniswapPoolABI } from '@/app/token_contracts';
import { wdiv } from '@/utils/Math'; // Use shared wdiv

function getDayEnd(t) {
  const adjustedTime = t - 14 * 3600; // Subtract 14 hours
  const daysSinceEpoch = Math.floor(adjustedTime / 86400);
  return (daysSinceEpoch + 1) * 86400 + 14 * 3600; // Next day at 2 PM UTC
}

export async function GET() {
  try {
    const client = createPublicClient({
      chain: mainnet,
      transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
    });

    // Fetch start timestamp
    const startTimestamp = await client.readContract({
      address: tokenContracts.FLARE_AUCTION.address,
      abi: auctionABI,
      functionName: 'startTimestamp',
    });

    const now = Date.now() / 1000;

    // Check if auction has started
    if (Number(startTimestamp) > now) {
      return NextResponse.json(
        {
          currentDay: 0,
          startTimestamp: Number(startTimestamp),
          flareEmitted: 0,
          titanXDeposited: 0,
          ethDeposited: 0,
          depositsLocked: false,
          roi: 0,
          currentFlarePerTitanX: 0,
          marketFlareTitanXPrice: 0,
          timeRemaining: 'Not started',
          deviationStatus: 'N/A',
          mintCycle: {
            currentCycle: 0,
            startsAt: 0,
            endsAt: 0,
            isMinting: false,
          },
        },
        {
          headers: {
            'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=300',
          },
        }
      );
    }

    // Calculate current day
    const currentDay = Math.max(1, Math.floor((now - Number(startTimestamp)) / 86400));

    // Fetch daily stats
    const dailyStats = await client.readContract({
      address: tokenContracts.FLARE_AUCTION.address,
      abi: auctionABI,
      functionName: 'dailyStats',
      args: [currentDay],
    });

    // Fetch minting cycle
    const mintCycle = await client.readContract({
      address: tokenContracts.FLARE_MINTING.address,
      abi: flareMintingABI,
      functionName: 'getCurrentMintCycle',
    });

    // Fetch TWAP and spot price
    const twapData = await client.readContract({
      address: tokenContracts.FLARE_X28.address,
      abi: uniswapPoolABI,
      functionName: 'observe',
      args: [[15 * 60, 0]], // 15-minute TWAP
    });
    const poolData = await client.readContract({
      address: tokenContracts.FLARE_X28.address,
      abi: uniswapPoolABI,
      functionName: 'slot0',
    });

    const [titanXDeposited, ethDeposited, flareEmitted, depositsLocked] = dailyStats;
    const [currentCycle, cycleStartsAt, cycleEndsAt] = mintCycle;
    const [sqrtPriceX96] = poolData;
    const [[tickCumulativesPast, tickCumulativesNow],] = twapData;

    // Calculate time remaining using getDayEnd
    const dayEnd = getDayEnd(Number(startTimestamp) + (currentDay - 1) * 86400);
    const secondsLeft = dayEnd - now;
    const hours = Math.floor(secondsLeft / 3600);
    const minutes = Math.floor((secondsLeft % 3600) / 60);
    const timeRemaining = secondsLeft > 0 ? `${hours}h ${minutes}m` : 'Ended';

    // Calculate deviation and prices
    let deviationStatus = 'N/A';
    let currentFlarePerTitanX = 0;
    let marketFlareTitanXPrice = 0;
    let roi = 0;
    if (flareEmitted !== 0n && titanXDeposited !== 0n) {
      const tickCumulativesDelta = Number(tickCumulativesNow) - Number(tickCumulativesPast);
      const secondsAgo = 15 * 60;
      let arithmeticMeanTick = Math.floor(tickCumulativesDelta / secondsAgo);
      if (tickCumulativesDelta < 0 && tickCumulativesDelta % secondsAgo !== 0) {
        arithmeticMeanTick--;
      }
      const sqrtPriceX96Twap = Math.sqrt(1.0001 ** arithmeticMeanTick) * 2 ** 96;
      const price = Number((BigInt(sqrtPriceX96) ** 2n) / (2n ** 192n)) / 1e18;
      const twapPrice = Number((BigInt(sqrtPriceX96Twap) ** 2n) / (2n ** 192n)) / 1e18;
      const diff = twapPrice >= price ? twapPrice - price : price - twapPrice;
      const deviationLimit = 300; // 3% from SwapActions.sol
      deviationStatus = (price * deviationLimit) / 10000 < diff ? 'Out of bounds' : 'Within bounds';
      currentFlarePerTitanX = Number(wdiv(flareEmitted, titanXDeposited)) / 1e18;
      marketFlareTitanXPrice = twapPrice;
      roi = deviationStatus === 'Out of bounds' ? 0 : (currentFlarePerTitanX / marketFlareTitanXPrice) * 100;
    }

    const auctionData = {
      currentDay,
      startTimestamp: Number(startTimestamp),
      flareEmitted: Number(flareEmitted) / 1e18,
      titanXDeposited: Number(titanXDeposited) / 1e18,
      ethDeposited: Number(ethDeposited) / 1e18,
      depositsLocked,
      roi,
      currentFlarePerTitanX,
      marketFlareTitanXPrice,
      timeRemaining,
      deviationStatus,
      mintCycle: {
        currentCycle: Number(currentCycle),
        startsAt: Number(cycleStartsAt),
        endsAt: Number(cycleEndsAt),
        isMinting: now < Number(cycleEndsAt),
      },
    };

    const cacheTTL = 5 * 60; // 5 minutes
    return NextResponse.json(auctionData, {
      headers: {
        'Cache-Control': `public, s-maxage=${cacheTTL}, stale-while-revalidate=${cacheTTL}`,
      },
    });
  } catch (error) {
    console.error('Error fetching Flare auction data:', error);
    return NextResponse.json(
      { error: `Failed to fetch auction data: ${error.message}` },
      { status: 500 }
    );
  }
}
---

---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}
---

---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';
import { useFlareROI } from '@/lib/auctions/flare';
import { useAscendantROI } from '@/lib/auctions/ascendant';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const {
    auctionFlarePerTitanX,
    marketFlarePerTitanX,
    flarePerX28,
    roi: flareROI,
    isLoading: flareLoading,
    hasError: flareError,
    status: flareStatus,
  } = useFlareROI();

  const {
    auctionAscendantPerTitanX,
    marketAscendantPerTitanX,
    ascendPerDragonX,
    marketDragonXPerTitanX,
    roi: ascendantROI,
    isLoading: ascendantLoading,
    hasError: ascendantError,
    status: ascendantStatus,
  } = useAscendantROI();

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  const renderAuctionDetails = (auction) => {
    if (auction.name === 'Flare') {
      if (flareLoading) {
        return <p className="text-gray-300 text-sm">Loading Flare data...</p>;
      }
      if (flareError || flareStatus === 'error') {
        return <p className="text-red-500 text-sm">Error loading Flare data.</p>;
      }
      if (flareStatus === 'no_data') {
        return <p className="text-gray-300 text-sm">No Flare auction data available.</p>;
      }
      return (
        <div className="text-gray-300 text-sm mt-2">
          <p><strong>ROI:</strong> {flareROI ? `${flareROI}%` : 'N/A'}</p>
          <p><strong>Auction Rate:</strong> {auctionFlarePerTitanX ? `${auctionFlarePerTitanX.toFixed(2)} FLARE/TX` : 'N/A'}</p>
          <p><strong>Market Rate:</strong> {marketFlarePerTitanX ? `${marketFlarePerTitanX.toFixed(2)} FLARE/TX` : 'N/A'}</p>
          <p><strong>FLARE/X28:</strong> {flarePerX28 ? `${flarePerX28.toFixed(2)} FLARE/X28` : 'N/A'}</p>
        </div>
      );
    }
    if (auction.name === 'Ascendant') {
      if (ascendantLoading) {
        return <p className="text-gray-300 text-sm">Loading Ascendant data...</p>;
      }
      if (ascendantError || ascendantStatus === 'error') {
        return <p className="text-red-500 text-sm">Error loading Ascendant data.</p>;
      }
      if (ascendantStatus === 'no_data') {
        return <p className="text-gray-300 text-sm">No Ascendant auction data available.</p>;
      }
      return (
        <div className="text-gray-300 text-sm mt-2">
          <p><strong>ROI:</strong> {ascendantROI ? `${ascendantROI}%` : 'N/A'}</p>
          <p><strong>Auction Rate:</strong> {auctionAscendantPerTitanX ? `${auctionAscendantPerTitanX.toFixed(2)} ASCEND/TX` : 'N/A'}</p>
          <p><strong>Market Rate:</strong> {marketAscendantPerTitanX ? `${marketAscendantPerTitanX.toFixed(2)} ASCEND/TX` : 'N/A'}</p>
          <p><strong>ASCEND/DRAGONX:</strong> {ascendPerDragonX ? `${ascendPerDragonX.toFixed(2)} ASCEND/DRAGONX` : 'N/A'}</p>
          <p><strong>DRAGONX/TITANX:</strong> {marketDragonXPerTitanX ? `${marketDragonXPerTitanX.toFixed(2)} DRAGONX/TX` : 'N/A'}</p>
        </div>
      );
    }
    return null; // No details for other auctions
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions in the TitanX ecosystem. Click to view.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <a
                  href={auction.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="hover:underline"
                  onClick={(e) => e.preventDefault()}
                >
                  {auction.url}
                </a>
              </p>
              {renderAuctionDetails(auction)}
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <iframe
              src={selectedAuction.url}
              className="w-full h-full border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
              onError={(e) => {
                console.error(`Failed to load iframe for ${selectedAuction.name}: ${selectedAuction.url}`, e);
              }}
            />
          </div>
        </div>
      )}
    </div>
  );
}
---

---
File: ./app/nft-contracts.js
// app/nft-contracts.js
export const nftContracts = {
  element280: {
    name: "Element 280",
    symbol: "ELMNT",
    address: "0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9",
    deploymentBlock: "20945304",
    tiers: {
      1: { name: "Common", multiplier: 10, allocation: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 12, allocation: "100000000000000000000000000" },
      3: { name: "Rare", multiplier: 100, allocation: "1000000000000000000000000000" },
      4: { name: "Rare Amped", multiplier: 120, allocation: "1000000000000000000000000000" },
      5: { name: "Legendary", multiplier: 1000, allocation: "10000000000000000000000000000" },
      6: { name: "Legendary Amped", multiplier: 1200, allocation: "10000000000000000000000000000" },
    },
    description:
      "Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.",
  },
  element369: {
    name: "Element 369",
    symbol: "E369",
    address: "0x024D64E2F65747d8bB02dFb852702D588A062575",
    deploymentBlock: "21224418",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      3: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
    },
    description:
      "Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.",
  },
  staxNFT: {
    name: "Stax",
    symbol: "STAX",
    address: "0x74270Ca3a274B4dbf26be319A55188690CACE6E1",
    deploymentBlock: "21452667",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 1.2, price: "100000000000000000000000000", amplifier: "10000000000000000000000000" },
      3: { name: "Common Super", multiplier: 1.4, price: "100000000000000000000000000", amplifier: "20000000000000000000000000" },
      4: { name: "Common LFG", multiplier: 2, price: "100000000000000000000000000", amplifier: "50000000000000000000000000" },
      5: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      6: { name: "Rare Amped", multiplier: 12, price: "1000000000000000000000000000", amplifier: "100000000000000000000000000" },
      7: { name: "Rare Super", multiplier: 14, price: "1000000000000000000000000000", amplifier: "200000000000000000000000000" },
      8: { name: "Rare LFG", multiplier: 20, price: "1000000000000000000000000000", amplifier: "500000000000000000000000000" },
      9: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
      10: { name: "Legendary Amped", multiplier: 120, price: "10000000000000000000000000000", amplifier: "1000000000000000000000000000" },
      11: { name: "Legendary Super", multiplier: 140, price: "10000000000000000000000000000", amplifier: "2000000000000000000000000000" },
      12: { name: "Legendary LFG", multiplier: 200, price: "10000000000000000000000000000", amplifier: "5000000000000000000000000000" },
    },
    description:
      "Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.",
  },
  ascendantNFT: {
    name: "Ascendant",
    symbol: "ASCNFT",
    address: "0x9da95c32c5869c84ba2c020b5e87329ec0adc97f",
    deploymentBlock: "21112535",
    tiers: {
      1: { name: "Tier 1", price: "7812500000000000000000", multiplier: 1.01 },
      2: { name: "Tier 2", price: "15625000000000000000000", multiplier: 1.02 },
      3: { name: "Tier 3", price: "31250000000000000000000", multiplier: 1.03 },
      4: { name: "Tier 4", price: "62500000000000000000000", multiplier: 1.04 },
      5: { name: "Tier 5", price: "125000000000000000000000", multiplier: 1.05 },
      6: { name: "Tier 6", price: "250000000000000000000000", multiplier: 1.06 },
      7: { name: "Tier 7", price: "500000000000000000000000", multiplier: 1.07 },
      8: { name: "Tier 8", price: "1000000000000000000000000", multiplier: 1.08 },
    },
    description:
      "Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.",
  },
  e280: {
    name: "E280",
    symbol: "E280",
    address: null, // Not deployed yet
    deploymentBlock: null,
    tiers: {}, // Define if applicable
    description: "E280 NFTs on BASE chain. Contract not yet deployed.",
  },
};

export const contractAddresses = {
  element280: nftContracts.element280.address,
  element369: nftContracts.element369.address,
  staxNFT: nftContracts.staxNFT.address,
  ascendantNFT: nftContracts.ascendantNFT.address,
  e280: nftContracts.e280.address,
};

export const deploymentBlocks = {
  element280: nftContracts.element280.deploymentBlock,
  element369: nftContracts.element369.deploymentBlock,
  staxNFT: nftContracts.staxNFT.deploymentBlock,
  ascendantNFT: nftContracts.ascendantNFT.deploymentBlock,
  e280: nftContracts.e280.deploymentBlock,
};

export const contractTiers = {
  element280: nftContracts.element280.tiers,
  element369: nftContracts.element369.tiers,
  staxNFT: nftContracts.staxNFT.tiers,
  ascendantNFT: nftContracts.ascendantNFT.tiers,
  e280: nftContracts.e280.tiers,
};

export const contractDetails = {
  element280: {
    name: nftContracts.element280.name,
    totalTokens: 8209, // Update with actual value if needed
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element280',
  },
  element369: {
    name: nftContracts.element369.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element369',
  },
  staxNFT: {
    name: nftContracts.staxNFT.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Stax',
  },
  ascendantNFT: {
    name: nftContracts.ascendantNFT.name,
    totalTokens: 0, // Update with actual value
    pageSize: 1000,
    apiEndpoint: '/api/holders/Ascendant',
  },
  e280: {
    name: nftContracts.e280.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/E280',
  },
};

export function getContractDetails(contractName) {
  return nftContracts[contractName] || null;
}
---

---
File: ./app/ClientProvider.js
// app/ClientProvider.js
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider, createConfig, http } from 'wagmi';
import { mainnet } from 'wagmi/chains';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 60 * 1000, // 30 minutes
      cacheTime: 60 * 60 * 1000, // 1 hour
    },
  },
});

const config = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http(`https://eth-mainnet.alchemyapi.io/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
  },
});

export default function ClientProvider({ children }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
}
---

---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.

const config = {
  plugins: ["tailwindcss"],
};
export default config;
---

---
File: ./next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

---

---
File: ./utils/Math.js
// app/utils/Math.js
export function wdiv(a, b) {
    if (BigInt(b) === 0n) return 0n; // Prevent division by zero
    return (BigInt(a) * 10n ** 18n) / BigInt(b);
  }
---

---
File: ./README.md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

---

---
File: ./components/HolderTable.js
// components/HolderTable.js
import { memo } from 'react'; // Add memo import
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  // Filter out null/undefined holders and those without a wallet property
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {Object.keys(contractTiers[contract] || {})
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                          {contractTiers[contract][tier].name}
                        </th>
                      ))}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md}px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(tiers)
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {tiers[tier].name}
                    </th>
                  ))}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total}</td>
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : 'N/A'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.shares / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay8 / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay28 / 1e18).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{(holder.pendingDay90 / 1e18).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.percentage.toFixed(2)}%</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.displayMultiplierSum.toFixed(2)}</td>
                  {Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                        {holder.tiers?.[tier] || 0}
                      </td>
                    ))}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// Export as memoized component to reduce unnecessary re-renders
export default memo(HolderTable);
---

---
File: ./components/AuctionCard.js
// components/AuctionCard.js
'use client';
import { useState, useEffect } from 'react';
import { useFlareAuctionState } from '@/lib/auctions/flare';

export default function AuctionCard({ name, url, roiData, onClick }) {
  console.log('[AuctionCard] Rendering for', name);
  const { isMinting } = name === 'Flare' ? useFlareAuctionState() : { isMinting: false };
  const [isModalOpen, setIsModalOpen] = useState(false);

  useEffect(() => {
    console.log('[AuctionCard] isModalOpen changed:', isModalOpen, 'for', name);
  }, [isModalOpen, name]);

  const openModal = (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('[AuctionCard] openModal called for', name);
    setIsModalOpen(true);
    if (onClick) {
      console.log('[AuctionCard] Triggering onClick for', name);
      onClick(name, url, roiData);
    }
  };

  const closeModal = (e) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    console.log('[AuctionCard] closeModal called for', name);
    setIsModalOpen(false);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      console.log('[AuctionCard] Closing modal due to background click for', name);
      closeModal(e);
    }
  };

  return (
    <>
      <div className="bg-gray-800 rounded-lg shadow-md p-6">
        <button
          onClick={openModal}
          className="bg-blue-600 text-white text-xl font-semibold w-full p-2 rounded hover:bg-blue-700"
        >
          {name} Auction
        </button>
        {name === 'Flare' && isMinting && (
          <p className="text-yellow-500 mt-2 text-sm font-medium">Paused (Minting Phase)</p>
        )}
        <p className="text-gray-400 mt-2 text-sm">
          <a href={url} target="_blank" rel="noopener noreferrer" className="hover:underline">
            {url}
          </a>
        </p>
        {roiData && (
          <div className="mt-2 text-sm text-orange-400">
            {roiData.isLoading ? (
              <p>Loading data...</p>
            ) : roiData.hasError ? (
              <p>Data unavailable</p>
            ) : (
              <>
                {roiData.timeRemaining && <p>Time: {roiData.timeRemaining}</p>}
                <p>ROI: {roiData.roi !== null ? `${roiData.roi}%` : 'N/A'}</p>
                {roiData.currentFlarePerTitanX !== null && (
                  <p>Auction: {roiData.currentFlarePerTitanX.toFixed(2)} FLARE/TX</p>
                )}
                {roiData.marketFlareTitanXPrice !== null && (
                  <p>Market: {roiData.marketFlareTitanXPrice.toFixed(2)} FLARE/TX</p>
                )}
                {roiData.currentAscendPerTitanX !== null && (
                  <p>Auction: {roiData.currentAscendPerTitanX.toFixed(2)} ASCEND/TX</p>
                )}
                {roiData.marketAscendTitanXPrice !== null && (
                  <p>Market: {roiData.marketAscendTitanXPrice.toFixed(2)} ASCEND/TX</p>
                )}
              </>
            )}
          </div>
        )}
      </div>

      {isModalOpen && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[1000]"
          onClick={handleBackgroundClick}
        >
          <div
            className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative"
            onClick={(e) => e.stopPropagation()}
          >
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center z-[1010]"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{name} Auction</h2>
            {roiData && (
              <div className="text-gray-300 mb-4">
                {roiData.isLoading ? (
                  <p>Loading data...</p>
                ) : roiData.hasError ? (
                  <p>Error loading data</p>
                ) : (
                  <>
                    {roiData.timeRemaining && <p><strong>Time:</strong> {roiData.timeRemaining}</p>}
                    <p><strong>ROI:</strong> {roiData.roi !== null ? `${roiData.roi}%` : 'N/A'}</p>
                    {roiData.currentFlarePerTitanX !== null && (
                      <p><strong>Auction FLARE/TX:</strong> {roiData.currentFlarePerTitanX.toFixed(2)}</p>
                    )}
                    {roiData.marketFlareTitanXPrice !== null && (
                      <p><strong>Market FLARE/TX:</strong> {roiData.marketFlareTitanXPrice.toFixed(2)}</p>
                    )}
                    {roiData.currentAscendPerTitanX !== null && (
                      <p><strong>Auction ASCEND/TX:</strong> {roiData.currentAscendPerTitanX.toFixed(2)}</p>
                    )}
                    {roiData.marketAscendTitanXPrice !== null && (
                      <p><strong>Market ASCEND/TX:</strong> {roiData.marketAscendTitanXPrice.toFixed(2)}</p>
                    )}
                    {roiData.deviationStatus && (
                      <p><strong>Price Stability:</strong> {roiData.deviationStatus}</p>
                    )}
                    {roiData.mintCycle && (
                      <p>
                        <strong>Mint Cycle:</strong>{' '}
                        {roiData.mintCycle.isMinting
                          ? `Cycle ${roiData.mintCycle.currentCycle} (Minting)`
                          : `Cycle ${roiData.mintCycle.currentCycle} (Ended)`}
                      </p>
                    )}
                  </>
                )}
              </div>
            )}
            <iframe
              src={url}
              className="w-full h-[calc(100%-8rem)] border-0 rounded"
              title={`${name} Auction`}
              allowFullScreen
              onLoad={() => console.log('[AuctionCard] Iframe loaded for', name)}
              onError={(e) => console.error('[AuctionCard] Iframe error for', name, e)}
            />
          </div>
        </div>
      )}
    </>
  );
}
---

---
File: ./components/LoadingIndicator.js
// app/components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status }) {
  return (
    <div className="flex flex-col items-center justify-center gap-3 animate-fade-in w-full flex-1">
      <motion.svg
        className="h-6 w-6 sm:h-8 sm:w-8 text-blue-400"
        animate={{ scale: [1, 1.2, 1], rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </motion.svg>
      <p className="text-sm sm:text-base text-gray-300">{status}</p>
    </div>
  );
}
---

---
File: ./components/NFTPage.js
// components/NFTPage.js
'use client';
import { useState, useEffect } from 'react';
import HolderTable from '@/components/HolderTable';
import LoadingIndicator from '@/components/LoadingIndicator';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTPage({ contractKey }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const { name, apiEndpoint } = contractDetails[contractKey] || {};
  const { getCache, setCache } = useNFTStore();

  useEffect(() => {
    async function fetchAllHolders() {
      if (!apiEndpoint) {
        setError('Invalid contract configuration');
        setLoading(false);
        return;
      }

      const cachedData = getCache(contractKey);
      if (cachedData) {
        setData(cachedData);
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        console.log(`[NFTPage] Starting fetch for ${contractKey} at ${apiEndpoint}`);
        let allHolders = [];
        let totalTokens = 0;
        let totalLockedAscendant = 0;
        let totalShares = 0;
        let toDistributeDay8 = 0;
        let toDistributeDay28 = 0;
        let toDistributeDay90 = 0;
        let pendingRewards = 0;
        let page = 0;
        let totalPages = Infinity;
        const pageSize = 1000;

        while (page < totalPages) {
          let attempts = 0;
          const maxAttempts = 3;
          let success = false;

          while (attempts < maxAttempts && !success) {
            try {
              console.log(`[NFTPage] Fetching ${contractKey} page ${page}`);
              const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
                signal: AbortSignal.timeout(30000),
              });
              if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
              }

              const json = await res.json();
              allHolders = allHolders.concat(json.holders || []);
              totalTokens = json.totalTokens || totalTokens;
              totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
              totalShares = json.totalShares || totalShares;
              toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
              toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
              toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
              pendingRewards = json.pendingRewards || pendingRewards;
              totalPages = json.totalPages || 1;
              page++;
              success = true;
              if (!json.holders || json.holders.length === 0) break;
            } catch (err) {
              attempts++;
              if (err.message.includes('Rate limit') || err.name === 'TimeoutError') {
                console.log(`[NFTPage] Retry ${attempts} for ${contractKey} page ${page} due to: ${err.message}`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
              } else {
                throw err;
              }
            }
          }
          if (!success) {
            throw new Error(`Failed to fetch page ${page} for ${contractKey} after ${maxAttempts} attempts`);
          }
        }

        const uniqueHoldersMap = new Map();
        allHolders.forEach(holder => {
          if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
        });
        const uniqueHolders = Array.from(uniqueHoldersMap.values());
        console.log(`[NFTPage] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

        const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
        if (!totalTokens && uniqueHolders.length > 0) {
          totalTokens = uniqueHolders.reduce((sum, h) => sum + (h.total || 0), 0);
        }

        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });

        const fetchedData = {
          holders: uniqueHolders,
          totalTokens,
          totalLockedAscendant,
          totalShares,
          toDistributeDay8,
          toDistributeDay28,
          toDistributeDay90,
          pendingRewards,
          totalMultiplierSum,
        };

        setCache(contractKey, fetchedData);
        setData(fetchedData);
        setLoading(false);
      } catch (err) {
        console.error('[NFTPage] Fetch Error:', err);
        setError(`Failed to load ${name} holders: ${err.message}. Try refreshing later (Alchemy limit possible).`);
        setLoading(false);
      }
    }

    fetchAllHolders();
  }, [contractKey, name, apiEndpoint, getCache, setCache]);

  const renderSummary = () => {
    if (!data) return null;

    const totalMultiplierSum = data.totalMultiplierSum || 0;
    const totalTokens = data.totalTokens || 0;

    if (contractKey === 'ascendantNFT') {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Locked Ascendant: <span className="font-bold">{(data.totalLockedAscendant / 1e18 || 0).toLocaleString()}</span></p>
          <p>Total Shares: <span className="font-bold">{(data.totalShares / 1e18 || 0).toLocaleString()}</span></p>
          <p>Total Pending DragonX Rewards: <span className="font-bold">{(data.pendingRewards / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY8 Rewards: <span className="font-bold">{(data.toDistributeDay8 / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY28 Rewards: <span className="font-bold">{(data.toDistributeDay28 / 1e18 || 0).toLocaleString()}</span></p>
          <p>Pending DAY90 Rewards: <span className="font-bold">{(data.toDistributeDay90 / 1e18 || 0).toLocaleString()}</span></p>
        </>
      );
    } else {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Multiplier Sum: <span className="font-bold">{totalMultiplierSum.toLocaleString()}</span></p>
        </>
      );
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      {loading ? (
        <LoadingIndicator status={`Loading all ${name || 'contract'} holders...`} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractKey}
            loading={loading}
            totalShares={contractKey === 'ascendantNFT' ? data.totalShares : undefined}
          />
          <div className="mt-8">
            <h3 className="text-xl font-bold mb-2">Raw Data:</h3>
            <pre className="text-sm bg-gray-700 p-4 rounded max-h-96 overflow-auto border-2 border-red-500">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  );
}
---

---
File: ./components/SearchResultsModal.js
// components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import HolderTable from './HolderTable';

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      onClick={handleBackgroundClick}
    >
      <motion.div
        className="bg-gray-800 text-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Search Results for {searchAddress}</h2>
          <button onClick={closeModal} className="text-gray-400 hover:text-white text-2xl">
            &times;
          </button>
        </div>

        {Object.keys(searchResult).length === 0 ? (
          <p className="text-gray-400">No results available.</p>
        ) : (
          Object.entries(searchResult).map(([contract, data]) => (
            <div key={contract} className="mb-6">
              <h3 className="text-xl font-semibold mb-2">{contractDetails[contract]?.name || contract}</h3>
              {data === null ? (
                <p className="text-gray-400">Wallet not found in this collection.</p>
              ) : data.error ? (
                <p className="text-red-500">Error: {data.error}</p>
              ) : data.message ? (
                <p className="text-gray-400">{data.message}</p>
              ) : (
                <HolderTable
                  holders={[data]}
                  contract={contract}
                  loading={false}
                  totalShares={data.totalShares} // Pass totalShares from search result
                />
              )}
            </div>
          ))
        )}
      </motion.div>
    </div>
  );
}

const contractDetails = {
  element280: { name: 'Element280' },
  element369: { name: 'Element369' },
  staxNFT: { name: 'Stax' },
  ascendantNFT: { name: 'Ascendant' },
  e280: { name: 'E280' },
};
---

---
File: ./components/Navbar.jsx
// components/Navbar.jsx
'use client';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10 },
    visible: { opacity: 1, y: 0 },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0 },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining' },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [
            { name: 'E280', href: '/nft/BASE/E280' },
          ],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="bg-gradient-to-r from-gray-900 to-gray-800 text-white p-4 sticky top-0 z-50 shadow-md">
      <div className="max-w-7xl mx-auto flex justify-between items-center">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="text-2xl font-bold"
        >
          <Link href="/">TitanXUtils</Link>
        </motion.div>

        {/* Desktop Links */}
        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative text-gray-300 hover:text-white transition-colors duration-200 group"
              whileHover={{ scale: 1.1, color: '#f97316' }}
              whileTap={{ scale: 0.95 }}
            >
              {item.external ? (
                <a href={item.href} target="_blank" rel="noopener noreferrer">
                  {item.name}
                </a>
              ) : (
                <Link href={item.href}>{item.name}</Link>
              )}
              {item.subItems && (
                <motion.div
                  className="absolute left-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg hidden group-hover:block"
                  variants={dropdownVariants}
                  initial="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white">
                        {subItem.href ? (
                          <Link href={subItem.href}>{subItem.name}</Link>
                        ) : (
                          <span>{subItem.name}</span>
                        )}
                      </div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <div
                              key={nestedItem.name}
                              className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white"
                            >
                              <Link href={nestedItem.href}>
                                {nestedItem.name}
                              </Link>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
        </div>

        {/* Mobile Menu Toggle */}
        <button
          className="md:hidden p-2 focus:outline-none"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      {/* Mobile Menu */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="block py-2 px-4 text-gray-300 hover:text-white hover:bg-gray-700 rounded-md transition-colors duration-200"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      {item.name}
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2">
                              {subItem.href ? (
                                <Link href={subItem.href} onClick={() => setIsOpen(false)}>
                                  {subItem.name}
                                </Link>
                              ) : (
                                <span>{subItem.name}</span>
                              )}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <div
                                    key={nestedItem.name}
                                    className="py-2"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    <Link href={nestedItem.href}>
                                      {nestedItem.name}
                                    </Link>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : item.external ? (
                  <a
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={() => setIsOpen(false)}
                  >
                    {item.name}
                  </a>
                ) : (
                  <Link href={item.href} onClick={() => setIsOpen(false)}>
                    {item.name}
                  </Link>
                )}
              </motion.div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;
---

---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts
---

---
File: ./scripts/testFlareMinting.js
// scripts/testFlareMinting.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { flareMintingABI } from '../app/token_contracts.js';
import dotenv from 'dotenv';

// Load environment variables from .env.local
dotenv.config({ path: '.env.local' });

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

async function testFlareMinting() {
  try {
    const mintCycle = await client.readContract({
      address: '0x9983eF6Af4DE8fE58C45f6DC54Cf5Ad349431A82',
      abi: flareMintingABI,
      functionName: 'getCurrentMintCycle',
    });
    console.log('Mint Cycle:', {
      currentCycle: Number(mintCycle[0]),
      startsAt: Number(mintCycle[1]),
      endsAt: Number(mintCycle[2]),
      isMinting: mintCycle[2] > Math.floor(Date.now() / 1000),
    });

    const startTimestamp = await client.readContract({
      address: '0x9983eF6Af4DE8fE58C45f6DC54Cf5Ad349431A82',
      abi: flareMintingABI,
      functionName: 'startTimestamp',
    });
    console.log('FlareMinting startTimestamp:', Number(startTimestamp));
  } catch (error) {
    console.error('Error querying FlareMinting:', error);
  }
}

testFlareMinting();
---

---
File: ./lib/wagmi.js
// @/lib/wagmi.js
import { http, createConfig } from 'wagmi';
import { mainnet } from 'wagmi/chains';

export const config = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`),
  },
});
---

---
File: ./lib/store.js
// lib/store.js
'use client';
import { create } from 'zustand';

export const useFlareAuctionStore = create((set) => ({
  isFlareAuctionDay: false,
  nextFlareAuctionStart: null,
  setFlareAuctionDay: (isFlareAuctionDay, nextFlareAuctionStart) =>
    set({ isFlareAuctionDay, nextFlareAuctionStart }),
}));
---

---
File: ./lib/auctions/flare.js
// lib/auctions/flare.js
'use client';
import { useEffect, useState } from 'react';
import { useReadContract } from 'wagmi';
import { formatEther } from 'viem';
import { tokenContracts, auctionABI, flareTokenABI, uniswapPoolABI, uniswapV2PoolABI } from '@/app/token_contracts';

export function useFlareROI() {
  const [retryCount, setRetryCount] = useState(0);
  const maxRetries = 3;
  const maxDays = 64;

  const auctionConfig = { address: tokenContracts.FLARE_AUCTION.address, abi: auctionABI, chainId: 1 };
  const flareTokenConfig = { address: tokenContracts.FLARE.address, abi: flareTokenABI, chainId: 1 };
  const flareX28Config = { address: tokenContracts.FLARE_X28.address, abi: uniswapV2PoolABI, chainId: 1 };
  const x28TitanXConfig = { address: tokenContracts.X28_TITANX.address, abi: uniswapPoolABI, chainId: 1 };
  const titanXWethConfig = { address: tokenContracts.TITANX_WETH.address, abi: uniswapPoolABI, chainId: 1 };
  const wethUsdcConfig = { address: tokenContracts.WETH_USDC.address, abi: uniswapPoolABI, chainId: 1 };

  const { data: flareX28PoolAddress, isLoading: flareX28PoolLoading, isError: flareX28PoolError, error: flareX28PoolErrorDetails } = useReadContract({
    ...flareTokenConfig,
    functionName: 'x28FlarePool',
  });
  const flareX28PoolConfig = { address: flareX28PoolAddress || tokenContracts.FLARE_X28.address, abi: uniswapV2PoolABI, chainId: 1 };

  const { data: startTimestamp, isLoading: startLoading, isError: startError, error: startErrorDetails } = useReadContract({
    ...auctionConfig,
    functionName: 'startTimestamp',
  });

  let currentDay = startTimestamp ? Math.floor((Date.now() / 1000 - Number(startTimestamp)) / (24 * 60 * 60)) : 0;
  currentDay = Math.max(0, Math.min(currentDay, maxDays - 1));

  const { data: dailyStats, isLoading: statsLoading, isError: statsError, error: statsErrorDetails } = useReadContract({
    ...auctionConfig,
    functionName: 'dailyStats',
    args: [currentDay],
  });

  const { data: flareX28Reserves, isLoading: flareX28ReservesLoading, isError: flareX28ReservesError, error: flareX28ReservesErrorDetails } = useReadContract({
    ...flareX28PoolConfig,
    functionName: 'getReserves',
  });

  const { data: flareX28Token0, isLoading: flareX28Token0Loading, isError: flareX28Token0Error, error: flareX28Token0ErrorDetails } = useReadContract({
    ...flareX28PoolConfig,
    functionName: 'token0',
  });

  const { data: x28TitanXSlot0, isLoading: x28TitanXSlot0Loading, isError: x28TitanXSlot0Error, error: x28TitanXSlot0ErrorDetails } = useReadContract({
    ...x28TitanXConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: x28TitanXToken0, isLoading: x28TitanXToken0Loading, isError: x28TitanXToken0Error, error: x28TitanXToken0ErrorDetails } = useReadContract({
    ...x28TitanXConfig,
    functionName: 'token0',
  });

  const { data: titanXWethSlot0, isLoading: titanXWethSlot0Loading, isError: titanXWethSlot0Error, error: titanXWethSlot0ErrorDetails } = useReadContract({
    ...titanXWethConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: titanXWethToken0, isLoading: titanXWethToken0Loading, isError: titanXWethToken0Error, error: titanXWethToken0ErrorDetails } = useReadContract({
    ...titanXWethConfig,
    functionName: 'token0',
  });

  const { data: wethUsdcSlot0, isLoading: wethUsdcSlot0Loading, isError: wethUsdcSlot0Error, error: wethUsdcSlot0ErrorDetails } = useReadContract({
    ...wethUsdcConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: wethUsdcToken0, isLoading: wethUsdcToken0Loading, isError: wethUsdcToken0Error, error: wethUsdcToken0ErrorDetails } = useReadContract({
    ...wethUsdcConfig,
    functionName: 'token0',
  });

  const coreLoading = startLoading || statsLoading || flareX28ReservesLoading || flareX28Token0Loading || x28TitanXSlot0Loading || x28TitanXToken0Loading || flareX28PoolLoading;
  const usdLoading = titanXWethSlot0Loading || titanXWethToken0Loading || wethUsdcSlot0Loading || wethUsdcToken0Loading;
  const coreError = startError || statsError || flareX28ReservesError || flareX28Token0Error || x28TitanXSlot0Error || x28TitanXToken0Error || flareX28PoolError;
  const usdError = titanXWethSlot0Error || titanXWethToken0Error || wethUsdcSlot0Error || wethUsdcToken0Error;

  const isLoading = coreLoading || usdLoading;
  const hasError = coreError || usdError;

  useEffect(() => {
    if (coreError && retryCount < maxRetries) {
      console.error(`[FlareROI] Retrying due to core error, attempt ${retryCount + 1}`, {
        startError: startErrorDetails?.message,
        statsError: statsErrorDetails?.message,
        flareX28ReservesError: flareX28ReservesErrorDetails?.message,
        flareX28Token0Error: flareX28Token0ErrorDetails?.message,
        x28TitanXSlot0Error: x28TitanXSlot0ErrorDetails?.message,
        x28TitanXToken0Error: x28TitanXToken0ErrorDetails?.message,
        flareX28PoolError: flareX28PoolErrorDetails?.message,
      });
      setTimeout(() => setRetryCount(retryCount + 1), 2000);
    } else if (!coreError && retryCount > 0) {
      setRetryCount(0);
    }
  }, [coreError, retryCount, startErrorDetails, statsErrorDetails, flareX28ReservesErrorDetails, flareX28Token0ErrorDetails, x28TitanXSlot0ErrorDetails, x28TitanXToken0ErrorDetails, flareX28PoolErrorDetails]);

  const getPoolPrice = (reservesOrSlot0, token0Address, token1Address, poolAddress, isV3 = false) => {
    if (!reservesOrSlot0) return { price: null, description: 'No data available' };
    if (!isV3 && Array.isArray(reservesOrSlot0) && reservesOrSlot0.length >= 2) {
      const reserve0 = Number(formatEther(BigInt(reservesOrSlot0[0])));
      const reserve1 = Number(formatEther(BigInt(reservesOrSlot0[1])));
      if (reserve0 === 0 || reserve1 === 0) return { price: null, description: 'Zero reserves' };
      const price = reserve1 / reserve0; // token1/token0
      return { price, description: `${token1Address}/${token0Address} from ${poolAddress}` };
    } else if (isV3 && Array.isArray(reservesOrSlot0) && reservesOrSlot0.length >= 1) {
      const sqrtPriceX96 = BigInt(reservesOrSlot0[0]);
      const sqrtPrice = Number(sqrtPriceX96) / (2 ** 96);
      let price = sqrtPrice * sqrtPrice; // token1/token0
      const isToken0USDC = token0Address?.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
      const isToken1USDC = token1Address?.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
      if (isToken0USDC) price = 1 / price;
      else if (isToken1USDC) price = price;
      return { price, description: `${token1Address}/${token0Address} from ${poolAddress}` };
    }
    return { price: null, description: 'Invalid data' };
  };

  let auctionFlarePerTitanX = null;
  let marketFlarePerTitanX = null;
  let flarePerX28 = null;
  let roi = null;
  let status = 'loading';

  if (!coreLoading && !coreError && flareX28Reserves && flareX28Token0 && x28TitanXSlot0 && x28TitanXToken0 && dailyStats && flareX28PoolAddress) {
    const isFlareToken0 = flareX28Token0.toLowerCase() === tokenContracts.FLARE.address.toLowerCase();
    const flareX28PriceInfo = getPoolPrice(flareX28Reserves, flareX28Token0, tokenContracts.X28.address, flareX28PoolAddress, false);
    flarePerX28 = isFlareToken0 ? flareX28PriceInfo.price : flareX28PriceInfo.price ? 1 / flareX28PriceInfo.price : null;

    const isX28Token0 = x28TitanXToken0.toLowerCase() === tokenContracts.X28.address.toLowerCase();
    const x28TitanXPriceInfo = getPoolPrice(x28TitanXSlot0, x28TitanXToken0, tokenContracts.TITANX.address, x28TitanXConfig.address, true);
    const x28PerTitanX = isX28Token0 ? (x28TitanXPriceInfo.price ? 1 / x28TitanXPriceInfo.price : null) : x28TitanXPriceInfo.price;

    if (flarePerX28 && x28PerTitanX) {
      marketFlarePerTitanX = flarePerX28 * x28PerTitanX;
    }

    const flareEmitted = dailyStats[2] ? Number(formatEther(BigInt(dailyStats[2]))) : 0;
    const titanXDeposited = dailyStats[0] ? Number(formatEther(BigInt(dailyStats[0]))) : 0;
    auctionFlarePerTitanX = titanXDeposited > 0 ? flareEmitted / titanXDeposited : null;

    roi = auctionFlarePerTitanX && marketFlarePerTitanX ? ((auctionFlarePerTitanX / marketFlarePerTitanX) * 100).toFixed(2) : null;
    status = roi ? 'success' : 'no_data';
  } else if (hasError) {
    status = 'error';
  }

  return {
    auctionFlarePerTitanX,
    marketFlarePerTitanX,
    flarePerX28,
    roi,
    isLoading,
    hasError,
    status,
  };
}
---

---
File: ./lib/auctions/ascendant.js
// lib/auctions/ascendant.js
'use client';
import { useEffect, useState } from 'react';
import { useReadContract } from 'wagmi';
import { formatEther } from 'viem';
import { tokenContracts, auctionABI, uniswapPoolABI } from '@/app/token_contracts';

export function useAscendantROI() {
  const [retryCount, setRetryCount] = useState(0);
  const maxRetries = 3;
  const maxDays = 64;

  const auctionConfig = { address: tokenContracts.ASCENDANT_AUCTION.address, abi: auctionABI, chainId: 1 };
  const ascendDragonXConfig = { address: tokenContracts.ASCENDANT_DRAGONX.address, abi: uniswapPoolABI, chainId: 1 };
  const dragonXTitanXConfig = { address: tokenContracts.DRAGONX_TITANX.address, abi: uniswapPoolABI, chainId: 1 };
  const titanXWethConfig = { address: tokenContracts.TITANX_WETH.address, abi: uniswapPoolABI, chainId: 1 };
  const wethUsdcConfig = { address: tokenContracts.WETH_USDC.address, abi: uniswapPoolABI, chainId: 1 };

  const { data: startTimestamp, isLoading: startLoading, isError: startError, error: startErrorDetails } = useReadContract({
    ...auctionConfig,
    functionName: 'startTimestamp',
  });

  let currentDay = startTimestamp ? Math.floor((Date.now() / 1000 - Number(startTimestamp)) / (24 * 60 * 60)) : 0;
  currentDay = Math.max(0, Math.min(currentDay, maxDays - 1));

  const { data: dailyStats, isLoading: statsLoading, isError: statsError, error: statsErrorDetails } = useReadContract({
    ...auctionConfig,
    functionName: 'dailyStats',
    args: [currentDay],
  });

  const { data: ascendDragonXSlot0, isLoading: ascendDragonXSlot0Loading, isError: ascendDragonXSlot0Error, error: ascendDragonXSlot0ErrorDetails } = useReadContract({
    ...ascendDragonXConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: ascendDragonXToken0, isLoading: ascendDragonXToken0Loading, isError: ascendDragonXToken0Error, error: ascendDragonXToken0ErrorDetails } = useReadContract({
    ...ascendDragonXConfig,
    functionName: 'token0',
  });

  const { data: dragonXTitanXSlot0, isLoading: dragonXTitanXSlot0Loading, isError: dragonXTitanXSlot0Error, error: dragonXTitanXSlot0ErrorDetails } = useReadContract({
    ...dragonXTitanXConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: dragonXTitanXToken0, isLoading: dragonXTitanXToken0Loading, isError: dragonXTitanXToken0Error, error: dragonXTitanXToken0ErrorDetails } = useReadContract({
    ...dragonXTitanXConfig,
    functionName: 'token0',
  });

  const { data: titanXWethSlot0, isLoading: titanXWethSlot0Loading, isError: titanXWethSlot0Error, error: titanXWethSlot0ErrorDetails } = useReadContract({
    ...titanXWethConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: titanXWethToken0, isLoading: titanXWethToken0Loading, isError: titanXWethToken0Error, error: titanXWethToken0ErrorDetails } = useReadContract({
    ...titanXWethConfig,
    functionName: 'token0',
  });

  const { data: wethUsdcSlot0, isLoading: wethUsdcSlot0Loading, isError: wethUsdcSlot0Error, error: wethUsdcSlot0ErrorDetails } = useReadContract({
    ...wethUsdcConfig,
    functionName: 'slot0',
    cacheTime: 0,
  });

  const { data: wethUsdcToken0, isLoading: wethUsdcToken0Loading, isError: wethUsdcToken0Error, error: wethUsdcToken0ErrorDetails } = useReadContract({
    ...wethUsdcConfig,
    functionName: 'token0',
  });

  const coreLoading = startLoading || statsLoading || ascendDragonXSlot0Loading || ascendDragonXToken0Loading || dragonXTitanXSlot0Loading || dragonXTitanXToken0Loading;
  const usdLoading = titanXWethSlot0Loading || titanXWethToken0Loading || wethUsdcSlot0Loading || wethUsdcToken0Loading;
  const coreError = startError || statsError || ascendDragonXSlot0Error || ascendDragonXToken0Error || dragonXTitanXSlot0Error || dragonXTitanXToken0Error;
  const usdError = titanXWethSlot0Error || titanXWethToken0Error || wethUsdcSlot0Error || wethUsdcToken0Error;

  const isLoading = coreLoading || usdLoading;
  const hasError = coreError || usdError;

  useEffect(() => {
    if (coreError && retryCount < maxRetries) {
      console.error(`[AscendantROI] Retrying due to core error, attempt ${retryCount + 1}`, {
        startError: startErrorDetails?.message,
        statsError: statsErrorDetails?.message,
        ascendDragonXSlot0Error: ascendDragonXSlot0ErrorDetails?.message,
        ascendDragonXToken0Error: ascendDragonXToken0ErrorDetails?.message,
        dragonXTitanXSlot0Error: dragonXTitanXSlot0ErrorDetails?.message,
        dragonXTitanXToken0Error: dragonXTitanXToken0ErrorDetails?.message,
      });
      setTimeout(() => setRetryCount(retryCount + 1), 2000);
    } else if (!coreError && retryCount > 0) {
      setRetryCount(0);
    }
  }, [coreError, retryCount, startErrorDetails, statsErrorDetails, ascendDragonXSlot0ErrorDetails, ascendDragonXToken0ErrorDetails, dragonXTitanXSlot0ErrorDetails, dragonXTitanXToken0ErrorDetails]);

  const getPoolPrice = (slot0, token0Address, token1Address, poolAddress) => {
    if (!slot0 || !slot0[0]) return { price: null, description: 'No data available' };
    const sqrtPriceX96 = BigInt(slot0[0]);
    const sqrtPrice = Number(sqrtPriceX96) / (2 ** 96);
    let price = sqrtPrice * sqrtPrice; // token1/token0
    const isToken0USDC = token0Address?.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
    const isToken1USDC = token1Address?.toLowerCase() === tokenContracts.USDC.address.toLowerCase();
    if (isToken0USDC) price = 1 / price;
    else if (isToken1USDC) price = price;
    return { price, description: `${token1Address}/${token0Address} from ${poolAddress}` };
  };

  let auctionAscendantPerTitanX = null;
  let marketAscendantPerTitanX = null;
  let ascendPerDragonX = null;
  let marketDragonXPerTitanX = null;
  let roi = null;
  let status = 'loading';

  if (!coreLoading && !coreError && dailyStats && ascendDragonXSlot0 && ascendDragonXToken0 && dragonXTitanXSlot0 && dragonXTitanXToken0) {
    const isAscendToken0 = ascendDragonXToken0.toLowerCase() === tokenContracts.ASCENDANT.address.toLowerCase();
    const ascendDragonXPriceInfo = getPoolPrice(ascendDragonXSlot0, ascendDragonXToken0, tokenContracts.DRAGONX.address, ascendDragonXConfig.address);
    ascendPerDragonX = isAscendToken0 ? ascendDragonXPriceInfo.price : ascendDragonXPriceInfo.price ? 1 / ascendDragonXPriceInfo.price : null;

    const isDragonXToken0 = dragonXTitanXToken0.toLowerCase() === tokenContracts.DRAGONX.address.toLowerCase();
    const dragonXTitanXPriceInfo = getPoolPrice(dragonXTitanXSlot0, dragonXTitanXToken0, tokenContracts.TITANX.address, dragonXTitanXConfig.address);
    marketDragonXPerTitanX = isDragonXToken0 ? (dragonXTitanXPriceInfo.price ? 1 / dragonXTitanXPriceInfo.price : null) : dragonXTitanXPriceInfo.price;

    if (ascendPerDragonX && marketDragonXPerTitanX) {
      marketAscendantPerTitanX = ascendPerDragonX * marketDragonXPerTitanX;
    }

    const tokenEmitted = dailyStats[2] ? Number(formatEther(BigInt(dailyStats[2]))) : 0;
    const titanXDeposited = dailyStats[0] ? Number(formatEther(BigInt(dailyStats[0]))) : 0;
    auctionAscendantPerTitanX = titanXDeposited > 0 ? tokenEmitted / titanXDeposited : null;

    roi = auctionAscendantPerTitanX && marketAscendantPerTitanX ? ((auctionAscendantPerTitanX / marketAscendantPerTitanX) * 100).toFixed(2) : null;
    status = roi ? 'success' : 'no_data';
  } else if (hasError) {
    status = 'error';
  }

  return {
    auctionAscendantPerTitanX,
    marketAscendantPerTitanX,
    ascendPerDragonX,
    marketDragonXPerTitanX,
    roi,
    isLoading,
    hasError,
    status,
  };
}
---

---
File: ./eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [...compat.extends("next/core-web-vitals")];

export default eslintConfig;

---
