\n---\nFile: ./tailwind.config.js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    './app/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n---\n\n---\nFile: ./.env.local\nNEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710\nNEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI\n---\n\n---\nFile: ./app/layout.js\n// app/layout.js\n'use client';\nimport './layout.css';\nimport { Inter } from 'next/font/google';\nimport Navbar from '../components/Navbar';\nimport ClientProvider from './ClientProvider';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang="en">\n      <head>\n        <title>TitanXUtils</title>\n      </head>\n      <body className={`${inter.className} bg-gray-900 text-white`}>\n        <ClientProvider>\n          <Navbar />\n          <main className="pt-16">{children}</main>\n        </ClientProvider>\n      </body>\n    </html>\n  );\n}\n---\n\n---\nFile: ./app/page.js\n// app/page.js\n'use client';\nimport { useState, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport Link from 'next/link';\nimport { useFlareAuctionStore } from '../lib/store';\nimport { useFlareAuctionState } from '../lib/auctions/flare';\n\nexport default function Home() {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const { setFlareAuctionDay } = useFlareAuctionStore();\n  const { startTimestamp, startLoading, getAuctionDayStatus } = useFlareAuctionState();\n\n  useEffect(() => {\n    setIsLoaded(true);\n\n    // Initialize Flare auction state\n    if (!startLoading && startTimestamp) {\n      const currentTimestamp = Math.floor(Date.now() / 1000);\n      const { isAuction, nextFlareAuctionStart } = getAuctionDayStatus(currentTimestamp);\n      setFlareAuctionDay(isAuction, nextFlareAuctionStart);\n\n      // Schedule daily update at 2 PM UTC\n      const scheduleNextUpdate = () => {\n        const now = new Date();\n        const next2PMUTC = new Date(Date.UTC(\n          now.getUTCFullYear(),\n          now.getUTCMonth(),\n          now.getUTCDate() + (now.getUTCHours() >= 14 ? 1 : 0),\n          14, // 2 PM UTC\n          0,\n          0\n        ));\n        const timeUntilNext = next2PMUTC - now;\n\n        setTimeout(() => {\n          const newTimestamp = Math.floor(Date.now() / 1000);\n          const { isAuction: newIsAuction, nextFlareAuctionStart: newNextStart } = getAuctionDayStatus(newTimestamp);\n          setFlareAuctionDay(newIsAuction, newNextStart);\n          scheduleNextUpdate();\n        }, timeUntilNext);\n      };\n      scheduleNextUpdate();\n    }\n  }, [startLoading, startTimestamp, setFlareAuctionDay]);\n\n  return (\n    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">\n      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">\n        <AnimatePresence>\n          {isLoaded && (\n            <motion.section\n              initial={{ opacity: 0, y: 50 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: 50 }}\n              transition={{ duration: 0.8 }}\n              className="text-center"\n            >\n              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">\n                Welcome to TitanXUtils\n              </h1>\n              <p className="mt-4 text-lg sm:text-xl text-gray-300">\n                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.\n              </p>\n              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">\n                <motion.div\n                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                >\n                  <Link href="/nft">NFT Protocols</Link>\n                </motion.div>\n                <motion.div\n                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                >\n                  <Link href="/auctions">TitanX Auctions</Link>\n                </motion.div>\n              </div>\n            </motion.section>\n          )}\n        </AnimatePresence>\n      </main>\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/nft/layout.js\n// app/nft/layout.js\n'use client';\nimport { useState, useRef } from 'react';\nimport { motion } from 'framer-motion';\nimport Link from 'next/link';\nimport SearchResultsModal from '@/components/SearchResultsModal';\nimport { contractDetails } from '@/app/nft-contracts';\nimport { useNFTStore } from '@/app/store';\n\nexport default function NFTLayout({ children }) {\n  const [selectedChain, setSelectedChain] = useState(null);\n  const [showE280Message, setShowE280Message] = useState(false);\n  const [searchAddress, setSearchAddress] = useState('');\n  const [searchResults, setSearchResults] = useState({});\n  const [searchLoading, setSearchLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const hasRun = useRef(false);\n\n  const { getCache, setCache } = useNFTStore();\n\n  const chains = [\n    { name: 'ETH', id: 'eth' },\n    { name: 'BASE', id: 'base' },\n  ];\n\n  const ethNFTs = [\n    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },\n    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },\n    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },\n    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },\n  ];\n\n  const baseNFTs = [\n    { name: 'E280', href: null, apiKey: 'e280' },\n  ];\n\n  const allNFTs = Object.keys(contractDetails).map((key) => ({\n    name: contractDetails[key].name,\n    apiKey: key,\n    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,\n  }));\n\n  const fetchCollectionData = async (contractKey) => {\n    console.log(`[NFTLayout] Fetching data for ${contractKey}`);\n    const cachedData = getCache(contractKey);\n    if (cachedData) {\n      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);\n      return cachedData;\n    }\n\n    if (contractKey === 'e280') {\n      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);\n      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };\n      setCache(contractKey, result);\n      return result;\n    }\n\n    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];\n    let allHolders = [];\n    let totalTokens = 0;\n    let totalLockedAscendant = 0;\n    let totalShares = 0;\n    let toDistributeDay8 = 0;\n    let toDistributeDay28 = 0;\n    let toDistributeDay90 = 0;\n    let pendingRewards = 0;\n    let page = 0;\n    let totalPages = Infinity;\n\n    try {\n      while (page < totalPages) {\n        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);\n        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {\n          signal: AbortSignal.timeout(30000),\n        });\n        if (!res.ok) {\n          const errorText = await res.text();\n          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);\n        }\n        const json = await res.json();\n        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders.length}`);\n        allHolders = allHolders.concat(json.holders || []);\n        totalTokens = json.totalTokens || totalTokens;\n        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;\n        totalShares = json.totalShares || totalShares;\n        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;\n        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;\n        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;\n        pendingRewards = json.pendingRewards || pendingRewards;\n        totalPages = json.totalPages || 1;\n        page++;\n        if (!json.holders || json.holders.length === 0) break;\n      }\n\n      const uniqueHoldersMap = new Map();\n      allHolders.forEach(holder => {\n        if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);\n      });\n      let uniqueHolders = Array.from(uniqueHoldersMap.values());\n      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);\n\n      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);\n      uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));\n      uniqueHolders.forEach((holder, index) => {\n        holder.rank = index + 1;\n        holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n      });\n\n      const result = {\n        holders: uniqueHolders,\n        totalTokens,\n        totalLockedAscendant,\n        totalShares,\n        toDistributeDay8,\n        toDistributeDay28,\n        toDistributeDay90,\n        pendingRewards,\n        totalMultiplierSum,\n      };\n      setCache(contractKey, result);\n      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);\n      return result;\n    } catch (err) {\n      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);\n      const errorResult = { holders: [], totalTokens: 0, error: err.message };\n      setCache(contractKey, errorResult);\n      return errorResult;\n    }\n  };\n\n  const handleSearch = async () => {\n    console.log('[NFTLayout] handleSearch called with address:', searchAddress);\n    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {\n      setError('Please enter a valid Ethereum address (e.g., 0x...)');\n      setSearchResults({});\n      return;\n    }\n\n    setSearchLoading(true);\n    setError(null);\n    setSearchResults({});\n\n    try {\n      console.log('[NFTLayout] Fetching all collection data before search');\n      const fetchPromises = allNFTs.map(nft => \n        fetchCollectionData(nft.apiKey)\n          .then(data => ({ apiKey: nft.apiKey, data }))\n          .catch(err => {\n            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);\n            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };\n          })\n      );\n      const results = await Promise.all(fetchPromises);\n      console.log('[NFTLayout] All collections fetched and cached');\n\n      const searchResults = {};\n      const lowerSearchAddress = searchAddress.toLowerCase();\n      results.forEach(({ apiKey, data }) => {\n        if (data.error) {\n          searchResults[apiKey] = { error: data.error };\n        } else if (data.message) {\n          searchResults[apiKey] = { message: data.message };\n        } else {\n          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);\n          if (holder) {\n            // Include totalShares for Ascendant to calculate Shares %\n            searchResults[apiKey] = {\n              ...holder,\n              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,\n            };\n          } else {\n            searchResults[apiKey] = null;\n          }\n          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');\n        }\n      });\n\n      setSearchResults(searchResults);\n      setIsModalOpen(true);\n    } catch (err) {\n      console.error('[NFTLayout] Search error:', err);\n      setError(`Search failed: ${err.message}`);\n    } finally {\n      setSearchLoading(false);\n    }\n  };\n\n  const handleChainSelect = (chainId) => {\n    setShowE280Message(false);\n    setSelectedChain(chainId === selectedChain ? null : chainId);\n  };\n\n  const handleE280Click = () => {\n    if (selectedChain === 'base') {\n      setShowE280Message(true);\n    }\n  };\n\n  return (\n    <div className="flex-1 p-6 flex flex-col items-center">\n      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>\n\n      <div className="w-full max-w-2xl mb-6">\n        <div className="flex flex-col sm:flex-row gap-2">\n          <input\n            type="text"\n            value={searchAddress}\n            onChange={(e) => setSearchAddress(e.target.value)}\n            placeholder="Search by wallet address (e.g., 0x...)"\n            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"\n          />\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={handleSearch}\n            disabled={searchLoading}\n            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}\n          >\n            {searchLoading ? 'Searching...' : 'Search'}\n          </motion.button>\n        </div>\n        {error && <p className="text-red-500 mt-2">{error}</p>}\n      </div>\n\n      <div className="flex space-x-4 mb-6">\n        {chains.map((chain) => (\n          <motion.button\n            key={chain.id}\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={() => handleChainSelect(chain.id)}\n            className={`px-6 py-2 rounded-md font-semibold transition-colors ${\n              selectedChain === chain.id\n                ? 'bg-orange-500 text-white'\n                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n            }`}\n          >\n            {chain.name}\n          </motion.button>\n        ))}\n      </div>\n\n      {selectedChain === 'eth' && (\n        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">\n          {ethNFTs.map((nft) => (\n            <Link key={nft.name} href={nft.href} className="flex-1">\n              <motion.button\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n                onClick={() => setShowE280Message(false)}\n                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"\n              >\n                {nft.name}\n              </motion.button>\n            </Link>\n          ))}\n        </div>\n      )}\n      {selectedChain === 'base' && (\n        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">\n          {baseNFTs.map((nft) => (\n            nft.href ? (\n              <Link key={nft.name} href={nft.href} className="flex-1">\n                <motion.button\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={() => setShowE280Message(false)}\n                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"\n                >\n                  {nft.name}\n                </motion.button>\n              </Link>\n            ) : (\n              <motion.button\n                key={nft.name}\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n                onClick={handleE280Click}\n                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"\n              >\n                {nft.name}\n              </motion.button>\n            )\n          ))}\n        </div>\n      )}\n      {showE280Message && selectedChain === 'base' && (\n        <div className="mt-6 text-center text-white">\n          <p className="text-lg">Contract not yet deployed. Coming soon...</p>\n        </div>\n      )}\n\n      {isModalOpen && (\n        <SearchResultsModal\n          searchResult={searchResults}\n          searchAddress={searchAddress}\n          closeModal={() => setIsModalOpen(false)}\n          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}\n        />\n      )}\n\n      <div className="w-full max-w-6xl">{children}</div>\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/nft/page.js\n// app/nft/page.js\nexport default function NFTOverview() {\n  return (\n    <div className="text-center text-white">\n      <p className="text-lg">Select a collection above to view details.</p>\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/nft/ETH/Stax/page.js\n// app/nft/ETH/Stax/page.js\nimport NFTPage from '@/components/NFTPage';\n\nexport default function StaxPage() {\n  return <NFTPage contractKey="staxNFT" />;\n}\n---\n\n---\nFile: ./app/nft/ETH/Element280/page.js\n// app/nft/ETH/Element280/page.js\nimport NFTPage from '@/components/NFTPage';\n\nexport default function Element280Page() {\n  return <NFTPage contractKey="element280" />;\n}\n---\n\n---\nFile: ./app/nft/ETH/Element369/page.js\n// app/nft/ETH/Element369/page.js\nimport NFTPage from '@/components/NFTPage';\nexport default function Element369Page() {\n  return <NFTPage contractKey="element369" />;\n}\n---\n\n---\nFile: ./app/nft/ETH/Ascendant/page.js\n// app/nft/ETH/Ascendant/page.js\nimport NFTPage from '@/components/NFTPage';\n\nexport default function AscendantPage() {\n  return <NFTPage contractKey="ascendantNFT" />;\n}\n---\n\n---\nFile: ./app/nft/BASE/E280/page.js\n// app/nft/BASE/E280/page.js\nimport NFTPage from '@/components/NFTPage';\n\nexport default function E280Page() {\n  return <NFTPage contractKey="e280" />;\n}\n---\n\n---\nBackup: ./app/token_contracts.js to token_contracts_backup.js\n\n---\n\n---\nFile: ./app/token_contracts.js\n// app/token_contracts.js\nexport const tokenContracts = {\n  // Ascendant\n  ASCENDANT: {\n    name: 'Ascendant Token',\n    address: '0x0943D06A5Ff3B25ddC51642717680c105AD63c01',\n    chainId: 1,\n    type: 'token',\n  },\n  ASCENDANT_AUCTION: {\n    name: 'Ascendant Auction',\n    address: '0x592daEb53eB1cef8aa96305588310E997ec58c0c',\n    chainId: 1,\n    type: 'auction',\n  },\n  ASCENDANT_BUY_AND_BURN: {\n    name: 'Ascendant Buy and Burn',\n    address: '0x27D21C4Fa62F063B5f005c5BD87cffEa62e348D1',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  ASCENDANT_DRAGONX: {\n    name: 'ASCENDANT/DRAGONX Pool',\n    address: '0xe8cC60F526bec8C663C6eEc5A65eFAe9d89Ee6aD',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n  ASCENDANT_NFT_MARKETPLACE: {\n    name: 'Ascendant NFT Marketplace',\n    address: '0x2a7156295E85991A3861e2FAB09Eef6AcAC94717',\n    chainId: 1,\n    type: 'marketplace',\n  },\n  ASCENDANT_NFT_MINTING: {\n    name: 'Ascendant NFT Minting',\n    address: '0x9dA95C32C5869c84Ba2C020B5e87329eC0aDC97f',\n    chainId: 1,\n    type: 'minting',\n  },\n  ASCENDANT_PRIDE: {\n    name: 'Ascendant Pride',\n    address: '0x1B7C257ee2D1f30E1be2F90968258F13eD961c82',\n    chainId: 1,\n    type: 'special',\n  },\n\n  // Blaze\n  BLAZE: {\n    name: 'Blaze Token',\n    address: '0xfcd7cceE4071aA4ecFAC1683b7CC0aFeCAF42A36',\n    chainId: 1,\n    type: 'token',\n  },\n  BLAZE_AUCTION: {\n    name: 'Blaze Auction',\n    address: '0x200ed69de20Fe522d08dF5d7CE3d69aba4e02e74',\n    chainId: 1,\n    type: 'auction',\n  },\n  BLAZE_BONFIRE: {\n    name: 'Blaze Bonfire',\n    address: '0x72AB9dcAc1BE635e83D0E458D2aA1FbF439B44f7',\n    chainId: 1,\n    type: 'bonfire',\n  },\n  BLAZE_BUY_AND_BURN: {\n    name: 'Blaze Buy and Burn',\n    address: '0x27D80441831252950C528343a4F5CcC6b1E0EA95',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  BLAZE_STAKING: {\n    name: 'Blaze Staking',\n    address: '0xBc0043bc5b0c394D9d05d49768f9548F8CF9587b',\n    chainId: 1,\n    type: 'staking',\n  },\n  BLAZE_TITANX: {\n    name: 'BLAZE/TITANX Pool',\n    address: '0x4D3A10d4792Dd12ececc5F3034C8e264B28485d1',\n    chainId: 1,\n    type: 'uniswapV2Pool',\n  },\n\n  // Bonfire\n  BONFIRE: {\n    name: 'Bonfire Token',\n    address: '0x7d51174B02b6242D7b4510Cd988d24bC39d026c3',\n    chainId: 1,\n    type: 'token',\n  },\n  BONFIRE_BUY_AND_BURN: {\n    name: 'Bonfire Buy and Burn',\n    address: '0xe871fEB86093809F1c9555a83B292419BB23F699',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  BONFIRE_X28: {\n    name: 'BONFIRE/X28 Pool',\n    address: '0x2DF1230D9Bd024A9d4EdB53336165Eb27AaBc7Fd',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // DragonX\n  DRAGONX: {\n    name: 'DragonX Token',\n    address: '0x96a5399D07896f757Bd4c6eF56461F58DB951862',\n    chainId: 1,\n    type: 'token',\n  },\n  DRAGONX_BURN_PROXY: {\n    name: 'DragonX Burn Proxy',\n    address: '0x1d59429571d8Fde785F45bf593E94F2Da6072Edb',\n    chainId: 1,\n    type: 'proxy',\n  },\n  DRAGONX_BUY_AND_BURN: {\n    name: 'DragonX Buy and Burn',\n    address: '0x1A4330EAf13869D15014abcA69516FC6AB36E54D',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  DRAGONX_BUY_TITANS: {\n    name: 'DragonX Buy Titans',\n    address: '0x1A4330EAf13869D15014abcA69516FC6AB36E54D',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  DRAGONX_HYBRID: {\n    name: 'DragonX Hybrid',\n    address: '0x619321771d67d9D8e69A3503683FcBa0678D2eF3',\n    chainId: 1,\n    type: 'hybrid',\n  },\n  DRAGONX_TITANX: {\n    name: 'DRAGONX/TITANX Pool',\n    address: '0x25215d9ba4403b3DA77ce50606b54577a71b7895',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // E280\n  E280_BASE: {\n    name: 'E280 Token (Base)',\n    address: '0x058E7b30200d001130232e8fBfDF900590E0bAA9',\n    chainId: 8453,\n    type: 'token',\n  },\n  E280_ETH: {\n    name: 'E280 Token (Ethereum)',\n    address: '0x058E7b30200d001130232e8fBfDF900590E0bAA9',\n    chainId: 1,\n    type: 'token',\n  },\n  E280_BUY_AND_BURN: {\n    name: 'E280 Buy and Burn',\n    address: '0x6E83D86841C70CCA0f16bf653A22899d06935Ee2',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  E280_LP_DEPOSITOR: {\n    name: 'E280 LP Depositor',\n    address: '0xB302fbF6c9836557371a79012b540303Cc758BB3',\n    chainId: 1,\n    type: 'depositor',\n  },\n  E280_REWARD_DEPOSITOR: {\n    name: 'E280 Reward Depositor',\n    address: '0xD8f842150511e8F501050E8a4c6878104312d82C',\n    chainId: 1,\n    type: 'depositor',\n  },\n  E280_TAX_DEPOSITOR: {\n    name: 'E280 Tax Depositor',\n    address: '0x55F643B0B7b8d8B824c2b33eC392023AbefF0a52',\n    chainId: 1,\n    type: 'depositor',\n  },\n  E280_TAX_DISTRIBUTOR: {\n    name: 'E280 Tax Distributor',\n    address: '0x1b25cc7461a9EE4a4c8f9dA82c828D8a39ea73e4',\n    chainId: 1,\n    type: 'distributor',\n  },\n  STAX_ELEMENT280: {\n    name: 'STAX/ELEMENT280 Pool',\n    address: '0x190BD81780e46124245d39774776be939bB8595B',\n    chainId: 1,\n    type: 'uniswapV2Pool',\n  },\n\n  // Eden\n  EDEN: {\n    name: 'Eden Token',\n    address: '0x31b2c59d760058cfe57e59472E7542f776d987FB',\n    chainId: 1,\n    type: 'token',\n  },\n  EDEN_BLOOM_POOL: {\n    name: 'Eden Bloom Pool',\n    address: '0xe5Da018596D0e60d704b09d0E43734266e280e05',\n    chainId: 1,\n    type: 'pool',\n  },\n  EDEN_BUY_AND_BURN: {\n    name: 'Eden Buy and Burn',\n    address: '0x1681EB21026104Fa63121fD517e065cEc21A4b4C',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  EDEN_MINING: {\n    name: 'Eden Mining',\n    address: '0x890B015ECA83a6CA03b436a748969976502B7c0c',\n    chainId: 1,\n    type: 'mining',\n  },\n  EDEN_STAKING: {\n    name: 'Eden Staking',\n    address: '0x32C611b0a96789BaA3d6bF9F0867b7E1b9d049Be',\n    chainId: 1,\n    type: 'staking',\n  },\n\n  // Element\n  ELEMENT: {\n    name: 'Element Token',\n    address: '0xe9A53C43a0B58706e67341C4055de861e29Ee943',\n    chainId: 1,\n    type: 'token',\n  },\n  ELEMENT_BUY_AND_BURN: {\n    name: 'Element Buy and Burn',\n    address: '0x3F2b113d180ecb1457e450b9EfcAC3df1Dd29AD3',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  ELEMENT_BUY_AND_BURN_V2: {\n    name: 'Element Buy and Burn V2',\n    address: '0x88BB363b333a6291Cf7CF5931eFe7a1E2D978325',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  ELEMENT_HOLDER_VAULT: {\n    name: 'Element Holder Vault',\n    address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',\n    chainId: 1,\n    type: 'vault',\n  },\n  ELEMENT_NFT: {\n    name: 'Element NFT',\n    address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',\n    chainId: 1,\n    type: 'nft',\n  },\n\n  // Element369\n  ELEMENT369_FLUX_HUB: {\n    name: 'Element369 Flux Hub',\n    address: '0x6067487ee98B6A830cc3E5E7F57Dc194044D1F1D',\n    chainId: 1,\n    type: 'hub',\n  },\n  ELEMENT369_HOLDER_VAULT: {\n    name: 'Element369 Holder Vault',\n    address: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',\n    chainId: 1,\n    type: 'vault',\n  },\n  ELEMENT369_NFT: {\n    name: 'Element369 NFT',\n    address: '0x024D64E2F65747d8bB02dFb852702D588A062575',\n    chainId: 1,\n    type: 'nft',\n  },\n\n  // Flare\n  FLARE: {\n    name: 'Flare Token',\n    address: '0x34a4FE5397bf2768189EDe14FE4adAD374B993B8',\n    chainId: 1,\n    type: 'token',\n  },\n  FLARE_AUCTION: {\n    name: 'Flare Auction',\n    address: '0x58aD6ef28BfB092635454D02303aDbd4D87b503C',\n    chainId: 1,\n    type: 'auction',\n  },\n  FLARE_AUCTION_BUY_AND_BURN: {\n    name: 'Flare Auction Buy and Burn',\n    address: '0x17d8258eC7fA1EfC9CA4c6C15f3417bF30564048',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  FLARE_AUCTION_TREASURY: {\n    name: 'Flare Auction Treasury',\n    address: '0x744D402674006f2711a3D6E4a80cc749C7915545',\n    chainId: 1,\n    type: 'treasury',\n  },\n  FLARE_BUY_AND_BURN: {\n    name: 'Flare Buy and Burn',\n    address: '0x6A12392C7dc5ddAA7d59007B329BFED35af092E6',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  FLARE_MINTING: {\n    name: 'Flare Minting',\n    address: '0x9983eF6Af4DE8fE58C45f6DC54Cf5Ad349431A82',\n    chainId: 1,\n    type: 'minting',\n  },\n  FLARE_X28: {\n    name: 'FLARE/X28 Pool',\n    address: '0x05b7Cc21A11354778Cf0D7faf159f1a99724ccFd',\n    chainId: 1,\n    type: 'uniswapV2Pool',\n  },\n\n  // Flux\n  FLUX: {\n    name: 'Flux Token',\n    address: '0xBFDE5ac4f5Adb419A931a5bF64B0f3BB5a623d06',\n    chainId: 1,\n    type: 'token',\n  },\n  FLUX_777: {\n    name: 'Flux 777',\n    address: '0x52ca28e311f200d1CD47C06996063e14eC2d6aB1',\n    chainId: 1,\n    type: 'special',\n  },\n  FLUX_AUCTION: {\n    name: 'Flux Auction',\n    address: '0x36e5a8105f000029d4B3B99d0C3D0e24aaA52adF',\n    chainId: 1,\n    type: 'auction',\n  },\n  FLUX_BUY_AND_BURN: {\n    name: 'Flux Buy and Burn',\n    address: '0xaE14148F726E7C3AA5C0c992D044bE113b32292C',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  FLUX_STAKING: {\n    name: 'Flux Staking',\n    address: '0xd605a87187563C94c577a6E57e4a36eC8433B9aE',\n    chainId: 1,\n    type: 'staking',\n  },\n  FLUX_TITANX: {\n    name: 'FLUX/TITANX Pool',\n    address: '0x2278012E61c0fB38DaE1579bD41a87A59A5954c2',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // GoatX\n  GOATX: {\n    name: 'GoatX Token',\n    address: '0x4Eca7761a516F8300711cbF920C0b85555261993',\n    chainId: 1,\n    type: 'token',\n  },\n  GOATX_AUCTION: {\n    name: 'GoatX Auction',\n    address: '0x059511B0BED706276Fa98877bd00ee0dD7303D32',\n    chainId: 1,\n    type: 'auction',\n  },\n  GOATX_BUY_AND_BURN: {\n    name: 'GoatX Buy and Burn',\n    address: '0xE6Cf4Cb42A6c37729c4546b4B9E83b97a05cE950',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  GOATX_MINING: {\n    name: 'GoatX Mining',\n    address: '0x4E83d6911bc1E191Bd207920737149B8FC060c8D',\n    chainId: 1,\n    type: 'mining',\n  },\n\n  // Helios\n  HELIOS: {\n    name: 'Helios Token',\n    address: '0x2614f29C39dE46468A921Fd0b41fdd99A01f2EDf',\n    chainId: 1,\n    type: 'token',\n  },\n  HELIOS_BUY_AND_BURN: {\n    name: 'Helios Buy and Burn',\n    address: '0x9bff9f810d19cdb4bf7701c9d5ad101e91cda08d',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  HELIOS_TITANX: {\n    name: 'HELIOS/TITANX Pool',\n    address: '0x2C83C54C5612BfD62a78124D4A0eA001278a689c',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // Hyper\n  HYPER: {\n    name: 'Hyper Token',\n    address: '0xE2cfD7a01ec63875cd9Da6C7c1B7025166c2fA2F',\n    chainId: 1,\n    type: 'token',\n  },\n  HYPER_BUY_AND_BURN: {\n    name: 'Hyper Buy and Burn',\n    address: '0x15Bec83b642217814dDAeB6F8A74ba7E0D6D157E',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  HYPER_TITANX: {\n    name: 'HYPER/TITANX Pool',\n    address: '0x14d725edB1299fF560d96f42462f0234B65B00AF',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // Hydra\n  HYDRA: {\n    name: 'Hydra Token',\n    address: '0xCC7ed2ab6c3396DdBc4316D2d7C1b59ff9d2091F',\n    chainId: 1,\n    type: 'token',\n  },\n  HYDRA_BUY_AND_BURN: {\n    name: 'Hydra Buy and Burn',\n    address: '0xfEF10De0823F58DF4f5F24856aB4274EdeDa6A5c',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  HYDRA_DRAGONX: {\n    name: 'HYDRA/DRAGONX Pool',\n    address: '0xF8F0Ef9f6A12336A1e035adDDbD634F3B0962F54',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // Matrix\n  MATRIX: {\n    name: 'Matrix Token',\n    address: '0xF2Fc894381792Ded27a7f08D9F0F246363cBe1ea',\n    chainId: 1,\n    type: 'token',\n  },\n  MATRIX_AUCTION: {\n    name: 'Matrix Auction',\n    address: '0x9f29E5b2d67C4a7315c5D6AbD448C45f9dD51CAF',\n    chainId: 1,\n    type: 'auction',\n  },\n  MATRIX_BUY_AND_BURN: {\n    name: 'Matrix Buy and Burn',\n    address: '0x50371D550e1eaB5aeC08d2D79B77B14b79dCC57E',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  MATRIX_HYPER: {\n    name: 'MATRIX/HYPER Pool',\n    address: '0x9dA4aCd7d87e7396901d92671173296bf9845c53',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // ORX\n  ORX: {\n    name: 'ORX Token',\n    address: '0xd536e7a9543cf9867a580b45cec7f748a1fe11ec',\n    chainId: 1,\n    type: 'token',\n  },\n  ORX_MINTER: {\n    name: 'ORX Minter',\n    address: '0x4C93D6380D22C44850Bdfa569Df5dD96e278622B',\n    chainId: 1,\n    type: 'minter',\n  },\n  ORX_MULTISIG: {\n    name: 'ORX Multisig',\n    address: '0x54FDAcea0af4026306A665E9dAB635Ef5fF2963f',\n    chainId: 1,\n    type: 'multisig',\n  },\n  ORX_STAKING: {\n    name: 'ORX Staking',\n    address: '0xE293DFD4720308c048B63AfE885F5971E135Eb1e',\n    chainId: 1,\n    type: 'staking',\n  },\n  ORX_TITANX: {\n    name: 'ORX/TITANX Pool',\n    address: '0x2A216495584E406C39582d3ee583aEDA937beba6',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n  USDX: {\n    name: 'USDx Stable',\n    address: '0xDDF73eAcB2218377FC38679aD14dfce51B651Dd1',\n    chainId: 1,\n    type: 'stablecoin',\n  },\n\n  // Phoenix\n  PHOENIX: {\n    name: 'Phoenix Token',\n    address: '0xfe3F988a90dEa3eE537BB43eC1aCa7337A15D002',\n    chainId: 1,\n    type: 'token',\n  },\n  PHOENIX_AUCTION: {\n    name: 'Phoenix Auction',\n    address: '0xF41b5c99b8B6b88cF1Bd0320cB57e562EaF17DE1',\n    chainId: 1,\n    type: 'auction',\n  },\n  PHOENIX_BLAZE_STAKING_VAULT: {\n    name: 'Phoenix Blaze Staking Vault',\n    address: '0xBbe51Ee30422cb9a92D93363d2921A330813b598',\n    chainId: 1,\n    type: 'stakingVault',\n  },\n  PHOENIX_BUY_AND_BURN: {\n    name: 'Phoenix Buy and Burn',\n    address: '0x97eBd4f9FfCFE0cBC8F63A4e0B296FbB54f0a185',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  PHOENIX_FLUX_STAKING_VAULT: {\n    name: 'Phoenix Flux Staking Vault',\n    address: '0x3F1BFcd2a04a829ff4106217F8EB8eFa1C31e89b',\n    chainId: 1,\n    type: 'stakingVault',\n  },\n  PHOENIX_MINTING: {\n    name: 'Phoenix Minting',\n    address: '0xAaE97688F2c28c3E391dFddC7B26276D8445B199',\n    chainId: 1,\n    type: 'minting',\n  },\n  PHOENIX_TITANX_STAKING_VAULT: {\n    name: 'Phoenix TitanX Staking Vault',\n    address: '0x6B59b8E9635909B7f0FF2C577BB15c936f32619A',\n    chainId: 1,\n    type: 'stakingVault',\n  },\n\n  // Shogun\n  SHOGUN: {\n    name: 'Shogun Token',\n    address: '0xfD4cB1294dF23920e683e046963117cAe6C807D9',\n    chainId: 1,\n    type: 'token',\n  },\n  SHOGUN_BUY_AND_BURN: {\n    name: 'Shogun Buy and Burn',\n    address: '0xF53D4f2E79d66605aE7c2CAdc0A40A1e7CbE973A',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  SHOGUN_TITANX: {\n    name: 'SHOGUN/TITANX Pool',\n    address: '0x79bd712f876c364Aa5e775A1eD40dE1FfdB2a50',\n    chainId: 1,\n    type: 'uniswapV2Pool',\n  },\n\n  // Stax\n  STAX: {\n    name: 'Stax Token',\n    address: '0x4bd0F1886010253a18BBb401a788d8972c155b9d',\n    chainId: 1,\n    type: 'token',\n  },\n  STAX_BANK: {\n    name: 'Stax Bank',\n    address: '0x1b15e269D07986F0b8751872C16D9F47e1582402',\n    chainId: 1,\n    type: 'bank',\n  },\n  STAX_BLAZE: {\n    name: 'Stax Blaze',\n    address: '0x03a48BaadAe6A0474aDc6F39111428BaDbfb54D1',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_BUY_AND_BURN: {\n    name: 'Stax Buy and Burn',\n    address: '0x1698a3e248FF7F0f1f91FE82Eedaa3F1212D1F7F',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  STAX_EDEN: {\n    name: 'Stax Eden',\n    address: '0x5d91C1180f063c66DC0a08CE136AeC92B97f8F87',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_FLUX: {\n    name: 'Stax Flux',\n    address: '0xC3379750B254977f195BA60D096BBcCfe6b81ce8',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_HELIOS: {\n    name: 'Stax Helios',\n    address: '0xCd5fd72664f5A4dB62E44e9c778E9dAeB01F2bB2',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_HELIOS_V2: {\n    name: 'Stax Helios V2',\n    address: '0x3A50Cc9740DE6143c8d53Df44ece96Eeb07318E8',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_HOLDER_VAULT: {\n    name: 'Stax Holder Vault',\n    address: '0x5D27813C32dD705404d1A78c9444dAb523331717',\n    chainId: 1,\n    type: 'vault',\n  },\n  STAX_HYPER: {\n    name: 'Stax Hyper',\n    address: '0xa23f149f10f415c56b1629Fe07bf94278c808271',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_NFT: {\n    name: 'Stax NFT',\n    address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',\n    chainId: 1,\n    type: 'nft',\n  },\n  STAX_ORX: {\n    name: 'Stax ORX',\n    address: '0xF1b7081Cab015ADB3c1B8D3A8732763dBc87B744',\n    chainId: 1,\n    type: 'staking',\n  },\n  STAX_TITANX: {\n    name: 'Stax TitanX',\n    address: '0x802974Ea9362b46a6eeAb4431E030D17dF6613E8',\n    chainId: 1,\n    type: 'staking',\n  },\n\n  // TitanX\n  TITANX: {\n    name: 'TitanX Token',\n    address: '0xF19308F923582A6f7c465e5CE7a9Dc1BEC6665B1',\n    chainId: 1,\n    type: 'token',\n  },\n  TITANX_BUY_AND_BURN_V1: {\n    name: 'TitanX Buy and Burn V1',\n    address: '0x1393ad734EA3c52865b4B541cf049dafd25c23a5',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  TITANX_BUY_AND_BURN_V2: {\n    name: 'TitanX Buy and Burn V2',\n    address: '0x410e10C33a49279f78CB99c8d816F18D5e7D5404',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  TITANX_TREASURY: {\n    name: 'TitanX Treasury',\n    address: '0xA2d21205Aa7273BadDFC8E9551e05E23bB49ce46',\n    chainId: 1,\n    type: 'treasury',\n  },\n  TITANX_WETH: {\n    name: 'TITANX/WETH Pool',\n    address: '0xc45A81BC23A64eA556ab4CdF08A86B61cdcEEA8b',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // USDC\n  USDC: {\n    name: 'USDC Token',\n    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n    chainId: 1,\n    type: 'stablecoin',\n  },\n\n  // Volt\n  VOLT: {\n    name: 'Volt Token',\n    address: '0x66b5228CfD34d9f4d9f03188d67816286C7c0b74',\n    chainId: 1,\n    type: 'token',\n  },\n  VOLT_AUCTION: {\n    name: 'Volt Auction',\n    address: '0xb3f2bE29BA969588E07bF7512e07008D6fdeB17B',\n    chainId: 1,\n    type: 'auction',\n  },\n  VOLT_BUY_AND_BURN: {\n    name: 'Volt Buy and Burn',\n    address: '0x2801592e5Cdd85aC4e462DB2abC80951705cf601',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  VOLT_TITANX: {\n    name: 'VOLT/TITANX Pool',\n    address: '0x3F1A36B6C946E406f4295A89fF06a5c7d62F2fe2',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n  VOLT_TREASURY: {\n    name: 'Volt Treasury',\n    address: '0xb638BFB7BC3B8398bee48569CFDAA6B3Bb004224',\n    chainId: 1,\n    type: 'treasury',\n  },\n\n  // Vyper\n  VYPER: {\n    name: 'Vyper Token',\n    address: '0xd7fa4cFC22eA07DfCeD53033fbE59d8b62B8Ee9E',\n    chainId: 1,\n    type: 'token',\n  },\n  VYPER_BOOST_AUCTION: {\n    name: 'Vyper Boost Auction',\n    address: '0x4D994F53FE2d8BdBbF64dC2e53C58Df00b84e713',\n    chainId: 1,\n    type: 'auction',\n  },\n  VYPER_BOOST_TREASURY: {\n    name: 'Vyper Boost Treasury',\n    address: '0x637dfBB5db0cf7B4062cb577E24cfB43c67d72BA',\n    chainId: 1,\n    type: 'treasury',\n  },\n  VYPER_CLASSIC_AUCTION: {\n    name: 'Vyper Classic Auction',\n    address: '0xC1da113c983b26aa2c3f4fFD5f10b47457FC3397',\n    chainId: 1,\n    type: 'auction',\n  },\n  VYPER_CLASSIC_TREASURY: {\n    name: 'Vyper Classic Treasury',\n    address: '0xeb103eb39375077c5Afaa04150B4D334df69128A',\n    chainId: 1,\n    type: 'treasury',\n  },\n  VYPER_DRAGONX: {\n    name: 'VYPER/DRAGONX Pool',\n    address: '0x214CAD3f7FbBe66919968Fa3a1b16E84cFcd457F',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // WETH\n  WETH: {\n    name: 'Wrapped Ether',\n    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n    chainId: 1,\n    type: 'token',\n  },\n\n  // WETH/USDC Pool\n  WETH_USDC: {\n    name: 'WETH/USDC Pool',\n    address: '0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n\n  // X28\n  X28: {\n    name: 'X28 Omnichain Token',\n    address: '0x5c47902c8C80779CB99235E42C354E53F38C3B0d',\n    chainId: 1,\n    type: 'token',\n  },\n  X28_BUY_AND_BURN: {\n    name: 'X28 Buy and Burn',\n    address: '0xa3144E7FCceD79Ce6ff6E14AE9d8DF229417A7a2',\n    chainId: 1,\n    type: 'buyAndBurn',\n  },\n  X28_TITANX: {\n    name: 'X28/TITANX Pool',\n    address: '0x99f60479da6A49D55eBA34893958cdAACc710eE9',\n    chainId: 1,\n    type: 'uniswapV3Pool',\n  },\n};\n\nexport const auctionABI = [\n  {\n    type: 'function',\n    name: 'startTimestamp',\n    inputs: [],\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'dailyStats',\n    inputs: [{ name: 'day', type: 'uint32' }],\n    outputs: [\n      { name: 'titanXDeposited', type: 'uint256' },\n      { name: 'ethDeposited', type: 'uint256' },\n      { name: 'flareEmitted', type: 'uint256' },\n      { name: 'depositsLocked', type: 'bool' },\n    ],\n    stateMutability: 'view',\n  },\n];\n\nexport const flareTokenABI = [\n  {\n    type: 'function',\n    name: 'x28FlarePool',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n];\n\nexport const uniswapPoolABI = [\n  {\n    type: 'function',\n    name: 'slot0',\n    inputs: [],\n    outputs: [\n      { name: 'sqrtPriceX96', type: 'uint160' },\n      { name: 'tick', type: 'int24' },\n      { name: 'observationIndex', type: 'uint16' },\n      { name: 'observationCardinality', type: 'uint16' },\n      { name: 'observationCardinalityNext', type: 'uint16' },\n      { name: 'feeProtocol', type: 'uint8' },\n      { name: 'unlocked', type: 'bool' },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'token0',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'token1',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n];\n\nexport const uniswapV2PoolABI = [\n  {\n    type: 'function',\n    name: 'getReserves',\n    inputs: [],\n    outputs: [\n      { name: '_reserve0', type: 'uint112' },\n      { name: '_reserve1', type: 'uint112' },\n      { name: '_blockTimestampLast', type: 'uint32' },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'token0',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'token1',\n    inputs: [],\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n  },\n];\n---\n\n---\nFile: ./app/store.js\n// app/store.js\n'use client';\nimport { create } from 'zustand';\n\nconst CACHE_TTL = 30 * 60 * 1000; // 30 minutes\n\nexport const useNFTStore = create((set, get) => ({\n  cache: {}, // { contractKey: { data: {...}, timestamp: number } }\n  setCache: (contractKey, data) => {\n    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);\n    set((state) => ({\n      cache: {\n        ...state.cache,\n        [contractKey]: { data, timestamp: Date.now() },\n      },\n    }));\n  },\n  getCache: (contractKey) => {\n    const cachedEntry = get().cache[contractKey];\n    if (!cachedEntry) return null;\n    const now = Date.now();\n    if (now - cachedEntry.timestamp > CACHE_TTL) {\n      console.log(`[NFTStore] Cache expired for ${contractKey}`);\n      set((state) => {\n        const newCache = { ...state.cache };\n        delete newCache[contractKey];\n        return { cache: newCache };\n      });\n      return null;\n    }\n    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);\n    return cachedEntry.data;\n  },\n}));\n---\n\n---\nFile: ./app/about/page.js\n// app/about/page.js\nexport default function AboutPage() {\n  return (\n    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">\n      <div className="max-w-2xl text-center">\n        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>\n        <p className="text-lg text-gray-300 leading-relaxed">\n        TitanXUtils is a platform co-developed by{' '}\n          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}\n          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower\n          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,\n          and community-driven development.\n        </p>\n        <p className="text-lg text-gray-300 leading-relaxed mt-4">\n          Its purpose is to serve as a centralized hub for accessing critical TitanX information,\n          streamlining the experience for both existing and new users. With numerous protocols to\n          navigate, NFTUtils simplifies the process by providing immediate, essential updates in\n          one convenient location.\n        </p>\n        <p className="text-lg text-gray-300 leading-relaxed mt-4">\n          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.\n        </p>\n        <p className="text-lg text-gray-300 leading-relaxed mt-4">\n          I'd like to add sections on our lending and farms protocols.  to be continued...\n        </p>\n      </div>\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/mining/page.js\n// app/mining/page.js\n'use client';\nimport { useState } from 'react';\n\nexport default function Mining() {\n  const [selectedMine, setSelectedMine] = useState(null);\n\n  const auctions = [\n    { name: 'TitanX', url: 'https://app.titanx.win/mine' },\n    { name: 'Hyper', url: 'https://app.hyper.win/mine' },\n    { name: 'Hydra', url: 'https://app.hydra.win/mine' },\n    { name: 'Helios', url: 'https://app.helios.win/mine' },\n    { name: 'Eden', url: 'https://www.eden.win/mine' },\n    { name: 'Lotus', url: 'https://lotus.win/mine' },\n  ];\n\n  const openModal = (mine) => {\n    setSelectedMine(mine);\n  };\n\n  const closeModal = () => {\n    setSelectedMine(null);\n  };\n\n  const handleBackgroundClick = (e) => {\n    if (e.target === e.currentTarget) {\n      closeModal();\n    }\n  };\n\n  return (\n    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">\n      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">\n        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">\n          TitanX Ecosystem Mining\n        </h1>\n        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">\n          Explore the current mining options available in the TitanX ecosystem.\n        </p>\n        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">\n          {auctions.map((mine) => (\n            <div\n              key={mine.name}\n              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 \n                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"\n            >\n              <button\n                onClick={() => openModal(mine)}\n                className="text-blue-400 hover:text-blue-300 text-xl font-semibold \n                  transition-colors duration-200 text-left w-full"\n              >\n                {mine.name} Mining\n              </button>\n              <p className="text-gray-400 mt-2 text-sm truncate">\n                <span className="hover:underline">{mine.url}</span>\n              </p>\n            </div>\n          ))}\n        </div>\n      </main>\n\n      {selectedMine && (\n        <div\n          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"\n          onClick={handleBackgroundClick}\n        >\n          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">\n            <button\n              onClick={closeModal}\n              className="absolute top-2 right-2 text-gray-300 hover:text-white \n                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"\n            >\n              ✕\n            </button>\n            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>\n            <iframe\n              src={selectedMine.url}\n              className="w-full h-[calc(100%-4rem)] border-0 rounded"\n              title={`${selectedMine.name} Mine`}\n              allowFullScreen\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/api/holders/Stax/route.js\n// app/api/holders/Stax/route.js\nimport { NextResponse } from 'next/server';\nimport { Alchemy, Network } from 'alchemy-sdk';\nimport { createPublicClient, http, parseAbi } from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { contractAddresses, contractTiers } from '@/app/nft-contracts';\n\nconst settings = {\n  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,\n  network: Network.ETH_MAINNET,\n};\nconst alchemy = new Alchemy(settings);\n\nconst client = createPublicClient({\n  chain: mainnet,\n  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),\n});\n\nconst nftAbi = parseAbi([\n  "function ownerOf(uint256 tokenId) view returns (address)",\n  "function getNftTier(uint256 tokenId) view returns (uint8)",\n]);\n\nfunction log(message) {\n  console.log(`[PROD_DEBUG] staxNFT - ${message}`);\n}\n\nasync function batchMulticall(calls, batchSize = 50) {\n  log(`batchMulticall: Processing ${calls.length} calls`);\n  const results = [];\n  for (let i = 0; i < calls.length; i += batchSize) {\n    const batch = calls.slice(i, i + batchSize);\n    const batchResults = await client.multicall({ contracts: batch });\n    results.push(...batchResults);\n  }\n  return results;\n}\n\nasync function getAllHolders(page = 0, pageSize = 1000) {\n  const contractAddress = contractAddresses.staxNFT;\n  const tiers = contractTiers.staxNFT;\n  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);\n\n  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {\n    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");\n    throw new Error("Server configuration error: Missing Alchemy API key");\n  }\n  if (!contractAddress) {\n    log("Missing contract address");\n    throw new Error("Contract address not found");\n  }\n  if (!tiers) {\n    log("Missing tiers configuration");\n    throw new Error("Tiers configuration not found");\n  }\n\n  log(`Using contract address: ${contractAddress}`);\n  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {\n    block: 'latest', // Dynamic supply\n    withTokenBalances: true,\n  });\n  const burnAddress = '0x0000000000000000000000000000000000000000';\n  const filteredOwners = ownersResponse.owners.filter(\n    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0\n  );\n  log(`Filtered live owners count: ${filteredOwners.length}`);\n\n  const tokenOwnerMap = new Map();\n  let totalTokens = 0;\n  filteredOwners.forEach(owner => {\n    const wallet = owner.ownerAddress.toLowerCase();\n    owner.tokenBalances.forEach(tb => {\n      const tokenId = BigInt(tb.tokenId);\n      tokenOwnerMap.set(tokenId, wallet);\n      totalTokens++;\n    });\n  });\n  log(`Total tokens checked: ${totalTokens}`);\n\n  const allTokenIds = Array.from(tokenOwnerMap.keys());\n  const start = page * pageSize;\n  const end = Math.min(start + pageSize, allTokenIds.length);\n  const paginatedTokenIds = allTokenIds.slice(start, end);\n  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);\n\n  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    return owner && owner !== burnAddress;\n  });\n  log(`Valid token IDs: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) {\n    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };\n  }\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'getNftTier',\n    args: [tokenId],\n  }));\n\n  const tierResults = await batchMulticall(tierCalls);\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const holdersMap = new Map();\n\n  tierResults.forEach((result, i) => {\n    if (result?.status === 'success') {\n      const tokenId = validTokenIds[i];\n      const wallet = tokenOwnerMap.get(tokenId);\n      const tier = Number(result.result);\n\n      if (tier >= 1 && tier <= maxTier) {\n        if (!holdersMap.has(wallet)) {\n          holdersMap.set(wallet, {\n            wallet,\n            total: 0,\n            multiplierSum: 0,\n            tiers: Array(maxTier + 1).fill(0),\n          });\n        }\n        const holder = holdersMap.get(wallet);\n        holder.total += 1;\n        holder.multiplierSum += tiers[tier].multiplier || 0;\n        holder.tiers[tier] += 1;\n      }\n    }\n  });\n\n  const holders = Array.from(holdersMap.values());\n  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  holders.forEach(holder => {\n    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n    holder.rank = 0;\n    holder.displayMultiplierSum = holder.multiplierSum; // No division for Stax\n  });\n\n  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);\n  holders.forEach((holder, index) => (holder.rank = index + 1));\n  log(`Final holders count: ${holders.length}`);\n\n  return {\n    holders,\n    totalTokens,\n    page,\n    pageSize,\n    totalPages: Math.ceil(totalTokens / pageSize),\n  };\n}\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const page = parseInt(searchParams.get('page') || '0', 10);\n  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);\n  log(`Received request: page=${page}, pageSize=${pageSize}`);\n\n  try {\n    const result = await getAllHolders(page, pageSize);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error(`[PROD_ERROR] StaxNFT API error: ${error.message}`);\n    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });\n  }\n}\n---\n\n---\nFile: ./app/api/holders/E280/route.js\n// app/api/holders/E280/route.js\nimport { NextResponse } from 'next/server';\nimport { log } from '../../utils';\n\nexport async function GET(request) {\n  log('GET /api/holders/E280: Data not available yet');\n  return NextResponse.json({ message: 'E280 data will go live after deployment' });\n}\n---\n\n---\nFile: ./app/api/holders/Element280/route.js\n// app/api/holders/Element280/route.js\nimport { NextResponse } from 'next/server';\nimport { alchemy, client, nftAbi, CACHE_TTL, log, batchMulticall } from '../../utils';\nimport { contractAddresses, contractTiers } from '@/app/nft-contracts';\nlet cache = {};\nlet tokenCache = new Map();\n\nasync function getAllHolders(contractAddress, tiers, page = 0, pageSize = 1000) {\n  const contractName = 'element280';\n  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;\n  const now = Date.now();\n\n  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {\n    log(`getAllHolders: Returning cached data for ${cacheKey}`);\n    return cache[cacheKey].data;\n  }\n\n  log(`getAllHolders start: ${contractName} at ${contractAddress}, page=${page}, pageSize=${pageSize}`);\n  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true });\n  log(`${contractName} - Raw owners count: ${ownersResponse.owners.length}`);\n\n  const burnAddress = '0x0000000000000000000000000000000000000000';\n  const filteredOwners = ownersResponse.owners.filter(\n    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0\n  );\n  log(`${contractName} - Filtered live owners count: ${filteredOwners.length}`);\n\n  const tokenOwnerMap = new Map();\n  let totalTokens = 0;\n  filteredOwners.forEach(owner => {\n    const wallet = owner.ownerAddress.toLowerCase();\n    owner.tokenBalances.forEach(tb => {\n      const tokenId = BigInt(tb.tokenId);\n      tokenOwnerMap.set(tokenId, wallet);\n      totalTokens++;\n    });\n  });\n  log(`${contractName} - Total tokens checked: ${totalTokens}`);\n\n  const allTokenIds = Array.from(tokenOwnerMap.keys());\n  const start = page * pageSize;\n  const end = Math.min(start + pageSize, allTokenIds.length);\n  const paginatedTokenIds = allTokenIds.slice(start, end);\n  log(`${contractName} - Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);\n\n  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = [];\n  paginatedTokenIds.forEach((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    const cacheKey = `${contractAddress}-${tokenId}-owner`;\n    if (owner && owner !== burnAddress) {\n      validTokenIds.push(tokenId);\n      tokenCache.set(cacheKey, owner);\n    } else {\n      tokenCache.set(cacheKey, null);\n    }\n  });\n  log(`${contractName} - Valid token IDs after ownerOf: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) {\n    log(`${contractName} - No valid tokens found in this page`);\n    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(allTokenIds.length / pageSize) };\n  }\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'getNftTier',\n    args: [tokenId],\n  }));\n\n  log(`${contractName} - Starting tier multicall for ${tierCalls.length} tokens`);\n  const tierResults = await batchMulticall(tierCalls);\n  log(`${contractName} - Tier results length: ${tierResults.length}`);\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const holdersMap = new Map();\n  let totalNftsHeld = 0;\n\n  tierResults.forEach((result, i) => {\n    if (!result) {\n      log(`${contractName} - Undefined tier result at index ${i}, tokenId: ${validTokenIds[i]}`);\n      return;\n    }\n    if (result.status === 'success') {\n      const tokenId = validTokenIds[i];\n      const wallet = tokenOwnerMap.get(tokenId);\n      const tier = Number(result.result);\n      const cacheKey = `${contractAddress}-${tokenId}-tier`;\n      tokenCache.set(cacheKey, tier);\n\n      if (tier >= 1 && tier <= maxTier) {\n        if (!holdersMap.has(wallet)) {\n          holdersMap.set(wallet, {\n            wallet,\n            total: 0,\n            multiplierSum: 0,\n            tiers: Array(maxTier + 1).fill(0),\n          });\n        }\n\n        const holder = holdersMap.get(wallet);\n        holder.total += 1;\n        holder.multiplierSum += tiers[tier]?.multiplier || 0;\n        holder.tiers[tier] += 1;\n        totalNftsHeld += 1;\n      } else {\n        log(`${contractName} - Invalid tier ${tier} for token ${tokenId}`);\n      }\n    } else {\n      log(`${contractName} - Failed tier fetch at index ${i}, tokenId: ${validTokenIds[i]}`);\n    }\n  });\n  log(`${contractName} - Total NFTs held after tier check: ${totalNftsHeld}`);\n\n  const holders = Array.from(holdersMap.values());\n  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  holders.forEach(holder => {\n    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n    holder.rank = 0;\n    holder.displayMultiplierSum = holder.multiplierSum / 10; // Element280 specific adjustment\n  });\n\n  const sortFn = (a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total;\n  holders.sort(sortFn);\n  holders.forEach((holder, index) => (holder.rank = index + 1));\n\n  const result = {\n    holders,\n    totalTokens,\n    page,\n    pageSize,\n    totalPages: Math.ceil(allTokenIds.length / pageSize),\n  };\n\n  cache[cacheKey] = { timestamp: now, data: result };\n  log(`${contractName} - Final holders count: ${holders.length}`);\n  return result;\n}\n\nasync function getHolderData(contractAddress, wallet, tiers) {\n  const contractName = 'element280';\n  const cacheKey = `${contractAddress}-${wallet}`;\n  const now = Date.now();\n\n  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {\n    log(`getHolderData: Returning cached data for ${cacheKey}`);\n    return cache[cacheKey].data;\n  }\n\n  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {\n    throw new Error('Invalid wallet address');\n  }\n\n  log(`getHolderData start: wallet=${wallet}, contract=${contractAddress}`);\n  const nfts = await alchemy.nft.getNftsForOwner(wallet, { contractAddresses: [contractAddress] });\n  log(`${contractAddress} - Initial NFTs for ${wallet}: ${nfts.totalCount}`);\n\n  if (nfts.totalCount === 0) return null;\n\n  const walletLower = wallet.toLowerCase();\n  const tokenIds = nfts.ownedNfts.map(nft => BigInt(nft.tokenId));\n  const ownerOfCalls = tokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = tokenIds.filter((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    const cacheKey = `${contractAddress}-${tokenId}-owner`;\n    tokenCache.set(cacheKey, owner);\n    return owner === walletLower;\n  });\n  log(`${contractAddress} - Valid token IDs for ${wallet}: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) return null;\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'getNftTier',\n    args: [tokenId],\n  }));\n\n  const tierResults = await batchMulticall(tierCalls);\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const tiersArray = Array(maxTier + 1).fill(0);\n  let total = 0;\n  let multiplierSum = 0;\n\n  tierResults.forEach((result, i) => {\n    if (!result) {\n      log(`${contractAddress} - Undefined tier result for wallet ${wallet} at index ${i}, tokenId: ${validTokenIds[i]}`);\n      return;\n    }\n    if (result.status === 'success') {\n      const tier = Number(result.result);\n      const tokenId = validTokenIds[i];\n      const cacheKey = `${contractAddress}-${tokenId}-tier`;\n      tokenCache.set(cacheKey, tier);\n      if (tier >= 1 && tier <= maxTier) {\n        tiersArray[tier] += 1;\n        total += 1;\n        multiplierSum += tiers[tier]?.multiplier || 0;\n      }\n    }\n  });\n  log(`${contractAddress} - Total NFTs for ${wallet} after tier check: ${total}`);\n\n  const allHolders = await getAllHolders(contractAddress, tiers, 0, 1000);\n  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  const percentage = totalMultiplierSum > 0 ? (multiplierSum / totalMultiplierSum) * 100 : 0;\n  const holder = allHolders.holders.find(h => h.wallet === walletLower) || { rank: allHolders.holders.length + 1 };\n\n  const result = {\n    wallet: walletLower,\n    rank: holder.rank,\n    total,\n    multiplierSum,\n    displayMultiplierSum: multiplierSum / 10, // Element280 specific adjustment\n    percentage,\n    tiers: tiersArray,\n  };\n\n  cache[cacheKey] = { timestamp: now, data: result };\n  log(`${contractAddress} - Final data for ${wallet}: total=${total}, multiplierSum=${multiplierSum}`);\n  return result;\n}\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const wallet = searchParams.get('wallet');\n  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));\n  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));\n\n  const address = contractAddresses['element280']; // Hardcoded for this endpoint\n  if (!address) {\n    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });\n  }\n\n  try {\n    if (wallet) {\n      const holderData = await getHolderData(address, wallet, contractTiers['element280']);\n      return NextResponse.json({ holders: holderData ? [holderData] : [] });\n    }\n\n    const result = await getAllHolders(address, contractTiers['element280'], page, pageSize);\n    return NextResponse.json(result);\n  } catch (error) {\n    log(`Error in GET /api/holders/Element280: ${error.message}`);\n    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });\n  }\n}\n---\n\n---\nFile: ./app/api/holders/Element369/route.js\n// app/api/holders/Element369/route.js\nimport { NextResponse } from 'next/server';\nimport { Alchemy, Network } from 'alchemy-sdk';\nimport { createPublicClient, http, parseAbi } from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { contractAddresses, contractTiers } from '@/app/nft-contracts';\n\nconst settings = {\n  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,\n  network: Network.ETH_MAINNET,\n};\nconst alchemy = new Alchemy(settings);\n\nconst client = createPublicClient({\n  chain: mainnet,\n  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),\n});\n\nconst nftAbi = parseAbi([\n  "function ownerOf(uint256 tokenId) view returns (address)",\n  "function getNftTier(uint256 tokenId) view returns (uint8)",\n]);\n\nfunction log(message) {\n  console.log(`[PROD_DEBUG] element369 - ${message}`);\n}\n\nasync function batchMulticall(calls, batchSize = 50) {\n  log(`batchMulticall: Processing ${calls.length} calls`);\n  const results = [];\n  for (let i = 0; i < calls.length; i += batchSize) {\n    const batch = calls.slice(i, i + batchSize);\n    const batchResults = await client.multicall({ contracts: batch });\n    results.push(...batchResults);\n  }\n  return results;\n}\n\nasync function getAllHolders(page = 0, pageSize = 1000) {\n  const contractAddress = contractAddresses.element369;\n  const tiers = contractTiers.element369;\n  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);\n\n  if (!process.env.NEXT_PUBLIC_ALCHEMY_API_KEY) {\n    log("Missing NEXT_PUBLIC_ALCHEMY_API_KEY");\n    throw new Error("Server configuration error: Missing Alchemy API key");\n  }\n  if (!contractAddress) {\n    log("Missing contract address");\n    throw new Error("Contract address not found");\n  }\n  if (!tiers) {\n    log("Missing tiers configuration");\n    throw new Error("Tiers configuration not found");\n  }\n\n  log(`Using contract address: ${contractAddress}`);\n  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {\n    block: 'latest',\n    withTokenBalances: true,\n  });\n  const burnAddress = '0x0000000000000000000000000000000000000000';\n  const filteredOwners = ownersResponse.owners.filter(\n    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0\n  );\n  log(`Filtered live owners count: ${filteredOwners.length}`);\n\n  const tokenOwnerMap = new Map();\n  let totalTokens = 0;\n  filteredOwners.forEach(owner => {\n    const wallet = owner.ownerAddress.toLowerCase();\n    owner.tokenBalances.forEach(tb => {\n      const tokenId = BigInt(tb.tokenId);\n      tokenOwnerMap.set(tokenId, wallet);\n      totalTokens++;\n    });\n  });\n  log(`Total tokens checked: ${totalTokens}`);\n\n  const allTokenIds = Array.from(tokenOwnerMap.keys());\n  const start = page * pageSize;\n  const end = Math.min(start + pageSize, allTokenIds.length);\n  const paginatedTokenIds = allTokenIds.slice(start, end);\n  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);\n\n  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    return owner && owner !== burnAddress;\n  });\n  log(`Valid token IDs: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) {\n    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(totalTokens / pageSize) };\n  }\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: nftAbi,\n    functionName: 'getNftTier',\n    args: [tokenId],\n  }));\n\n  const tierResults = await batchMulticall(tierCalls);\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const holdersMap = new Map();\n\n  tierResults.forEach((result, i) => {\n    if (result?.status === 'success') {\n      const tokenId = validTokenIds[i];\n      const wallet = tokenOwnerMap.get(tokenId);\n      const tier = Number(result.result);\n\n      if (tier >= 1 && tier <= maxTier) {\n        if (!holdersMap.has(wallet)) {\n          holdersMap.set(wallet, {\n            wallet,\n            total: 0,\n            multiplierSum: 0,\n            tiers: Array(maxTier + 1).fill(0),\n          });\n        }\n        const holder = holdersMap.get(wallet);\n        holder.total += 1;\n        holder.multiplierSum += tiers[tier].multiplier || 0;\n        holder.tiers[tier] += 1;\n      }\n    }\n  });\n\n  const holders = Array.from(holdersMap.values());\n  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  holders.forEach(holder => {\n    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n    holder.rank = 0;\n    holder.displayMultiplierSum = holder.multiplierSum;\n  });\n\n  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);\n  holders.forEach((holder, index) => (holder.rank = index + 1));\n  log(`Final holders count: ${holders.length}`);\n\n  return {\n    holders,\n    totalTokens,\n    page,\n    pageSize,\n    totalPages: Math.ceil(totalTokens / pageSize),\n  };\n}\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const page = parseInt(searchParams.get('page') || '0', 10);\n  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);\n  log(`Received request: page=${page}, pageSize=${pageSize}`);\n\n  try {\n    const result = await getAllHolders(page, pageSize);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error(`[PROD_ERROR] Element369 API error: ${error.message}`);\n    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });\n  }\n}\n---\n\n---\nFile: ./app/api/holders/Ascendant/route.js\n// app/api/holders/Ascendant/route.js\nimport { NextResponse } from 'next/server';\nimport { alchemy, client, ascendantAbi, CACHE_TTL, log, batchMulticall } from '../../utils';\nimport { contractAddresses, contractTiers } from '@/app/nft-contracts';\n\nlet cache = {};\nlet tokenCache = new Map();\n\nasync function getAllHolders(page = 0, pageSize = 1000) {\n  const contractAddress = contractAddresses.ascendantNFT;\n  const tiers = contractTiers.ascendantNFT;\n  const contractName = 'ascendantNFT';\n  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;\n  const now = Date.now();\n\n  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {\n    log(`Returning cached data for ${cacheKey}`);\n    return cache[cacheKey].data;\n  }\n\n  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);\n  if (!contractAddress) {\n    log("Missing contract address");\n    throw new Error("Contract address not found");\n  }\n  if (!tiers) {\n    log("Missing tiers configuration");\n    throw new Error("Tiers configuration not found");\n  }\n\n  log(`Using contract address: ${contractAddress}`);\n  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {\n    block: 'latest',\n    withTokenBalances: true,\n  });\n  log(`Raw owners count: ${ownersResponse.owners.length}`);\n\n  const burnAddress = '0x0000000000000000000000000000000000000000';\n  const filteredOwners = ownersResponse.owners.filter(\n    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0\n  );\n  log(`Filtered live owners count: ${filteredOwners.length}`);\n\n  const tokenOwnerMap = new Map();\n  let totalTokens = 0;\n  filteredOwners.forEach(owner => {\n    const wallet = owner.ownerAddress.toLowerCase();\n    owner.tokenBalances.forEach(tb => {\n      const tokenId = BigInt(tb.tokenId);\n      tokenOwnerMap.set(tokenId, wallet);\n      totalTokens++;\n    });\n  });\n  log(`Total tokens checked: ${totalTokens}`);\n\n  const allTokenIds = Array.from(tokenOwnerMap.keys());\n  const start = page * pageSize;\n  const end = Math.min(start + pageSize, allTokenIds.length);\n  const paginatedTokenIds = allTokenIds.slice(start, end);\n  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);\n\n  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    return owner && owner !== burnAddress;\n  });\n  log(`Valid token IDs: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) {\n    const result = { \n      holders: [], \n      totalTokens, \n      totalLockedAscendant: 0, \n      totalShares: 0,\n      toDistributeDay8: 0,\n      toDistributeDay28: 0,\n      toDistributeDay90: 0,\n      pendingRewards: 0,\n      page, \n      pageSize, \n      totalPages: Math.ceil(totalTokens / pageSize) \n    };\n    cache[cacheKey] = { timestamp: now, data: result };\n    return result;\n  }\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'getNFTAttribute',\n    args: [tokenId],\n  }));\n  const recordCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'userRecords',\n    args: [tokenId],\n  }));\n\n  const [tierResults, recordResults] = await Promise.all([\n    batchMulticall(tierCalls),\n    batchMulticall(recordCalls),\n  ]);\n\n  const totalShares = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'totalShares',\n  }));\n  const toDistributeDay8 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [0], // POOLS.DAY8\n  }));\n  const toDistributeDay28 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [1], // POOLS.DAY28\n  }));\n  const toDistributeDay90 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [2], // POOLS.DAY90\n  }));\n  const rewardPerShare = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'rewardPerShare',\n  }));\n\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const holdersMap = new Map();\n  let totalLockedAscendant = 0;\n\n  tierResults.forEach((result, i) => {\n    if (result?.status === 'success') {\n      const tokenId = validTokenIds[i];\n      const wallet = tokenOwnerMap.get(tokenId);\n      const tier = Number(result.result[1]);\n      const record = recordResults[i]?.status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];\n      const shares = Number(record[0]);\n      const lockedAscendant = Number(record[1]);\n      const rewardDebt = Number(record[2]);\n\n      if (tier >= 1 && tier <= maxTier) {\n        if (!holdersMap.has(wallet)) {\n          holdersMap.set(wallet, {\n            wallet,\n            total: 0,\n            multiplierSum: 0,\n            tiers: Array(maxTier + 1).fill(0),\n            shares: 0,\n            lockedAscendant: 0,\n            rewardDebt: 0,\n            pendingDay8: 0,\n            pendingDay28: 0,\n            pendingDay90: 0,\n          });\n        }\n        const holder = holdersMap.get(wallet);\n        holder.total += 1;\n        holder.multiplierSum += tiers[tier]?.multiplier || 0;\n        holder.tiers[tier] += 1;\n        holder.shares += shares;\n        holder.lockedAscendant += lockedAscendant;\n        holder.rewardDebt += rewardDebt;\n        totalLockedAscendant += lockedAscendant;\n      }\n    }\n  });\n\n  // Calculate pending rewards per wallet\n  const holders = Array.from(holdersMap.values());\n  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;\n  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;\n  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;\n\n  holders.forEach(holder => {\n    const currentRewardPerShare = rewardPerShare + pendingRewardPerShareDay8 + pendingRewardPerShareDay28 + pendingRewardPerShareDay90;\n    const totalPending = holder.shares * (currentRewardPerShare - holder.rewardDebt / holder.total);\n    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;\n    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;\n    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;\n    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n    holder.rank = 0;\n    holder.displayMultiplierSum = holder.multiplierSum;\n  });\n\n  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);\n  holders.forEach((holder, index) => (holder.rank = index + 1));\n  log(`Final holders count: ${holders.length}`);\n\n  const result = {\n    holders,\n    totalTokens,\n    totalLockedAscendant,\n    totalShares,\n    toDistributeDay8,\n    toDistributeDay28,\n    toDistributeDay90,\n    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,\n    page,\n    pageSize,\n    totalPages: Math.ceil(totalTokens / pageSize),\n  };\n\n  cache[cacheKey] = { timestamp: now, data: result };\n  log(`Returning: holders=${holders.length}, totalTokens=${totalTokens}, totalLockedAscendant=${totalLockedAscendant}, totalShares=${totalShares}, pendingRewards=${result.pendingRewards}`);\n  return result;\n}\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const page = parseInt(searchParams.get('page') || '0', 10);\n  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);\n  log(`Received request: page=${page}, pageSize=${pageSize}`);\n\n  try {\n    const result = await getAllHolders(page, pageSize);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error(`[PROD_ERROR] AscendantNFT API error: ${error.message}`);\n    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });\n  }\n}\n---\n\n---\nFile: ./app/api/holders/Ascendant/route copy.js\n// app/api/holders/Ascendant/route.js\nimport { NextResponse } from 'next/server';\nimport { alchemy, client, ascendantAbi, CACHE_TTL, log, batchMulticall } from '../../utils';\nimport { contractAddresses, contractTiers } from '@/app/nft-contracts';\n\nlet cache = {};\nlet tokenCache = new Map();\n\nasync function getAllHolders(page = 0, pageSize = 1000) {\n  const contractAddress = contractAddresses.ascendantNFT;\n  const tiers = contractTiers.ascendantNFT;\n  const contractName = 'ascendantNFT';\n  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;\n  const now = Date.now();\n\n  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {\n    log(`Returning cached data for ${cacheKey}`);\n    return cache[cacheKey].data;\n  }\n\n  log(`Fetching holders, page=${page}, pageSize=${pageSize}`);\n  if (!contractAddress) {\n    log("Missing contract address");\n    throw new Error("Contract address not found");\n  }\n  if (!tiers) {\n    log("Missing tiers configuration");\n    throw new Error("Tiers configuration not found");\n  }\n\n  log(`Using contract address: ${contractAddress}`);\n  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {\n    block: 'latest',\n    withTokenBalances: true,\n  });\n  log(`Raw owners count: ${ownersResponse.owners.length}`);\n\n  const burnAddress = '0x0000000000000000000000000000000000000000';\n  const filteredOwners = ownersResponse.owners.filter(\n    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0\n  );\n  log(`Filtered live owners count: ${filteredOwners.length}`);\n\n  const tokenOwnerMap = new Map();\n  let totalTokens = 0;\n  filteredOwners.forEach(owner => {\n    const wallet = owner.ownerAddress.toLowerCase();\n    owner.tokenBalances.forEach(tb => {\n      const tokenId = BigInt(tb.tokenId);\n      tokenOwnerMap.set(tokenId, wallet);\n      totalTokens++;\n    });\n  });\n  log(`Total tokens checked: ${totalTokens}`);\n\n  const allTokenIds = Array.from(tokenOwnerMap.keys());\n  const start = page * pageSize;\n  const end = Math.min(start + pageSize, allTokenIds.length);\n  const paginatedTokenIds = allTokenIds.slice(start, end);\n  log(`Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);\n\n  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'ownerOf',\n    args: [tokenId],\n  }));\n\n  const ownerOfResults = await batchMulticall(ownerOfCalls);\n  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {\n    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();\n    return owner && owner !== burnAddress;\n  });\n  log(`Valid token IDs: ${validTokenIds.length}`);\n\n  if (validTokenIds.length === 0) {\n    const result = { \n      holders: [], \n      totalTokens, \n      totalLockedAscendant: 0, \n      totalShares: 0,\n      toDistributeDay8: 0,\n      toDistributeDay28: 0,\n      toDistributeDay90: 0,\n      pendingRewards: 0,\n      page, \n      pageSize, \n      totalPages: Math.ceil(totalTokens / pageSize) \n    };\n    cache[cacheKey] = { timestamp: now, data: result };\n    return result;\n  }\n\n  const tierCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'getNFTAttribute',\n    args: [tokenId],\n  }));\n  const recordCalls = validTokenIds.map(tokenId => ({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'userRecords',\n    args: [tokenId],\n  }));\n\n  const [tierResults, recordResults] = await Promise.all([\n    batchMulticall(tierCalls),\n    batchMulticall(recordCalls),\n  ]);\n\n  const totalShares = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'totalShares',\n  }));\n  const toDistributeDay8 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [0], // POOLS.DAY8\n  }));\n  const toDistributeDay28 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [1], // POOLS.DAY28\n  }));\n  const toDistributeDay90 = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'toDistribute',\n    args: [2], // POOLS.DAY90\n  }));\n  const rewardPerShare = Number(await client.readContract({\n    address: contractAddress,\n    abi: ascendantAbi,\n    functionName: 'rewardPerShare',\n  }));\n\n  const maxTier = Math.max(...Object.keys(tiers).map(Number));\n  const holdersMap = new Map();\n  let totalLockedAscendant = 0;\n\n  tierResults.forEach((result, i) => {\n    if (result?.status === 'success') {\n      const tokenId = validTokenIds[i];\n      const wallet = tokenOwnerMap.get(tokenId);\n      const tier = Number(result.result[1]);\n      const record = recordResults[i]?.status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];\n      const shares = Number(record[0]);\n      const lockedAscendant = Number(record[1]);\n      const rewardDebt = Number(record[2]);\n\n      if (tier >= 1 && tier <= maxTier) {\n        if (!holdersMap.has(wallet)) {\n          holdersMap.set(wallet, {\n            wallet,\n            total: 0,\n            multiplierSum: 0,\n            tiers: Array(maxTier + 1).fill(0),\n            shares: 0,\n            lockedAscendant: 0,\n            rewardDebt: 0,\n            pendingDay8: 0,\n            pendingDay28: 0,\n            pendingDay90: 0,\n          });\n        }\n        const holder = holdersMap.get(wallet);\n        holder.total += 1;\n        holder.multiplierSum += tiers[tier]?.multiplier || 0;\n        holder.tiers[tier] += 1;\n        holder.shares += shares;\n        holder.lockedAscendant += lockedAscendant;\n        holder.rewardDebt += rewardDebt;\n        totalLockedAscendant += lockedAscendant;\n      }\n    }\n  });\n\n  // Calculate pending rewards per wallet\n  const holders = Array.from(holdersMap.values());\n  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);\n  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;\n  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;\n  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;\n\n  holders.forEach(holder => {\n    const currentRewardPerShare = rewardPerShare + pendingRewardPerShareDay8 + pendingRewardPerShareDay28 + pendingRewardPerShareDay90;\n    const totalPending = holder.shares * (currentRewardPerShare - holder.rewardDebt / holder.total);\n    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;\n    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;\n    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;\n    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;\n    holder.rank = 0;\n    holder.displayMultiplierSum = holder.multiplierSum;\n  });\n\n  holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);\n  holders.forEach((holder, index) => (holder.rank = index + 1));\n  log(`Final holders count: ${holders.length}`);\n\n  const result = {\n    holders,\n    totalTokens,\n    totalLockedAscendant,\n    totalShares,\n    toDistributeDay8,\n    toDistributeDay28,\n    toDistributeDay90,\n    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,\n    page,\n    pageSize,\n    totalPages: Math.ceil(totalTokens / pageSize),\n  };\n\n  cache[cacheKey] = { timestamp: now, data: result };\n  log(`Returning: holders=${holders.length}, totalTokens=${totalTokens}, totalLockedAscendant=${totalLockedAscendant}, totalShares=${totalShares}, pendingRewards=${result.pendingRewards}`);\n  return result;\n}\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const page = parseInt(searchParams.get('page') || '0', 10);\n  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);\n  log(`Received request: page=${page}, pageSize=${pageSize}`);\n\n  try {\n    const result = await getAllHolders(page, pageSize);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error(`[PROD_ERROR] AscendantNFT API error: ${error.message}`);\n    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });\n  }\n}\n---\n\n---\nFile: ./app/api/utils.js\n// app/api/utils.js\nimport { createPublicClient, http, parseAbi } from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { Alchemy, Network } from 'alchemy-sdk';\n\nexport const alchemy = new Alchemy({\n  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),\n  network: Network.ETH_MAINNET,\n});\n\nexport const client = createPublicClient({\n  chain: mainnet,\n  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),\n});\n\nexport const nftAbi = parseAbi([\n  "function ownerOf(uint256 tokenId) view returns (address)",\n  "function getNftTier(uint256 tokenId) view returns (uint8)",\n]);\n\nexport const ascendantAbi = parseAbi([\n  "function ownerOf(uint256 tokenId) view returns (address)",\n  "function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)",\n  "function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)",\n  "function totalShares() view returns (uint256)",\n  "function toDistribute(uint8 pool) view returns (uint256)",\n  "function rewardPerShare() view returns (uint256)",\n  "error NonExistentToken(uint256 tokenId)"\n]);\n\nexport const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport function log(message) {\n  console.log(`[PROD_DEBUG] ${message}`);\n}\n\nexport async function batchMulticall(calls, batchSize = 50) {\n  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);\n  const results = [];\n  for (let i = 0; i < calls.length; i += batchSize) {\n    const batch = calls.slice(i, i + batchSize);\n    try {\n      const batchResults = await client.multicall({ contracts: batch });\n      results.push(...batchResults);\n      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);\n    } catch (error) {\n      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);\n      results.push(...batch.map(() => ({ status: 'failure', result: null })));\n    }\n  }\n  log(`batchMulticall: Completed with ${results.length} results`);\n  return results;\n}\n---\n\n---\nFile: ./app/api/auctions/flare/route.js\n// app/api/auctions/flare/route.js\nimport { NextResponse } from 'next/server';\nimport { createPublicClient, http } from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { tokenContracts, auctionABI, flareMintingABI, uniswapPoolABI } from '@/app/token_contracts';\nimport { wdiv } from '@/utils/Math'; // Use shared wdiv\n\nfunction getDayEnd(t) {\n  const adjustedTime = t - 14 * 3600; // Subtract 14 hours\n  const daysSinceEpoch = Math.floor(adjustedTime / 86400);\n  return (daysSinceEpoch + 1) * 86400 + 14 * 3600; // Next day at 2 PM UTC\n}\n\nexport async function GET() {\n  try {\n    const client = createPublicClient({\n      chain: mainnet,\n      transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),\n    });\n\n    // Fetch start timestamp\n    const startTimestamp = await client.readContract({\n      address: tokenContracts.FLARE_AUCTION.address,\n      abi: auctionABI,\n      functionName: 'startTimestamp',\n    });\n\n    const now = Date.now() / 1000;\n\n    // Check if auction has started\n    if (Number(startTimestamp) > now) {\n      return NextResponse.json(\n        {\n          currentDay: 0,\n          startTimestamp: Number(startTimestamp),\n          flareEmitted: 0,\n          titanXDeposited: 0,\n          ethDeposited: 0,\n          depositsLocked: false,\n          roi: 0,\n          currentFlarePerTitanX: 0,\n          marketFlareTitanXPrice: 0,\n          timeRemaining: 'Not started',\n          deviationStatus: 'N/A',\n          mintCycle: {\n            currentCycle: 0,\n            startsAt: 0,\n            endsAt: 0,\n            isMinting: false,\n          },\n        },\n        {\n          headers: {\n            'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=300',\n          },\n        }\n      );\n    }\n\n    // Calculate current day\n    const currentDay = Math.max(1, Math.floor((now - Number(startTimestamp)) / 86400));\n\n    // Fetch daily stats\n    const dailyStats = await client.readContract({\n      address: tokenContracts.FLARE_AUCTION.address,\n      abi: auctionABI,\n      functionName: 'dailyStats',\n      args: [currentDay],\n    });\n\n    // Fetch minting cycle\n    const mintCycle = await client.readContract({\n      address: tokenContracts.FLARE_MINTING.address,\n      abi: flareMintingABI,\n      functionName: 'getCurrentMintCycle',\n    });\n\n    // Fetch TWAP and spot price\n    const twapData = await client.readContract({\n      address: tokenContracts.FLARE_X28.address,\n      abi: uniswapPoolABI,\n      functionName: 'observe',\n      args: [[15 * 60, 0]], // 15-minute TWAP\n    });\n    const poolData = await client.readContract({\n      address: tokenContracts.FLARE_X28.address,\n      abi: uniswapPoolABI,\n      functionName: 'slot0',\n    });\n\n    const [titanXDeposited, ethDeposited, flareEmitted, depositsLocked] = dailyStats;\n    const [currentCycle, cycleStartsAt, cycleEndsAt] = mintCycle;\n    const [sqrtPriceX96] = poolData;\n    const [[tickCumulativesPast, tickCumulativesNow],] = twapData;\n\n    // Calculate time remaining using getDayEnd\n    const dayEnd = getDayEnd(Number(startTimestamp) + (currentDay - 1) * 86400);\n    const secondsLeft = dayEnd - now;\n    const hours = Math.floor(secondsLeft / 3600);\n    const minutes = Math.floor((secondsLeft % 3600) / 60);\n    const timeRemaining = secondsLeft > 0 ? `${hours}h ${minutes}m` : 'Ended';\n\n    // Calculate deviation and prices\n    let deviationStatus = 'N/A';\n    let currentFlarePerTitanX = 0;\n    let marketFlareTitanXPrice = 0;\n    let roi = 0;\n    if (flareEmitted !== 0n && titanXDeposited !== 0n) {\n      const tickCumulativesDelta = Number(tickCumulativesNow) - Number(tickCumulativesPast);\n      const secondsAgo = 15 * 60;\n      let arithmeticMeanTick = Math.floor(tickCumulativesDelta / secondsAgo);\n      if (tickCumulativesDelta < 0 && tickCumulativesDelta % secondsAgo !== 0) {\n        arithmeticMeanTick--;\n      }\n      const sqrtPriceX96Twap = Math.sqrt(1.0001 ** arithmeticMeanTick) * 2 ** 96;\n      const price = Number((BigInt(sqrtPriceX96) ** 2n) / (2n ** 192n)) / 1e18;\n      const twapPrice = Number((BigInt(sqrtPriceX96Twap) ** 2n) / (2n ** 192n)) / 1e18;\n      const diff = twapPrice >= price ? twapPrice - price : price - twapPrice;\n      const deviationLimit = 300; // 3% from SwapActions.sol\n      deviationStatus = (price * deviationLimit) / 10000 < diff ? 'Out of bounds' : 'Within bounds';\n      currentFlarePerTitanX = Number(wdiv(flareEmitted, titanXDeposited)) / 1e18;\n      marketFlareTitanXPrice = twapPrice;\n      roi = deviationStatus === 'Out of bounds' ? 0 : (currentFlarePerTitanX / marketFlareTitanXPrice) * 100;\n    }\n\n    const auctionData = {\n      currentDay,\n      startTimestamp: Number(startTimestamp),\n      flareEmitted: Number(flareEmitted) / 1e18,\n      titanXDeposited: Number(titanXDeposited) / 1e18,\n      ethDeposited: Number(ethDeposited) / 1e18,\n      depositsLocked,\n      roi,\n      currentFlarePerTitanX,\n      marketFlareTitanXPrice,\n      timeRemaining,\n      deviationStatus,\n      mintCycle: {\n        currentCycle: Number(currentCycle),\n        startsAt: Number(cycleStartsAt),\n        endsAt: Number(cycleEndsAt),\n        isMinting: now < Number(cycleEndsAt),\n      },\n    };\n\n    const cacheTTL = 5 * 60; // 5 minutes\n    return NextResponse.json(auctionData, {\n      headers: {\n        'Cache-Control': `public, s-maxage=${cacheTTL}, stale-while-revalidate=${cacheTTL}`,\n      },\n    });\n  } catch (error) {\n    console.error('Error fetching Flare auction data:', error);\n    return NextResponse.json(\n      { error: `Failed to fetch auction data: ${error.message}` },\n      { status: 500 }\n    );\n  }\n}\n---\n\n---\nFile: ./app/layout.css\n/* app/layout.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n.animate-fade-in {\n  animation: fadeIn 0.5s ease-in;\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.highlight-row-bold {\n  background-color: #fef08a; /* Bold yellow */\n  font-weight: 600;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  transition: background-color 0.3s ease;\n}\n---\n\n---\nFile: ./app/auctions/page.js\n// app/auctions/page.js\n'use client';\nimport { useState } from 'react';\nimport { useFlareROI } from '@/lib/auctions/flare';\nimport { useAscendantROI } from '@/lib/auctions/ascendant';\n\nexport default function Auctions() {\n  const [selectedAuction, setSelectedAuction] = useState(null);\n\n  const {\n    auctionFlarePerTitanX,\n    marketFlarePerTitanX,\n    flarePerX28,\n    roi: flareROI,\n    isLoading: flareLoading,\n    hasError: flareError,\n    status: flareStatus,\n  } = useFlareROI();\n\n  const {\n    auctionAscendantPerTitanX,\n    marketAscendantPerTitanX,\n    ascendPerDragonX,\n    marketDragonXPerTitanX,\n    roi: ascendantROI,\n    isLoading: ascendantLoading,\n    hasError: ascendantError,\n    status: ascendantStatus,\n  } = useAscendantROI();\n\n  const auctions = [\n    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },\n    { name: 'Flare', url: 'https://www.flare.win/auction' },\n    { name: 'Shogun', url: 'https://app.shogun.win/auction' },\n    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },\n    { name: 'Volt', url: 'https://app.volt.win/auction' },\n    { name: 'Vyper', url: 'https://app.vyper.win/auction' },\n    { name: 'Flux', url: 'https://app.flux.win/auction' },\n    { name: 'Phoenix', url: 'https://app.phoenix.win/' },\n    { name: 'Turbo', url: 'https://app.turbo.win/auction' },\n    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },\n  ];\n\n  const openModal = (auction) => {\n    setSelectedAuction(auction);\n  };\n\n  const closeModal = () => {\n    setSelectedAuction(null);\n  };\n\n  const handleBackgroundClick = (e) => {\n    if (e.target === e.currentTarget) {\n      closeModal();\n    }\n  };\n\n  const renderAuctionDetails = (auction) => {\n    if (auction.name === 'Flare') {\n      if (flareLoading) {\n        return <p className="text-gray-300 text-sm">Loading Flare data...</p>;\n      }\n      if (flareError || flareStatus === 'error') {\n        return <p className="text-red-500 text-sm">Error loading Flare data.</p>;\n      }\n      if (flareStatus === 'no_data') {\n        return <p className="text-gray-300 text-sm">No Flare auction data available.</p>;\n      }\n      return (\n        <div className="text-gray-300 text-sm mt-2">\n          <p><strong>ROI:</strong> {flareROI ? `${flareROI}%` : 'N/A'}</p>\n          <p><strong>Auction Rate:</strong> {auctionFlarePerTitanX ? `${auctionFlarePerTitanX.toFixed(2)} FLARE/TX` : 'N/A'}</p>\n          <p><strong>Market Rate:</strong> {marketFlarePerTitanX ? `${marketFlarePerTitanX.toFixed(2)} FLARE/TX` : 'N/A'}</p>\n          <p><strong>FLARE/X28:</strong> {flarePerX28 ? `${flarePerX28.toFixed(2)} FLARE/X28` : 'N/A'}</p>\n        </div>\n      );\n    }\n    if (auction.name === 'Ascendant') {\n      if (ascendantLoading) {\n        return <p className="text-gray-300 text-sm">Loading Ascendant data...</p>;\n      }\n      if (ascendantError || ascendantStatus === 'error') {\n        return <p className="text-red-500 text-sm">Error loading Ascendant data.</p>;\n      }\n      if (ascendantStatus === 'no_data') {\n        return <p className="text-gray-300 text-sm">No Ascendant auction data available.</p>;\n      }\n      return (\n        <div className="text-gray-300 text-sm mt-2">\n          <p><strong>ROI:</strong> {ascendantROI ? `${ascendantROI}%` : 'N/A'}</p>\n          <p><strong>Auction Rate:</strong> {auctionAscendantPerTitanX ? `${auctionAscendantPerTitanX.toFixed(2)} ASCEND/TX` : 'N/A'}</p>\n          <p><strong>Market Rate:</strong> {marketAscendantPerTitanX ? `${marketAscendantPerTitanX.toFixed(2)} ASCEND/TX` : 'N/A'}</p>\n          <p><strong>ASCEND/DRAGONX:</strong> {ascendPerDragonX ? `${ascendPerDragonX.toFixed(2)} ASCEND/DRAGONX` : 'N/A'}</p>\n          <p><strong>DRAGONX/TITANX:</strong> {marketDragonXPerTitanX ? `${marketDragonXPerTitanX.toFixed(2)} DRAGONX/TX` : 'N/A'}</p>\n        </div>\n      );\n    }\n    return null; // No details for other auctions\n  };\n\n  return (\n    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">\n      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">\n        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">\n          TitanX Ecosystem Auctions\n        </h1>\n        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">\n          Explore the current auctions in the TitanX ecosystem. Click to view.\n        </p>\n        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">\n          {auctions.map((auction) => (\n            <div\n              key={auction.name}\n              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 \n                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"\n            >\n              <button\n                onClick={() => openModal(auction)}\n                className="text-blue-400 hover:text-blue-300 text-xl font-semibold \n                  transition-colors duration-200 text-left w-full"\n              >\n                {auction.name} Auction\n              </button>\n              <p className="text-gray-400 mt-2 text-sm truncate">\n                <a\n                  href={auction.url}\n                  target="_blank"\n                  rel="noopener noreferrer"\n                  className="hover:underline"\n                  onClick={(e) => e.preventDefault()}\n                >\n                  {auction.url}\n                </a>\n              </p>\n              {renderAuctionDetails(auction)}\n            </div>\n          ))}\n        </div>\n      </main>\n\n      {selectedAuction && (\n        <div\n          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"\n          onClick={handleBackgroundClick}\n        >\n          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">\n            <button\n              onClick={closeModal}\n              className="absolute top-2 right-2 text-gray-300 hover:text-white \n                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"\n            >\n              ✕\n            </button>\n            <iframe\n              src={selectedAuction.url}\n              className="w-full h-full border-0 rounded"\n              title={`${selectedAuction.name} Auction`}\n              allowFullScreen\n              onError={(e) => {\n                console.error(`Failed to load iframe for ${selectedAuction.name}: ${selectedAuction.url}`, e);\n              }}\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n---\n\n---\nFile: ./app/nft-contracts.js\n// app/nft-contracts.js\nexport const nftContracts = {\n  element280: {\n    name: "Element 280",\n    symbol: "ELMNT",\n    address: "0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9",\n    deploymentBlock: "20945304",\n    tiers: {\n      1: { name: "Common", multiplier: 10, allocation: "100000000000000000000000000" },\n      2: { name: "Common Amped", multiplier: 12, allocation: "100000000000000000000000000" },\n      3: { name: "Rare", multiplier: 100, allocation: "1000000000000000000000000000" },\n      4: { name: "Rare Amped", multiplier: 120, allocation: "1000000000000000000000000000" },\n      5: { name: "Legendary", multiplier: 1000, allocation: "10000000000000000000000000000" },\n      6: { name: "Legendary Amped", multiplier: 1200, allocation: "10000000000000000000000000000" },\n    },\n    description:\n      "Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.",\n  },\n  element369: {\n    name: "Element 369",\n    symbol: "E369",\n    address: "0x024D64E2F65747d8bB02dFb852702D588A062575",\n