-e 
---
File: ./jsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"]
    }
  }
}
-e 
---
File: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};-e 
---
File: ./.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI-e 
---
File: ./app/layout.js
// app/layout.js
import './layout.css';
import { Inter } from 'next/font/google';
import Navbar from '../components/Navbar';
import ClientProvider from './ClientProvider';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={`${inter.className} bg-gray-900 text-white`}>
        <ClientProvider>
          <Navbar />
          <main className="pt-16">{children}</main>
        </ClientProvider>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-gray-300">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
// app/nft/layout.js
'use client';
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(contractDetails).map((key) => ({
    name: contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    const cachedData = getCache(contractKey);
    if (cachedData) {
      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
      return cachedData;
    }

    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }

    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];
    let allHolders = [];
    let totalTokens = 0;
    let totalLockedAscendant = 0;
    let totalShares = 0;
    let toDistributeDay8 = 0;
    let toDistributeDay28 = 0;
    let toDistributeDay90 = 0;
    let pendingRewards = 0;
    let page = 0;
    let totalPages = Infinity;

    try {
      while (page < totalPages) {
        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);
        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
          signal: AbortSignal.timeout(30000),
        });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);
        }
        const json = await res.json();
        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders.length}`);
        allHolders = allHolders.concat(json.holders || []);
        totalTokens = json.totalTokens || totalTokens;
        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
        totalShares = json.totalShares || totalShares;
        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
        pendingRewards = json.pendingRewards || pendingRewards;
        totalPages = json.totalPages || 1;
        page++;
        if (!json.holders || json.holders.length === 0) break;
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
      });
      let uniqueHolders = Array.from(uniqueHoldersMap.values());
      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      if (contractKey === 'ascendantNFT') {
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1; // Retain API rank
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      }

      const result = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalMultiplierSum,
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);
      const errorResult = { holders: [], totalTokens: 0, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map(nft => 
        fetchCollectionData(nft.apiKey)
          .then(data => ({ apiKey: nft.apiKey, data }))
          .catch(err => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            // Include totalShares for Ascendant to calculate Shares %
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`px-6 py-2 rounded-md font-semibold transition-colors ${
              selectedChain === chain.id
                ? 'bg-orange-500 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) => (
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            )
          ))}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl">{children}</div>
    </div>
  );
}-e 
---
File: ./app/nft/page.js
// app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="text-center text-white">
      <p className="text-lg">Select a collection above to view details.</p>
    </div>
  );
}-e 
---
File: ./app/nft/ETH/Stax/page.js
// app/nft/ETH/Stax/page.js
import NFTPage from '@/components/NFTPage';

export default function StaxPage() {
  return <NFTPage contractKey="staxNFT" />;
}-e 
---
File: ./app/nft/ETH/Element280/page.js
// app/nft/ETH/Element280/page.js
import NFTPage from '@/components/NFTPage';

export default function Element280Page() {
  return <NFTPage contractKey="element280" />;
}-e 
---
File: ./app/nft/ETH/Element369/page.js
// app/nft/ETH/Element369/page.js
import NFTPage from '@/components/NFTPage';
export default function Element369Page() {
  return <NFTPage contractKey="element369" />;
}-e 
---
File: ./app/nft/ETH/Ascendant/page.js
// app/nft/ETH/Ascendant/page.js
import NFTPage from '@/components/NFTPage';

export default function AscendantPage() {
  return <NFTPage contractKey="ascendantNFT" />;
}-e 
---
File: ./app/nft/BASE/E280/page.js
// app/nft/BASE/E280/page.js
import NFTPage from '@/components/NFTPage';

export default function E280Page() {
  return <NFTPage contractKey="e280" />;
}-e 
---
File: ./app/store.js
// app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          I'd like to add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              âœ•
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/api/holders/Stax/route.js
// app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, staxNFTAbi, staxVaultAbi } from '../../utils';

const contractAddress = nftContracts.staxNFT.address;
const vaultAddress = nftContracts.staxNFT.vaultAddress;
const tiersConfig = nftContracts.staxNFT.tiers;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '1000');
  const wallet = searchParams.get('wallet');

  log(`[Stax] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Stax contract or vault address missing');
    }

    const cacheKey = `stax_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL) {
      log(`[Stax] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Stax] Cache miss: ${cacheKey}`);

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Stax] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddresses = [
      '0x0000000000000000000000000000000000000000',
      '0x000000000000000000000000000000000000dead',
    ];
    const filteredOwners = ownersResponse.owners.filter(
      owner => !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
    );
    log(`[Stax] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
      ownerTokens.set(wallet, tokenIds);
    });
    log(`[Stax] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Stax] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: staxNFTAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Stax] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const wallet = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && wallet) {
          if (!holdersMap.has(wallet)) {
            holdersMap.set(wallet, {
              wallet,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier + 1).fill(0),
              claimableRewards: 0,
            });
          }
          const holder = holdersMap.get(wallet);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier] += 1;
        } else {
          log(`[Stax] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Stax] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch rewards
    const holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: staxVaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet],
      };
    });

    const totalRewardPoolCall = {
      address: vaultAddress,
      abi: staxVaultAbi,
      functionName: 'totalRewardPool',
      args: [],
    };

    log(`[Stax] Fetching rewards for ${holders.length} holders`);
    const [rewardResults, totalRewardPoolResult] = await Promise.all([
      rewardCalls.length ? batchMulticall(rewardCalls) : [],
      batchMulticall([totalRewardPoolCall]),
    ]);

    const totalRewardPool = totalRewardPoolResult[0]?.status === 'success'
      ? Number(totalRewardPoolResult[0].result) / 1e18
      : 0;

    holders.forEach((holder, i) => {
      if (rewardResults[i]?.status === 'success' && rewardResults[i].result) {
        const [, totalPayout] = rewardResults[i].result;
        holder.claimableRewards = Number(totalPayout) / 1e18;
        log(
          `[Stax] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Claimable=${holder.claimableRewards.toFixed(4)}, ` +
          `Tokens=${ownerTokens.get(holder.wallet).length}`
        );
        if (holder.claimableRewards === 0) {
          log(`[Stax] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.claimableRewards = 0;
        log(`[Stax] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardResults[i]?.error || 'Unknown'}`);
      }
      holder.percentage = totalRewardPool ? (holder.claimableRewards / totalRewardPool) * 100 : 0;
      holder.rank = 0;
    });

    // Calculate ranks
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
    });

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Stax] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Stax] Error: ${error.message}`);
    console.error('[Stax] Error stack:', error.stack);
    let status = 500;
    let message = 'Failed to fetch Stax data';
    if (error.message.includes('Rate limit')) {
      status = 429;
      message = 'Alchemy rate limit exceeded';
    }
    return NextResponse.json({ error: message, details: error.message }, { status });
  }
}-e 
---
File: ./app/api/holders/E280/route.js
// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Data not available yet');
  return NextResponse.json({ message: 'E280 data will go live after deployment' });
}-e 
---
File: ./app/api/holders/Element280/route.js
// app/api/holders/Element280/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, nftAbi, element280VaultAbi, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers, vaultAddresses } from '@/app/nft-contracts';

let cache = {};
let tokenCache = new Map();

async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 1000) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getAllHolders: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`getAllHolders start: ${contractName} at ${contractAddress}, page=${page}, pageSize=${pageSize}`);
  const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true });
  log(`${contractName} - Raw owners count: ${ownersResponse.owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = ownersResponse.owners.filter(
    owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`${contractName} - Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    const wallet = owner.ownerAddress.toLowerCase();
    owner.tokenBalances.forEach(tb => {
      const tokenId = BigInt(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`${contractName} - Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`${contractName} - Paginated token IDs: ${paginatedTokenIds.length} (start=${start}, end=${end})`);

  const ownerOfCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = [];
  paginatedTokenIds.forEach((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    if (owner && owner !== burnAddress) {
      validTokenIds.push(tokenId);
      tokenCache.set(cacheKey, owner);
    } else {
      tokenCache.set(cacheKey, null);
    }
  });
  log(`${contractName} - Valid token IDs after ownerOf: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    log(`${contractName} - No valid tokens found in this page`);
    return { holders: [], totalTokens, page, pageSize, totalPages: Math.ceil(allTokenIds.length / pageSize) };
  }

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  log(`${contractName} - Starting tier multicall for ${tierCalls.length} tokens`);
  const tierResults = await batchMulticall(tierCalls);
  log(`${contractName} - Tier results length: ${tierResults.length}`);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalNftsHeld = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractName} - Undefined tier result at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tokenId = validTokenIds[i];
      const wallet = tokenOwnerMap.get(tokenId);
      const tier = Number(result.result);
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);

      if (tier >= 1 && tier <= maxTier) {
        if (!holdersMap.has(wallet)) {
          holdersMap.set(wallet, {
            wallet,
            total: 0,
            multiplierSum: 0,
            tiers: Array(maxTier + 1).fill(0),
            claimableRewards: 0,
          });
        }

        const holder = holdersMap.get(wallet);
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
        holder.tiers[tier] += 1;
        totalNftsHeld += 1;
      } else {
        log(`${contractName} - Invalid tier ${tier} for token ${tokenId}`);
      }
    } else {
      log(`${contractName} - Failed tier fetch at index ${i}, tokenId: ${validTokenIds[i]}`);
    }
  });
  log(`${contractName} - Total NFTs held after tier check: ${totalNftsHeld}`);

  // Fetch claimable rewards from vault
  const holders = Array.from(holdersMap.values());
  const rewardCalls = holders.map(holder => ({
    address: vaultAddresses.element280,
    abi: element280VaultAbi,
    functionName: 'claimableReward',
    args: [holder.wallet],
  }));

  const rewardResults = await batchMulticall(rewardCalls);
  holders.forEach((holder, i) => {
    if (rewardResults[i]?.status === 'success') {
      holder.claimableRewards = Number(rewardResults[i].result);
    } else {
      holder.claimableRewards = 0;
      log(`${contractName} - Failed to fetch rewards for ${holder.wallet}`);
    }
  });

  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holders.forEach(holder => {
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum / 10;
  });

  const sortFn = (a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total;
  holders.sort(sortFn);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders,
    totalTokens,
    page,
    pageSize,
    totalPages: Math.ceil(allTokenIds.length / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractName} - Final holders count: ${holders.length}`);
  return result;
}

async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    log(`getHolderData: Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  log(`getHolderData start: wallet=${wallet}, contract=${contractAddress}`);
  const nfts = await alchemy.nft.getNftsForOwner(wallet, { contractAddresses: [contractAddress] });
  log(`${contractAddress} - Initial NFTs for ${wallet}: ${nfts.totalCount}`);

  if (nfts.totalCount === 0) return null;

  const walletLower = wallet.toLowerCase();
  const tokenIds = nfts.ownedNfts.map(nft => BigInt(nft.tokenId));
  const ownerOfCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  const ownerOfResults = await batchMulticall(ownerOfCalls);
  const validTokenIds = tokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    tokenCache.set(cacheKey, owner);
    return owner === walletLower;
  });
  log(`${contractAddress} - Valid token IDs for ${wallet}: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) return null;

  const tierCalls = validTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: nftAbi,
    functionName: 'getNftTier',
    args: [tokenId],
  }));

  const tierResults = await batchMulticall(tierCalls);
  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;

  tierResults.forEach((result, i) => {
    if (!result) {
      log(`${contractAddress} - Undefined tier result for wallet ${wallet} at index ${i}, tokenId: ${validTokenIds[i]}`);
      return;
    }
    if (result.status === 'success') {
      const tier = Number(result.result);
      const tokenId = validTokenIds[i];
      const cacheKey = `${contractAddress}-${tokenId}-tier`;
      tokenCache.set(cacheKey, tier);
      if (tier >= 1 && tier <= maxTier) {
        tiersArray[tier] += 1;
        total += 1;
        multiplierSum += tiers[tier]?.multiplier || 0;
      }
    }
  });
  log(`${contractAddress} - Total NFTs for ${wallet} after tier check: ${total}`);

  const rewardResult = await client.readContract({
    address: vaultAddresses.element280,
    abi: element280VaultAbi,
    functionName: 'claimableReward',
    args: [walletLower],
  });
  const claimableRewards = Number(rewardResult) || 0;

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 1000);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const percentage = totalMultiplierSum > 0 ? (multiplierSum / totalMultiplierSum) * 100 : 0;
  const holder = allHolders.holders.find(h => h.wallet === walletLower) || { rank: allHolders.holders.length + 1 };

  const result = {
    wallet: walletLower,
    rank: holder.rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum / 10,
    percentage,
    tiers: tiersArray,
    claimableRewards,
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`${contractAddress} - Final data for ${wallet}: total=${total}, multiplierSum=${multiplierSum}, claimableRewards=${claimableRewards}`);
  return result;
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  const address = contractAddresses['element280'];
  if (!address) {
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers['element280']);
      return NextResponse.json({ holders: holderData ? [holderData] : [] });
    }

    const result = await getAllHolders(address, contractTiers['element280'], page, pageSize);
    return NextResponse.json(result);
  } catch (error) {
    log(`Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element369/route.js
// app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, element369VaultAbi, element369Abi } from '../../utils';

const contractAddress = nftContracts.element369.address;
const vaultAddress = nftContracts.element369.vaultAddress;
const tiersConfig = nftContracts.element369.tiers;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '1000');
  const wallet = searchParams.get('wallet');

  log(`[Element369] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Element369 contract or vault address missing');
    }

    const cacheKey = `element369_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL) {
      log(`[Element369] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Element369] Cache miss: ${cacheKey}`);

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Element369] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const filteredOwners = ownersResponse.owners.filter(
      owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
    );
    log(`[Element369] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
      ownerTokens.set(wallet, tokenIds);
    });
    log(`[Element369] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Element369] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element369Abi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Element369] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const wallet = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && wallet) {
          if (!holdersMap.has(wallet)) {
            holdersMap.set(wallet, {
              wallet,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier + 1).fill(0),
              infernoRewards: 0,
              fluxRewards: 0,
              e280Rewards: 0,
            });
          }
          const holder = holdersMap.get(wallet);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier] += 1;
        } else {
          log(`[Element369] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Element369] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch current cycle for debugging
    let currentCycle = 0;
    try {
      currentCycle = await client.readContract({
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getCurrentE369Cycle',
      });
      log(`[Element369] Current cycle: ${currentCycle}`);
    } catch (error) {
      log(`[Element369] Error fetching cycle: ${error.message}`);
    }

    // Fetch rewards
    const holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet, false], // isBacking: false for claimable rewards
      };
    });

    log(`[Element369] Fetching rewards for ${holders.length} holders`);
    const rewardsResults = await batchMulticall(rewardCalls);

    holders.forEach((holder, i) => {
      if (rewardsResults[i]?.status === 'success' && rewardsResults[i].result) {
        const [availability, burned, infernoPool, fluxPool, e280Pool] = rewardsResults[i].result;
        holder.infernoRewards = Number(infernoPool) / 1e18;
        holder.fluxRewards = Number(fluxPool) / 1e18;
        holder.e280Rewards = Number(e280Pool) / 1e18;
        log(
          `[Element369] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Inferno=${holder.infernoRewards.toFixed(4)}, ` +
          `Flux=${holder.fluxRewards.toFixed(4)}, ` +
          `E280=${holder.e280Rewards.toFixed(4)}, ` +
          `Tokens=${availability.length}, Burned=${burned.filter(b => b).length}, ` +
          `Availability=${availability.join(',')}`
        );
        if (holder.infernoRewards === 0 && holder.fluxRewards === 0 && holder.e280Rewards === 0) {
          log(`[Element369] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.infernoRewards = 0;
        holder.fluxRewards = 0;
        holder.e280Rewards = 0;
        log(`[Element369] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardsResults[i]?.error || 'Unknown'}`);
      }
      holder.displayMultiplierSum = holder.multiplierSum;
      holder.percentage = 0;
      holder.rank = 0;
    });

    // Calculate percentages and ranks
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holders.forEach((holder, index) => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.rank = index + 1;
      holder.displayMultiplierSum = holder.multiplierSum;
    });

    // Sort holders
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Element369] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Element369] Error: ${error.message}`);
    console.error('[Element369] Error stack:', error.stack);
    return NextResponse.json({ error: 'Failed to fetch Element369 data' }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers } from '@/app/nft-contracts';
import { formatUnits, getAddress } from 'viem';
import { v4 as uuidv4 } from 'uuid';
import ascendantABI from '../../../../abi/ascendantNFT.json';

let cache = {};
let tokenCache = new Map();

// Utility to sanitize BigInt values by converting them to strings
function sanitizeBigInt(obj, path = 'root') {
  if (typeof obj === 'bigint') {
    log(`[BigInt Detected] at ${path}: ${obj}`);
    return obj.toString();
  }
  if (Array.isArray(obj)) {
    return obj.map((item, i) => sanitizeBigInt(item, `${path}[${i}]`));
  }
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value, `${path}.${key}`);
    }
    return sanitized;
  }
  return obj;
}

// Utility to safely log objects containing BigInt
function safeLog(obj) {
  return JSON.stringify(obj, (key, value) => 
    typeof value === 'bigint' ? value.toString() : value
  );
}

// Utility to safely serialize response objects containing BigInt
function safeSerialize(obj) {
  return JSON.parse(JSON.stringify(obj, (key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  ));
}

// Fetch data for all holders with pagination
async function getAllHolders(page = 0, pageSize = 1000, requestId = '') {
  const contractAddress = contractAddresses.ascendantNFT;
  const tiers = contractTiers.ascendantNFT;
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    log(`[${requestId}] Returning cached data for ${cacheKey}`);
    return cache[cacheKey].data;
  }

  log(`[${requestId}] Fetching holders, page=${page}, pageSize=${pageSize}`);
  if (!contractAddress || !tiers) {
    throw new Error('Missing contract address or tiers');
  }

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        log(`[${requestId}] Retry ${i + 1}/${attempts} failed: ${error.message}`);
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  let owners = [];
  let pageKey = null;
  do {
    const response = await retry(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        block: 'latest',
        withTokenBalances: true,
        pageKey,
      })
    );
    owners = owners.concat(response.owners);
    pageKey = response.pageKey;
  } while (pageKey);
  log(`[${requestId}] Raw owners count: ${owners.length}`);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = owners.filter(
    (owner) => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
  );
  log(`[${requestId}] Filtered live owners count: ${filteredOwners.length}`);

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach((owner) => {
    const wallet = getAddress(owner.ownerAddress);
    owner.tokenBalances.forEach((tb) => {
      const tokenId = Number(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });
  log(`[${requestId}] Total tokens checked: ${totalTokens}`);

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);
  log(`[${requestId}] Paginated token IDs: ${paginatedTokenIds.length}`);

  const ownerOfCalls = paginatedTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'ownerOf',
    args: [BigInt(tokenId)],
  }));

  const ownerOfResults = await retry(() => batchMulticall(ownerOfCalls));
  const validTokenIds = paginatedTokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    return owner && owner !== burnAddress;
  });
  log(`[${requestId}] Valid token IDs: ${validTokenIds.length}`);

  if (validTokenIds.length === 0) {
    const result = {
      holders: [],
      totalTokens,
      totalLockedAscendant: 0,
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = validTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = validTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));

  log(`[${requestId}] Tier calls: ${safeLog(tierCalls.map((c) => ({ tokenId: c.args[0], functionName: c.functionName })))}`);
  log(`[${requestId}] Record calls: ${safeLog(recordCalls.map((c) => ({ tokenId: c.args[0], functionName: c.functionName })))}`);

  const [rawTierResults, rawRecordResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults, 'tierResults');
  const recordResults = sanitizeBigInt(rawRecordResults, 'recordResults');

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));
  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));
  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));
  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  const walletTokenIds = new Map();
  validTokenIds.forEach((tokenId) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!walletTokenIds.has(wallet)) {
      walletTokenIds.set(wallet, []);
    }
    walletTokenIds.get(wallet).push(tokenId);
  });

  const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'batchClaimableAmount',
    args: [tokenIds.map((id) => BigInt(id))],
  }));

  log(`[${requestId}] Claimable calls: ${safeLog(claimableCalls.map((c) => ({ wallet, tokenIds: c.args[1] })))}`);

  const rawClaimableResults = await retry(() => batchMulticall(claimableCalls));
  const claimableResults = sanitizeBigInt(rawClaimableResults, 'claimableResults');

  validTokenIds.forEach((tokenId, i) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!holdersMap.has(wallet)) {
      holdersMap.set(wallet, {
        wallet,
        total: 0,
        multiplierSum: 0,
        tiers: Array(maxTier + 1).fill(0),
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: 0,
        pendingDay28: 0,
        pendingDay90: 0,
        claimableRewards: 0,
      });
    }
    const holder = holdersMap.get(wallet);

    const tierResult = tierResults[i];
    if (tierResult?.status === 'success' && Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
      const tier = Number(tierResult.result[1]);
      if (tier >= 1 && tier <= maxTier) {
        holder.tiers[tier] += 1;
        holder.total += 1;
        holder.multiplierSum += tiers[tier]?.multiplier || 0;
      }
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const shares = parseFloat(formatUnits(sharesRaw, 18));
      const lockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      holder.shares += shares;
      holder.lockedAscendant += lockedAscendant;
      totalLockedAscendant += lockedAscendant;
    }
  });

  let claimableIndex = 0;
  for (const [wallet, tokenIds] of walletTokenIds.entries()) {
    const holder = holdersMap.get(wallet);
    if (holder && claimableResults[claimableIndex]?.status === 'success') {
      const claimableRaw = claimableResults[claimableIndex].result || '0';
      holder.claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
    } else {
      holder.claimableRewards = 0;
    }
    claimableIndex++;
  }

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach((holder) => {
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders: sanitizeBigInt(holders),
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  return result;
}

// Fetch data for a specific wallet
async function getHolderData(wallet, requestId = '') {
  const contractAddress = contractAddresses.ascendantNFT;
  const tiers = contractTiers.ascendantNFT;
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();

  delete cache[cacheKey]; // Force fresh data

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  const checksummedWallet = getAddress(wallet);
  log(`[${requestId}] getHolderData start: wallet=${checksummedWallet}, contract=${contractAddress}`);

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        log(`[${requestId}] Retry ${i + 1}/${attempts} failed: ${error.message}`);
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  const nfts = await retry(() =>
    alchemy.nft.getNftsForOwner(checksummedWallet, { contractAddresses: [contractAddress] })
  );
  log(`[${requestId}] ${contractAddress} - Initial NFTs for ${checksummedWallet}: ${nfts.totalCount}`);

  if (nfts.totalCount === 0) return null;

  const walletLower = checksummedWallet.toLowerCase();
  const tokenIds = nfts.ownedNfts.map((nft) => Number(nft.tokenId));
  log(`[${requestId}] ${contractAddress} - Token IDs for ${checksummedWallet}: [${tokenIds.join(', ')}]`);

  const ownerOfCalls = tokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'ownerOf',
    args: [BigInt(tokenId)],
  }));

  const ownerOfResultsRaw = await retry(() => batchMulticall(ownerOfCalls));
  const ownerOfResults = sanitizeBigInt(ownerOfResultsRaw, 'ownerOfResults');

  const validTokenIds = tokenIds.filter((tokenId, i) => {
    const owner = ownerOfResults[i]?.status === 'success' && ownerOfResults[i].result.toLowerCase();
    const cacheKey = `${contractAddress}-${tokenId}-owner`;
    tokenCache.set(cacheKey, owner);
    return owner === walletLower;
  });
  log(`[${requestId}] ${contractAddress} - Valid token IDs for ${checksummedWallet}: [${validTokenIds.join(', ')}]`);

  if (validTokenIds.length === 0) return null;

  const tierCalls = validTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = validTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));
  const claimableCall = [
    {
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'batchClaimableAmount',
      args: [validTokenIds.map((id) => BigInt(id))],
    },
  ];

  log(`[${requestId}] Tier calls: ${safeLog(tierCalls.map((c) => ({ tokenId: c.args[0], functionName: c.functionName })))}`);
  log(`[${requestId}] Record calls: ${safeLog(recordCalls.map((c) => ({ tokenId: c.args[0], functionName: c.functionName })))}`);
  log(`[${requestId}] Claimable call: ${safeLog(claimableCall)}`);

  const [rawTierResults, rawRecordResults, rawClaimableResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
    retry(() => batchMulticall(claimableCall)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults, 'tierResults');
  const recordResults = sanitizeBigInt(rawRecordResults, 'recordResults');
  const claimableResults = sanitizeBigInt(rawClaimableResults, 'claimableResults');

  let claimableRewards = 0;
  if (claimableResults[0]?.status === 'success') {
    const claimableRaw = claimableResults[0].result || '0';
    claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
  }

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;
  let shares = 0;
  let lockedAscendant = 0;

  validTokenIds.forEach((tokenId, i) => {
    const tierResult = tierResults[i];
    if (tierResult?.status === 'success' && Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
      const tier = Number(tierResult.result[1]);
      if (tier >= 1 && tier <= maxTier) {
        tiersArray[tier] += 1;
        total += 1;
        multiplierSum += tiers[tier]?.multiplier || 0;
      }
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const tokenShares = parseFloat(formatUnits(sharesRaw, 18));
      const tokenLockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      shares += tokenShares;
      lockedAscendant += tokenLockedAscendant;
    }
  });

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  const totalMultiplierSum = multiplierSum || 1;
  const percentage = (multiplierSum / totalMultiplierSum) * 100;
  const rank = 1;

  const result = {
    wallet: checksummedWallet,
    rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum,
    percentage,
    tiers: tiersArray,
    shares,
    lockedAscendant,
    pendingDay8: shares * pendingRewardPerShareDay8,
    pendingDay28: shares * pendingRewardPerShareDay28,
    pendingDay90: shares * pendingRewardPerShareDay90,
    claimableRewards,
  };

  const sanitizedResult = sanitizeBigInt(result);
  cache[cacheKey] = { timestamp: now, data: sanitizedResult };
  return sanitizedResult;
}

// API endpoint handler
export async function GET(request) {
  const requestId = uuidv4();
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '1000', 10);
  log(`[${requestId}] Received request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (wallet) {
      const holderData = await getHolderData(wallet, requestId);
      const response = { holders: holderData ? [holderData] : [] };
      return NextResponse.json(safeSerialize(response));
    }

    const result = await getAllHolders(page, pageSize, requestId);
    return NextResponse.json(safeSerialize(result));
  } catch (error) {
    console.error(`[${requestId}] [PROD_ERROR] AscendantNFT API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils.js
// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

// Shared cache for routes that import it
export const cache = {};

// Import all ABI JSON files using @ notation
import staxNFTAbi from '@/abi/staxNFT.json';
import element369Abi from '@/abi/element369.json';
import element369VaultAbi from '@/abi/element369Vault.json';
import staxVaultAbi from '@/abi/staxVault.json';
import ascendantNFTAbi from '@/abi/ascendantNFT.json';
import element280Abi from '@/abi/element280.json';
import element280VaultAbi from '@/abi/element280Vault.json';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(
    process.env.ETH_RPC_URL ||
    `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`
  ),
});

// Generic NFT ABI for common functions
export const nftAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNftTier(uint256 tokenId) view returns (uint8)',
]);

// Ascendant NFT ABI with specific functions
export const ascendantAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)',
  'function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)',
  'function totalShares() view returns (uint256)',
  'function toDistribute(uint8 pool) view returns (uint256)',
  'function rewardPerShare() view returns (uint256)',
  'error NonExistentToken(uint256 tokenId)',
]);

// Export all ABIs
export {
  staxNFTAbi,
  element369Abi,
  element369VaultAbi,
  staxVaultAbi,
  ascendantNFTAbi,
  element280Abi,
  element280VaultAbi,
};

export const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export function log(message) {
  console.log(`[PROD_DEBUG] ${message}`);
}

export async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);
    } catch (error) {
      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);
      results.push(...batch.map(() => ({ status: 'failure', result: null })));
    }
  }
  log(`batchMulticall: Completed with ${results.length} results`);
  return results;
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              âœ•
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/nft-contracts.js
// app/nft-contracts.js
export const nftContracts = {
  element280: {
    name: "Element 280",
    symbol: "ELMNT",
    address: "0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9",
    vaultAddress: "0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97",
    deploymentBlock: "20945304",
    tiers: {
      1: { name: "Common", multiplier: 10, allocation: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 12, allocation: "100000000000000000000000000" },
      3: { name: "Rare", multiplier: 100, allocation: "1000000000000000000000000000" },
      4: { name: "Rare Amped", multiplier: 120, allocation: "1000000000000000000000000000" },
      5: { name: "Legendary", multiplier: 1000, allocation: "10000000000000000000000000000" },
      6: { name: "Legendary Amped", multiplier: 1200, allocation: "10000000000000000000000000000" },
    },
    description:
      "Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.",
  },
  element369: {
    name: "Element 369",
    symbol: "E369",
    address: "0x024D64E2F65747d8bB02dFb852702D588A062575",
    vaultAddress: "0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5",
    deploymentBlock: "21224418",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      3: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
    },
    description:
      "Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.",
  },
  staxNFT: {
    name: "Stax",
    symbol: "STAX",
    address: "0x74270Ca3a274B4dbf26be319A55188690CACE6E1",
    vaultAddress: "0x5D27813C32dD705404d1A78c9444dAb523331717",
    deploymentBlock: "21452667",
    tiers: {
      1: { name: "Common", multiplier: 1, price: "100000000000000000000000000" },
      2: { name: "Common Amped", multiplier: 1.2, price: "100000000000000000000000000", amplifier: "10000000000000000000000000" },
      3: { name: "Common Super", multiplier: 1.4, price: "100000000000000000000000000", amplifier: "20000000000000000000000000" },
      4: { name: "Common LFG", multiplier: 2, price: "100000000000000000000000000", amplifier: "50000000000000000000000000" },
      5: { name: "Rare", multiplier: 10, price: "1000000000000000000000000000" },
      6: { name: "Rare Amped", multiplier: 12, price: "1000000000000000000000000000", amplifier: "100000000000000000000000000" },
      7: { name: "Rare Super", multiplier: 14, price: "1000000000000000000000000000", amplifier: "200000000000000000000000000" },
      8: { name: "Rare LFG", multiplier: 20, price: "1000000000000000000000000000", amplifier: "500000000000000000000000000" },
      9: { name: "Legendary", multiplier: 100, price: "10000000000000000000000000000" },
      10: { name: "Legendary Amped", multiplier: 120, price: "10000000000000000000000000000", amplifier: "1000000000000000000000000000" },
      11: { name: "Legendary Super", multiplier: 140, price: "10000000000000000000000000000", amplifier: "2000000000000000000000000000" },
      12: { name: "Legendary LFG", multiplier: 200, price: "10000000000000000000000000000", amplifier: "5000000000000000000000000000" },
    },
    description:
      "Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.",
  },
  ascendantNFT: {
    name: "Ascendant",
    symbol: "ASCNFT",
    address: "0x9da95c32c5869c84ba2c020b5e87329ec0adc97f",
    deploymentBlock: "21112535",
    tiers: {
      1: { name: "Tier 1", price: "7812500000000000000000", multiplier: 1.01 },
      2: { name: "Tier 2", price: "15625000000000000000000", multiplier: 1.02 },
      3: { name: "Tier 3", price: "31250000000000000000000", multiplier: 1.03 },
      4: { name: "Tier 4", price: "62500000000000000000000", multiplier: 1.04 },
      5: { name: "Tier 5", price: "125000000000000000000000", multiplier: 1.05 },
      6: { name: "Tier 6", price: "250000000000000000000000", multiplier: 1.06 },
      7: { name: "Tier 7", price: "500000000000000000000000", multiplier: 1.07 },
      8: { name: "Tier 8", price: "1000000000000000000000000", multiplier: 1.08 },
    },
    description:
      "Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.",
  },
  e280: {
    name: "E280",
    symbol: "E280",
    address: null,
    deploymentBlock: null,
    tiers: {},
    description: "E280 NFTs on BASE chain. Contract not yet deployed.",
  },
};

export const contractAddresses = {
  element280: nftContracts.element280.address,
  element369: nftContracts.element369.address,
  staxNFT: nftContracts.staxNFT.address,
  ascendantNFT: nftContracts.ascendantNFT.address,
  e280: nftContracts.e280.address,
};

export const vaultAddresses = {
  element280: nftContracts.element280.vaultAddress,
  element369: nftContracts.element369.vaultAddress,
  staxNFT: nftContracts.staxNFT.vaultAddress,
  e280: null,
};

export const deploymentBlocks = {
  element280: nftContracts.element280.deploymentBlock,
  element369: nftContracts.element369.deploymentBlock,
  staxNFT: nftContracts.staxNFT.deploymentBlock,
  ascendantNFT: nftContracts.ascendantNFT.deploymentBlock,
  e280: nftContracts.e280.deploymentBlock,
};

export const contractTiers = {
  element280: nftContracts.element280.tiers,
  element369: nftContracts.element369.tiers,
  staxNFT: nftContracts.staxNFT.tiers,
  ascendantNFT: nftContracts.ascendantNFT.tiers,
  e280: nftContracts.e280.tiers,
};

export const contractDetails = {
  element280: {
    name: nftContracts.element280.name,
    totalTokens: 8209,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element280',
    rewardToken: 'ELMNT',
  },
  element369: {
    name: nftContracts.element369.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element369',
  },
  staxNFT: {
    name: nftContracts.staxNFT.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Stax',
    rewardToken: 'X28',
  },
  ascendantNFT: {
    name: nftContracts.ascendantNFT.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Ascendant',
    rewardToken: 'DRAGONX',
  },
  e280: {
    name: nftContracts.e280.name,
    totalTokens: 0,
    pageSize: 1000,
    apiEndpoint: '/api/holders/E280',
    rewardToken: 'E280',
  },
};

export function getContractDetails(contractName) {
  return nftContracts[contractName] || null;
}-e 
---
File: ./app/ClientProvider.js
// app/ClientProvider.js
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 60 * 1000, // 30 minutes
      cacheTime: 60 * 60 * 1000, // 1 hour
    },
  },
});

export default function ClientProvider({ children }) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.

const config = {
  plugins: ["tailwindcss"],
};
export default config;-e 
---
File: ./next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
-e 
---
File: ./element369.json
{"holders":[{"wallet":"0x074ade052e2a8eed3db1df9e6717dd869f65c396","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x07df2bb35b3030681e6f9fb97113a83d250556bc","total":4,"tier1":2,"tier2":2,"tier3":0,"multiplierSum":22,"claimableRewards":46292138.40829844},{"wallet":"0x08b30ade63c9c1ec3f64a5a84d040eb6823e6870","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x0b73c8ed83f333963e5c6604226fd38ee97a90da","total":2,"tier1":1,"tier2":1,"tier3":0,"multiplierSum":11,"claimableRewards":7090397.3025417505},{"wallet":"0x1184fa9a6f73a5789c0f0d0618c31e0fe7ef459b","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":3251599.1256541354},{"wallet":"0x1279acc327ed3faf54e7d781714a6a8817561ca8","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x1488bad8ad5e0127b0eb1e027b29fdaca36effb8","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x15702443110894b26911b913b17ea4931f803b02","total":9,"tier1":0,"tier2":9,"tier3":0,"multiplierSum":90,"claimableRewards":58012341.56625068},{"wallet":"0x15918cee59ba7a0eba6682eb196d012a53ff5c67","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":1289163.145916682},{"wallet":"0x15e5b9b9adf208cc7ca3ae1e6a49506eb5f397dd","total":15,"tier1":0,"tier2":0,"tier3":15,"multiplierSum":1500,"claimableRewards":3597998988.4106555},{"wallet":"0x16b2e0235ddd6392c89eca4f46a49ef31c45c5e6","total":10,"tier1":10,"tier2":0,"tier3":0,"multiplierSum":10,"claimableRewards":23986659.922737703},{"wallet":"0x1797078687b258264d74158cacfafafc71fc69a3","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x18c7217ed83aa7b90a31e89b9f09396b6b643791","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":4502854.101741881},{"wallet":"0x18cb4b36f62f850130a8f2fea97ae7ae3c063f04","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":1289163.145916682},{"wallet":"0x19bd6fd9350a7cb5f125c7794ecd7f8bff2f9e08","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x1de5546abef2c1defa935e2805abbdde28e0284d","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":325159.9125654135},{"wallet":"0x2000b50a35b4eeb93b5b917cbf9dc39a5c12ab0a","total":20,"tier1":20,"tier2":0,"tier3":0,"multiplierSum":20,"claimableRewards":51481537.37620102},{"wallet":"0x201f12fb8ec9267f117fb9cd96edf5926343e6d7","total":5,"tier1":0,"tier2":5,"tier3":0,"multiplierSum":50,"claimableRewards":0},{"wallet":"0x207d757dfa34dc4351359c207ef1c7b005de4304","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x2131558f15fdc7311f170f57fcbdfe4508557d3b","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x23c5669195333480e932dee3ef839b44dbb1acea","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x24fa1c5c8b5a760ea5de41f8f24f915e5c09ea44","total":4,"tier1":0,"tier2":4,"tier3":0,"multiplierSum":40,"claimableRewards":25783262.91833364},{"wallet":"0x24fe402b9acbaf6e55435175b5293a3cafb04389","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2398665.9922737703},{"wallet":"0x280bd4e997041c2f36882bdf96dbe732b4eab595","total":4,"tier1":4,"tier2":0,"tier3":0,"multiplierSum":4,"claimableRewards":10296307.475240204},{"wallet":"0x29562ff51bee7f8aaf65a75c0a1e0d49554b2bc8","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":3251599.1256541354},{"wallet":"0x29ad2d067e4caa2bc9d77b34cd28ff5a9f62ff29","total":1,"tier1":0,"tier2":0,"tier3":1,"multiplierSum":100,"claimableRewards":32515991.256541356},{"wallet":"0x2b7961940b7d0ad43063da152a5b0723e259a048","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x2c7ea35e9345b9a0ac44a83f62e205dcf5d0fd6a","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x2cd85dafb0cd6f875fac1493f25e643e93e69447","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":4208376.218936222},{"wallet":"0x2d0df0d6d1109dfb2a162b2c7033c5691a755873","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":4797331.984547541},{"wallet":"0x33c6eeb8aabf6c06daa23a5dbb67e92a4f2d9e0a","total":2,"tier1":1,"tier2":1,"tier3":0,"multiplierSum":11,"claimableRewards":28314845.556910563},{"wallet":"0x36a28f814ded9260de31115ffd72c6f05b8d9fc3","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0x3b71c69a41620dcb22ed6d082ed0fd89d496b976","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x3b754dfae801a9576ff17e231b76aeaecc06c0fa","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x3c0ac3432ab66815ec48ee010e4957121c15b2eb","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x3ec874cfd9c65a407bf5d5a8a56beb3b7f04f823","total":2,"tier1":0,"tier2":0,"tier3":2,"multiplierSum":200,"claimableRewards":128916314.59166819},{"wallet":"0x4523fa431d98e96c7e3d13801f15725c27715f41","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x46b8fb50d0c3f611ed387d0d590a63b504c6e245","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":12870384.344050255},{"wallet":"0x47755ba9cbeacf6540973b8500110ee2805a016e","total":2,"tier1":1,"tier2":1,"tier3":0,"multiplierSum":11,"claimableRewards":23146069.20414922},{"wallet":"0x4b653ad55051fab223b8d319ce70e45e7fa3ab9b","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x4cf6468958b88ce3bd2ddf5151e05cf62411503f","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x4fdb40c2f44f008e7364a1838421a50d356e6621","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x50ef162381f8ae276774d71b4afb18dcee7e33b2","total":10,"tier1":8,"tier2":2,"tier3":0,"multiplierSum":28,"claimableRewards":58917267.06510711},{"wallet":"0x54e762b675d1af95f1942a6674a71252ea8330bd","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x5626eb3647a9ec3e401565077d702f43f42910ac","total":2,"tier1":0,"tier2":2,"tier3":0,"multiplierSum":20,"claimableRewards":47973319.845475405},{"wallet":"0x59494c2a49cd0cdda00249111c9dd75537879cf7","total":18,"tier1":16,"tier2":2,"tier3":0,"multiplierSum":36,"claimableRewards":86351975.72185573},{"wallet":"0x598761631c4988dcc0bdffcacb0c9d1126a80efa","total":7,"tier1":7,"tier2":0,"tier3":0,"multiplierSum":7,"claimableRewards":11591208.873329371},{"wallet":"0x5d23a593503d4c1a35f096eb78a02ecba40a0fee","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x5d58c390def5a94296cabc757af8ac1ccb772adc","total":1,"tier1":0,"tier2":0,"tier3":1,"multiplierSum":100,"claimableRewards":32515991.256541356},{"wallet":"0x5e8604ff72d33389c57a9468e44f81bde23f7c94","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x5f57c8a32bc5777a206415155755afa73580c0e4","total":10,"tier1":0,"tier2":10,"tier3":0,"multiplierSum":100,"claimableRewards":257407686.8810051},{"wallet":"0x62eb3e90696d302f80c48d859943f0e244823436","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":12870384.344050255},{"wallet":"0x64091bd5d902cb53a2e55fdc154507dd8c709f82","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":325159.9125654135},{"wallet":"0x64cbecbe87b47183e4dba6069f0e0aa4b723f255","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":644581.572958341},{"wallet":"0x665643ac490d23906b23c75f834950f22b9c45f3","total":10,"tier1":10,"tier2":0,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x665d4026156e916dd31f620fd6fb60a6ef5848e8","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":6445815.72958341},{"wallet":"0x675009487742d62303903b0f4fb13ee284ba5037","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":10520940.547340553},{"wallet":"0x67c9e7a2fc4d7840b7bf8e25b2640888a47f429e","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x6821860c20de7cf4f295b80df598d6e679dd8efc","total":3,"tier1":0,"tier2":3,"tier3":0,"multiplierSum":30,"claimableRewards":9754797.376962405},{"wallet":"0x689dcb6c727a18c60c42635f99c78bef67367ff0","total":6,"tier1":0,"tier2":6,"tier3":0,"multiplierSum":60,"claimableRewards":126251286.56808665},{"wallet":"0x69da7529ac98d70c0658d24f54417c7af6a9cc40","total":3,"tier1":0,"tier2":3,"tier3":0,"multiplierSum":30,"claimableRewards":63125643.28404333},{"wallet":"0x6a23a4b38915d6d7788bb81bd22ad84c5e3004de","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x6a88c1f502978fedec1defee9cf54b1bdb3e698a","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x6bda870f3fb123851d1e25cac281e5f688736a99","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0x6be39541d91d87a14f09f3df5aa5ba6155a363e0","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x6fd2cd66a7e30ab28b8b000e3283d6c544098c14","total":2,"tier1":1,"tier2":1,"tier3":0,"multiplierSum":11,"claimableRewards":28314845.556910563},{"wallet":"0x702cf959881819191f847b2f059a28320dd50e7a","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":7722230.606430153},{"wallet":"0x7094072f97d04c0784ffb95677c52c605254152d","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":7546819.729893872},{"wallet":"0x7220febb3a3646764ca4785b5027656e61b18c45","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":3222907.864791705},{"wallet":"0x75c26b2b971ac740d2029575384e82017ecf9062","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":650319.825130827},{"wallet":"0x76d946a2484c3aac891cc0a7dd45cc0dac37250b","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x788de1d847807aae0f252bffb5ab5d523b5f9346","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x7ad04d23bd7dcf336ad10bcf3ea0287147faab0c","total":10,"tier1":6,"tier2":4,"tier3":0,"multiplierSum":46,"claimableRewards":118407535.96526234},{"wallet":"0x7afd8c5ba9f879883a25b89ad3d789f7d0ecf755","total":4,"tier1":4,"tier2":0,"tier3":0,"multiplierSum":4,"claimableRewards":10296307.475240204},{"wallet":"0x7b75ec8a8ca7305fb8da026090c23ad9c59c2c16","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x7bd36fe9dbff09192fca6f58d5c59d40918564b0","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x7eb49ad9f25b65d855f54e1d6d1606819efa2c69","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x840cbb88524e20d03ccdfacc733feb3264ef488d","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":325159.9125654135},{"wallet":"0x849290aa3e6d094592eaf2fac5eb2b2f02d0baea","total":5,"tier1":0,"tier2":5,"tier3":0,"multiplierSum":50,"claimableRewards":32229078.647917047},{"wallet":"0x862412dd2d38f649041828e19aa2546f3e4d5ddf","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2104188.109468111},{"wallet":"0x86b1f6bde3578f7c588566b3cd88f2eab3bd61a9","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0x88ba35dfd256572e16883fd560d19dbbd8dcce1a","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x8974b7db7c46be6268a673e3cb56d94885d8119e","total":4,"tier1":2,"tier2":2,"tier3":0,"multiplierSum":22,"claimableRewards":14180794.605083501},{"wallet":"0x8bd442a100994dd97b3be7ad70bf61ccdbcbadc0","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0x9504e8488576bce17332e831a4e4a1521e1fcdca","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":12870384.344050255},{"wallet":"0x95e8331343cfb7b3eb2e0113b6277dac040adf73","total":5,"tier1":5,"tier2":0,"tier3":0,"multiplierSum":5,"claimableRewards":10520940.547340553},{"wallet":"0x965dfc3694c1bafec7cef645d7a17167c9a5f0f4","total":6,"tier1":5,"tier2":1,"tier3":0,"multiplierSum":15,"claimableRewards":38611153.03215077},{"wallet":"0x96701f02ed9e694cc6d68d234402b058e75b0b85","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":325159.9125654135},{"wallet":"0x9731a290bbe838791241ad52a446113b86d9d613","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x9809aa9a91436a33cf7872614515d1385577bd9a","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":3251599.1256541354},{"wallet":"0x988a7057c33702127174ae3671a87d9c0c9fdf50","total":3,"tier1":0,"tier2":3,"tier3":0,"multiplierSum":30,"claimableRewards":19337447.188750226},{"wallet":"0x989b0536bdd5b3c899f2d584f7f28221f8117607","total":10,"tier1":10,"tier2":0,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0x994493864b3d7f4f91f836ec9cf78c1e08e824b5","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":6445815.72958341},{"wallet":"0x9a5e3cd9c92c455a1fcf4acd52068f1dd3ec3998","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":23986659.922737703},{"wallet":"0x9b6dd6c69f56170ea58323a9f4529c90d1d44c75","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":4208376.218936222},{"wallet":"0x9c725f41e1732198e5f5066cb09185229a5de0a0","total":8,"tier1":8,"tier2":0,"tier3":0,"multiplierSum":8,"claimableRewards":19189327.938190162},{"wallet":"0x9f54598363ada26717656c11dcc66a96bf856b5a","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0x9f99dc994579ff651da914d6537fa8075da4b4ae","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xa1f02d0d3d61e13b03acda31d866181563d50b59","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0xa2aa01003994cc5f14ad6aec263b7258553616c7","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0xa2e4c81fb652f3808a0dbe4cede5a8695d47043e","total":1,"tier1":0,"tier2":0,"tier3":1,"multiplierSum":100,"claimableRewards":257407686.8810051},{"wallet":"0xac4ae84fbea2273d6975f7490138b28553436457","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":6312564.3284043325},{"wallet":"0xb0d8213af23697e0618629e35f5104ff3e8a9a67","total":10,"tier1":10,"tier2":0,"tier3":0,"multiplierSum":10,"claimableRewards":25740768.68810051},{"wallet":"0xb18c4a028dbedadf06e9e43ee7721f29a3b3ba92","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":23986659.922737703},{"wallet":"0xb24f7dd5ae191fc5a820f5f13e144a132267552f","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":6445815.72958341},{"wallet":"0xb3f59a0f954287789836cab5823c79b66920c309","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2398665.9922737703},{"wallet":"0xb5935d95c4af1fcf55cf76ed92dd0b11f6887148","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0xb73c95ca93126cc12b79ccc46b3c0cd4ba099edf","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xbd4713eab86029180770da858df526c7f2a51d2b","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2104188.109468111},{"wallet":"0xc2394863c15a59a22f5cede33ff80cd63fc2931a","total":12,"tier1":11,"tier2":1,"tier3":0,"multiplierSum":21,"claimableRewards":13536213.032125158},{"wallet":"0xc4ed347542a610b05f428aeebd60e8414a44a530","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xc64bf6400fcc7c936d50909540f5492a57e50849","total":2,"tier1":1,"tier2":1,"tier3":0,"multiplierSum":11,"claimableRewards":26385325.915011473},{"wallet":"0xc72c0ca472b0f9cba977a8cfe7ddced82a5b860e","total":2,"tier1":0,"tier2":2,"tier3":0,"multiplierSum":20,"claimableRewards":51481537.37620102},{"wallet":"0xc790c7562b900099299bd7f55ea1459f7ac53aa9","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":1933744.7188750228},{"wallet":"0xca77c25fd53e21e35c4bc9cf90a66df624b3f0ca","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":6445815.72958341},{"wallet":"0xca8e2b82dc328afe6bc6aef78bc04a20b9cc9f33","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":325159.9125654135},{"wallet":"0xcbd34554e073075ebbfa351c2861481b94e0a931","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xcca784a4e59e9cf4553dc817f106ce118eab7933","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xce173b5b683e4360137bed8a317ba4dece6118f8","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xcfed607e64e7ac5b7094b670984ccbed2110842e","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xd05d5cfa1c0343374063da83a979ac8a31afe731","total":8,"tier1":8,"tier2":0,"tier3":0,"multiplierSum":8,"claimableRewards":20592614.95048041},{"wallet":"0xd742d93f3bedd4cce9eec48336e16944d0dac0da","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":7195997.97682131},{"wallet":"0xd7c8d0f774b696c4bfb12cc8e97b232deeeede18","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":21041881.094681107},{"wallet":"0xdaddabbfda8de64c97a3f57d825d26700008020d","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0xdc5ffb80c482a2d9b15905f71a1d348c2a6e0efe","total":9,"tier1":6,"tier2":3,"tier3":0,"multiplierSum":36,"claimableRewards":86351975.72185573},{"wallet":"0xdd70bb443b234f22a233f5f5a0bced5039d1d44b","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":0},{"wallet":"0xe18ff21f1edea06b7af475a1b7a81baeef8ffc25","total":1,"tier1":0,"tier2":0,"tier3":1,"multiplierSum":100,"claimableRewards":257407686.8810051},{"wallet":"0xe3ac7ff8156091b17b6609467d20d1f7979d1d77","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":644581.572958341},{"wallet":"0xe40d6b27456eff65fa4cb34d948365a5fba356ea","total":1,"tier1":0,"tier2":1,"tier3":0,"multiplierSum":10,"claimableRewards":23986659.922737703},{"wallet":"0xeb19ccbbba733b739f310db4d0f5354183cfe5f9","total":3,"tier1":3,"tier2":0,"tier3":0,"multiplierSum":3,"claimableRewards":7722230.606430153},{"wallet":"0xeff28fb26fea5e543b112fbd78852499ab16cee7","total":2,"tier1":2,"tier2":0,"tier3":0,"multiplierSum":2,"claimableRewards":5148153.737620102},{"wallet":"0xf11682da4d21cea7435b0e0fa8f1152ccaef373a","total":8,"tier1":8,"tier2":0,"tier3":0,"multiplierSum":8,"claimableRewards":18663119.654628698},{"wallet":"0xf419f10bcd7137382284ebc7ae59243e29f4a909","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051},{"wallet":"0xf84cd420b3472f8bec338a9028c58e796fd563c1","total":1,"tier1":0,"tier2":0,"tier3":1,"multiplierSum":100,"claimableRewards":210418810.9468111},{"wallet":"0xf97d9cd83963c27a52a081a8d2e1f1701e4d546d","total":12,"tier1":2,"tier2":10,"tier3":0,"multiplierSum":102,"claimableRewards":65747320.44175077},{"wallet":"0xfe310fd984bfea016e2eff725005b2b6f37057ff","total":1,"tier1":1,"tier2":0,"tier3":0,"multiplierSum":1,"claimableRewards":2574076.868810051}],"totalTokens":415,"totalMultiplierSum":3610,"page":0,"pageSize":1000,"totalPages":1}-e 
---
File: ./README.md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
-e 
---
File: ./components/HolderTable.js
// components/HolderTable.js
import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';
  const isElement369 = contract === 'element369';
  const isStax = contract === 'staxNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isElement369 ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                  </>
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                )}
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {Object.keys(contractTiers[contract] || {})
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                          {contractTiers[contract][tier].name}
                        </th>
                      ))}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isElement369 ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  )}
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isElement369 ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
              </>
            ) : (
              <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            )}
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(tiers)
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {tiers[tier].name}
                    </th>
                  ))}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total}</td>
              {isElement369 ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.infernoRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.fluxRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.e280Rewards).toLocaleString()}
                  </td>
                </>
              ) : (
                <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {(isStax || isAscendant
                    ? Math.floor(holder.claimableRewards)
                    : holder.claimableRewards.toFixed(2)
                  ).toLocaleString()}
                </td>
              )}
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : '0.00'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.shares).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay8).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay28).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay90).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.percentage.toFixed(2)}%</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.multiplierSum.toFixed(2)}</td>
                  {Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                        {holder.tiers?.[tier] || 0}
                      </td>
                    ))}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/LoadingIndicator.js
// app/components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status }) {
  return (
    <div className="flex flex-col items-center justify-center gap-3 animate-fade-in w-full flex-1">
      <motion.svg
        className="h-6 w-6 sm:h-8 sm:w-8 text-blue-400"
        animate={{ scale: [1, 1.2, 1], rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </motion.svg>
      <p className="text-sm sm:text-base text-gray-300">{status}</p>
    </div>
  );
}-e 
---
File: ./components/NFTPage.js
// components/NFTPage.js
'use client';
import { useState, useEffect } from 'react';
import HolderTable from '@/components/HolderTable';
import LoadingIndicator from '@/components/LoadingIndicator';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTPage({ contractKey }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const { name, apiEndpoint, rewardToken } = contractDetails[contractKey] || {};
  const { getCache, setCache } = useNFTStore();
  const isElement369 = contractKey === 'element369';
  const isStax = contractKey === 'staxNFT';

  useEffect(() => {
    async function fetchAllHolders() {
      if (!apiEndpoint) {
        setError('Invalid contract configuration');
        setLoading(false);
        return;
      }

      if (contractKey === 'e280') {
        setData({ holders: [], totalTokens: 0, message: 'E280 data not available yet' });
        setCache(contractKey, { holders: [], totalTokens: 0, message: 'E280 data not available yet' });
        setLoading(false);
        return;
      }

      const cachedData = getCache(contractKey);
      if (cachedData) {
        setData(cachedData);
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        console.log(`[NFTPage] Starting fetch for ${contractKey} at ${apiEndpoint}`);
        let allHolders = [];
        let totalTokens = 0;
        let totalLockedAscendant = 0;
        let totalShares = 0;
        let toDistributeDay8 = 0;
        let toDistributeDay28 = 0;
        let toDistributeDay90 = 0;
        let pendingRewards = 0;
        let totalClaimableRewards = 0;
        let totalInfernoRewards = 0;
        let totalFluxRewards = 0;
        let totalE280Rewards = 0;
        let page = 0;
        let totalPages = Infinity;
        const pageSize = 1000;

        while (page < totalPages) {
          let attempts = 0;
          const maxAttempts = 3;
          let success = false;

          while (attempts < maxAttempts && !success) {
            try {
              console.log(`[NFTPage] Fetching ${contractKey} page ${page}`);
              const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
                signal: AbortSignal.timeout(30000),
              });
              if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
              }

              const json = await res.json();
              allHolders = allHolders.concat(json.holders || []);
              totalTokens = json.totalTokens || totalTokens;
              totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
              totalShares = json.totalShares || totalShares;
              toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
              toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
              toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
              pendingRewards = json.pendingRewards || pendingRewards;
              totalPages = json.totalPages || 1;
              page++;
              success = true;
              if (!json.holders || json.holders.length === 0) break;
            } catch (err) {
              attempts++;
              if (err.message.includes('Rate limit') || err.name === 'TimeoutError') {
                console.log(`[NFTPage] Retry ${attempts} for ${contractKey} page ${page} due to: ${err.message}`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
              } else {
                throw err;
              }
            }
          }
          if (!success) {
            throw new Error(`Failed to fetch page ${page} for ${contractKey} after ${maxAttempts} attempts`);
          }
        }

        const uniqueHoldersMap = new Map();
        allHolders.forEach(holder => {
          if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
        });
        const uniqueHolders = Array.from(uniqueHoldersMap.values());
        console.log(`[NFTPage] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

        const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
        if (isElement369) {
          totalInfernoRewards = uniqueHolders.reduce((sum, h) => sum + (h.infernoRewards || 0), 0);
          totalFluxRewards = uniqueHolders.reduce((sum, h) => sum + (h.fluxRewards || 0), 0);
          totalE280Rewards = uniqueHolders.reduce((sum, h) => sum + (h.e280Rewards || 0), 0);
        } else {
          totalClaimableRewards = uniqueHolders.reduce((sum, h) => sum + (h.claimableRewards || 0), 0);
        }
        if (!totalTokens && uniqueHolders.length > 0) {
          totalTokens = uniqueHolders.reduce((sum, h) => sum + (h.total || 0), 0);
        }

        if (contractKey === 'ascendantNFT') {
          uniqueHolders.forEach((holder, index) => {
            holder.rank = index + 1;
            holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          });
        } else {
          uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
          uniqueHolders.forEach((holder, index) => {
            holder.rank = index + 1;
            holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          });
        }

        const fetchedData = {
          holders: uniqueHolders,
          totalTokens,
          totalLockedAscendant,
          totalShares,
          toDistributeDay8,
          toDistributeDay28,
          toDistributeDay90,
          pendingRewards,
          totalMultiplierSum,
          totalClaimableRewards,
          totalInfernoRewards,
          totalFluxRewards,
          totalE280Rewards,
        };

        setCache(contractKey, fetchedData);
        setData(fetchedData);
        setLoading(false);
      } catch (err) {
        console.error('[NFTPage] Fetch Error:', err);
        setError(`Failed to load ${name} holders: ${err.message}. Try refreshing later (Alchemy limit possible).`);
        setLoading(false);
      }
    }

    fetchAllHolders();
  }, [contractKey, name, apiEndpoint, getCache, setCache]);

  const renderSummary = () => {
    if (!data) return null;

    const totalMultiplierSum = data.totalMultiplierSum || 0;
    const totalTokens = data.totalTokens || 0;
    const totalClaimableRewards = data.totalClaimableRewards || 0;
    const totalInfernoRewards = data.totalInfernoRewards || 0;
    const totalFluxRewards = data.totalFluxRewards || 0;
    const totalE280Rewards = data.totalE280Rewards || 0;

    if (contractKey === 'ascendantNFT') {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Locked Ascendant: <span className="font-bold">{(data.totalLockedAscendant || 0).toLocaleString()}</span></p>
          <p>Total Shares: <span className="font-bold">{(data.totalShares || 0).toLocaleString()}</span></p>
          <p>Total Claimable Rewards: <span className="font-bold">{Math.floor(totalClaimableRewards).toLocaleString()} DRAGONX</span></p>
          <p>Total Pending DragonX Rewards: <span className="font-bold">{(data.pendingRewards || 0).toLocaleString()}</span></p>
          <p>Pending DAY8 Rewards: <span className="font-bold">{(data.toDistributeDay8 || 0).toLocaleString()}</span></p>
          <p>Pending DAY28 Rewards: <span className="font-bold">{(data.toDistributeDay28 || 0).toLocaleString()}</span></p>
          <p>Pending DAY90 Rewards: <span className="font-bold">{(data.toDistributeDay90 || 0).toLocaleString()}</span></p>
        </>
      );
    } else if (isElement369) {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Multiplier Sum: <span className="font-bold">{totalMultiplierSum.toLocaleString()}</span></p>
          <p>Total Claimable Inferno Rewards: <span className="font-bold">{Math.floor(totalInfernoRewards).toLocaleString()}</span></p>
          <p>Total Claimable Flux Rewards: <span className="font-bold">{Math.floor(totalFluxRewards).toLocaleString()}</span></p>
          <p>Total Claimable E280 Rewards: <span className="font-bold">{Math.floor(totalE280Rewards).toLocaleString()}</span></p>
        </>
      );
    } else {
      return (
        <>
          <h2 className="text-2xl font-semibold mb-2">Summary</h2>
          <p>Number of Unique Wallets Holding NFTs: <span className="font-bold">{data.holders.length}</span></p>
          <p>Total Number of Active NFTs in Circulation: <span className="font-bold">{totalTokens.toLocaleString()}</span></p>
          <p>Total Multiplier Sum: <span className="font-bold">{totalMultiplierSum.toLocaleString()}</span></p>
          <p>
            Total Claimable Rewards:{' '}
            <span className="font-bold">
              {Math.floor(totalClaimableRewards).toLocaleString()} {rewardToken || ''}
            </span>
          </p>
        </>
      );
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      {loading ? (
        <LoadingIndicator status={`Loading all ${name || 'contract'} holders...`} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : data.message ? (
        <p className="text-gray-400 text-lg">{data.message}</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractKey}
            loading={loading}
            totalShares={contractKey === 'ascendantNFT' ? data.totalShares : undefined}
          />
          <div className="mt-8">
            <h3 className="text-xl font-bold mb-2">Raw Data:</h3>
            <pre className="text-sm bg-gray-700 p-4 rounded max-h-96 overflow-auto border-2 border-red-500">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
// components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import HolderTable from './HolderTable';

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      onClick={handleBackgroundClick}
    >
      <motion.div
        className="bg-gray-800 text-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Search Results for {searchAddress}</h2>
          <button onClick={closeModal} className="text-gray-400 hover:text-white text-2xl">
            &times;
          </button>
        </div>

        {Object.keys(searchResult).length === 0 ? (
          <p className="text-gray-400">No results available.</p>
        ) : (
          Object.entries(searchResult).map(([contract, data]) => (
            <div key={contract} className="mb-6">
              <h3 className="text-xl font-semibold mb-2">{contractDetails[contract]?.name || contract}</h3>
              {data === null ? (
                <p className="text-gray-400">Wallet not found in this collection.</p>
              ) : data.error ? (
                <p className="text-red-500">Error: {data.error}</p>
              ) : data.message ? (
                <p className="text-gray-400">{data.message}</p>
              ) : (
                <HolderTable
                  holders={[data]}
                  contract={contract}
                  loading={false}
                  totalShares={data.totalShares} // Pass totalShares from search result
                />
              )}
            </div>
          ))
        )}
      </motion.div>
    </div>
  );
}

const contractDetails = {
  element280: { name: 'Element280' },
  element369: { name: 'Element369' },
  staxNFT: { name: 'Stax' },
  ascendantNFT: { name: 'Ascendant' },
  e280: { name: 'E280' },
};-e 
---
File: ./components/Navbar.jsx
// components/Navbar.jsx
'use client';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10 },
    visible: { opacity: 1, y: 0 },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0 },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining' },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [
            { name: 'E280', href: '/nft/BASE/E280' },
          ],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="bg-gradient-to-r from-gray-900 to-gray-800 text-white p-4 sticky top-0 z-50 shadow-md">
      <div className="max-w-7xl mx-auto flex justify-between items-center">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="text-2xl font-bold"
        >
          <Link href="/">TitanXUtils</Link>
        </motion.div>

        {/* Desktop Links */}
        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative text-gray-300 hover:text-white transition-colors duration-200 group"
              whileHover={{ scale: 1.1, color: '#f97316' }}
              whileTap={{ scale: 0.95 }}
            >
              {item.external ? (
                <a href={item.href} target="_blank" rel="noopener noreferrer">
                  {item.name}
                </a>
              ) : (
                <Link href={item.href}>{item.name}</Link>
              )}
              {item.subItems && (
                <motion.div
                  className="absolute left-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg hidden group-hover:block"
                  variants={dropdownVariants}
                  initial="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white">
                        {subItem.href ? (
                          <Link href={subItem.href}>{subItem.name}</Link>
                        ) : (
                          <span>{subItem.name}</span>
                        )}
                      </div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <div
                              key={nestedItem.name}
                              className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white"
                            >
                              <Link href={nestedItem.href}>
                                {nestedItem.name}
                              </Link>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
        </div>

        {/* Mobile Menu Toggle */}
        <button
          className="md:hidden p-2 focus:outline-none"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      {/* Mobile Menu */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="block py-2 px-4 text-gray-300 hover:text-white hover:bg-gray-700 rounded-md transition-colors duration-200"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      {item.name}
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2">
                              {subItem.href ? (
                                <Link href={subItem.href} onClick={() => setIsOpen(false)}>
                                  {subItem.name}
                                </Link>
                              ) : (
                                <span>{subItem.name}</span>
                              )}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <div
                                    key={nestedItem.name}
                                    className="py-2"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    <Link href={nestedItem.href}>
                                      {nestedItem.name}
                                    </Link>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : item.external ? (
                  <a
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={() => setIsOpen(false)}
                  >
                    {item.name}
                  </a>
                ) : (
                  <Link href={item.href} onClick={() => setIsOpen(false)}>
                    {item.name}
                  </Link>
                )}
              </motion.div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts-e 
---
File: ./package.json
{
  "name": "titanx-utility",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.72.1",
    "@wagmi/connectors": "^5.7.11",
    "alchemy-sdk": "^3.5.6",
    "dotenv": "^16.5.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.3",
    "next": "14.2.15",
    "pino-pretty": "^13.0.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-virtualized": "^9.22.6",
    "uuid": "^11.1.0",
    "viem": "^2.24.3",
    "wagmi": "^2.14.15",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^3.4.17"
  }
}
-e 
---
File: ./scripts/verifyContracts.js
// scripts/verifyContracts.js
import { tokenContracts } from '../app/token_contracts.js';

Object.entries(tokenContracts).forEach(([key, config]) => {
  console.log(`${key}: ${config.address}`);
});-e 
---
File: ./scripts/ascendantWalletData.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { formatUnits } from 'viem';
import { Alchemy, Network } from 'alchemy-sdk';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import path from 'path';
import { contractTiers } from '../app/nft-contracts.js';

// Load ABI from file
const ascendantAbi = JSON.parse(await fs.readFile(path.join(process.cwd(), 'abi', 'ascendantNFT.json'), 'utf8'));

// Load .env.local
dotenv.config({ path: '.env.local' });

const ALCHEMY_API_KEY = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || 'rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI';
const WALLET_ADDRESS = '0xf98f0ee190d9f2e6531e226933f1e47a2890cbda';
const CONTRACT_ADDRESS = '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f';
const SAVE_TO_FILE = false; // Set to true to save output

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`, { timeout: 10000 }),
});

const alchemy = new Alchemy({
  apiKey: ALCHEMY_API_KEY,
  network: Network.ETH_MAINNET,
});

async function retry(fn, attempts = 5, delay = 2000) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      console.log(`Retry ${i + 1}/${attempts} failed: ${error.message}`);
      if (i === attempts - 1) throw error;
      await new Promise(res => setTimeout(res, delay * (i + 1)));
    }
  }
}

async function getTokenIds(wallet) {
  let tokenIds = [];

  // 1. Check balanceOf
  console.log('Checking balanceOf for wallet:', wallet);
  try {
    const balance = await retry(() =>
      client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'balanceOf',
        args: [wallet],
      })
    );
    console.log(`Balance of NFTs: ${balance}`);
    if (Number(balance) === 0) {
      console.log('No NFTs owned according to balanceOf.');
      return [];
    }
  } catch (error) {
    console.error(`balanceOf failed: ${error.message}`);
  }

  // 2. Try getNftsForOwner
  console.log('Querying getNftsForOwner for wallet:', wallet);
  try {
    const nfts = await retry(() =>
      alchemy.nft.getNftsForOwner(wallet, {
        contractAddresses: [CONTRACT_ADDRESS],
        withTokenBalances: true,
      })
    );
    console.log('getNftsForOwner response:', {
      totalCount: nfts.totalCount,
      ownedNfts: nfts.ownedNfts.map(nft => ({ tokenId: nft.tokenId, contract: nft.contract.address })),
    });
    tokenIds = nfts.ownedNfts.map(nft => BigInt(nft.tokenId));
  } catch (error) {
    console.error(`getNftsForOwner failed: ${error.message}`);
  }

  if (tokenIds.length > 0) {
    console.log('Found tokens (getNftsForOwner):', tokenIds.map(id => id.toString()));
    return tokenIds;
  }

  // 3. Try getOwnersForContract
  console.log('getNftsForOwner returned empty; trying getOwnersForContract');
  try {
    const owners = await retry(() =>
      alchemy.nft.getOwnersForContract(CONTRACT_ADDRESS, { withTokenBalances: true })
    );
    console.log('getOwnersForContract response:', {
      ownersCount: owners.owners.length,
      walletData: owners.owners.find(owner => owner.ownerAddress.toLowerCase() === wallet.toLowerCase()),
    });
    const walletData = owners.owners.find(
      owner => owner.ownerAddress.toLowerCase() === wallet.toLowerCase()
    );
    tokenIds = walletData ? walletData.tokenBalances.map(tb => BigInt(tb.tokenId)) : [];
    console.log('getOwnersForContract tokens:', tokenIds.map(id => id.toString()));
  } catch (error) {
    console.error(`getOwnersForContract failed: ${error.message}`);
  }

  if (tokenIds.length > 0) {
    console.log('Found tokens (getOwnersForContract):', tokenIds.map(id => id.toString()));
    return tokenIds;
  }

  // 4. Scan ownerOf
  console.log('Alchemy calls failed; scanning ownerOf for token IDs 1â€“10000...');
  try {
    const maxTokenId = 10000;
    const batchSize = 500;
    let allTokenIds = [];
    for (let start = 1; start <= maxTokenId; start += batchSize) {
      const end = Math.min(start + batchSize - 1, maxTokenId);
      console.log(`Scanning token IDs ${start}â€“${end}...`);
      const ownerOfCalls = Array.from({ length: end - start + 1 }, (_, i) => ({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'ownerOf',
        args: [BigInt(start + i)],
      }));
      const ownerOfResults = await retry(() => client.multicall({ contracts: ownerOfCalls }));
      const batchTokenIds = ownerOfResults
        .map((result, i) => {
          if (result.status === 'success' && result.result.toLowerCase() === wallet.toLowerCase()) {
            return BigInt(start + i);
          }
          return null;
        })
        .filter(id => id !== null);
      allTokenIds = [...allTokenIds, ...batchTokenIds];
    }
    console.log('ownerOf scan tokens:', allTokenIds.map(id => id.toString()));
    tokenIds = allTokenIds;
  } catch (error) {
    console.error(`ownerOf scan failed: ${error.message}`);
  }

  return tokenIds;
}

async function getWalletData() {
  console.log(`Fetching data for wallet ${WALLET_ADDRESS} on contract ${CONTRACT_ADDRESS} (chain: ${client.chain.name})...`);

  // 1. Fetch token IDs
  let tokenIds = [];
  try {
    tokenIds = await retry(() => getTokenIds(WALLET_ADDRESS));
    console.log(`Total NFTs: ${tokenIds.length}`);
    console.log(`Token IDs: [${tokenIds.join(', ')}]`);
  } catch (error) {
    console.error(`Failed to fetch token IDs: ${error.message}`);
    return;
  }

  if (tokenIds.length === 0) {
    console.log('No NFTs found.');
    return;
  }

  // 2. Validate ownership
  const ownerOfCalls = tokenIds.map(tokenId => ({
    address: CONTRACT_ADDRESS,
    abi: ascendantAbi,
    functionName: 'ownerOf',
    args: [tokenId],
  }));

  let validTokenIds = [];
  try {
    const ownerOfResults = await retry(() => client.multicall({ contracts: ownerOfCalls }));
    validTokenIds = tokenIds.filter((tokenId, i) => {
      const owner = ownerOfResults[i].status === 'success' && ownerOfResults[i].result.toLowerCase();
      const isValid = owner === WALLET_ADDRESS.toLowerCase();
      if (!isValid) {
        console.log(`Token ${tokenId} not owned by ${WALLET_ADDRESS}: owner=${owner}`);
      }
      return isValid;
    });
    console.log(`Valid Token IDs: [${validTokenIds.join(', ')}]`);
  } catch (error) {
    console.error(`Failed to validate ownership: ${error.message}`);
    return;
  }

  if (validTokenIds.length === 0) {
    console.log('No valid NFTs owned.');
    return;
  }

  // 3. Fetch NFT attributes and user records
  const tierCalls = validTokenIds.map(tokenId => ({
    address: CONTRACT_ADDRESS,
    abi: ascendantAbi,
    functionName: 'nftAttributes', // Try nftAttributes instead of getNFTAttribute
    args: [tokenId],
  }));
  const recordCalls = validTokenIds.map(tokenId => ({
    address: CONTRACT_ADDRESS,
    abi: ascendantAbi,
    functionName: 'userRecords',
    args: [tokenId],
  }));
  const claimableCall = [{
    address: CONTRACT_ADDRESS,
    abi: ascendantAbi,
    functionName: 'batchClaimableAmount',
    args: [validTokenIds],
  }];

  let tierResults, recordResults, claimableResult;
  try {
    [tierResults, recordResults, claimableResult] = await Promise.all([
      retry(() => client.multicall({ contracts: tierCalls })),
      retry(() => client.multicall({ contracts: recordCalls })),
      retry(() => client.multicall({ contracts: claimableCall })),
    ]);
    console.log('Raw tierResults:', tierResults);
  } catch (error) {
    console.error(`Failed to fetch contract data: ${error.message}`);
    return;
  }

  // 4. Process token data
  const tokenData = validTokenIds.map((tokenId, i) => {
    const tierResult = tierResults[i].status === 'success' && tierResults[i].result ? tierResults[i].result : [0, 8, 0]; // Fallback to tier 8
    const tier = Number(tierResult[1]); // tier is second element
    const record = recordResults[i].status === 'success' ? recordResults[i].result : [0, 0, 0, 0, 0];
    return {
      tokenId: tokenId.toString(),
      tier,
      shares: parseFloat(formatUnits(BigInt(record[0]), 18)),
      lockedAscendant: parseFloat(formatUnits(BigInt(record[1]), 18)),
      rewardDebt: parseFloat(formatUnits(BigInt(record[2]), 18)),
      startTime: Number(record[3]),
      endTime: Number(record[4]),
    };
  });

  // 5. Claimable rewards
  let claimableRewards = 0;
  let claimableRaw = 0n;
  if (claimableResult[0].status === 'success') {
    claimableRaw = BigInt(claimableResult[0].result || 0);
    claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
  } else {
    console.error(`Failed batchClaimableAmount: ${claimableResult[0].error || 'No result'}`);
  }

  // 6. Contract-level data
  let totalShares = 0, toDistributeDay8 = 0, toDistributeDay28 = 0, toDistributeDay90 = 0, rewardPerShare = 0;
  try {
    const [totalSharesRaw, day8Raw, day28Raw, day90Raw, rewardPerShareRaw] = await Promise.all([
      retry(() => client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'totalShares',
      })),
      retry(() => client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'toDistribute',
        args: [0], // POOLS.DAY_8
      })),
      retry(() => client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'toDistribute',
        args: [1], // POOLS.DAY_28
      })),
      retry(() => client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'toDistribute',
        args: [2], // POOLS.DAY_90
      })),
      retry(() => client.readContract({
        address: CONTRACT_ADDRESS,
        abi: ascendantAbi,
        functionName: 'rewardPerShare',
      })),
    ]);
    totalShares = parseFloat(formatUnits(totalSharesRaw, 18));
    toDistributeDay8 = parseFloat(formatUnits(day8Raw, 18));
    toDistributeDay28 = parseFloat(formatUnits(day28Raw, 18));
    toDistributeDay90 = parseFloat(formatUnits(day90Raw, 18));
    rewardPerShare = parseFloat(formatUnits(rewardPerShareRaw, 18));
  } catch (error) {
    console.error(`Failed to fetch contract-level data: ${error.message}`);
  }

  // 7. Calculate pending rewards and multiplier
  const totalTokenShares = tokenData.reduce((sum, t) => sum + t.shares, 0);
  const multiplierSum = tokenData.reduce((sum, t) => sum + (contractTiers.ascendantNFT[t.tier]?.multiplier || 0), 0);

  // 8. Output
  const result = {
    wallet: WALLET_ADDRESS,
    totalNfts: validTokenIds.length,
    tokenData,
    claimableRewards,
    claimableRaw: claimableRaw.toString(),
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    rewardPerShare,
    pendingDay8: totalTokenShares * (totalShares > 0 ? toDistributeDay8 / totalShares : 0),
    pendingDay28: totalTokenShares * (totalShares > 0 ? toDistributeDay28 / totalShares : 0),
    pendingDay90: totalTokenShares * (totalShares > 0 ? toDistributeDay90 / totalShares : 0),
    shares: totalTokenShares,
    lockedAscendant: tokenData.reduce((sum, t) => sum + t.lockedAscendant, 0),
    multiplierSum,
  };

  console.log('\n=== Wallet Data ===');
  console.log(`Wallet: ${result.wallet}`);
  console.log(`Total NFTs: ${result.totalNfts}`);
  console.log(`Shares: ${result.shares}`);
  console.log(`Locked Ascendant: ${result.lockedAscendant}`);
  console.log(`Multiplier Sum: ${result.multiplierSum}`);
  console.log(`Claimable Rewards: ${result.claimableRewards} DragonX`);
  console.log(`Claimable Raw: ${result.claimableRaw}`);
  console.log(`Pending Day 8: ${result.pendingDay8}`);
  console.log(`Pending Day 28: ${result.pendingDay28}`);
  console.log(`Pending Day 90: ${result.pendingDay90}`);
  console.log(`\nContract Data:`);
  console.log(`Total Shares: ${result.totalShares}`);
  console.log(`To Distribute Day 8: ${result.toDistributeDay8}`);
  console.log(`To Distribute Day 28: ${result.toDistributeDay28}`);
  console.log(`To Distribute Day 90: ${result.toDistributeDay90}`);
  console.log(`Reward Per Share: ${result.rewardPerShare}`);
  console.log(`\nToken Details:`);
  console.table(tokenData);

  // Optional: Save to file
  if (SAVE_TO_FILE) {
    await fs.writeFile('ascendant_wallet_data.json', JSON.stringify(result, null, 2));
    console.log('Saved to ascendant_wallet_data.json');
  }
}

getWalletData().catch(error => console.error('Script failed:', error.message));-e 
---
File: ./scripts/checkTokens.js
// scripts/checkTokens.js
import { Alchemy, Network } from 'alchemy-sdk';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const ALCHEMY_API_KEY = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || 'rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI';
const NFT_ADDRESS = '0xC1bD0B0E4bC6a3F3e439eE4D0fD69267c29F4180';
const WALLET = '0x15702443110894B26911B913b17ea4931F803B02';

async function check() {
  const alchemy = new Alchemy({ apiKey: ALCHEMY_API_KEY, network: Network.ETH_MAINNET });
  try {
    const nfts = await alchemy.nft.getNftsForOwner(WALLET, {
      contractAddresses: [NFT_ADDRESS],
    });
    console.log('Total NFTs:', nfts.totalCount);
    console.log('Token IDs:', nfts.ownedNfts.map(nft => Number(nft.tokenId)));
  } catch (e) {
    console.error('Error:', e.message);
  }
}

check().catch(console.error);-e 
---
File: ./scripts/again.js
import { getAddress } from 'viem';

const address = '0x58aD6ef28BfB092635454D02303aBbd4D87b503C';
console.log('Checksummed address:', getAddress(address));-e 
---
File: ./scripts/checkEnv.js
// scripts/checkEnv.js
import dotenv from 'dotenv';
dotenv.config({ path: '/Users/ollyjukes/nextjs.projects/titanx-utility/.env.local' });

console.log('Alchemy API Key:', process.env.NEXT_PUBLIC_ALCHEMY_API_KEY);-e 
---
File: ./scripts/testContract.js
// scripts/testContract.js
import dotenv from 'dotenv';
dotenv.config({ path: '/Users/ollyjukes/nextjs.projects/titanx-utility/.env.local' });

import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { tokenContracts, uniswapV2PoolABI } from '../app/token_contracts.js';

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`),
});

async function test() {
  try {
    console.log('Alchemy API Key:', process.env.NEXT_PUBLIC_ALCHEMY_API_KEY);

    // Flare Auction
    console.log('Flare address:', tokenContracts.FLARE_AUCTION.address);
    let flareTimestamp = 0;
    try {
      flareTimestamp = await client.readContract({
        address: tokenContracts.FLARE_AUCTION.address,
        abi: tokenContracts.FLARE_AUCTION.abi,
        functionName: 'startTimestamp',
      });
      console.log('Flare startTimestamp:', flareTimestamp);
    } catch (e) {
      console.log('Flare startTimestamp failed:', e.shortMessage);
      console.log('Assuming startTimestamp is 0 (auction not started)');
    }

    try {
      const auctionState = await client.readContract({
        address: tokenContracts.FLARE_AUCTION.address,
        abi: tokenContracts.FLARE_AUCTION.abi,
        functionName: 'state',
      });
      console.log('Flare auction state:', auctionState);
    } catch (e) {
      console.log('Flare state failed:', e.shortMessage);
    }

    if (flareTimestamp > 0) {
      const flareDay = Math.max(1, Math.floor((Date.now() / 1000 - Number(flareTimestamp)) / (24 * 60 * 60)) + 1);
      try {
        const flareStats = await client.readContract({
          address: tokenContracts.FLARE_AUCTION.address,
          abi: tokenContracts.FLARE_AUCTION.abi,
          functionName: 'dailyStats',
          args: [flareDay],
        });
        console.log('Flare dailyStats:', flareStats);
      } catch (e) {
        console.log('Flare dailyStats failed:', e.shortMessage);
      }
    } else {
      console.log('Skipping Flare dailyStats: Auction not started');
    }

    // Ascendant Auction
    console.log('Ascendant address:', tokenContracts.ASCENDANT_AUCTION.address);
    let ascendantTimestamp = 0;
    try {
      ascendantTimestamp = await client.readContract({
        address: tokenContracts.ASCENDANT_AUCTION.address,
        abi: tokenContracts.ASCENDANT_AUCTION.abi,
        functionName: 'startTimestamp',
      });
      console.log('Ascendant startTimestamp:', ascendantTimestamp);
    } catch (e) {
      console.log('Ascendant startTimestamp failed:', e.shortMessage);
      console.log('Assuming startTimestamp is 0 (auction not started)');
    }

    if (ascendantTimestamp > 0) {
      const ascendantDay = Math.max(1, Math.floor((Date.now() / 1000 - Number(ascendantTimestamp)) / (24 * 60 * 60)) + 1);
      try {
        const ascendantStats = await client.readContract({
          address: tokenContracts.ASCENDANT_AUCTION.address,
          abi: tokenContracts.ASCENDANT_AUCTION.abi,
          functionName: 'dailyStats',
          args: [ascendantDay],
        });
        console.log('Ascendant dailyStats:', ascendantStats);
      } catch (e) {
        console.log('Ascendant dailyStats failed:', e.shortMessage);
      }
    } else {
      console.log('Skipping Ascendant dailyStats: Auction not started');
    }

    // Flare/X28 Pool
    console.log('Flare/X28 address:', tokenContracts.FLARE_X28.address);
    try {
      const flareX28Reserves = await client.readContract({
        address: tokenContracts.FLARE_X28.address,
        abi: uniswapV2PoolABI,
        functionName: 'getReserves',
      });
      console.log('Flare/X28 reserves:', flareX28Reserves);
    } catch (e) {
      console.log('Flare/X28 reserves failed:', e.shortMessage);
    }

    try {
      const flareX28Token0 = await client.readContract({
        address: tokenContracts.FLARE_X28.address,
        abi: uniswapV2PoolABI,
        functionName: 'token0',
      });
      console.log('Flare/X28 token0:', flareX28Token0);
    } catch (e) {
      console.log('Flare/X28 token0 failed:', e.shortMessage);
    }
  } catch (error) {
    console.error('General error:', error);
  }
}

test();-e 
---
File: ./scripts/testElement369Vault.js
// scripts/testElement369Vault.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

// Configuration
const ALCHEMY_API_KEY = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || 'rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI';
const NFT_ADDRESS = '0x024D64E2F65747d8bB02dFb852702D588A062575'; // Element369 NFT
const VAULT_ADDRESS = '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5';
const TEST_WALLET = '0x15702443110894B26911B913b17ea4931F803B02';

// Minimal ABI
const VAULT_ABI = [
  {
    name: 'getRewards',
    inputs: [
      { type: 'uint256[]' },
      { type: 'address' },
      { type: 'bool' },
    ],
    outputs: [
      { type: 'bool[]' },
      { type: 'bool[]' },
      { type: 'uint256' },
      { type: 'uint256' },
      { type: 'uint256' },
    ],
    stateMutability: 'view',
    type: 'function',
  },
];

async function getTokenIds(wallet) {
  const settings = {
    apiKey: ALCHEMY_API_KEY,
    network: Network.ETH_MAINNET,
  };
  const alchemy = new Alchemy(settings);
  try {
    console.log('Querying getNftsForOwner for contract:', NFT_ADDRESS, 'wallet:', wallet);
    const nfts = await alchemy.nft.getNftsForOwner(wallet, {
      contractAddresses: [NFT_ADDRESS],
    });
    console.log('Total NFTs:', nfts.totalCount);
    const tokenIds = nfts.ownedNfts.map(nft => Number(nft.tokenId));
    if (tokenIds.length > 0) {
      console.log('Found tokens:', tokenIds);
      return tokenIds;
    }

    console.log('getNftsForOwner returned empty; trying getOwnersForContract');
    const owners = await alchemy.nft.getOwnersForContract(NFT_ADDRESS, {
      withTokenBalances: true,
    });
    const walletData = owners.owners.find(
      owner => owner.ownerAddress.toLowerCase() === wallet.toLowerCase()
    );
    const ownerTokens = walletData ? walletData.tokenBalances.map(tb => Number(tb.tokenId)) : [];
    console.log('getOwnersForContract tokens:', ownerTokens);
    return ownerTokens;
  } catch (e) {
    console.error('Token fetch failed:', e.message);
    return [];
  }
}

async function test() {
  // Initialize client
  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`),
  });

  // Fetch token IDs
  let tokenIds = [];
  try {
    console.log('Fetching token IDs for wallet:', TEST_WALLET);
    tokenIds = await getTokenIds(TEST_WALLET);
    console.log('Final Token IDs:', tokenIds);
    if (tokenIds.length === 0) {
      console.log('No tokens found; using sample IDs: [101, 102]');
      tokenIds = [101, 102];
    } else {
      tokenIds = tokenIds.slice(0, 2); // Use up to 2 tokens
    }
  } catch (e) {
    console.error('Failed to fetch token IDs:', e.message);
    console.log('Using sample IDs: [101, 102]');
    tokenIds = [101, 102];
  }

  // Test getRewards
  try {
    console.log('\nTesting getRewards with token IDs:', tokenIds);
    const result = await client.readContract({
      address: VAULT_ADDRESS,
      abi: VAULT_ABI,
      functionName: 'getRewards',
      args: [tokenIds, TEST_WALLET, false],
    });
    console.log('getRewards Result:', {
      availability: result[0],
      burned: result[1],
      infernoPool: Number(result[2]) / 1e18,
      fluxPool: Number(result[3]) / 1e18,
      e280Pool: Number(result[4]) / 1e18,
    });
  } catch (e) {
    console.error('getRewards failed:', e.message);
  }
}

test().catch(console.error);-e 
---
File: ./scripts/testAscendantOrder.js
// scripts/testAscendantWallet.js

async function fetchAscendantHoldersForWallet(targetWallet) {
    const targetWalletLower = targetWallet.toLowerCase(); // Normalize for comparison
    try {
      // Fetch from the Next.js server
      const res = await fetch('http://localhost:3000/api/holders/Ascendant?page=0&pageSize=1000');
      if (!res.ok) {
        throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);
      }
      const data = await res.json();
  
      // Validate response
      if (!data.holders || !Array.isArray(data.holders)) {
        throw new Error('Invalid response: holders data is missing or not an array');
      }
  
      // Find the target wallet
      const targetHolder = data.holders.find(
        (holder) => holder && holder.wallet && holder.wallet.toLowerCase() === targetWalletLower
      );
  
      // Display target wallet details
      console.log(`\nDetails for Wallet ${targetWallet}:`);
      if (targetHolder) {
        console.log(
          `Rank: ${targetHolder.rank},\n` +
          `Wallet: ${targetHolder.wallet},\n` +
          `Shares: ${(targetHolder.shares / 1e18).toLocaleString()},\n` +
          `% Shares: ${data.totalShares ? ((targetHolder.shares / data.totalShares) * 100).toFixed(2) : 'N/A'}%,\n` +
          `Total NFTs: ${targetHolder.total},\n` +
          `Locked Ascendant: ${(targetHolder.lockedAscendant / 1e18).toLocaleString()},\n` +
          `Pending DAY8 Rewards: ${(targetHolder.pendingDay8 / 1e18).toLocaleString()},\n` +
          `Pending DAY28 Rewards: ${(targetHolder.pendingDay28 / 1e18).toLocaleString()},\n` +
          `Pending DAY90 Rewards: ${(targetHolder.pendingDay90 / 1e18).toLocaleString()}`
        );
      } else {
        console.log('This wallet does not hold any Ascendant NFTs.');
      }
  
      // Display top 5 holders for context (ordered by shares)
      console.log('\nTop 5 Ascendant Holders Ordered by Shares:');
      data.holders.slice(0, 5).forEach((holder, index) => {
        if (holder && holder.wallet && typeof holder.shares === 'number' && typeof holder.total === 'number') {
          console.log(
            `Rank ${index + 1}: Wallet ${holder.wallet.slice(0, 6)}...${holder.wallet.slice(-4)}, ` +
            `Shares: ${(holder.shares / 1e18).toLocaleString()}, ` +
            `% Shares: ${data.totalShares ? ((holder.shares / data.totalShares) * 100).toFixed(2) : 'N/A'}%, ` +
            `Total NFTs: ${holder.total}`
          );
        } else {
          console.warn(`Invalid holder data at index ${index}:`, holder);
        }
      });
  
      // Log total stats
      console.log('\nCollection Summary:');
      console.log(`Total Holders: ${data.holders.length}`);
      console.log(`Total Shares: ${(data.totalShares / 1e18).toLocaleString()}`);
      console.log(`Total NFTs: ${data.totalTokens.toLocaleString()}`);
      console.log(`Total Pending Rewards: ${(data.pendingRewards / 1e18).toLocaleString()}`);
    } catch (err) {
      console.error('Error:', err.message);
    }
  }
  
  // Run the function for the specified wallet
  fetchAscendantHoldersForWallet('0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA');-e 
---
File: ./eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [...compat.extends("next/core-web-vitals")];

export default eslintConfig;
