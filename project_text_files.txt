-e 
---
File: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};-e 
---
File: ./.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
-e 
---
File: ./app/layout.js
// app/layout.js
import './layout.css';
import { Inter } from 'next/font/google';
import Navbar from '../components/Navbar';
import ClientProvider from './ClientProvider';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={`${inter.className} bg-gray-900 text-white`}>
        <ClientProvider>
          <Navbar />
          <main className="pt-16">{children}</main>
        </ClientProvider>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-gray-300">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
// app/nft/layout.js
'use client';
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import { contractDetails } from '@/app/nft-contracts';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(contractDetails).map((key) => ({
    name: contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    // Bypass cache for ascendantNFT to ensure fresh data
    if (contractKey !== 'ascendantNFT') {
      const cachedData = getCache(contractKey);
      if (cachedData) {
        console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
        return cachedData;
      }
    } else {
      console.log(`[NFTLayout] Bypassing cache for ascendantNFT to ensure fresh sorting`);
    }
  
    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }
  
    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];
    let allHolders = [];
    let totalTokens = 0;
    let totalLockedAscendant = 0;
    let totalShares = 0;
    let toDistributeDay8 = 0;
    let toDistributeDay28 = 0;
    let toDistributeDay90 = 0;
    let pendingRewards = 0;
    let page = 0;
    let totalPages = Infinity;
  
    try {
      while (page < totalPages) {
        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);
        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
          signal: AbortSignal.timeout(30000),
        });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);
        }
        const json = await res.json();
        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders?.length || 0}`);
        console.log(`[NFTLayout] Raw API response sample:`, JSON.stringify(json.holders?.slice(0, 2), null, 2));
        allHolders = allHolders.concat(json.holders || []);
        totalTokens = json.totalTokens || totalTokens;
        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
        totalShares = json.totalShares || totalShares;
        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
        pendingRewards = json.pendingRewards || pendingRewards;
        totalPages = json.totalPages || 1;
        page++;
        if (!json.holders || json.holders.length === 0) break;
      }
  
      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) {
          // Map API fields to expected names
          holder.Shares = holder.shares || holder.totalShares || 0;
          holder.totalNfts = holder.totalNfts || holder.total || 0;
          if (holder.Shares === undefined || holder.totalNfts === undefined) {
            console.warn(`[NFTLayout] Holder ${holder.wallet} missing Shares or totalNfts:`, holder);
          }
          uniqueHoldersMap.set(holder.wallet, holder);
        }
      });
      let uniqueHolders = Array.from(uniqueHoldersMap.values());
      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);
      console.log(`[NFTLayout] Aggregate totalShares for ${contractKey}: ${totalShares}`);
  
      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
  
      // Calculate sharesPercentage for display
      uniqueHolders.forEach(holder => {
        holder.sharesPercentage = totalShares > 0 ? ((holder.Shares || 0) / totalShares) * 100 : 0;
        console.log(`[NFTLayout] Holder ${holder.wallet.slice(0, 8)}: sharesPercentage=${holder.sharesPercentage.toFixed(2)}%, totalNfts=${holder.totalNfts || 0}, Shares=${holder.Shares || 0}`);
      });
  
      if (contractKey === 'ascendantNFT') {
        // Sort by Shares (descending), then by totalNfts (descending)
        uniqueHolders.sort((a, b) => {
          const sharesDiff = (b.Shares || 0) - (a.Shares || 0);
          if (sharesDiff !== 0) return sharesDiff; // Primary: Shares
          return (b.totalNfts || 0) - (a.totalNfts || 0); // Secondary: Total NFTs
        });
        // Assign ranks and log sorted order
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0; // For compatibility
          console.log(`[NFTLayout] Rank ${holder.rank}: ${holder.wallet.slice(0, 8)}, sharesPercentage=${holder.sharesPercentage.toFixed(2)}%, totalNfts=${holder.totalNfts || 0}, Shares=${holder.Shares || 0}`);
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.totalNfts || 0) - (a.totalNfts || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      }
  
      const result = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalMultiplierSum,
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);
      const errorResult = { holders: [], totalTokens: 0, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map(nft => 
        fetchCollectionData(nft.apiKey)
          .then(data => ({ apiKey: nft.apiKey, data }))
          .catch(err => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            // Include totalShares for Ascendant to calculate Shares %
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`px-6 py-2 rounded-md font-semibold transition-colors ${
              selectedChain === chain.id
                ? 'bg-orange-500 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) => (
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            )
          ))}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl">{children}</div>
    </div>
  );
}-e 
---
File: ./app/nft/page.js
// app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="text-center text-white">
      <p className="text-lg">Select a collection above to view details.</p>
    </div>
  );
}-e 
---
File: ./app/nft/[chain]/[contract]/page.js
// app/nft/[chain]/[contract]/page.js
import { notFound } from 'next/navigation';
import NFTPage from '@/components/NFTPage';
import { supportedChains, contractDetails } from '@/app/nft-contracts';

export default function Page({ params }) {
  const { chain, contract } = params;
  console.log('[Page] Received params:', params); // Debug params

  // Validate chain and contract
  const supportedContracts = Object.keys(contractDetails).map(key => key.toLowerCase());
  if (!supportedChains.includes(chain) || !supportedContracts.includes(contract.toLowerCase())) {
    notFound(); // Render 404 for invalid chain or contract
  }

  return <NFTPage chain={chain} contract={contract} />;
}

// Define static paths for SSG
export async function generateStaticParams() {
  // Generate paths from contractDetails
  return Object.entries(contractDetails).map(([contractId, details]) => ({
    chain: details.chain,
    contract: contractId.charAt(0).toUpperCase() + contractId.slice(1), // Capitalize first letter (e.g., 'element280' -> 'Element280')
  }));
}

// Enable Incremental Static Regeneration (ISR)
export const revalidate = 60; // Revalidate every 60 seconds-e 
---
File: ./app/store.js
// app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          I'd like to add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              âœ•
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, staxNFTAbi, staxVaultAbi } from '../../utils';

const contractAddress = nftContracts.stax?.address;
const vaultAddress = nftContracts.stax?.vaultAddress;
const tiersConfig = nftContracts.stax?.tiers;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '1000');
  const wallet = searchParams.get('wallet')?.toLowerCase();

  log(`[Stax] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Stax contract or vault address missing');
    }

    const cacheKey = `stax_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL && !wallet) {
      log(`[Stax] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Stax] Cache miss or wallet filter: ${cacheKey}`);

    // Clear cache for wallet-specific queries to avoid stale data
    if (wallet) {
      delete cache[cacheKey];
    }

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Stax] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddresses = [
      '0x0000000000000000000000000000000000000000',
      '0x000000000000000000000000000000000000dead',
    ];
    const filteredOwners = wallet
      ? ownersResponse.owners.filter(
          owner => owner.ownerAddress.toLowerCase() === wallet && !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
        )
      : ownersResponse.owners.filter(
          owner => !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
        );
    log(`[Stax] Live owners after filter: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const walletAddr = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, walletAddr);
        totalTokens++;
      });
      ownerTokens.set(walletAddr, tokenIds);
    });
    log(`[Stax] Total tokens: ${totalTokens}`);

    // Paginate (only if no wallet filter)
    let paginatedTokenIds = Array.from(tokenOwnerMap.keys());
    if (!wallet) {
      const start = page * pageSize;
      const end = Math.min(start + pageSize, paginatedTokenIds.length);
      paginatedTokenIds = paginatedTokenIds.slice(start, end);
    }
    log(`[Stax] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: staxNFTAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Stax] Tiers fetched for ${tierResults.length} tokens`);

    // Log tier results for debugging
    tierResults.forEach((result, i) => {
      const tokenId = paginatedTokenIds[i];
      if (result?.status === 'success') {
        log(`[Stax] Token ${tokenId}: Tier ${result.result}`);
      } else {
        log(`[Stax] Tier fetch failed for token ${tokenId}: ${result?.error || 'Unknown'}`);
      }
    });

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number)); // 12
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const walletAddr = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && walletAddr) {
          if (!holdersMap.has(walletAddr)) {
            holdersMap.set(walletAddr, {
              wallet: walletAddr,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier).fill(0), // 12 elements
              claimableRewards: 0,
            });
          }
          const holder = holdersMap.get(walletAddr);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier - 1] += 1; // Zero-based indexing
        } else {
          log(`[Stax] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Stax] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch rewards
    let holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: staxVaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet],
      };
    });

    const totalRewardPoolCall = {
      address: vaultAddress,
      abi: staxVaultAbi,
      functionName: 'totalRewardPool',
      args: [],
    };

    log(`[Stax] Fetching rewards for ${holders.length} holders`);
    const [rewardResults, totalRewardPoolResult] = await Promise.all([
      rewardCalls.length ? batchMulticall(rewardCalls) : [],
      batchMulticall([totalRewardPoolCall]),
    ]);

    const totalRewardPool = totalRewardPoolResult[0]?.status === 'success'
      ? Number(totalRewardPoolResult[0].result) / 1e18
      : 0;

    holders.forEach((holder, i) => {
      if (rewardResults[i]?.status === 'success' && rewardResults[i].result) {
        const [, totalPayout] = rewardResults[i].result;
        holder.claimableRewards = Number(totalPayout) / 1e18;
        log(
          `[Stax] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Claimable=${holder.claimableRewards.toFixed(4)}, ` +
          `Tokens=${ownerTokens.get(holder.wallet).length}`
        );
        if (holder.claimableRewards === 0) {
          log(`[Stax] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.claimableRewards = 0;
        log(`[Stax] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardResults[i]?.error || 'Unknown'}`);
      }
      holder.percentage = totalRewardPool ? (holder.claimableRewards / totalRewardPool) * 100 : 0;
      holder.rank = 0;
    });

    // Calculate ranks
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
    });

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: wallet ? 1 : Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Stax] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Stax] Error: ${error.message}`);
    console.error('[Stax] Error stack:', error.stack);
    let status = 500;
    let message = 'Failed to fetch Stax data';
    if (error.message.includes('Rate limit')) {
      status = 429;
      message = 'Alchemy rate limit exceeded';
    }
    return NextResponse.json({ error: message, details: error.message }, { status });
  }
}-e 
---
File: ./app/api/holders/E280/route.js
// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}

export async function POST(request) {
  log('POST /api/holders/E280: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}-e 
---
File: ./app/api/holders/Element280/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';

// In-memory cache
let cache = {};
let tokenCache = new Map();
let holdersMapCache = null;
let isCachePopulating = false;
let totalOwners = 0;
let totalSupplyCache = null;
let totalBurnedCache = null;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0 };

// Export cache state for /progress route
export function getCacheState() {
  return { isCachePopulating, holdersMapCache, totalOwners, progressState };
}

// Utility to serialize BigInt values
function serializeBigInt(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )
  );
}

// Retry utility with minimal logging
async function retry(fn, attempts = 5, delay = (retryCount, error) => (error?.details?.code === 429 ? 4000 * 2 ** retryCount : 2000), strict = true) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        log(`[element280] Retry failed after ${attempts} attempts: ${error.message}`);
        if (strict) throw error;
        return null;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch and cache total supply and burned tokens
async function getTotalSupply(contractAddress, errorLog) {
  const contractName = 'element280';
  if (totalSupplyCache !== null && totalBurnedCache !== null) {
    return totalSupplyCache;
  }
  const startTime = Date.now();
  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalSupply',
          },
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalBurned',
          },
        ],
      })
    );
    const totalSupply = results[0].status === 'success' ? Number(results[0].result) : 0;
    const totalBurned = results[1].status === 'success' && results[1].result != null ? Number(results[1].result) : 0;
    if (isNaN(totalSupply) || isNaN(totalBurned)) {
      const errorMsg = `Invalid totalSupply=${totalSupply} or totalBurned=${totalBurned}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: errorMsg });
      throw new Error(errorMsg);
    }
    totalSupplyCache = totalSupply;
    totalBurnedCache = totalBurned;
    log(`[element280] Fetched total supply: ${totalSupplyCache}, total burned: ${totalBurnedCache} in ${Date.now() - startTime}ms`);
    return totalSupplyCache;
  } catch (error) {
    log(`[element280] Failed to fetch total supply or burned: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: error.message });
    throw error;
  }
}

// Fetch all NFT ownership data using contract calls
async function fetchAllNftOwnership(contractAddress, errorLog, timings) {
  const contractName = 'element280';
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();
  const burnAddress = '0x0000000000000000000000000000000000000000';

  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    const errorMsg = `Invalid contract address: ${contractAddress}`;
    log(`[element280] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_contract', error: errorMsg });
    throw new Error(errorMsg);
  }
  log(`[element280] Starting NFT ownership fetch for contract: ${contractAddress}`);

  try {
    // Step 1: Get token IDs from Alchemy
    const tokenIdStart = Date.now();
    let pageKey = null;
    let pageCount = 0;
    let tokenIds = [];
    do {
      pageCount++;
      const response = await retry(() =>
        alchemy.nft.getNftsForContract(contractAddress, { pageKey })
      );
      if (!response.nfts || !Array.isArray(response.nfts)) {
        const errorMsg = `Invalid NFT response: nfts array missing`;
        log(`[element280] ${errorMsg}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
        throw new Error(errorMsg);
      }
      response.nfts.forEach(nft => {
        const tokenId = nft.tokenId || nft.id || nft.token_id;
        if (tokenId) tokenIds.push(tokenId);
      });
      pageKey = response.pageKey;
    } while (pageKey);
    timings.tokenIdFetch = Date.now() - tokenIdStart;
    log(`[element280] Collected ${tokenIds.length} token IDs in ${timings.tokenIdFetch}ms`);

    if (tokenIds.length === 0) {
      const errorMsg = `No token IDs found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
      throw new Error(errorMsg);
    }

    // Step 2: Fetch owners via contract ownerOf calls
    const ownerFetchStart = Date.now();
    const ownerCalls = tokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'ownerOf',
      args: [BigInt(tokenId)],
    }));
    const limit = pLimit(10);
    const chunkSize = 100;
    const ownerResults = [];
    for (let i = 0; i < ownerCalls.length; i += chunkSize) {
      const chunk = ownerCalls.slice(i, i + chunkSize);
      const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
      ownerResults.push(...results);
    }
    timings.ownerFetch = Date.now() - ownerFetchStart;
    log(`[element280] Fetched owners for ${ownerResults.length} tokens in ${timings.ownerFetch}ms`);

    // Step 3: Process owners
    const ownerProcessStart = Date.now();
    let invalidTokens = 0;
    let nonExistentTokens = 0;
    tokenIds.forEach((tokenId, index) => {
      const result = ownerResults[index];
      if (result.status === 'success') {
        const owner = result.result.toLowerCase();
        if (owner && owner !== burnAddress) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        } else {
          invalidTokens++;
        }
      } else {
        if (result.error?.message.includes('0xdf2d9b42')) {
          nonExistentTokens++;
        } else {
          log(`[element280] Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owners', error: `Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
        invalidTokens++;
      }
    });
    timings.ownerProcess = Date.now() - ownerProcessStart;
    log(`[element280] Processed owners: ${ownershipByToken.size} valid NFTs, skipped ${invalidTokens} invalid tokens (including ${nonExistentTokens} non-existent) in ${timings.ownerProcess}ms`);

    // Step 4: Validate against totalSupply
    const totalSupply = await getTotalSupply(contractAddress, errorLog);
    const expectedLiveTokens = totalSupply - (totalBurnedCache || 0);
    if (ownershipByToken.size === 0) {
      const errorMsg = `No valid NFTs with owners found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
      throw new Error(errorMsg);
    }
    if (ownershipByToken.size > expectedLiveTokens) {
      const errorMsg = `Found ${ownershipByToken.size} NFTs, more than expected ${expectedLiveTokens}`;
      log(`[element280] Warning: ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    }

    log(`[element280] Completed ownership fetch: ${ownershipByToken.size} NFTs across ${ownershipByWallet.size} wallets`);
    return { ownershipByToken, ownershipByWallet };
  } catch (error) {
    log(`[element280] Failed to fetch NFT ownership: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_ownership', error: error.message });
    throw error;
  }
}

// Populate holdersMapCache with timing and error tracking
async function populateHoldersMapCache(contractAddress, tiers) {
  const contractName = 'element280';
  log(`[element280] Starting populateHoldersMapCache for contract: ${contractAddress}`);
  if (isCachePopulating) {
    log(`[element280] Cache population already in progress`);
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 };
  const timings = {
    totalSupply: 0,
    tokenIdFetch: 0,
    ownerFetch: 0,
    ownerProcess: 0,
    holderInit: 0,
    tierFetch: 0,
    rewardFetch: 0,
    metricsCalc: 0,
    total: 0,
  };
  const errorLog = [];
  const totalStart = Date.now();

  try {
    holdersMapCache = new Map();

    // Step 1: Fetch total supply
    const supplyStart = Date.now();
    const totalTokens = await getTotalSupply(contractAddress, errorLog);
    timings.totalSupply = Date.now() - supplyStart;
    progressState = { step: 'fetching_ownership', processedNfts: 0, totalNfts: totalTokens };
    log(`[element280] Fetched total supply: ${totalTokens} in ${timings.totalSupply}ms`);

    // Step 2: Fetch all NFT ownership
    const { ownershipByToken, ownershipByWallet } = await fetchAllNftOwnership(contractAddress, errorLog, timings);
    totalOwners = ownershipByWallet.size;
    progressState = { step: 'initializing_holders', processedNfts: ownershipByToken.size, totalNfts: totalTokens };
    log(`[element280] Fetched ownership: ${ownershipByToken.size} NFTs, ${totalOwners} wallets`);

    // Step 3: Initialize holders
    const holderInitStart = Date.now();
    ownershipByWallet.forEach((tokenIds, wallet) => {
      const holder = {
        wallet,
        total: tokenIds.length,
        totalLive: tokenIds.length,
        multiplierSum: 0,
        displayMultiplierSum: 0,
        tiers: Array(6).fill(0),
        tokenIds: tokenIds.map(id => BigInt(id)),
        claimableRewards: 0,
        percentage: 0,
        rank: 0,
      };
      holdersMapCache.set(wallet, holder);
      tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
    });
    timings.holderInit = Date.now() - holderInitStart;
    log(`[element280] Initialized ${holdersMapCache.size} holders in ${timings.holderInit}ms`);
    progressState = { step: 'fetching_tiers', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 4: Batch fetch tiers
    const tierFetchStart = Date.now();
    const allTokenIds = Array.from(ownershipByToken.keys()).map(id => BigInt(id));
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    if (tierCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const tierResults = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        tierResults.push(...results);
        progressState = {
          step: 'fetching_tiers',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      tierResults.forEach((result, index) => {
        const tokenId = allTokenIds[index].toString();
        if (result.status === 'success') {
          const tier = Number(result.result);
          if (tier >= 1 && tier <= 6) {
            const owner = ownershipByToken.get(tokenId);
            const holder = holdersMapCache.get(owner);
            if (holder) {
              holder.tiers[tier - 1]++;
              tokenCache.set(`${contractAddress}-${tokenId}-tier`, tier);
            } else {
              log(`[element280] Warning: No holder found for token ${tokenId} (owner: ${owner})`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `No holder found for token ${tokenId} (owner: ${owner})` });
            }
          } else {
            log(`[element280] Invalid tier ${tier} for token ${tokenId}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Invalid tier ${tier} for token ${tokenId}` });
          }
        } else {
          log(`[element280] Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
      });
    }
    timings.tierFetch = Date.now() - tierFetchStart;
    log(`[element280] Fetched tiers for ${allTokenIds.length} NFTs in ${timings.tierFetch}ms`);
    progressState = { step: 'fetching_rewards', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 5: Batch fetch rewards
    const rewardFetchStart = Date.now();
    const rewardCalls = [];
    ownershipByWallet.forEach((tokenIds, wallet) => {
      tokenIds.forEach(tokenId => {
        rewardCalls.push({
          address: vaultAddresses.element280.address,
          abi: element280VaultAbi,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], wallet],
        });
      });
    });
    if (rewardCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const rewardResults = [];
      for (let i = 0; i < rewardCalls.length; i += chunkSize) {
        const chunk = rewardCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        rewardResults.push(...results);
        progressState = {
          step: 'fetching_rewards',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      let resultIndex = 0;
      ownershipByWallet.forEach((tokenIds, wallet) => {
        let totalRewards = 0n;
        tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          } else {
            log(`[element280] Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}` });
          }
        });
        const holder = holdersMapCache.get(wallet);
        if (holder) {
          holder.claimableRewards = Number(totalRewards) / 1e18;
          if (isNaN(holder.claimableRewards)) {
            holder.claimableRewards = 0;
            log(`[element280] Warning: NaN rewards for wallet ${wallet}, set to 0`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `NaN rewards for wallet ${wallet}` });
          }
          tokenCache.set(`${contractName}-${wallet}-reward`, holder.claimableRewards);
        }
      });
    }
    timings.rewardFetch = Date.now() - rewardFetchStart;
    log(`[element280] Fetched rewards for ${rewardCalls.length} NFTs in ${timings.rewardFetch}ms`);
    progressState = { step: 'calculating_metrics', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 6: Calculate multipliers and metrics
    const metricsStart = Date.now();
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    const totalMultiplierSum = Array.from(holdersMapCache.values()).reduce((sum, holder) => {
      holder.multiplierSum = holder.tiers.reduce(
        (sum, count, index) => sum + count * (multipliers[index] || 0),
        0
      );
      holder.displayMultiplierSum = holder.multiplierSum / 10;
      return sum + holder.multiplierSum;
    }, 0);
    const holders = Array.from(holdersMapCache.values());
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    });
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
      holdersMapCache.set(holder.wallet, holder);
    });
    timings.metricsCalc = Date.now() - metricsStart;
    log(`[element280] Calculated metrics for ${holders.length} holders in ${timings.metricsCalc}ms`);
    progressState = { step: 'idle', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Log summary
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: ownershipByToken.size,
      walletsProcessed: ownershipByWallet.size,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);

  } catch (error) {
    log(`[element280] Failed to populate holdersMapCache: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    holdersMapCache = null;
    cache = {};
    progressState = { step: 'error', processedNfts: 0, totalNfts: 0 };

    // Log summary on error
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: 0,
      walletsProcessed: 0,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start (Failed) =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);
    throw error;
  } finally {
    isCachePopulating = false;
    totalOwners = 0;
    log(`[element280] Cache population complete, isCachePopulating=false, totalOwners=0`);
  }
}

// Fetch holder data for a specific wallet
async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();
  const walletLower = wallet.toLowerCase();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  while (isCachePopulating) {
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  if (holdersMapCache?.has(walletLower)) {
    const holder = holdersMapCache.get(walletLower);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }

  const holder = {
    wallet: walletLower,
    total: 0,
    totalLive: 0,
    multiplierSum: 0,
    displayMultiplierSum: 0,
    tiers: Array(6).fill(0),
    tokenIds: [],
    claimableRewards: 0,
    percentage: 0,
    rank: 0,
  };

  const tokenIdsResponse = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [walletLower],
    })
  );
  const tokenIds = tokenIdsResponse.map(id => id.toString());
  const nfts = tokenIds.map(tokenId => ({ tokenId, tier: 0 }));
  holder.total = nfts.length;
  holder.totalLive = nfts.length;
  tokenCache.set(`${contractAddress}-${walletLower}-nfts`, nfts);

  if (nfts.length === 0) {
    return null;
  }

  const bigIntTokenIds = nfts.map(nft => BigInt(nft.tokenId));
  const calls = [];
  bigIntTokenIds.forEach(tokenId => {
    calls.push({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    });
    calls.push({
      address: vaultAddresses.element280.address,
      abi: element280VaultAbi,
      functionName: 'getRewards',
      args: [[tokenId], walletLower],
    });
  });

  const results = await retry(() => client.multicall({ contracts: calls }));
  const finalTokenIds = [];
  let totalRewards = 0n;
  nfts.forEach((nft, index) => {
    const tierResult = results[index * 2];
    const rewardResult = results[index * 2 + 1];
    if (tierResult.status === 'success') {
      const tier = Number(tierResult.result);
      if (tier >= 1 && tier <= 6) {
        nft.tier = tier;
        holder.tiers[tier - 1]++;
        finalTokenIds.push(BigInt(nft.tokenId));
        tokenCache.set(`${contractAddress}-${nft.tokenId}-tier`, tier);
      }
    }
    if (rewardResult.status === 'success') {
      const rewardValue = BigInt(rewardResult.result[1] || 0);
      totalRewards += rewardValue;
      tokenCache.set(`${contractAddress}-${nft.tokenId}-single-reward`, rewardValue);
    }
  });
  holder.tokenIds = finalTokenIds;
  holder.claimableRewards = Number(totalRewards) / 1e18;
  if (isNaN(holder.claimableRewards)) {
    holder.claimableRewards = 0;
  }
  tokenCache.set(`${contractName}-${walletLower}-reward`, holder.claimableRewards);

  const multipliers = Object.values(tiers).map(t => t.multiplier);
  holder.multiplierSum = holder.tiers.reduce(
    (sum, count, index) => sum + count * (multipliers[index] || 0),
    0
  );
  holder.displayMultiplierSum = holder.multiplierSum / 10;

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 100);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
  const existingHolder = allHolders.holders.find(h => h.wallet === walletLower);
  holder.rank = existingHolder ? existingHolder.rank : allHolders.holders.length + 1;

  if (holder.total > 0) {
    holdersMapCache?.set(walletLower, holder);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }
  return null;
}

// Fetch all holders (paginated)
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (!refresh && cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  let holdersMap = holdersMapCache;
  if (refresh || !holdersMap || isCachePopulating) {
    while (isCachePopulating) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (refresh || !holdersMap) {
      await populateHoldersMapCache(contractAddress, tiers);
      holdersMap = holdersMapCache;
      if (!holdersMap) {
        log(`[element280] Error: holdersMapCache is null after population`);
        throw new Error('Failed to populate holdersMapCache');
      }
    }
  }

  const totalTokens = await getTotalSupply(contractAddress, []);
  const holders = Array.from(holdersMap.values());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, holders.length);
  const paginatedHolders = holders.slice(start, end);

  const result = {
    holders: paginatedHolders,
    totalTokens: holdersMap.size > 0 ? holders.reduce((sum, h) => sum + h.total, 0) : totalTokens,
    totalHolders: holders.length,
    page,
    pageSize,
    totalPages: Math.ceil(holders.length / pageSize),
    summary: {
      totalLive: totalTokens,
      totalBurned: totalBurnedCache || 0,
      multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      totalRewardPool: holders.reduce((sum, h) => sum + h.claimableRewards, 0),
    },
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`[element280] Paginated ${paginatedHolders.length} holders: totalHolders=${holders.length}, totalBurned=${result.summary.totalBurned}, multiplierPool=${result.summary.multiplierPool}`);
  return serializeBigInt(result);
}

// GET handler
export async function GET(request) {
  const contractName = 'element280';
  let url = request.url || (request.nextUrl && request.nextUrl.toString());
  if (!url) {
    log(`[element280] Error: Both request.url and request.nextUrl are undefined`);
    return NextResponse.json({ error: 'Invalid request: URL is undefined' }, { status: 400 });
  }

  try {
    const { searchParams } = new URL(url);
    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    const address = contractAddresses.element280.address;
    if (!address) {
      log(`[element280] Error: Element280 contract address not found`);
      return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      log(`[element280] GET /api/holders/Element280?wallet=${wallet} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      log(`[element280] GET /api/holders/Element280?page=${page}&pageSize=${pageSize} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt(result));
    }
  } catch (error) {
    log(`[element280] Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

// POST handler
export async function POST() {
  const contractName = 'element280';
  const address = contractAddresses.element280.address;
  if (!address) {
    log(`[element280] Error: Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    log(`[element280] Cache preload completed, total holders: ${holdersMapCache?.size || 0}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders: holdersMapCache?.size || 0 });
  } catch (error) {
    log(`[element280] Error in POST /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element280/progress/route.js
// api/holders/Element280/progress/route.js
// This route handles the progress of the cache population for the Element280 contract.
// It provides information about the current state of the cache population process,
// including whether it is currently populating, the total number of wallets,
// the total number of owners, and the current phase of the process.
// It also handles errors that may occur during the process and logs relevant information.
// The route is defined as a GET request handler and returns a JSON response with the progress information.

import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isCachePopulating, holdersMapCache, totalOwners, progressState } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isCachePopulating}, totalWallets=${holdersMapCache?.size || 0}, totalOwners=${totalOwners}, step=${progressState.step}`);

  try {
    const progressPercentage = progressState.totalNfts > 0 ? (progressState.processedNfts / progressState.totalNfts) * 100 : 0;
    const phase = isCachePopulating
      ? {
          fetching_supply: 'Fetching total supply',
          fetching_ownership: 'Fetching NFT ownership',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[progressState.step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating: isCachePopulating,
      totalWallets: holdersMapCache?.size || 0,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element280/progress/route cache db.js
// api/holders/Element280/progress/route.js


import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isPopulating, totalWallets, totalOwners, step, processedNfts, totalNfts } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isPopulating}, totalWallets=${totalWallets}, totalOwners=${totalOwners}, step=${step}`);

  try {
    const progressPercentage = totalNfts > 0 ? (processedNfts / totalNfts) * 100 : 0;
    const phase = isPopulating
      ? {
          fetching_supply: 'Fetching total supply',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating,
      totalWallets,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element280/progress/route copy.js
// api/holders/Element280/progress/route.js
// This route handles the progress of the cache population for the Element280 contract.
// It provides information about the current state of the cache population process,
// including whether it is currently populating, the total number of wallets,
// the total number of owners, and the current phase of the process.
// It also handles errors that may occur during the process and logs relevant information.
// The route is defined as a GET request handler and returns a JSON response with the progress information.

import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isCachePopulating, holdersMapCache, totalOwners, progressState } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isCachePopulating}, totalWallets=${holdersMapCache?.size || 0}, totalOwners=${totalOwners}, step=${progressState.step}`);

  try {
    const progressPercentage = progressState.totalNfts > 0 ? (progressState.processedNfts / progressState.totalNfts) * 100 : 0;
    const phase = isCachePopulating
      ? {
          fetching_supply: 'Fetching total supply',
          fetching_ownership: 'Fetching NFT ownership',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[progressState.step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating: isCachePopulating,
      totalWallets: holdersMapCache?.size || 0,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element280/route cache db.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, batchMulticall } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import { LRUCache } from 'lru-cache';

// SQLite database setup
let db;
let dbInitialized = false;
async function initDb() {
  if (dbInitialized) return db;
  try {
    db = await open({
      filename: './element280.db',
      driver: sqlite3.Database,
      mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
      busyTimeout: 10000,
    });
    await db.exec(`
      CREATE TABLE IF NOT EXISTS holders (
        wallet TEXT PRIMARY KEY,
        total INTEGER,
        totalLive INTEGER,
        multiplierSum INTEGER,
        displayMultiplierSum REAL,
        tiers TEXT,
        tokenIds TEXT,
        claimableRewards REAL,
        percentage REAL,
        rank INTEGER
      );
      CREATE TABLE IF NOT EXISTS tokens (
        tokenId TEXT PRIMARY KEY,
        owner TEXT,
        tier INTEGER,
        reward REAL,
        lastUpdated INTEGER
      );
      CREATE TABLE IF NOT EXISTS metadata (
        key TEXT PRIMARY KEY,
        value TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_tokens_owner ON tokens(owner);
      CREATE INDEX IF NOT EXISTS idx_tokens_lastUpdated ON tokens(lastUpdated);
    `);
    dbInitialized = true;
    log('[element280] SQLite database initialized');
  } catch (error) {
    log(`[element280] error: SQLite initialization failed: ${error.message}, stack: ${error.stack}`);
    throw error;
  }
  return db;
}

// In-memory cache
const cache = new LRUCache({ max: 1000, ttl: CACHE_TTL });
const tokenCache = new LRUCache({ max: 10000, ttl: 24 * 60 * 60 * 1000 });
let isCachePopulating = false;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0, totalWallets: 0 };
const MAX_INITIAL_SUPPLY = 16883;
const FALLBACK_TOTAL_SUPPLY = 8137; // Current, may decrease
const FALLBACK_TOTAL_BURNED = 8746; // Current, may increase
const FALLBACK_EXPECTED_HOLDERS = 921; // Current, may change
const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';

// Logging configuration
const logLevel = 'ERROR'; // Set to 'DEBUG' for verbose, 'ERROR' for minimal
function log(message) {
  if (logLevel === 'ERROR' && !message.toLowerCase().includes('error') && !message.includes('failed') && !message.includes('completed') && !message.includes('initialized')) {
    return;
  }
  console.log(`[${new Date().toISOString()}] [element280] ${message}`);
}

// Export cache state for /progress route
export function getCacheState() {
  return {
    isPopulating: isCachePopulating,
    totalWallets: progressState.totalWallets,
    totalOwners: tokenCache.size,
    step: progressState.step,
    processedNfts: progressState.processedNfts,
    totalNfts: progressState.totalNfts,
    progressPercentage: progressState.totalNfts > 0 ? Math.round((progressState.processedNfts / progressState.totalNfts) * 100) : 0,
  };
}

// Serialize BigInt
function serializeBigInt(obj) {
  return JSON.parse(JSON.stringify(obj, (key, value) => 
    typeof value === 'bigint' ? value.toString() : value
  ));
}

// Retry utility
async function retry(fn, attempts = 5, delay = (retryCount, error) => 
  error?.details?.code === 429 ? 6000 * 2 ** retryCount : 2000) {
  let lastError;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i === attempts - 1) {
        log(`[element280] error: Retry failed: ${error.message}, code: ${error?.details?.code || 'unknown'}`);
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch total supply
async function getTotalSupply(contractAddress, db) {
  const cacheKey = `totalSupply:${contractAddress}`;
  try {
    const cached = await db.get('SELECT value FROM metadata WHERE key = ?', cacheKey);
    if (cached) return parseInt(cached.value);

    const result = await retry(() => client.multicall({
      contracts: [{ address: contractAddress, abi: element280MainAbi, functionName: 'totalSupply' }],
    }));
    const totalSupply = Number(result[0].result);
    if (isNaN(totalSupply) || totalSupply < 0 || totalSupply > MAX_INITIAL_SUPPLY) {
      log(`[element280] error: Invalid totalSupply=${totalSupply}, using fallback=${FALLBACK_TOTAL_SUPPLY}`);
      await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', cacheKey, FALLBACK_TOTAL_SUPPLY);
      return FALLBACK_TOTAL_SUPPLY;
    }
    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', cacheKey, totalSupply);
    return totalSupply;
  } catch (error) {
    log(`[element280] error: getTotalSupply failed: ${error.message}`);
    return FALLBACK_TOTAL_SUPPLY;
  }
}

// Fetch NFT ownership
async function fetchAllNftOwnership(contractAddress, db, timings) {
  const start = Date.now();
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();

  try {
    const cachedTokens = await db.all('SELECT tokenId, owner FROM tokens WHERE lastUpdated > ?', 
      Date.now() - 7 * 24 * 60 * 60 * 1000);
    if (cachedTokens.length >= FALLBACK_TOTAL_SUPPLY) {
      cachedTokens.forEach(({ tokenId, owner }) => {
        if (owner !== BURN_ADDRESS) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        }
      });
      timings.tokenIdFetch = 0;
      return { ownershipByToken, ownershipByWallet, invalidTokens: MAX_INITIAL_SUPPLY - ownershipByToken.size };
    }

    const response = await retry(() => 
      alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true })
    );
    let invalidTokens = 0;
    response.owners.forEach(owner => {
      const ownerAddress = owner.ownerAddress.toLowerCase();
      if (ownerAddress === BURN_ADDRESS) {
        invalidTokens += owner.tokenBalances.length;
        return;
      }
      owner.tokenBalances.forEach(token => {
        const tokenId = token.tokenId;
        ownershipByToken.set(tokenId, ownerAddress);
        const walletTokens = ownershipByWallet.get(ownerAddress) || [];
        walletTokens.push(tokenId);
        ownershipByWallet.set(ownerAddress, walletTokens);
        db.run('INSERT OR REPLACE INTO tokens (tokenId, owner, tier, reward, lastUpdated) VALUES (?, ?, ?, ?, ?)', 
          [tokenId, ownerAddress, 0, 0, Date.now()]);
      });
    });

    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'invalidTokens', invalidTokens);
    timings.tokenIdFetch = Date.now() - start;
    return { ownershipByToken, ownershipByWallet, invalidTokens };
  } catch (error) {
    log(`[element280] error: fetchAllNftOwnership failed: ${error.message}`);
    throw error;
  }
}

// Populate holders cache
async function populateHoldersMapCache(contractAddress, tiers) {
  if (isCachePopulating) {
    log('[element280] error: Cache population already in progress');
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0, totalWallets: 0 };
  const timings = { totalSupply: 0, tokenIdFetch: 0, holderInit: 0, tierFetch: 0, rewardFetch: 0, metricsCalc: 0, total: 0 };
  const errorLog = [];
  const totalStart = Date.now();
  const db = await initDb();

  const timeoutPromise = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Cache population timed out after 30s')), 30000)
  );

  let ownershipByToken = new Map();
  let ownershipByWallet = new Map();
  let invalidTokens = 0;

  try {
    await Promise.race([
      (async () => {
        const totalSupplyStart = Date.now();
        const totalSupply = await getTotalSupply(contractAddress, db);
        timings.totalSupply = Date.now() - totalSupplyStart;
        invalidTokens = MAX_INITIAL_SUPPLY - totalSupply;
        await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'invalidTokens', invalidTokens);

        const ownershipResult = await fetchAllNftOwnership(contractAddress, db, timings);
        ownershipByToken = ownershipResult.ownershipByToken;
        ownershipByWallet = ownershipResult.ownershipByWallet;
        invalidTokens = ownershipResult.invalidTokens;
        progressState = { 
          step: 'initializing_holders', 
          processedNfts: ownershipByToken.size, 
          totalNfts: MAX_INITIAL_SUPPLY, 
          totalWallets: ownershipByWallet.size 
        };

        const holderInitStart = Date.now();
        let processedWallets = 0;
        for (const [wallet, tokenIds] of ownershipByWallet) {
          try {
            const holder = {
              wallet,
              total: tokenIds.length,
              totalLive: tokenIds.length,
              multiplierSum: 0,
              displayMultiplierSum: 0,
              tiers: Array(6).fill(0),
              tokenIds: tokenIds.map(id => id.toString()),
              claimableRewards: 0,
              percentage: 0,
              rank: 0,
            };
            await db.run(
              'INSERT OR REPLACE INTO holders (wallet, total, totalLive, multiplierSum, displayMultiplierSum, tiers, tokenIds, claimableRewards, percentage, rank) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
              [wallet, holder.total, holder.totalLive, holder.multiplierSum, holder.displayMultiplierSum, JSON.stringify(holder.tiers), JSON.stringify(holder.tokenIds), holder.claimableRewards, holder.percentage, holder.rank]
            );
            tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
            processedWallets++;
            progressState.totalWallets = processedWallets;
          } catch (error) {
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'holder_init', wallet, error: error.message });
          }
        }
        timings.holderInit = Date.now() - holderInitStart;

        const tierFetchStart = Date.now();
        const allTokenIds = Array.from(ownershipByToken.keys());
        const tierCalls = [];
        for (const tokenId of allTokenIds) {
          const cached = await db.get('SELECT tier, lastUpdated FROM tokens WHERE tokenId = ?', tokenId);
          if (cached && cached.lastUpdated > Date.now() - 60 * 60 * 1000) {
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.tiers = JSON.parse(holder.tiers);
              holder.tiers[cached.tier - 1]++;
              await db.run('UPDATE holders SET tiers = ? WHERE wallet = ?', [JSON.stringify(holder.tiers), owner]);
            }
            continue;
          }
          tierCalls.push({ address: contractAddress, abi: element280MainAbi, functionName: 'getNftTier', args: [BigInt(tokenId)] });
        }
        const tierResults = await batchMulticall(tierCalls, 50);
        for (let i = 0; i < tierResults.length; i++) {
          const tokenId = tierCalls[i].args[0].toString();
          if (tierResults[i].status === 'success' && Number(tierResults[i].result) >= 1 && Number(tierResults[i].result) <= 6) {
            const tier = Number(tierResults[i].result);
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.tiers = JSON.parse(holder.tiers);
              holder.tiers[tier - 1]++;
              await db.run('UPDATE holders SET tiers = ? WHERE wallet = ?', [JSON.stringify(holder.tiers), owner]);
              await db.run('UPDATE tokens SET tier = ?, lastUpdated = ? WHERE tokenId = ?', [tier, Date.now(), tokenId]);
            }
          }
        }
        timings.tierFetch = Date.now() - tierFetchStart;

        const rewardFetchStart = Date.now();
        const rewardCalls = [];
        for (const [wallet, tokenIds] of ownershipByWallet) {
          for (const tokenId of tokenIds) {
            const cached = await db.get('SELECT reward, lastUpdated FROM tokens WHERE tokenId = ?', tokenId);
            if (cached && cached.lastUpdated > Date.now() - 60 * 60 * 1000) {
              const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', wallet);
              if (holder) {
                holder.claimableRewards += cached.reward;
                await db.run('UPDATE holders SET claimableRewards = ? WHERE wallet = ?', [holder.claimableRewards, wallet]);
              }
              continue;
            }
            rewardCalls.push({
              address: vaultAddresses.element280.address,
              abi: element280VaultAbi,
              functionName: 'getRewards',
              args: [[BigInt(tokenId)], wallet],
            });
          }
        }
        const rewardResults = await batchMulticall(rewardCalls, 50);
        for (let i = 0; i < rewardResults.length; i++) {
          const result = rewardResults[i];
          if (result.status === 'success') {
            const tokenId = rewardCalls[i].args[0][0].toString();
            const reward = Number(BigInt(result.result[1] || 0)) / 1e18;
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.claimableRewards += reward;
              await db.run('UPDATE tokens SET reward = ?, lastUpdated = ? WHERE tokenId = ?', [reward, Date.now(), tokenId]);
              await db.run('UPDATE holders SET claimableRewards = ? WHERE wallet = ?', [holder.claimableRewards, owner]);
            }
          }
        }
        timings.rewardFetch = Date.now() - rewardFetchStart;

        const metricsStart = Date.now();
        const multipliers = Object.values(tiers).map(t => t.multiplier);
        let totalMultiplierSum = 0;
        const holders = await db.all('SELECT * FROM holders');
        for (const holder of holders) {
          holder.tiers = JSON.parse(holder.tiers);
          holder.multiplierSum = holder.tiers.reduce((sum, count, index) => sum + count * (multipliers[index] || 0), 0);
          holder.displayMultiplierSum = holder.multiplierSum / 10;
          totalMultiplierSum += holder.multiplierSum;
          await db.run('UPDATE holders SET multiplierSum = ?, displayMultiplierSum = ? WHERE wallet = ?', 
            [holder.multiplierSum, holder.displayMultiplierSum, holder.wallet]);
        }
        holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
        for (let i = 0; i < holders.length; i++) {
          const holder = holders[i];
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          holder.rank = i + 1;
          await db.run('UPDATE holders SET percentage = ?, rank = ? WHERE wallet = ?', [holder.percentage, holder.rank, holder.wallet]);
        }
        timings.metricsCalc = Date.now() - metricsStart;

        timings.total = Date.now() - totalStart;
        const summary = {
          totalDurationMs: timings.total,
          phases: { 
            fetchTotalSupply: timings.totalSupply, 
            fetchTokenIds: timings.tokenIdFetch, 
            holderInit: timings.holderInit, 
            fetchTiers: timings.tierFetch, 
            fetchRewards: timings.rewardFetch, 
            calculateMetrics: timings.metricsCalc 
          },
          nftsProcessed: ownershipByToken.size,
          walletsProcessed: ownershipByWallet.size,
          errors: errorLog,
        };
        await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'lastSummary', JSON.stringify(summary));
        progressState = { 
          step: 'idle', 
          processedNfts: ownershipByToken.size, 
          totalNfts: MAX_INITIAL_SUPPLY, 
          totalWallets: ownershipByWallet.size 
        };
        log(`[element280] Cache population completed in ${timings.total}ms, holders: ${ownershipByWallet.size}, errors: ${errorLog.length}`);
      })(),
      timeoutPromise,
    ]);
  } catch (error) {
    log(`[element280] error: Cache population failed: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'lastSummary', JSON.stringify({
      totalDurationMs: Date.now() - totalStart, 
      phases: timings, 
      nftsProcessed: ownershipByToken.size || 0, 
      walletsProcessed: ownershipByWallet.size || 0, 
      errors: errorLog 
    }));
    throw error;
  } finally {
    isCachePopulating = false;
  }
}

// Get holder data
async function getHolderData(contractAddress, wallet, tiers) {
  const cacheKey = `${contractAddress}-${wallet}`;
  const cached = cache.get(cacheKey);
  if (cached) return cached;

  const db = await initDb();
  try {
    let holder = await db.get('SELECT * FROM holders WHERE wallet = ?', wallet.toLowerCase());
    if (holder) {
      holder.tiers = JSON.parse(holder.tiers);
      holder.tokenIds = JSON.parse(holder.tokenIds);
      cache.set(cacheKey, holder);
      return serializeBigInt(holder);
    }

    holder = {
      wallet: wallet.toLowerCase(),
      total: 0,
      totalLive: 0,
      multiplierSum: 0,
      displayMultiplierSum: 0,
      tiers: Array(6).fill(0),
      tokenIds: [],
      claimableRewards: 0,
      percentage: 0,
      rank: 0,
    };

    const tokenIds = await retry(() => client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [wallet.toLowerCase()],
    }));
    holder.total = tokenIds.length;
    holder.totalLive = tokenIds.length;
    if (tokenIds.length === 0) return null;

    const calls = tokenIds.flatMap(tokenId => [
      { address: contractAddress, abi: element280MainAbi, functionName: 'getNftTier', args: [tokenId] },
      { address: vaultAddresses.element280.address, abi: element280VaultAbi, functionName: 'getRewards', args: [[tokenId], wallet.toLowerCase()] },
    ]);
    const results = await batchMulticall(calls, 50);
    let totalRewards = 0;
    for (let i = 0; i < tokenIds.length; i++) {
      const tierResult = results[i * 2];
      const rewardResult = results[i * 2 + 1];
      const tokenId = tokenIds[i].toString();
      if (tierResult.status === 'success' && Number(tierResult.result) >= 1 && Number(tierResult.result) <= 6) {
        const tier = Number(tierResult.result);
        holder.tiers[tier - 1]++;
        holder.tokenIds.push(tokenId);
        await db.run('INSERT OR REPLACE INTO tokens (tokenId, owner, tier, reward, lastUpdated) VALUES (?, ?, ?, ?, ?)', 
          [tokenId, wallet.toLowerCase(), tier, 0, Date.now()]);
      }
      if (rewardResult.status === 'success') {
        const reward = Number(BigInt(rewardResult.result[1] || 0)) / 1e18;
        totalRewards += reward;
        await db.run('UPDATE tokens SET reward = ?, lastUpdated = ? WHERE tokenId = ?', [reward, Date.now(), tokenId]);
      }
    }
    holder.claimableRewards = totalRewards;
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    holder.multiplierSum = holder.tiers.reduce((sum, count, index) => sum + count * (multipliers[index] || 0), 0);
    holder.displayMultiplierSum = holder.multiplierSum / 10;

    const allHolders = await db.all('SELECT * FROM holders');
    const totalMultiplierSum = allHolders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    const sortedHolders = allHolders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holder.rank = sortedHolders.findIndex(h => h.wallet === wallet.toLowerCase()) + 1 || sortedHolders.length + 1;

    await db.run(
      'INSERT OR REPLACE INTO holders (wallet, total, totalLive, multiplierSum, displayMultiplierSum, tiers, tokenIds, claimableRewards, percentage, rank) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [holder.wallet, holder.total, holder.totalLive, holder.multiplierSum, holder.displayMultiplierSum, JSON.stringify(holder.tiers), JSON.stringify(holder.tokenIds), holder.claimableRewards, holder.percentage, holder.rank]
    );
    cache.set(cacheKey, holder);
    return serializeBigInt(holder);
  } catch (error) {
    log(`[element280] error: getHolderData failed for wallet ${wallet}: ${error.message}`);
    throw error;
  }
}

// Get all holders
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const cached = cache.get(cacheKey);
  if (!refresh && cached) {
    return cached; // Silent cache hit
  }

  const db = await initDb();
  try {
    if (refresh) await populateHoldersMapCache(contractAddress, tiers);

    const totalSupply = await getTotalSupply(contractAddress, db);
    const holders = await db.all('SELECT * FROM holders LIMIT ? OFFSET ?', Math.min(pageSize, 100), page * Math.min(pageSize, 100));
    const totalHolders = (await db.get('SELECT COUNT(*) as count FROM holders')).count;
    const totalTokens = holders.reduce((sum, h) => sum + h.total, 0) || totalSupply;
    const invalidTokens = (await db.get('SELECT value FROM metadata WHERE key = ?', 'invalidTokens'))?.value || (MAX_INITIAL_SUPPLY - totalSupply);

    if (totalSupply + invalidTokens > MAX_INITIAL_SUPPLY) {
      log(`[element280] error: Data mismatch: totalSupply=${totalSupply}, invalidTokens=${invalidTokens}, exceeds MAX_INITIAL_SUPPLY=${MAX_INITIAL_SUPPLY}`);
    }

    const result = {
      holders: holders.map(h => ({ 
        ...h, 
        tiers: JSON.parse(h.tiers), 
        tokenIds: JSON.parse(h.tokenIds), 
        claimableRewards: Number(h.claimableRewards) 
      })),
      totalTokens,
      totalHolders,
      page,
      pageSize: Math.min(pageSize, 100),
      totalPages: Math.ceil(totalHolders / Math.min(pageSize, 100)),
      summary: {
        totalLive: totalSupply,
        totalBurned: invalidTokens,
        multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
        totalRewardPool: holders.reduce((sum, h) => sum + Number(h.claimableRewards), 0),
      },
    };
    cache.set(cacheKey, result);
    return serializeBigInt(result);
  } catch (error) {
    log(`[element280] error: getAllHolders failed for page=${page}: ${error.message}`);
    throw error;
  }
}

// GET handler
export async function GET(request) {
  const { searchParams, pathname } = new URL(request.url);
  const address = contractAddresses.element280.address;
  if (!address) return NextResponse.json({ error: 'Element280 contract address not found', code: 400 }, { status: 400 });

  try {
    const db = await initDb();
    if (pathname.endsWith('/summary')) {
      const summary = await db.get('SELECT value FROM metadata WHERE key = ?', 'lastSummary');
      return NextResponse.json(summary ? JSON.parse(summary.value) : { error: 'No summary available', code: 404 }, { status: summary ? 200 : 404 });
    }

    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    if (isCachePopulating && !wallet) {
      const cached = cache.get(`${address}-all-${page}-${pageSize}`);
      if (cached) {
        return NextResponse.json(serializeBigInt(cached), { headers: { 'X-Cache-Status': 'stale' } });
      }
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      return NextResponse.json(serializeBigInt(result), { headers: { 'X-Cache-Status': cache.get(`${address}-all-${page}-${pageSize}`) ? 'hit' : 'miss' } });
    }
  } catch (error) {
    const status = error.details?.code === 429 ? 429 : 500;
    const message = error.details?.code === 429 ? 'Rate limit exceeded' : `Server error: ${error.message}`;
    log(`[element280] error: GET error: ${message}`);
    return NextResponse.json({ error: message, code: status }, { status });
  }
}

// POST handler
export async function POST() {
  const address = contractAddresses.element280.address;
  if (!address) return NextResponse.json({ error: 'Element280 contract address not found', code: 400 }, { status: 400 });

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    const db = await initDb();
    const totalHolders = (await db.get('SELECT COUNT(*) as count FROM holders')).count;
    log(`[element280] Cache preload completed, total holders: ${totalHolders}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders });
  } catch (error) {
    log(`[element280] error: Cache preload failed: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}`, code: 500 }, { status: 500 });
  }
}

// Initialize cache on startup
let cacheInitialized = false;
if (!cacheInitialized) {
  cacheInitialized = true;
  (async () => {
    try {
      await populateHoldersMapCache(contractAddresses.element280.address, contractTiers.element280);
    } catch (error) {
      log(`[element280] error: Initial cache population failed: ${error.message}`);
    }
  })();
}-e 
---
File: ./app/api/holders/Element280/route copy.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';

// In-memory cache
let cache = {};
let tokenCache = new Map();
let holdersMapCache = null;
let isCachePopulating = false;
let totalOwners = 0;
let totalSupplyCache = null;
let totalBurnedCache = null;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0 };

// Export cache state for /progress route
export function getCacheState() {
  return { isCachePopulating, holdersMapCache, totalOwners, progressState };
}

// Utility to serialize BigInt values
function serializeBigInt(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )
  );
}

// Retry utility with minimal logging
async function retry(fn, attempts = 5, delay = (retryCount, error) => (error?.details?.code === 429 ? 4000 * 2 ** retryCount : 2000), strict = true) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        log(`[element280] Retry failed after ${attempts} attempts: ${error.message}`);
        if (strict) throw error;
        return null;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch and cache total supply and burned tokens
async function getTotalSupply(contractAddress, errorLog) {
  const contractName = 'element280';
  if (totalSupplyCache !== null && totalBurnedCache !== null) {
    return totalSupplyCache;
  }
  const startTime = Date.now();
  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalSupply',
          },
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalBurned',
          },
        ],
      })
    );
    const totalSupply = results[0].status === 'success' ? Number(results[0].result) : 0;
    const totalBurned = results[1].status === 'success' && results[1].result != null ? Number(results[1].result) : 0;
    if (isNaN(totalSupply) || isNaN(totalBurned)) {
      const errorMsg = `Invalid totalSupply=${totalSupply} or totalBurned=${totalBurned}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: errorMsg });
      throw new Error(errorMsg);
    }
    totalSupplyCache = totalSupply;
    totalBurnedCache = totalBurned;
    log(`[element280] Fetched total supply: ${totalSupplyCache}, total burned: ${totalBurnedCache} in ${Date.now() - startTime}ms`);
    return totalSupplyCache;
  } catch (error) {
    log(`[element280] Failed to fetch total supply or burned: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: error.message });
    throw error;
  }
}

// Fetch all NFT ownership data using contract calls
async function fetchAllNftOwnership(contractAddress, errorLog, timings) {
  const contractName = 'element280';
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();
  const burnAddress = '0x0000000000000000000000000000000000000000';

  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    const errorMsg = `Invalid contract address: ${contractAddress}`;
    log(`[element280] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_contract', error: errorMsg });
    throw new Error(errorMsg);
  }
  log(`[element280] Starting NFT ownership fetch for contract: ${contractAddress}`);

  try {
    // Step 1: Get token IDs from Alchemy
    const tokenIdStart = Date.now();
    let pageKey = null;
    let pageCount = 0;
    let tokenIds = [];
    do {
      pageCount++;
      const response = await retry(() =>
        alchemy.nft.getNftsForContract(contractAddress, { pageKey })
      );
      if (!response.nfts || !Array.isArray(response.nfts)) {
        const errorMsg = `Invalid NFT response: nfts array missing`;
        log(`[element280] ${errorMsg}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
        throw new Error(errorMsg);
      }
      response.nfts.forEach(nft => {
        const tokenId = nft.tokenId || nft.id || nft.token_id;
        if (tokenId) tokenIds.push(tokenId);
      });
      pageKey = response.pageKey;
    } while (pageKey);
    timings.tokenIdFetch = Date.now() - tokenIdStart;
    log(`[element280] Collected ${tokenIds.length} token IDs in ${timings.tokenIdFetch}ms`);

    if (tokenIds.length === 0) {
      const errorMsg = `No token IDs found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
      throw new Error(errorMsg);
    }

    // Step 2: Fetch owners via contract ownerOf calls
    const ownerFetchStart = Date.now();
    const ownerCalls = tokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'ownerOf',
      args: [BigInt(tokenId)],
    }));
    const limit = pLimit(10);
    const chunkSize = 100;
    const ownerResults = [];
    for (let i = 0; i < ownerCalls.length; i += chunkSize) {
      const chunk = ownerCalls.slice(i, i + chunkSize);
      const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
      ownerResults.push(...results);
    }
    timings.ownerFetch = Date.now() - ownerFetchStart;
    log(`[element280] Fetched owners for ${ownerResults.length} tokens in ${timings.ownerFetch}ms`);

    // Step 3: Process owners
    const ownerProcessStart = Date.now();
    let invalidTokens = 0;
    let nonExistentTokens = 0;
    tokenIds.forEach((tokenId, index) => {
      const result = ownerResults[index];
      if (result.status === 'success') {
        const owner = result.result.toLowerCase();
        if (owner && owner !== burnAddress) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        } else {
          invalidTokens++;
        }
      } else {
        if (result.error?.message.includes('0xdf2d9b42')) {
          nonExistentTokens++;
        } else {
          log(`[element280] Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owners', error: `Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
        invalidTokens++;
      }
    });
    timings.ownerProcess = Date.now() - ownerProcessStart;
    log(`[element280] Processed owners: ${ownershipByToken.size} valid NFTs, skipped ${invalidTokens} invalid tokens (including ${nonExistentTokens} non-existent) in ${timings.ownerProcess}ms`);

    // Step 4: Validate against totalSupply
    const totalSupply = await getTotalSupply(contractAddress, errorLog);
    const expectedLiveTokens = totalSupply - (totalBurnedCache || 0);
    if (ownershipByToken.size === 0) {
      const errorMsg = `No valid NFTs with owners found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
      throw new Error(errorMsg);
    }
    if (ownershipByToken.size > expectedLiveTokens) {
      const errorMsg = `Found ${ownershipByToken.size} NFTs, more than expected ${expectedLiveTokens}`;
      log(`[element280] Warning: ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    }

    log(`[element280] Completed ownership fetch: ${ownershipByToken.size} NFTs across ${ownershipByWallet.size} wallets`);
    return { ownershipByToken, ownershipByWallet };
  } catch (error) {
    log(`[element280] Failed to fetch NFT ownership: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_ownership', error: error.message });
    throw error;
  }
}

// Populate holdersMapCache with timing and error tracking
async function populateHoldersMapCache(contractAddress, tiers) {
  const contractName = 'element280';
  log(`[element280] Starting populateHoldersMapCache for contract: ${contractAddress}`);
  if (isCachePopulating) {
    log(`[element280] Cache population already in progress`);
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 };
  const timings = {
    totalSupply: 0,
    tokenIdFetch: 0,
    ownerFetch: 0,
    ownerProcess: 0,
    holderInit: 0,
    tierFetch: 0,
    rewardFetch: 0,
    metricsCalc: 0,
    total: 0,
  };
  const errorLog = [];
  const totalStart = Date.now();

  try {
    holdersMapCache = new Map();

    // Step 1: Fetch total supply
    const supplyStart = Date.now();
    const totalTokens = await getTotalSupply(contractAddress, errorLog);
    timings.totalSupply = Date.now() - supplyStart;
    progressState = { step: 'fetching_ownership', processedNfts: 0, totalNfts: totalTokens };
    log(`[element280] Fetched total supply: ${totalTokens} in ${timings.totalSupply}ms`);

    // Step 2: Fetch all NFT ownership
    const { ownershipByToken, ownershipByWallet } = await fetchAllNftOwnership(contractAddress, errorLog, timings);
    totalOwners = ownershipByWallet.size;
    progressState = { step: 'initializing_holders', processedNfts: ownershipByToken.size, totalNfts: totalTokens };
    log(`[element280] Fetched ownership: ${ownershipByToken.size} NFTs, ${totalOwners} wallets`);

    // Step 3: Initialize holders
    const holderInitStart = Date.now();
    ownershipByWallet.forEach((tokenIds, wallet) => {
      const holder = {
        wallet,
        total: tokenIds.length,
        totalLive: tokenIds.length,
        multiplierSum: 0,
        displayMultiplierSum: 0,
        tiers: Array(6).fill(0),
        tokenIds: tokenIds.map(id => BigInt(id)),
        claimableRewards: 0,
        percentage: 0,
        rank: 0,
      };
      holdersMapCache.set(wallet, holder);
      tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
    });
    timings.holderInit = Date.now() - holderInitStart;
    log(`[element280] Initialized ${holdersMapCache.size} holders in ${timings.holderInit}ms`);
    progressState = { step: 'fetching_tiers', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 4: Batch fetch tiers
    const tierFetchStart = Date.now();
    const allTokenIds = Array.from(ownershipByToken.keys()).map(id => BigInt(id));
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    if (tierCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const tierResults = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        tierResults.push(...results);
        progressState = {
          step: 'fetching_tiers',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      tierResults.forEach((result, index) => {
        const tokenId = allTokenIds[index].toString();
        if (result.status === 'success') {
          const tier = Number(result.result);
          if (tier >= 1 && tier <= 6) {
            const owner = ownershipByToken.get(tokenId);
            const holder = holdersMapCache.get(owner);
            if (holder) {
              holder.tiers[tier - 1]++;
              tokenCache.set(`${contractAddress}-${tokenId}-tier`, tier);
            } else {
              log(`[element280] Warning: No holder found for token ${tokenId} (owner: ${owner})`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `No holder found for token ${tokenId} (owner: ${owner})` });
            }
          } else {
            log(`[element280] Invalid tier ${tier} for token ${tokenId}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Invalid tier ${tier} for token ${tokenId}` });
          }
        } else {
          log(`[element280] Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
      });
    }
    timings.tierFetch = Date.now() - tierFetchStart;
    log(`[element280] Fetched tiers for ${allTokenIds.length} NFTs in ${timings.tierFetch}ms`);
    progressState = { step: 'fetching_rewards', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 5: Batch fetch rewards
    const rewardFetchStart = Date.now();
    const rewardCalls = [];
    ownershipByWallet.forEach((tokenIds, wallet) => {
      tokenIds.forEach(tokenId => {
        rewardCalls.push({
          address: vaultAddresses.element280.address,
          abi: element280VaultAbi,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], wallet],
        });
      });
    });
    if (rewardCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const rewardResults = [];
      for (let i = 0; i < rewardCalls.length; i += chunkSize) {
        const chunk = rewardCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        rewardResults.push(...results);
        progressState = {
          step: 'fetching_rewards',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      let resultIndex = 0;
      ownershipByWallet.forEach((tokenIds, wallet) => {
        let totalRewards = 0n;
        tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          } else {
            log(`[element280] Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}` });
          }
        });
        const holder = holdersMapCache.get(wallet);
        if (holder) {
          holder.claimableRewards = Number(totalRewards) / 1e18;
          if (isNaN(holder.claimableRewards)) {
            holder.claimableRewards = 0;
            log(`[element280] Warning: NaN rewards for wallet ${wallet}, set to 0`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `NaN rewards for wallet ${wallet}` });
          }
          tokenCache.set(`${contractName}-${wallet}-reward`, holder.claimableRewards);
        }
      });
    }
    timings.rewardFetch = Date.now() - rewardFetchStart;
    log(`[element280] Fetched rewards for ${rewardCalls.length} NFTs in ${timings.rewardFetch}ms`);
    progressState = { step: 'calculating_metrics', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 6: Calculate multipliers and metrics
    const metricsStart = Date.now();
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    const totalMultiplierSum = Array.from(holdersMapCache.values()).reduce((sum, holder) => {
      holder.multiplierSum = holder.tiers.reduce(
        (sum, count, index) => sum + count * (multipliers[index] || 0),
        0
      );
      holder.displayMultiplierSum = holder.multiplierSum / 10;
      return sum + holder.multiplierSum;
    }, 0);
    const holders = Array.from(holdersMapCache.values());
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    });
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
      holdersMapCache.set(holder.wallet, holder);
    });
    timings.metricsCalc = Date.now() - metricsStart;
    log(`[element280] Calculated metrics for ${holders.length} holders in ${timings.metricsCalc}ms`);
    progressState = { step: 'idle', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Log summary
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: ownershipByToken.size,
      walletsProcessed: ownershipByWallet.size,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);

  } catch (error) {
    log(`[element280] Failed to populate holdersMapCache: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    holdersMapCache = null;
    cache = {};
    progressState = { step: 'error', processedNfts: 0, totalNfts: 0 };

    // Log summary on error
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: 0,
      walletsProcessed: 0,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start (Failed) =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);
    throw error;
  } finally {
    isCachePopulating = false;
    totalOwners = 0;
    log(`[element280] Cache population complete, isCachePopulating=false, totalOwners=0`);
  }
}

// Fetch holder data for a specific wallet
async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();
  const walletLower = wallet.toLowerCase();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  while (isCachePopulating) {
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  if (holdersMapCache?.has(walletLower)) {
    const holder = holdersMapCache.get(walletLower);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }

  const holder = {
    wallet: walletLower,
    total: 0,
    totalLive: 0,
    multiplierSum: 0,
    displayMultiplierSum: 0,
    tiers: Array(6).fill(0),
    tokenIds: [],
    claimableRewards: 0,
    percentage: 0,
    rank: 0,
  };

  const tokenIdsResponse = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [walletLower],
    })
  );
  const tokenIds = tokenIdsResponse.map(id => id.toString());
  const nfts = tokenIds.map(tokenId => ({ tokenId, tier: 0 }));
  holder.total = nfts.length;
  holder.totalLive = nfts.length;
  tokenCache.set(`${contractAddress}-${walletLower}-nfts`, nfts);

  if (nfts.length === 0) {
    return null;
  }

  const bigIntTokenIds = nfts.map(nft => BigInt(nft.tokenId));
  const calls = [];
  bigIntTokenIds.forEach(tokenId => {
    calls.push({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    });
    calls.push({
      address: vaultAddresses.element280.address,
      abi: element280VaultAbi,
      functionName: 'getRewards',
      args: [[tokenId], walletLower],
    });
  });

  const results = await retry(() => client.multicall({ contracts: calls }));
  const finalTokenIds = [];
  let totalRewards = 0n;
  nfts.forEach((nft, index) => {
    const tierResult = results[index * 2];
    const rewardResult = results[index * 2 + 1];
    if (tierResult.status === 'success') {
      const tier = Number(tierResult.result);
      if (tier >= 1 && tier <= 6) {
        nft.tier = tier;
        holder.tiers[tier - 1]++;
        finalTokenIds.push(BigInt(nft.tokenId));
        tokenCache.set(`${contractAddress}-${nft.tokenId}-tier`, tier);
      }
    }
    if (rewardResult.status === 'success') {
      const rewardValue = BigInt(rewardResult.result[1] || 0);
      totalRewards += rewardValue;
      tokenCache.set(`${contractAddress}-${nft.tokenId}-single-reward`, rewardValue);
    }
  });
  holder.tokenIds = finalTokenIds;
  holder.claimableRewards = Number(totalRewards) / 1e18;
  if (isNaN(holder.claimableRewards)) {
    holder.claimableRewards = 0;
  }
  tokenCache.set(`${contractName}-${walletLower}-reward`, holder.claimableRewards);

  const multipliers = Object.values(tiers).map(t => t.multiplier);
  holder.multiplierSum = holder.tiers.reduce(
    (sum, count, index) => sum + count * (multipliers[index] || 0),
    0
  );
  holder.displayMultiplierSum = holder.multiplierSum / 10;

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 100);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
  const existingHolder = allHolders.holders.find(h => h.wallet === walletLower);
  holder.rank = existingHolder ? existingHolder.rank : allHolders.holders.length + 1;

  if (holder.total > 0) {
    holdersMapCache?.set(walletLower, holder);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }
  return null;
}

// Fetch all holders (paginated)
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (!refresh && cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  let holdersMap = holdersMapCache;
  if (refresh || !holdersMap || isCachePopulating) {
    while (isCachePopulating) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (refresh || !holdersMap) {
      await populateHoldersMapCache(contractAddress, tiers);
      holdersMap = holdersMapCache;
      if (!holdersMap) {
        log(`[element280] Error: holdersMapCache is null after population`);
        throw new Error('Failed to populate holdersMapCache');
      }
    }
  }

  const totalTokens = await getTotalSupply(contractAddress, []);
  const holders = Array.from(holdersMap.values());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, holders.length);
  const paginatedHolders = holders.slice(start, end);

  const result = {
    holders: paginatedHolders,
    totalTokens: holdersMap.size > 0 ? holders.reduce((sum, h) => sum + h.total, 0) : totalTokens,
    totalHolders: holders.length,
    page,
    pageSize,
    totalPages: Math.ceil(holders.length / pageSize),
    summary: {
      totalLive: totalTokens,
      totalBurned: totalBurnedCache || 0,
      multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      totalRewardPool: holders.reduce((sum, h) => sum + h.claimableRewards, 0),
    },
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`[element280] Paginated ${paginatedHolders.length} holders: totalHolders=${holders.length}, totalBurned=${result.summary.totalBurned}, multiplierPool=${result.summary.multiplierPool}`);
  return serializeBigInt(result);
}

// GET handler
export async function GET(request) {
  const contractName = 'element280';
  let url = request.url || (request.nextUrl && request.nextUrl.toString());
  if (!url) {
    log(`[element280] Error: Both request.url and request.nextUrl are undefined`);
    return NextResponse.json({ error: 'Invalid request: URL is undefined' }, { status: 400 });
  }

  try {
    const { searchParams } = new URL(url);
    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    const address = contractAddresses.element280.address;
    if (!address) {
      log(`[element280] Error: Element280 contract address not found`);
      return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      log(`[element280] GET /api/holders/Element280?wallet=${wallet} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      log(`[element280] GET /api/holders/Element280?page=${page}&pageSize=${pageSize} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt(result));
    }
  } catch (error) {
    log(`[element280] Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

// POST handler
export async function POST() {
  const contractName = 'element280';
  const address = contractAddresses.element280.address;
  if (!address) {
    log(`[element280] Error: Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    log(`[element280] Cache preload completed, total holders: ${holdersMapCache?.size || 0}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders: holdersMapCache?.size || 0 });
  } catch (error) {
    log(`[element280] Error in POST /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element369/route.js
// app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, element369VaultAbi, element369Abi } from '../../utils';

const contractAddress = nftContracts.element369?.address;
const vaultAddress = nftContracts.element369?.vaultAddress;
const tiersConfig = nftContracts.element369?.tiers;
const defaultPageSize = contractDetails.element369?.pageSize || 1000;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || defaultPageSize);
  const wallet = searchParams.get('wallet');

  log(`[Element369] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Element369 contract or vault address missing');
    }

    const cacheKey = `element369_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL) {
      log(`[Element369] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Element369] Cache miss: ${cacheKey}`);

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Element369] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const filteredOwners = ownersResponse.owners.filter(
      owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
    );
    log(`[Element369] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
      ownerTokens.set(wallet, tokenIds);
    });
    log(`[Element369] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Element369] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element369Abi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Element369] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const wallet = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && wallet) {
          if (!holdersMap.has(wallet)) {
            holdersMap.set(wallet, {
              wallet,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier + 1).fill(0),
              infernoRewards: 0,
              fluxRewards: 0,
              e280Rewards: 0,
            });
          }
          const holder = holdersMap.get(wallet);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier] += 1;
        } else {
          log(`[Element369] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Element369] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch current cycle for debugging
    let currentCycle = 0;
    try {
      currentCycle = await client.readContract({
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getCurrentE369Cycle',
      });
      log(`[Element369] Current cycle: ${currentCycle}`);
    } catch (error) {
      log(`[Element369] Error fetching cycle: ${error.message}`);
    }

    // Fetch rewards
    const holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet, false], // isBacking: false for claimable rewards
      };
    });

    log(`[Element369] Fetching rewards for ${holders.length} holders`);
    const rewardsResults = await batchMulticall(rewardCalls);

    holders.forEach((holder, i) => {
      if (rewardsResults[i]?.status === 'success' && rewardsResults[i].result) {
        const [availability, burned, infernoPool, fluxPool, e280Pool] = rewardsResults[i].result;
        holder.infernoRewards = Number(infernoPool) / 1e18;
        holder.fluxRewards = Number(fluxPool) / 1e18;
        holder.e280Rewards = Number(e280Pool) / 1e18;
        log(
          `[Element369] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Inferno=${holder.infernoRewards.toFixed(4)}, ` +
          `Flux=${holder.fluxRewards.toFixed(4)}, ` +
          `E280=${holder.e280Rewards.toFixed(4)}, ` +
          `Tokens=${availability.length}, Burned=${burned.filter(b => b).length}, ` +
          `Availability=${availability.join(',')}`
        );
        if (holder.infernoRewards === 0 && holder.fluxRewards === 0 && holder.e280Rewards === 0) {
          log(`[Element369] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.infernoRewards = 0;
        holder.fluxRewards = 0;
        holder.e280Rewards = 0;
        log(`[Element369] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardsResults[i]?.error || 'Unknown'}`);
      }
      holder.displayMultiplierSum = holder.multiplierSum;
      holder.percentage = 0;
      holder.rank = 0;
    });

    // Calculate percentages and ranks
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holders.forEach((holder, index) => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.rank = index + 1;
      holder.displayMultiplierSum = holder.multiplierSum;
    });

    // Sort holders
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Element369] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Element369] Error: ${error.message}`);
    console.error('[Element369] Error stack:', error.stack);
    return NextResponse.json({ error: 'Failed to fetch Element369 data' }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Ascendant/route.js
// app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers, contractDetails } from '@/app/nft-contracts';
import { formatUnits, getAddress } from 'viem';
import { v4 as uuidv4 } from 'uuid';
import ascendantABI from '../../../../abi/ascendantNFT.json';

let cache = {};
let tokenCache = new Map();

// Utility to sanitize BigInt values
function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') {
    return obj.toString();
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => sanitizeBigInt(item));
  }
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}

// Utility to serialize response objects
function safeSerialize(obj) {
  return JSON.parse(JSON.stringify(obj, (key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  ));
}

// Fetch data for all holders with pagination
async function getAllHolders(page = 0, pageSize = 1000, requestId = '') {
  const contractAddress = contractAddresses.ascendant.address; // Fix: Use .address
  const tiers = contractTiers.ascendant;
  const defaultPageSize = contractDetails.ascendant?.pageSize || 1000;
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  if (!contractAddress || !tiers) {
    throw new Error('Missing contract address or tiers');
  }

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  let owners = [];
  let pageKey = null;
  do {
    const response = await retry(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        block: 'latest',
        withTokenBalances: true,
        pageKey,
      })
    );
    owners = owners.concat(response.owners);
    pageKey = response.pageKey;
  } while (pageKey);

  const burnAddress = '0x000000000000000 DOB0000000000000000000000';
  const filteredOwners = owners.filter(
    (owner) => owner?.ownerAddress && owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances?.length > 0
  );

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach((owner) => {
    if (!owner.ownerAddress) return;
    let wallet;
    try {
      wallet = getAddress(owner.ownerAddress);
    } catch (e) {
      return;
    }
    owner.tokenBalances.forEach((tb) => {
      if (!tb.tokenId) return;
      const tokenId = Number(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);

  if (paginatedTokenIds.length === 0) {
    const result = {
      holders: [],
      totalTokens,
      totalLockedAscendant: 0,
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = paginatedTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = paginatedTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));

  const [rawTierResults, rawRecordResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults);
  const recordResults = sanitizeBigInt(rawRecordResults);

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));
  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));
  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));
  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  const walletTokenIds = new Map();
  paginatedTokenIds.forEach((tokenId) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!walletTokenIds.has(wallet)) {
      walletTokenIds.set(wallet, []);
    }
    walletTokenIds.get(wallet).push(tokenId);
  });

  const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'batchClaimableAmount',
    args: [tokenIds.map((id) => BigInt(id))],
  }));

  const rawClaimableResults = await retry(() => batchMulticall(claimableCalls));
  const claimableResults = sanitizeBigInt(rawClaimableResults);

  paginatedTokenIds.forEach((tokenId, i) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!holdersMap.has(wallet)) {
      holdersMap.set(wallet, {
        wallet,
        total: 0,
        multiplierSum: 0,
        tiers: Array(maxTier + 1).fill(0),
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: 0,
        pendingDay28: 0,
        pendingDay90: 0,
        claimableRewards: 0,
      });
    }
    const holder = holdersMap.get(wallet);

    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      holder.tiers[tier] += 1;
      holder.total += 1;
      holder.multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const shares = parseFloat(formatUnits(sharesRaw, 18));
      const lockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      holder.shares += shares;
      holder.lockedAscendant += lockedAscendant;
      totalLockedAscendant += lockedAscendant;
    }
  });

  let claimableIndex = 0;
  for (const [wallet, tokenIds] of walletTokenIds.entries()) {
    const holder = holdersMap.get(wallet);
    if (!holder) {
      claimableIndex++;
      continue;
    }
    if (claimableResults[claimableIndex]?.status === 'success') {
      const claimableRaw = claimableResults[claimableIndex].result || '0';
      holder.claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
    }
    claimableIndex++;
  }

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach((holder) => {
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders: sanitizeBigInt(holders),
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  return result;
}

// Fetch data for a specific wallet
async function getHolderData(wallet, requestId = '') {
  const contractAddress = contractAddresses.ascendant.address; // Fix: Use .address
  const tiers = contractTiers.ascendant;
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();


  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  const checksummedWallet = getAddress(wallet);

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  const nfts = await retry(() =>
    alchemy.nft.getNftsForOwner(checksummedWallet, { contractAddresses: [contractAddress] })
  );

  if (nfts.totalCount === 0) return null;

  const tokenIds = nfts.ownedNfts
    .filter((nft) => nft.contract.address.toLowerCase() === contractAddress.toLowerCase())
    .map((nft) => Number(nft.tokenId));

  if (tokenIds.length === 0) return null;

  const tierCalls = tokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = tokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));
  const claimableCall = [
    {
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'batchClaimableAmount',
      args: [tokenIds.map((id) => BigInt(id))],
    },
  ];

  const [rawTierResults, rawRecordResults, rawClaimableResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
    retry(() => batchMulticall(claimableCall)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults);
  const recordResults = sanitizeBigInt(rawRecordResults);
  const claimableResults = sanitizeBigInt(rawClaimableResults);

  let claimableRewards = 0;
  if (claimableResults[0]?.status === 'success') {
    const claimableRaw = claimableResults[0].result || '0';
    claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
  }

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;
  let shares = 0;
  let lockedAscendant = 0;

  tokenIds.forEach((tokenId, i) => {
    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      tiersArray[tier] += 1;
      total += 1;
      multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const tokenShares = parseFloat(formatUnits(sharesRaw, 18));
      const tokenLockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      shares += tokenShares;
      lockedAscendant += tokenLockedAscendant;
    }
  });

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  const totalMultiplierSum = multiplierSum || 1;
  const percentage = (multiplierSum / totalMultiplierSum) * 100;
  const rank = 1;

  const result = {
    wallet: checksummedWallet,
    rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum,
    percentage,
    tiers: tiersArray,
    shares,
    lockedAscendant,
    pendingDay8: shares * pendingRewardPerShareDay8,
    pendingDay28: shares * pendingRewardPerShareDay28,
    pendingDay90: shares * pendingRewardPerShareDay90,
    claimableRewards,
  };

  const sanitizedResult = sanitizeBigInt(result);
  cache[cacheKey] = { timestamp: now, data: sanitizedResult };
  return sanitizedResult;
}

// API endpoint handler
export async function GET(request) {
  const requestId = uuidv4();
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || contractDetails.ascendant?.pageSize || 1000, 10);

  try {
    if (wallet) {
      const holderData = await getHolderData(wallet, requestId);
      const response = { holders: holderData ? [holderData] : [] };
      return NextResponse.json(safeSerialize(response));
    }

    const result = await getAllHolders(page, pageSize, requestId);
    return NextResponse.json(safeSerialize(result));
  } catch (error) {
    console.error(`[${requestId}] [PROD_ERROR] Ascendant API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Stax/route.js
// app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, staxNFTAbi, staxVaultAbi } from '../../utils';

const contractAddress = nftContracts.stax?.address;
const vaultAddress = nftContracts.stax?.vaultAddress;
const tiersConfig = nftContracts.stax?.tiers;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '1000');
  const wallet = searchParams.get('wallet');

  log(`[Stax] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Stax contract or vault address missing');
    }

    const cacheKey = `stax_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL) {
      log(`[Stax] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Stax] Cache miss: ${cacheKey}`);

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Stax] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddresses = [
      '0x0000000000000000000000000000000000000000',
      '0x000000000000000000000000000000000000dead',
    ];
    const filteredOwners = ownersResponse.owners.filter(
      owner => !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
    );
    log(`[Stax] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
      ownerTokens.set(wallet, tokenIds);
    });
    log(`[Stax] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Stax] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: staxNFTAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Stax] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const wallet = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && wallet) {
          if (!holdersMap.has(wallet)) {
            holdersMap.set(wallet, {
              wallet,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier + 1).fill(0),
              claimableRewards: 0,
            });
          }
          const holder = holdersMap.get(wallet);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier] += 1;
        } else {
          log(`[Stax] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Stax] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch rewards
    const holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: staxVaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet],
      };
    });

    const totalRewardPoolCall = {
      address: vaultAddress,
      abi: staxVaultAbi,
      functionName: 'totalRewardPool',
      args: [],
    };

    log(`[Stax] Fetching rewards for ${holders.length} holders`);
    const [rewardResults, totalRewardPoolResult] = await Promise.all([
      rewardCalls.length ? batchMulticall(rewardCalls) : [],
      batchMulticall([totalRewardPoolCall]),
    ]);

    const totalRewardPool = totalRewardPoolResult[0]?.status === 'success'
      ? Number(totalRewardPoolResult[0].result) / 1e18
      : 0;

    holders.forEach((holder, i) => {
      if (rewardResults[i]?.status === 'success' && rewardResults[i].result) {
        const [, totalPayout] = rewardResults[i].result;
        holder.claimableRewards = Number(totalPayout) / 1e18;
        log(
          `[Stax] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Claimable=${holder.claimableRewards.toFixed(4)}, ` +
          `Tokens=${ownerTokens.get(holder.wallet).length}`
        );
        if (holder.claimableRewards === 0) {
          log(`[Stax] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.claimableRewards = 0;
        log(`[Stax] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardResults[i]?.error || 'Unknown'}`);
      }
      holder.percentage = totalRewardPool ? (holder.claimableRewards / totalRewardPool) * 100 : 0;
      holder.rank = 0;
    });

    // Calculate ranks
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
    });

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Stax] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Stax] Error: ${error.message}`);
    console.error('[Stax] Error stack:', error.stack);
    let status = 500;
    let message = 'Failed to fetch Stax data';
    if (error.message.includes('Rate limit')) {
      status = 429;
      message = 'Alchemy rate limit exceeded';
    }
    return NextResponse.json({ error: message, details: error.message }, { status });
  }
}-e 
---
File: ./app/api/holders copy/E280/route.js
// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}

export async function POST(request) {
  log('POST /api/holders/E280: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}-e 
---
File: ./app/api/holders copy/Element280/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';

// In-memory cache
let cache = {};
let tokenCache = new Map();
let holdersMapCache = null;
let isCachePopulating = false;
let totalOwners = 0;
let totalSupplyCache = null;
let totalBurnedCache = null;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0 };

// Export cache state for /progress route
export function getCacheState() {
  return { isCachePopulating, holdersMapCache, totalOwners, progressState };
}

// Utility to serialize BigInt values
function serializeBigInt(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )
  );
}

// Retry utility with minimal logging
async function retry(fn, attempts = 5, delay = (retryCount, error) => (error?.details?.code === 429 ? 4000 * 2 ** retryCount : 2000), strict = true) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        log(`[element280] Retry failed after ${attempts} attempts: ${error.message}`);
        if (strict) throw error;
        return null;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch and cache total supply and burned tokens
async function getTotalSupply(contractAddress, errorLog) {
  const contractName = 'element280';
  if (totalSupplyCache !== null && totalBurnedCache !== null) {
    return totalSupplyCache;
  }
  const startTime = Date.now();
  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalSupply',
          },
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalBurned',
          },
        ],
      })
    );
    const totalSupply = results[0].status === 'success' ? Number(results[0].result) : 0;
    const totalBurned = results[1].status === 'success' && results[1].result != null ? Number(results[1].result) : 0;
    if (isNaN(totalSupply) || isNaN(totalBurned)) {
      const errorMsg = `Invalid totalSupply=${totalSupply} or totalBurned=${totalBurned}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: errorMsg });
      throw new Error(errorMsg);
    }
    totalSupplyCache = totalSupply;
    totalBurnedCache = totalBurned;
    log(`[element280] Fetched total supply: ${totalSupplyCache}, total burned: ${totalBurnedCache} in ${Date.now() - startTime}ms`);
    return totalSupplyCache;
  } catch (error) {
    log(`[element280] Failed to fetch total supply or burned: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: error.message });
    throw error;
  }
}

// Fetch all NFT ownership data using contract calls
async function fetchAllNftOwnership(contractAddress, errorLog, timings) {
  const contractName = 'element280';
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();
  const burnAddress = '0x0000000000000000000000000000000000000000';

  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    const errorMsg = `Invalid contract address: ${contractAddress}`;
    log(`[element280] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_contract', error: errorMsg });
    throw new Error(errorMsg);
  }
  log(`[element280] Starting NFT ownership fetch for contract: ${contractAddress}`);

  try {
    // Step 1: Get token IDs from Alchemy
    const tokenIdStart = Date.now();
    let pageKey = null;
    let pageCount = 0;
    let tokenIds = [];
    do {
      pageCount++;
      const response = await retry(() =>
        alchemy.nft.getNftsForContract(contractAddress, { pageKey })
      );
      if (!response.nfts || !Array.isArray(response.nfts)) {
        const errorMsg = `Invalid NFT response: nfts array missing`;
        log(`[element280] ${errorMsg}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
        throw new Error(errorMsg);
      }
      response.nfts.forEach(nft => {
        const tokenId = nft.tokenId || nft.id || nft.token_id;
        if (tokenId) tokenIds.push(tokenId);
      });
      pageKey = response.pageKey;
    } while (pageKey);
    timings.tokenIdFetch = Date.now() - tokenIdStart;
    log(`[element280] Collected ${tokenIds.length} token IDs in ${timings.tokenIdFetch}ms`);

    if (tokenIds.length === 0) {
      const errorMsg = `No token IDs found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
      throw new Error(errorMsg);
    }

    // Step 2: Fetch owners via contract ownerOf calls
    const ownerFetchStart = Date.now();
    const ownerCalls = tokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'ownerOf',
      args: [BigInt(tokenId)],
    }));
    const limit = pLimit(10);
    const chunkSize = 100;
    const ownerResults = [];
    for (let i = 0; i < ownerCalls.length; i += chunkSize) {
      const chunk = ownerCalls.slice(i, i + chunkSize);
      const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
      ownerResults.push(...results);
    }
    timings.ownerFetch = Date.now() - ownerFetchStart;
    log(`[element280] Fetched owners for ${ownerResults.length} tokens in ${timings.ownerFetch}ms`);

    // Step 3: Process owners
    const ownerProcessStart = Date.now();
    let invalidTokens = 0;
    let nonExistentTokens = 0;
    tokenIds.forEach((tokenId, index) => {
      const result = ownerResults[index];
      if (result.status === 'success') {
        const owner = result.result.toLowerCase();
        if (owner && owner !== burnAddress) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        } else {
          invalidTokens++;
        }
      } else {
        if (result.error?.message.includes('0xdf2d9b42')) {
          nonExistentTokens++;
        } else {
          log(`[element280] Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owners', error: `Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
        invalidTokens++;
      }
    });
    timings.ownerProcess = Date.now() - ownerProcessStart;
    log(`[element280] Processed owners: ${ownershipByToken.size} valid NFTs, skipped ${invalidTokens} invalid tokens (including ${nonExistentTokens} non-existent) in ${timings.ownerProcess}ms`);

    // Step 4: Validate against totalSupply
    const totalSupply = await getTotalSupply(contractAddress, errorLog);
    const expectedLiveTokens = totalSupply - (totalBurnedCache || 0);
    if (ownershipByToken.size === 0) {
      const errorMsg = `No valid NFTs with owners found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
      throw new Error(errorMsg);
    }
    if (ownershipByToken.size > expectedLiveTokens) {
      const errorMsg = `Found ${ownershipByToken.size} NFTs, more than expected ${expectedLiveTokens}`;
      log(`[element280] Warning: ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    }

    log(`[element280] Completed ownership fetch: ${ownershipByToken.size} NFTs across ${ownershipByWallet.size} wallets`);
    return { ownershipByToken, ownershipByWallet };
  } catch (error) {
    log(`[element280] Failed to fetch NFT ownership: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_ownership', error: error.message });
    throw error;
  }
}

// Populate holdersMapCache with timing and error tracking
async function populateHoldersMapCache(contractAddress, tiers) {
  const contractName = 'element280';
  log(`[element280] Starting populateHoldersMapCache for contract: ${contractAddress}`);
  if (isCachePopulating) {
    log(`[element280] Cache population already in progress`);
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 };
  const timings = {
    totalSupply: 0,
    tokenIdFetch: 0,
    ownerFetch: 0,
    ownerProcess: 0,
    holderInit: 0,
    tierFetch: 0,
    rewardFetch: 0,
    metricsCalc: 0,
    total: 0,
  };
  const errorLog = [];
  const totalStart = Date.now();

  try {
    holdersMapCache = new Map();

    // Step 1: Fetch total supply
    const supplyStart = Date.now();
    const totalTokens = await getTotalSupply(contractAddress, errorLog);
    timings.totalSupply = Date.now() - supplyStart;
    progressState = { step: 'fetching_ownership', processedNfts: 0, totalNfts: totalTokens };
    log(`[element280] Fetched total supply: ${totalTokens} in ${timings.totalSupply}ms`);

    // Step 2: Fetch all NFT ownership
    const { ownershipByToken, ownershipByWallet } = await fetchAllNftOwnership(contractAddress, errorLog, timings);
    totalOwners = ownershipByWallet.size;
    progressState = { step: 'initializing_holders', processedNfts: ownershipByToken.size, totalNfts: totalTokens };
    log(`[element280] Fetched ownership: ${ownershipByToken.size} NFTs, ${totalOwners} wallets`);

    // Step 3: Initialize holders
    const holderInitStart = Date.now();
    ownershipByWallet.forEach((tokenIds, wallet) => {
      const holder = {
        wallet,
        total: tokenIds.length,
        totalLive: tokenIds.length,
        multiplierSum: 0,
        displayMultiplierSum: 0,
        tiers: Array(6).fill(0),
        tokenIds: tokenIds.map(id => BigInt(id)),
        claimableRewards: 0,
        percentage: 0,
        rank: 0,
      };
      holdersMapCache.set(wallet, holder);
      tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
    });
    timings.holderInit = Date.now() - holderInitStart;
    log(`[element280] Initialized ${holdersMapCache.size} holders in ${timings.holderInit}ms`);
    progressState = { step: 'fetching_tiers', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 4: Batch fetch tiers
    const tierFetchStart = Date.now();
    const allTokenIds = Array.from(ownershipByToken.keys()).map(id => BigInt(id));
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    if (tierCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const tierResults = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        tierResults.push(...results);
        progressState = {
          step: 'fetching_tiers',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      tierResults.forEach((result, index) => {
        const tokenId = allTokenIds[index].toString();
        if (result.status === 'success') {
          const tier = Number(result.result);
          if (tier >= 1 && tier <= 6) {
            const owner = ownershipByToken.get(tokenId);
            const holder = holdersMapCache.get(owner);
            if (holder) {
              holder.tiers[tier - 1]++;
              tokenCache.set(`${contractAddress}-${tokenId}-tier`, tier);
            } else {
              log(`[element280] Warning: No holder found for token ${tokenId} (owner: ${owner})`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `No holder found for token ${tokenId} (owner: ${owner})` });
            }
          } else {
            log(`[element280] Invalid tier ${tier} for token ${tokenId}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Invalid tier ${tier} for token ${tokenId}` });
          }
        } else {
          log(`[element280] Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
      });
    }
    timings.tierFetch = Date.now() - tierFetchStart;
    log(`[element280] Fetched tiers for ${allTokenIds.length} NFTs in ${timings.tierFetch}ms`);
    progressState = { step: 'fetching_rewards', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 5: Batch fetch rewards
    const rewardFetchStart = Date.now();
    const rewardCalls = [];
    ownershipByWallet.forEach((tokenIds, wallet) => {
      tokenIds.forEach(tokenId => {
        rewardCalls.push({
          address: vaultAddresses.element280.address,
          abi: element280VaultAbi,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], wallet],
        });
      });
    });
    if (rewardCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const rewardResults = [];
      for (let i = 0; i < rewardCalls.length; i += chunkSize) {
        const chunk = rewardCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        rewardResults.push(...results);
        progressState = {
          step: 'fetching_rewards',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      let resultIndex = 0;
      ownershipByWallet.forEach((tokenIds, wallet) => {
        let totalRewards = 0n;
        tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          } else {
            log(`[element280] Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}` });
          }
        });
        const holder = holdersMapCache.get(wallet);
        if (holder) {
          holder.claimableRewards = Number(totalRewards) / 1e18;
          if (isNaN(holder.claimableRewards)) {
            holder.claimableRewards = 0;
            log(`[element280] Warning: NaN rewards for wallet ${wallet}, set to 0`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `NaN rewards for wallet ${wallet}` });
          }
          tokenCache.set(`${contractName}-${wallet}-reward`, holder.claimableRewards);
        }
      });
    }
    timings.rewardFetch = Date.now() - rewardFetchStart;
    log(`[element280] Fetched rewards for ${rewardCalls.length} NFTs in ${timings.rewardFetch}ms`);
    progressState = { step: 'calculating_metrics', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 6: Calculate multipliers and metrics
    const metricsStart = Date.now();
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    const totalMultiplierSum = Array.from(holdersMapCache.values()).reduce((sum, holder) => {
      holder.multiplierSum = holder.tiers.reduce(
        (sum, count, index) => sum + count * (multipliers[index] || 0),
        0
      );
      holder.displayMultiplierSum = holder.multiplierSum / 10;
      return sum + holder.multiplierSum;
    }, 0);
    const holders = Array.from(holdersMapCache.values());
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    });
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
      holdersMapCache.set(holder.wallet, holder);
    });
    timings.metricsCalc = Date.now() - metricsStart;
    log(`[element280] Calculated metrics for ${holders.length} holders in ${timings.metricsCalc}ms`);
    progressState = { step: 'idle', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Log summary
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: ownershipByToken.size,
      walletsProcessed: ownershipByWallet.size,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);

  } catch (error) {
    log(`[element280] Failed to populate holdersMapCache: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    holdersMapCache = null;
    cache = {};
    progressState = { step: 'error', processedNfts: 0, totalNfts: 0 };

    // Log summary on error
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: 0,
      walletsProcessed: 0,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start (Failed) =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);
    throw error;
  } finally {
    isCachePopulating = false;
    totalOwners = 0;
    log(`[element280] Cache population complete, isCachePopulating=false, totalOwners=0`);
  }
}

// Fetch holder data for a specific wallet
async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();
  const walletLower = wallet.toLowerCase();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  while (isCachePopulating) {
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  if (holdersMapCache?.has(walletLower)) {
    const holder = holdersMapCache.get(walletLower);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }

  const holder = {
    wallet: walletLower,
    total: 0,
    totalLive: 0,
    multiplierSum: 0,
    displayMultiplierSum: 0,
    tiers: Array(6).fill(0),
    tokenIds: [],
    claimableRewards: 0,
    percentage: 0,
    rank: 0,
  };

  const tokenIdsResponse = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [walletLower],
    })
  );
  const tokenIds = tokenIdsResponse.map(id => id.toString());
  const nfts = tokenIds.map(tokenId => ({ tokenId, tier: 0 }));
  holder.total = nfts.length;
  holder.totalLive = nfts.length;
  tokenCache.set(`${contractAddress}-${walletLower}-nfts`, nfts);

  if (nfts.length === 0) {
    return null;
  }

  const bigIntTokenIds = nfts.map(nft => BigInt(nft.tokenId));
  const calls = [];
  bigIntTokenIds.forEach(tokenId => {
    calls.push({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    });
    calls.push({
      address: vaultAddresses.element280.address,
      abi: element280VaultAbi,
      functionName: 'getRewards',
      args: [[tokenId], walletLower],
    });
  });

  const results = await retry(() => client.multicall({ contracts: calls }));
  const finalTokenIds = [];
  let totalRewards = 0n;
  nfts.forEach((nft, index) => {
    const tierResult = results[index * 2];
    const rewardResult = results[index * 2 + 1];
    if (tierResult.status === 'success') {
      const tier = Number(tierResult.result);
      if (tier >= 1 && tier <= 6) {
        nft.tier = tier;
        holder.tiers[tier - 1]++;
        finalTokenIds.push(BigInt(nft.tokenId));
        tokenCache.set(`${contractAddress}-${nft.tokenId}-tier`, tier);
      }
    }
    if (rewardResult.status === 'success') {
      const rewardValue = BigInt(rewardResult.result[1] || 0);
      totalRewards += rewardValue;
      tokenCache.set(`${contractAddress}-${nft.tokenId}-single-reward`, rewardValue);
    }
  });
  holder.tokenIds = finalTokenIds;
  holder.claimableRewards = Number(totalRewards) / 1e18;
  if (isNaN(holder.claimableRewards)) {
    holder.claimableRewards = 0;
  }
  tokenCache.set(`${contractName}-${walletLower}-reward`, holder.claimableRewards);

  const multipliers = Object.values(tiers).map(t => t.multiplier);
  holder.multiplierSum = holder.tiers.reduce(
    (sum, count, index) => sum + count * (multipliers[index] || 0),
    0
  );
  holder.displayMultiplierSum = holder.multiplierSum / 10;

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 100);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
  const existingHolder = allHolders.holders.find(h => h.wallet === walletLower);
  holder.rank = existingHolder ? existingHolder.rank : allHolders.holders.length + 1;

  if (holder.total > 0) {
    holdersMapCache?.set(walletLower, holder);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }
  return null;
}

// Fetch all holders (paginated)
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (!refresh && cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  let holdersMap = holdersMapCache;
  if (refresh || !holdersMap || isCachePopulating) {
    while (isCachePopulating) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (refresh || !holdersMap) {
      await populateHoldersMapCache(contractAddress, tiers);
      holdersMap = holdersMapCache;
      if (!holdersMap) {
        log(`[element280] Error: holdersMapCache is null after population`);
        throw new Error('Failed to populate holdersMapCache');
      }
    }
  }

  const totalTokens = await getTotalSupply(contractAddress, []);
  const holders = Array.from(holdersMap.values());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, holders.length);
  const paginatedHolders = holders.slice(start, end);

  const result = {
    holders: paginatedHolders,
    totalTokens: holdersMap.size > 0 ? holders.reduce((sum, h) => sum + h.total, 0) : totalTokens,
    totalHolders: holders.length,
    page,
    pageSize,
    totalPages: Math.ceil(holders.length / pageSize),
    summary: {
      totalLive: totalTokens,
      totalBurned: totalBurnedCache || 0,
      multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      totalRewardPool: holders.reduce((sum, h) => sum + h.claimableRewards, 0),
    },
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`[element280] Paginated ${paginatedHolders.length} holders: totalHolders=${holders.length}, totalBurned=${result.summary.totalBurned}, multiplierPool=${result.summary.multiplierPool}`);
  return serializeBigInt(result);
}

// GET handler
export async function GET(request) {
  const contractName = 'element280';
  let url = request.url || (request.nextUrl && request.nextUrl.toString());
  if (!url) {
    log(`[element280] Error: Both request.url and request.nextUrl are undefined`);
    return NextResponse.json({ error: 'Invalid request: URL is undefined' }, { status: 400 });
  }

  try {
    const { searchParams } = new URL(url);
    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    const address = contractAddresses.element280.address;
    if (!address) {
      log(`[element280] Error: Element280 contract address not found`);
      return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      log(`[element280] GET /api/holders/Element280?wallet=${wallet} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      log(`[element280] GET /api/holders/Element280?page=${page}&pageSize=${pageSize} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt(result));
    }
  } catch (error) {
    log(`[element280] Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

// POST handler
export async function POST() {
  const contractName = 'element280';
  const address = contractAddresses.element280.address;
  if (!address) {
    log(`[element280] Error: Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    log(`[element280] Cache preload completed, total holders: ${holdersMapCache?.size || 0}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders: holdersMapCache?.size || 0 });
  } catch (error) {
    log(`[element280] Error in POST /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Element280/progress/route.js
// api/holders/Element280/progress/route.js
// This route handles the progress of the cache population for the Element280 contract.
// It provides information about the current state of the cache population process,
// including whether it is currently populating, the total number of wallets,
// the total number of owners, and the current phase of the process.
// It also handles errors that may occur during the process and logs relevant information.
// The route is defined as a GET request handler and returns a JSON response with the progress information.

import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isCachePopulating, holdersMapCache, totalOwners, progressState } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isCachePopulating}, totalWallets=${holdersMapCache?.size || 0}, totalOwners=${totalOwners}, step=${progressState.step}`);

  try {
    const progressPercentage = progressState.totalNfts > 0 ? (progressState.processedNfts / progressState.totalNfts) * 100 : 0;
    const phase = isCachePopulating
      ? {
          fetching_supply: 'Fetching total supply',
          fetching_ownership: 'Fetching NFT ownership',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[progressState.step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating: isCachePopulating,
      totalWallets: holdersMapCache?.size || 0,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Element280/progress/route cache db.js
// api/holders/Element280/progress/route.js


import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isPopulating, totalWallets, totalOwners, step, processedNfts, totalNfts } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isPopulating}, totalWallets=${totalWallets}, totalOwners=${totalOwners}, step=${step}`);

  try {
    const progressPercentage = totalNfts > 0 ? (processedNfts / totalNfts) * 100 : 0;
    const phase = isPopulating
      ? {
          fetching_supply: 'Fetching total supply',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating,
      totalWallets,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Element280/progress/route copy.js
// api/holders/Element280/progress/route.js
// This route handles the progress of the cache population for the Element280 contract.
// It provides information about the current state of the cache population process,
// including whether it is currently populating, the total number of wallets,
// the total number of owners, and the current phase of the process.
// It also handles errors that may occur during the process and logs relevant information.
// The route is defined as a GET request handler and returns a JSON response with the progress information.

import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '../route';

export async function GET(request) {
  const { isCachePopulating, holdersMapCache, totalOwners, progressState } = getCacheState();
  const contractName = 'element280';

  log(`Handling /progress: isPopulating=${isCachePopulating}, totalWallets=${holdersMapCache?.size || 0}, totalOwners=${totalOwners}, step=${progressState.step}`);

  try {
    const progressPercentage = progressState.totalNfts > 0 ? (progressState.processedNfts / progressState.totalNfts) * 100 : 0;
    const phase = isCachePopulating
      ? {
          fetching_supply: 'Fetching total supply',
          fetching_ownership: 'Fetching NFT ownership',
          initializing_holders: 'Initializing holder data',
          fetching_tiers: `Fetching tiers (${progressPercentage.toFixed(1)}%)`,
          fetching_rewards: `Fetching rewards (${progressPercentage.toFixed(1)}%)`,
          calculating_metrics: 'Calculating multipliers and rankings',
          error: 'Error during processing',
        }[progressState.step] || 'Processing'
      : 'Idle';

    return NextResponse.json({
      isPopulating: isCachePopulating,
      totalWallets: holdersMapCache?.size || 0,
      totalOwners,
      phase,
      progressPercentage: progressPercentage.toFixed(1),
    });
  } catch (error) {
    log(`Error in GET /progress: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Element280/route cache db.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, batchMulticall } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import { LRUCache } from 'lru-cache';

// SQLite database setup
let db;
let dbInitialized = false;
async function initDb() {
  if (dbInitialized) return db;
  try {
    db = await open({
      filename: './element280.db',
      driver: sqlite3.Database,
      mode: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
      busyTimeout: 10000,
    });
    await db.exec(`
      CREATE TABLE IF NOT EXISTS holders (
        wallet TEXT PRIMARY KEY,
        total INTEGER,
        totalLive INTEGER,
        multiplierSum INTEGER,
        displayMultiplierSum REAL,
        tiers TEXT,
        tokenIds TEXT,
        claimableRewards REAL,
        percentage REAL,
        rank INTEGER
      );
      CREATE TABLE IF NOT EXISTS tokens (
        tokenId TEXT PRIMARY KEY,
        owner TEXT,
        tier INTEGER,
        reward REAL,
        lastUpdated INTEGER
      );
      CREATE TABLE IF NOT EXISTS metadata (
        key TEXT PRIMARY KEY,
        value TEXT
      );
      CREATE INDEX IF NOT EXISTS idx_tokens_owner ON tokens(owner);
      CREATE INDEX IF NOT EXISTS idx_tokens_lastUpdated ON tokens(lastUpdated);
    `);
    dbInitialized = true;
    log('[element280] SQLite database initialized');
  } catch (error) {
    log(`[element280] error: SQLite initialization failed: ${error.message}, stack: ${error.stack}`);
    throw error;
  }
  return db;
}

// In-memory cache
const cache = new LRUCache({ max: 1000, ttl: CACHE_TTL });
const tokenCache = new LRUCache({ max: 10000, ttl: 24 * 60 * 60 * 1000 });
let isCachePopulating = false;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0, totalWallets: 0 };
const MAX_INITIAL_SUPPLY = 16883;
const FALLBACK_TOTAL_SUPPLY = 8137; // Current, may decrease
const FALLBACK_TOTAL_BURNED = 8746; // Current, may increase
const FALLBACK_EXPECTED_HOLDERS = 921; // Current, may change
const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';

// Logging configuration
const logLevel = 'ERROR'; // Set to 'DEBUG' for verbose, 'ERROR' for minimal
function log(message) {
  if (logLevel === 'ERROR' && !message.toLowerCase().includes('error') && !message.includes('failed') && !message.includes('completed') && !message.includes('initialized')) {
    return;
  }
  console.log(`[${new Date().toISOString()}] [element280] ${message}`);
}

// Export cache state for /progress route
export function getCacheState() {
  return {
    isPopulating: isCachePopulating,
    totalWallets: progressState.totalWallets,
    totalOwners: tokenCache.size,
    step: progressState.step,
    processedNfts: progressState.processedNfts,
    totalNfts: progressState.totalNfts,
    progressPercentage: progressState.totalNfts > 0 ? Math.round((progressState.processedNfts / progressState.totalNfts) * 100) : 0,
  };
}

// Serialize BigInt
function serializeBigInt(obj) {
  return JSON.parse(JSON.stringify(obj, (key, value) => 
    typeof value === 'bigint' ? value.toString() : value
  ));
}

// Retry utility
async function retry(fn, attempts = 5, delay = (retryCount, error) => 
  error?.details?.code === 429 ? 6000 * 2 ** retryCount : 2000) {
  let lastError;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i === attempts - 1) {
        log(`[element280] error: Retry failed: ${error.message}, code: ${error?.details?.code || 'unknown'}`);
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch total supply
async function getTotalSupply(contractAddress, db) {
  const cacheKey = `totalSupply:${contractAddress}`;
  try {
    const cached = await db.get('SELECT value FROM metadata WHERE key = ?', cacheKey);
    if (cached) return parseInt(cached.value);

    const result = await retry(() => client.multicall({
      contracts: [{ address: contractAddress, abi: element280MainAbi, functionName: 'totalSupply' }],
    }));
    const totalSupply = Number(result[0].result);
    if (isNaN(totalSupply) || totalSupply < 0 || totalSupply > MAX_INITIAL_SUPPLY) {
      log(`[element280] error: Invalid totalSupply=${totalSupply}, using fallback=${FALLBACK_TOTAL_SUPPLY}`);
      await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', cacheKey, FALLBACK_TOTAL_SUPPLY);
      return FALLBACK_TOTAL_SUPPLY;
    }
    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', cacheKey, totalSupply);
    return totalSupply;
  } catch (error) {
    log(`[element280] error: getTotalSupply failed: ${error.message}`);
    return FALLBACK_TOTAL_SUPPLY;
  }
}

// Fetch NFT ownership
async function fetchAllNftOwnership(contractAddress, db, timings) {
  const start = Date.now();
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();

  try {
    const cachedTokens = await db.all('SELECT tokenId, owner FROM tokens WHERE lastUpdated > ?', 
      Date.now() - 7 * 24 * 60 * 60 * 1000);
    if (cachedTokens.length >= FALLBACK_TOTAL_SUPPLY) {
      cachedTokens.forEach(({ tokenId, owner }) => {
        if (owner !== BURN_ADDRESS) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        }
      });
      timings.tokenIdFetch = 0;
      return { ownershipByToken, ownershipByWallet, invalidTokens: MAX_INITIAL_SUPPLY - ownershipByToken.size };
    }

    const response = await retry(() => 
      alchemy.nft.getOwnersForContract(contractAddress, { withTokenBalances: true })
    );
    let invalidTokens = 0;
    response.owners.forEach(owner => {
      const ownerAddress = owner.ownerAddress.toLowerCase();
      if (ownerAddress === BURN_ADDRESS) {
        invalidTokens += owner.tokenBalances.length;
        return;
      }
      owner.tokenBalances.forEach(token => {
        const tokenId = token.tokenId;
        ownershipByToken.set(tokenId, ownerAddress);
        const walletTokens = ownershipByWallet.get(ownerAddress) || [];
        walletTokens.push(tokenId);
        ownershipByWallet.set(ownerAddress, walletTokens);
        db.run('INSERT OR REPLACE INTO tokens (tokenId, owner, tier, reward, lastUpdated) VALUES (?, ?, ?, ?, ?)', 
          [tokenId, ownerAddress, 0, 0, Date.now()]);
      });
    });

    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'invalidTokens', invalidTokens);
    timings.tokenIdFetch = Date.now() - start;
    return { ownershipByToken, ownershipByWallet, invalidTokens };
  } catch (error) {
    log(`[element280] error: fetchAllNftOwnership failed: ${error.message}`);
    throw error;
  }
}

// Populate holders cache
async function populateHoldersMapCache(contractAddress, tiers) {
  if (isCachePopulating) {
    log('[element280] error: Cache population already in progress');
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0, totalWallets: 0 };
  const timings = { totalSupply: 0, tokenIdFetch: 0, holderInit: 0, tierFetch: 0, rewardFetch: 0, metricsCalc: 0, total: 0 };
  const errorLog = [];
  const totalStart = Date.now();
  const db = await initDb();

  const timeoutPromise = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Cache population timed out after 30s')), 30000)
  );

  let ownershipByToken = new Map();
  let ownershipByWallet = new Map();
  let invalidTokens = 0;

  try {
    await Promise.race([
      (async () => {
        const totalSupplyStart = Date.now();
        const totalSupply = await getTotalSupply(contractAddress, db);
        timings.totalSupply = Date.now() - totalSupplyStart;
        invalidTokens = MAX_INITIAL_SUPPLY - totalSupply;
        await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'invalidTokens', invalidTokens);

        const ownershipResult = await fetchAllNftOwnership(contractAddress, db, timings);
        ownershipByToken = ownershipResult.ownershipByToken;
        ownershipByWallet = ownershipResult.ownershipByWallet;
        invalidTokens = ownershipResult.invalidTokens;
        progressState = { 
          step: 'initializing_holders', 
          processedNfts: ownershipByToken.size, 
          totalNfts: MAX_INITIAL_SUPPLY, 
          totalWallets: ownershipByWallet.size 
        };

        const holderInitStart = Date.now();
        let processedWallets = 0;
        for (const [wallet, tokenIds] of ownershipByWallet) {
          try {
            const holder = {
              wallet,
              total: tokenIds.length,
              totalLive: tokenIds.length,
              multiplierSum: 0,
              displayMultiplierSum: 0,
              tiers: Array(6).fill(0),
              tokenIds: tokenIds.map(id => id.toString()),
              claimableRewards: 0,
              percentage: 0,
              rank: 0,
            };
            await db.run(
              'INSERT OR REPLACE INTO holders (wallet, total, totalLive, multiplierSum, displayMultiplierSum, tiers, tokenIds, claimableRewards, percentage, rank) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
              [wallet, holder.total, holder.totalLive, holder.multiplierSum, holder.displayMultiplierSum, JSON.stringify(holder.tiers), JSON.stringify(holder.tokenIds), holder.claimableRewards, holder.percentage, holder.rank]
            );
            tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
            processedWallets++;
            progressState.totalWallets = processedWallets;
          } catch (error) {
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'holder_init', wallet, error: error.message });
          }
        }
        timings.holderInit = Date.now() - holderInitStart;

        const tierFetchStart = Date.now();
        const allTokenIds = Array.from(ownershipByToken.keys());
        const tierCalls = [];
        for (const tokenId of allTokenIds) {
          const cached = await db.get('SELECT tier, lastUpdated FROM tokens WHERE tokenId = ?', tokenId);
          if (cached && cached.lastUpdated > Date.now() - 60 * 60 * 1000) {
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.tiers = JSON.parse(holder.tiers);
              holder.tiers[cached.tier - 1]++;
              await db.run('UPDATE holders SET tiers = ? WHERE wallet = ?', [JSON.stringify(holder.tiers), owner]);
            }
            continue;
          }
          tierCalls.push({ address: contractAddress, abi: element280MainAbi, functionName: 'getNftTier', args: [BigInt(tokenId)] });
        }
        const tierResults = await batchMulticall(tierCalls, 50);
        for (let i = 0; i < tierResults.length; i++) {
          const tokenId = tierCalls[i].args[0].toString();
          if (tierResults[i].status === 'success' && Number(tierResults[i].result) >= 1 && Number(tierResults[i].result) <= 6) {
            const tier = Number(tierResults[i].result);
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.tiers = JSON.parse(holder.tiers);
              holder.tiers[tier - 1]++;
              await db.run('UPDATE holders SET tiers = ? WHERE wallet = ?', [JSON.stringify(holder.tiers), owner]);
              await db.run('UPDATE tokens SET tier = ?, lastUpdated = ? WHERE tokenId = ?', [tier, Date.now(), tokenId]);
            }
          }
        }
        timings.tierFetch = Date.now() - tierFetchStart;

        const rewardFetchStart = Date.now();
        const rewardCalls = [];
        for (const [wallet, tokenIds] of ownershipByWallet) {
          for (const tokenId of tokenIds) {
            const cached = await db.get('SELECT reward, lastUpdated FROM tokens WHERE tokenId = ?', tokenId);
            if (cached && cached.lastUpdated > Date.now() - 60 * 60 * 1000) {
              const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', wallet);
              if (holder) {
                holder.claimableRewards += cached.reward;
                await db.run('UPDATE holders SET claimableRewards = ? WHERE wallet = ?', [holder.claimableRewards, wallet]);
              }
              continue;
            }
            rewardCalls.push({
              address: vaultAddresses.element280.address,
              abi: element280VaultAbi,
              functionName: 'getRewards',
              args: [[BigInt(tokenId)], wallet],
            });
          }
        }
        const rewardResults = await batchMulticall(rewardCalls, 50);
        for (let i = 0; i < rewardResults.length; i++) {
          const result = rewardResults[i];
          if (result.status === 'success') {
            const tokenId = rewardCalls[i].args[0][0].toString();
            const reward = Number(BigInt(result.result[1] || 0)) / 1e18;
            const owner = ownershipByToken.get(tokenId);
            const holder = await db.get('SELECT * FROM holders WHERE wallet = ?', owner);
            if (holder) {
              holder.claimableRewards += reward;
              await db.run('UPDATE tokens SET reward = ?, lastUpdated = ? WHERE tokenId = ?', [reward, Date.now(), tokenId]);
              await db.run('UPDATE holders SET claimableRewards = ? WHERE wallet = ?', [holder.claimableRewards, owner]);
            }
          }
        }
        timings.rewardFetch = Date.now() - rewardFetchStart;

        const metricsStart = Date.now();
        const multipliers = Object.values(tiers).map(t => t.multiplier);
        let totalMultiplierSum = 0;
        const holders = await db.all('SELECT * FROM holders');
        for (const holder of holders) {
          holder.tiers = JSON.parse(holder.tiers);
          holder.multiplierSum = holder.tiers.reduce((sum, count, index) => sum + count * (multipliers[index] || 0), 0);
          holder.displayMultiplierSum = holder.multiplierSum / 10;
          totalMultiplierSum += holder.multiplierSum;
          await db.run('UPDATE holders SET multiplierSum = ?, displayMultiplierSum = ? WHERE wallet = ?', 
            [holder.multiplierSum, holder.displayMultiplierSum, holder.wallet]);
        }
        holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
        for (let i = 0; i < holders.length; i++) {
          const holder = holders[i];
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          holder.rank = i + 1;
          await db.run('UPDATE holders SET percentage = ?, rank = ? WHERE wallet = ?', [holder.percentage, holder.rank, holder.wallet]);
        }
        timings.metricsCalc = Date.now() - metricsStart;

        timings.total = Date.now() - totalStart;
        const summary = {
          totalDurationMs: timings.total,
          phases: { 
            fetchTotalSupply: timings.totalSupply, 
            fetchTokenIds: timings.tokenIdFetch, 
            holderInit: timings.holderInit, 
            fetchTiers: timings.tierFetch, 
            fetchRewards: timings.rewardFetch, 
            calculateMetrics: timings.metricsCalc 
          },
          nftsProcessed: ownershipByToken.size,
          walletsProcessed: ownershipByWallet.size,
          errors: errorLog,
        };
        await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'lastSummary', JSON.stringify(summary));
        progressState = { 
          step: 'idle', 
          processedNfts: ownershipByToken.size, 
          totalNfts: MAX_INITIAL_SUPPLY, 
          totalWallets: ownershipByWallet.size 
        };
        log(`[element280] Cache population completed in ${timings.total}ms, holders: ${ownershipByWallet.size}, errors: ${errorLog.length}`);
      })(),
      timeoutPromise,
    ]);
  } catch (error) {
    log(`[element280] error: Cache population failed: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    await db.run('INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)', 'lastSummary', JSON.stringify({
      totalDurationMs: Date.now() - totalStart, 
      phases: timings, 
      nftsProcessed: ownershipByToken.size || 0, 
      walletsProcessed: ownershipByWallet.size || 0, 
      errors: errorLog 
    }));
    throw error;
  } finally {
    isCachePopulating = false;
  }
}

// Get holder data
async function getHolderData(contractAddress, wallet, tiers) {
  const cacheKey = `${contractAddress}-${wallet}`;
  const cached = cache.get(cacheKey);
  if (cached) return cached;

  const db = await initDb();
  try {
    let holder = await db.get('SELECT * FROM holders WHERE wallet = ?', wallet.toLowerCase());
    if (holder) {
      holder.tiers = JSON.parse(holder.tiers);
      holder.tokenIds = JSON.parse(holder.tokenIds);
      cache.set(cacheKey, holder);
      return serializeBigInt(holder);
    }

    holder = {
      wallet: wallet.toLowerCase(),
      total: 0,
      totalLive: 0,
      multiplierSum: 0,
      displayMultiplierSum: 0,
      tiers: Array(6).fill(0),
      tokenIds: [],
      claimableRewards: 0,
      percentage: 0,
      rank: 0,
    };

    const tokenIds = await retry(() => client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [wallet.toLowerCase()],
    }));
    holder.total = tokenIds.length;
    holder.totalLive = tokenIds.length;
    if (tokenIds.length === 0) return null;

    const calls = tokenIds.flatMap(tokenId => [
      { address: contractAddress, abi: element280MainAbi, functionName: 'getNftTier', args: [tokenId] },
      { address: vaultAddresses.element280.address, abi: element280VaultAbi, functionName: 'getRewards', args: [[tokenId], wallet.toLowerCase()] },
    ]);
    const results = await batchMulticall(calls, 50);
    let totalRewards = 0;
    for (let i = 0; i < tokenIds.length; i++) {
      const tierResult = results[i * 2];
      const rewardResult = results[i * 2 + 1];
      const tokenId = tokenIds[i].toString();
      if (tierResult.status === 'success' && Number(tierResult.result) >= 1 && Number(tierResult.result) <= 6) {
        const tier = Number(tierResult.result);
        holder.tiers[tier - 1]++;
        holder.tokenIds.push(tokenId);
        await db.run('INSERT OR REPLACE INTO tokens (tokenId, owner, tier, reward, lastUpdated) VALUES (?, ?, ?, ?, ?)', 
          [tokenId, wallet.toLowerCase(), tier, 0, Date.now()]);
      }
      if (rewardResult.status === 'success') {
        const reward = Number(BigInt(rewardResult.result[1] || 0)) / 1e18;
        totalRewards += reward;
        await db.run('UPDATE tokens SET reward = ?, lastUpdated = ? WHERE tokenId = ?', [reward, Date.now(), tokenId]);
      }
    }
    holder.claimableRewards = totalRewards;
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    holder.multiplierSum = holder.tiers.reduce((sum, count, index) => sum + count * (multipliers[index] || 0), 0);
    holder.displayMultiplierSum = holder.multiplierSum / 10;

    const allHolders = await db.all('SELECT * FROM holders');
    const totalMultiplierSum = allHolders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    const sortedHolders = allHolders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holder.rank = sortedHolders.findIndex(h => h.wallet === wallet.toLowerCase()) + 1 || sortedHolders.length + 1;

    await db.run(
      'INSERT OR REPLACE INTO holders (wallet, total, totalLive, multiplierSum, displayMultiplierSum, tiers, tokenIds, claimableRewards, percentage, rank) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [holder.wallet, holder.total, holder.totalLive, holder.multiplierSum, holder.displayMultiplierSum, JSON.stringify(holder.tiers), JSON.stringify(holder.tokenIds), holder.claimableRewards, holder.percentage, holder.rank]
    );
    cache.set(cacheKey, holder);
    return serializeBigInt(holder);
  } catch (error) {
    log(`[element280] error: getHolderData failed for wallet ${wallet}: ${error.message}`);
    throw error;
  }
}

// Get all holders
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const cached = cache.get(cacheKey);
  if (!refresh && cached) {
    return cached; // Silent cache hit
  }

  const db = await initDb();
  try {
    if (refresh) await populateHoldersMapCache(contractAddress, tiers);

    const totalSupply = await getTotalSupply(contractAddress, db);
    const holders = await db.all('SELECT * FROM holders LIMIT ? OFFSET ?', Math.min(pageSize, 100), page * Math.min(pageSize, 100));
    const totalHolders = (await db.get('SELECT COUNT(*) as count FROM holders')).count;
    const totalTokens = holders.reduce((sum, h) => sum + h.total, 0) || totalSupply;
    const invalidTokens = (await db.get('SELECT value FROM metadata WHERE key = ?', 'invalidTokens'))?.value || (MAX_INITIAL_SUPPLY - totalSupply);

    if (totalSupply + invalidTokens > MAX_INITIAL_SUPPLY) {
      log(`[element280] error: Data mismatch: totalSupply=${totalSupply}, invalidTokens=${invalidTokens}, exceeds MAX_INITIAL_SUPPLY=${MAX_INITIAL_SUPPLY}`);
    }

    const result = {
      holders: holders.map(h => ({ 
        ...h, 
        tiers: JSON.parse(h.tiers), 
        tokenIds: JSON.parse(h.tokenIds), 
        claimableRewards: Number(h.claimableRewards) 
      })),
      totalTokens,
      totalHolders,
      page,
      pageSize: Math.min(pageSize, 100),
      totalPages: Math.ceil(totalHolders / Math.min(pageSize, 100)),
      summary: {
        totalLive: totalSupply,
        totalBurned: invalidTokens,
        multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
        totalRewardPool: holders.reduce((sum, h) => sum + Number(h.claimableRewards), 0),
      },
    };
    cache.set(cacheKey, result);
    return serializeBigInt(result);
  } catch (error) {
    log(`[element280] error: getAllHolders failed for page=${page}: ${error.message}`);
    throw error;
  }
}

// GET handler
export async function GET(request) {
  const { searchParams, pathname } = new URL(request.url);
  const address = contractAddresses.element280.address;
  if (!address) return NextResponse.json({ error: 'Element280 contract address not found', code: 400 }, { status: 400 });

  try {
    const db = await initDb();
    if (pathname.endsWith('/summary')) {
      const summary = await db.get('SELECT value FROM metadata WHERE key = ?', 'lastSummary');
      return NextResponse.json(summary ? JSON.parse(summary.value) : { error: 'No summary available', code: 404 }, { status: summary ? 200 : 404 });
    }

    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    if (isCachePopulating && !wallet) {
      const cached = cache.get(`${address}-all-${page}-${pageSize}`);
      if (cached) {
        return NextResponse.json(serializeBigInt(cached), { headers: { 'X-Cache-Status': 'stale' } });
      }
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      return NextResponse.json(serializeBigInt(result), { headers: { 'X-Cache-Status': cache.get(`${address}-all-${page}-${pageSize}`) ? 'hit' : 'miss' } });
    }
  } catch (error) {
    const status = error.details?.code === 429 ? 429 : 500;
    const message = error.details?.code === 429 ? 'Rate limit exceeded' : `Server error: ${error.message}`;
    log(`[element280] error: GET error: ${message}`);
    return NextResponse.json({ error: message, code: status }, { status });
  }
}

// POST handler
export async function POST() {
  const address = contractAddresses.element280.address;
  if (!address) return NextResponse.json({ error: 'Element280 contract address not found', code: 400 }, { status: 400 });

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    const db = await initDb();
    const totalHolders = (await db.get('SELECT COUNT(*) as count FROM holders')).count;
    log(`[element280] Cache preload completed, total holders: ${totalHolders}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders });
  } catch (error) {
    log(`[element280] error: Cache preload failed: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}`, code: 500 }, { status: 500 });
  }
}

// Initialize cache on startup
let cacheInitialized = false;
if (!cacheInitialized) {
  cacheInitialized = true;
  (async () => {
    try {
      await populateHoldersMapCache(contractAddresses.element280.address, contractTiers.element280);
    } catch (error) {
      log(`[element280] error: Initial cache population failed: ${error.message}`);
    }
  })();
}-e 
---
File: ./app/api/holders copy/Element280/route copy.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log } from '@/app/api/utils';
import { contractAddresses, contractTiers, vaultAddresses, element280MainAbi, element280VaultAbi } from '@/app/nft-contracts';
import pLimit from 'p-limit';

// In-memory cache
let cache = {};
let tokenCache = new Map();
let holdersMapCache = null;
let isCachePopulating = false;
let totalOwners = 0;
let totalSupplyCache = null;
let totalBurnedCache = null;
let progressState = { step: 'idle', processedNfts: 0, totalNfts: 0 };

// Export cache state for /progress route
export function getCacheState() {
  return { isCachePopulating, holdersMapCache, totalOwners, progressState };
}

// Utility to serialize BigInt values
function serializeBigInt(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )
  );
}

// Retry utility with minimal logging
async function retry(fn, attempts = 5, delay = (retryCount, error) => (error?.details?.code === 429 ? 4000 * 2 ** retryCount : 2000), strict = true) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        log(`[element280] Retry failed after ${attempts} attempts: ${error.message}`);
        if (strict) throw error;
        return null;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch and cache total supply and burned tokens
async function getTotalSupply(contractAddress, errorLog) {
  const contractName = 'element280';
  if (totalSupplyCache !== null && totalBurnedCache !== null) {
    return totalSupplyCache;
  }
  const startTime = Date.now();
  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalSupply',
          },
          {
            address: contractAddress,
            abi: element280MainAbi,
            functionName: 'totalBurned',
          },
        ],
      })
    );
    const totalSupply = results[0].status === 'success' ? Number(results[0].result) : 0;
    const totalBurned = results[1].status === 'success' && results[1].result != null ? Number(results[1].result) : 0;
    if (isNaN(totalSupply) || isNaN(totalBurned)) {
      const errorMsg = `Invalid totalSupply=${totalSupply} or totalBurned=${totalBurned}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: errorMsg });
      throw new Error(errorMsg);
    }
    totalSupplyCache = totalSupply;
    totalBurnedCache = totalBurned;
    log(`[element280] Fetched total supply: ${totalSupplyCache}, total burned: ${totalBurnedCache} in ${Date.now() - startTime}ms`);
    return totalSupplyCache;
  } catch (error) {
    log(`[element280] Failed to fetch total supply or burned: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: error.message });
    throw error;
  }
}

// Fetch all NFT ownership data using contract calls
async function fetchAllNftOwnership(contractAddress, errorLog, timings) {
  const contractName = 'element280';
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();
  const burnAddress = '0x0000000000000000000000000000000000000000';

  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    const errorMsg = `Invalid contract address: ${contractAddress}`;
    log(`[element280] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_contract', error: errorMsg });
    throw new Error(errorMsg);
  }
  log(`[element280] Starting NFT ownership fetch for contract: ${contractAddress}`);

  try {
    // Step 1: Get token IDs from Alchemy
    const tokenIdStart = Date.now();
    let pageKey = null;
    let pageCount = 0;
    let tokenIds = [];
    do {
      pageCount++;
      const response = await retry(() =>
        alchemy.nft.getNftsForContract(contractAddress, { pageKey })
      );
      if (!response.nfts || !Array.isArray(response.nfts)) {
        const errorMsg = `Invalid NFT response: nfts array missing`;
        log(`[element280] ${errorMsg}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
        throw new Error(errorMsg);
      }
      response.nfts.forEach(nft => {
        const tokenId = nft.tokenId || nft.id || nft.token_id;
        if (tokenId) tokenIds.push(tokenId);
      });
      pageKey = response.pageKey;
    } while (pageKey);
    timings.tokenIdFetch = Date.now() - tokenIdStart;
    log(`[element280] Collected ${tokenIds.length} token IDs in ${timings.tokenIdFetch}ms`);

    if (tokenIds.length === 0) {
      const errorMsg = `No token IDs found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
      throw new Error(errorMsg);
    }

    // Step 2: Fetch owners via contract ownerOf calls
    const ownerFetchStart = Date.now();
    const ownerCalls = tokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'ownerOf',
      args: [BigInt(tokenId)],
    }));
    const limit = pLimit(10);
    const chunkSize = 100;
    const ownerResults = [];
    for (let i = 0; i < ownerCalls.length; i += chunkSize) {
      const chunk = ownerCalls.slice(i, i + chunkSize);
      const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
      ownerResults.push(...results);
    }
    timings.ownerFetch = Date.now() - ownerFetchStart;
    log(`[element280] Fetched owners for ${ownerResults.length} tokens in ${timings.ownerFetch}ms`);

    // Step 3: Process owners
    const ownerProcessStart = Date.now();
    let invalidTokens = 0;
    let nonExistentTokens = 0;
    tokenIds.forEach((tokenId, index) => {
      const result = ownerResults[index];
      if (result.status === 'success') {
        const owner = result.result.toLowerCase();
        if (owner && owner !== burnAddress) {
          ownershipByToken.set(tokenId, owner);
          const walletTokens = ownershipByWallet.get(owner) || [];
          walletTokens.push(tokenId);
          ownershipByWallet.set(owner, walletTokens);
        } else {
          invalidTokens++;
        }
      } else {
        if (result.error?.message.includes('0xdf2d9b42')) {
          nonExistentTokens++;
        } else {
          log(`[element280] Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owners', error: `Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
        invalidTokens++;
      }
    });
    timings.ownerProcess = Date.now() - ownerProcessStart;
    log(`[element280] Processed owners: ${ownershipByToken.size} valid NFTs, skipped ${invalidTokens} invalid tokens (including ${nonExistentTokens} non-existent) in ${timings.ownerProcess}ms`);

    // Step 4: Validate against totalSupply
    const totalSupply = await getTotalSupply(contractAddress, errorLog);
    const expectedLiveTokens = totalSupply - (totalBurnedCache || 0);
    if (ownershipByToken.size === 0) {
      const errorMsg = `No valid NFTs with owners found for contract ${contractAddress}`;
      log(`[element280] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
      throw new Error(errorMsg);
    }
    if (ownershipByToken.size > expectedLiveTokens) {
      const errorMsg = `Found ${ownershipByToken.size} NFTs, more than expected ${expectedLiveTokens}`;
      log(`[element280] Warning: ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    }

    log(`[element280] Completed ownership fetch: ${ownershipByToken.size} NFTs across ${ownershipByWallet.size} wallets`);
    return { ownershipByToken, ownershipByWallet };
  } catch (error) {
    log(`[element280] Failed to fetch NFT ownership: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_ownership', error: error.message });
    throw error;
  }
}

// Populate holdersMapCache with timing and error tracking
async function populateHoldersMapCache(contractAddress, tiers) {
  const contractName = 'element280';
  log(`[element280] Starting populateHoldersMapCache for contract: ${contractAddress}`);
  if (isCachePopulating) {
    log(`[element280] Cache population already in progress`);
    return;
  }
  isCachePopulating = true;
  progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 };
  const timings = {
    totalSupply: 0,
    tokenIdFetch: 0,
    ownerFetch: 0,
    ownerProcess: 0,
    holderInit: 0,
    tierFetch: 0,
    rewardFetch: 0,
    metricsCalc: 0,
    total: 0,
  };
  const errorLog = [];
  const totalStart = Date.now();

  try {
    holdersMapCache = new Map();

    // Step 1: Fetch total supply
    const supplyStart = Date.now();
    const totalTokens = await getTotalSupply(contractAddress, errorLog);
    timings.totalSupply = Date.now() - supplyStart;
    progressState = { step: 'fetching_ownership', processedNfts: 0, totalNfts: totalTokens };
    log(`[element280] Fetched total supply: ${totalTokens} in ${timings.totalSupply}ms`);

    // Step 2: Fetch all NFT ownership
    const { ownershipByToken, ownershipByWallet } = await fetchAllNftOwnership(contractAddress, errorLog, timings);
    totalOwners = ownershipByWallet.size;
    progressState = { step: 'initializing_holders', processedNfts: ownershipByToken.size, totalNfts: totalTokens };
    log(`[element280] Fetched ownership: ${ownershipByToken.size} NFTs, ${totalOwners} wallets`);

    // Step 3: Initialize holders
    const holderInitStart = Date.now();
    ownershipByWallet.forEach((tokenIds, wallet) => {
      const holder = {
        wallet,
        total: tokenIds.length,
        totalLive: tokenIds.length,
        multiplierSum: 0,
        displayMultiplierSum: 0,
        tiers: Array(6).fill(0),
        tokenIds: tokenIds.map(id => BigInt(id)),
        claimableRewards: 0,
        percentage: 0,
        rank: 0,
      };
      holdersMapCache.set(wallet, holder);
      tokenCache.set(`${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })));
    });
    timings.holderInit = Date.now() - holderInitStart;
    log(`[element280] Initialized ${holdersMapCache.size} holders in ${timings.holderInit}ms`);
    progressState = { step: 'fetching_tiers', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 4: Batch fetch tiers
    const tierFetchStart = Date.now();
    const allTokenIds = Array.from(ownershipByToken.keys()).map(id => BigInt(id));
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    if (tierCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const tierResults = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        tierResults.push(...results);
        progressState = {
          step: 'fetching_tiers',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      tierResults.forEach((result, index) => {
        const tokenId = allTokenIds[index].toString();
        if (result.status === 'success') {
          const tier = Number(result.result);
          if (tier >= 1 && tier <= 6) {
            const owner = ownershipByToken.get(tokenId);
            const holder = holdersMapCache.get(owner);
            if (holder) {
              holder.tiers[tier - 1]++;
              tokenCache.set(`${contractAddress}-${tokenId}-tier`, tier);
            } else {
              log(`[element280] Warning: No holder found for token ${tokenId} (owner: ${owner})`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `No holder found for token ${tokenId} (owner: ${owner})` });
            }
          } else {
            log(`[element280] Invalid tier ${tier} for token ${tokenId}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Invalid tier ${tier} for token ${tokenId}` });
          }
        } else {
          log(`[element280] Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tiers', error: `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}` });
        }
      });
    }
    timings.tierFetch = Date.now() - tierFetchStart;
    log(`[element280] Fetched tiers for ${allTokenIds.length} NFTs in ${timings.tierFetch}ms`);
    progressState = { step: 'fetching_rewards', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 5: Batch fetch rewards
    const rewardFetchStart = Date.now();
    const rewardCalls = [];
    ownershipByWallet.forEach((tokenIds, wallet) => {
      tokenIds.forEach(tokenId => {
        rewardCalls.push({
          address: vaultAddresses.element280.address,
          abi: element280VaultAbi,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], wallet],
        });
      });
    });
    if (rewardCalls.length > 0) {
      const limit = pLimit(10);
      const chunkSize = 100;
      const rewardResults = [];
      for (let i = 0; i < rewardCalls.length; i += chunkSize) {
        const chunk = rewardCalls.slice(i, i + chunkSize);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        rewardResults.push(...results);
        progressState = {
          step: 'fetching_rewards',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalTokens,
        };
      }
      let resultIndex = 0;
      ownershipByWallet.forEach((tokenIds, wallet) => {
        let totalRewards = 0n;
        tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          } else {
            log(`[element280] Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `Failed to fetch reward for wallet ${wallet}: ${result.error || 'unknown error'}` });
          }
        });
        const holder = holdersMapCache.get(wallet);
        if (holder) {
          holder.claimableRewards = Number(totalRewards) / 1e18;
          if (isNaN(holder.claimableRewards)) {
            holder.claimableRewards = 0;
            log(`[element280] Warning: NaN rewards for wallet ${wallet}, set to 0`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', error: `NaN rewards for wallet ${wallet}` });
          }
          tokenCache.set(`${contractName}-${wallet}-reward`, holder.claimableRewards);
        }
      });
    }
    timings.rewardFetch = Date.now() - rewardFetchStart;
    log(`[element280] Fetched rewards for ${rewardCalls.length} NFTs in ${timings.rewardFetch}ms`);
    progressState = { step: 'calculating_metrics', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Step 6: Calculate multipliers and metrics
    const metricsStart = Date.now();
    const multipliers = Object.values(tiers).map(t => t.multiplier);
    const totalMultiplierSum = Array.from(holdersMapCache.values()).reduce((sum, holder) => {
      holder.multiplierSum = holder.tiers.reduce(
        (sum, count, index) => sum + count * (multipliers[index] || 0),
        0
      );
      holder.displayMultiplierSum = holder.multiplierSum / 10;
      return sum + holder.multiplierSum;
    }, 0);
    const holders = Array.from(holdersMapCache.values());
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    });
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
      holdersMapCache.set(holder.wallet, holder);
    });
    timings.metricsCalc = Date.now() - metricsStart;
    log(`[element280] Calculated metrics for ${holders.length} holders in ${timings.metricsCalc}ms`);
    progressState = { step: 'idle', processedNfts: ownershipByToken.size, totalNfts: totalTokens };

    // Log summary
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: ownershipByToken.size,
      walletsProcessed: ownershipByWallet.size,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);

  } catch (error) {
    log(`[element280] Failed to populate holdersMapCache: ${error.message}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    holdersMapCache = null;
    cache = {};
    progressState = { step: 'error', processedNfts: 0, totalNfts: 0 };

    // Log summary on error
    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: 0,
      walletsProcessed: 0,
      errors: errorLog,
    };
    log(`[element280] ===== Cache Population Summary Start (Failed) =====\n${JSON.stringify(summary, null, 2)}\n===== Cache Population Summary End =====`);
    throw error;
  } finally {
    isCachePopulating = false;
    totalOwners = 0;
    log(`[element280] Cache population complete, isCachePopulating=false, totalOwners=0`);
  }
}

// Fetch holder data for a specific wallet
async function getHolderData(contractAddress, wallet, tiers) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();
  const walletLower = wallet.toLowerCase();

  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  while (isCachePopulating) {
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  if (holdersMapCache?.has(walletLower)) {
    const holder = holdersMapCache.get(walletLower);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }

  const holder = {
    wallet: walletLower,
    total: 0,
    totalLive: 0,
    multiplierSum: 0,
    displayMultiplierSum: 0,
    tiers: Array(6).fill(0),
    tokenIds: [],
    claimableRewards: 0,
    percentage: 0,
    rank: 0,
  };

  const tokenIdsResponse = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'tokenIdsOf',
      args: [walletLower],
    })
  );
  const tokenIds = tokenIdsResponse.map(id => id.toString());
  const nfts = tokenIds.map(tokenId => ({ tokenId, tier: 0 }));
  holder.total = nfts.length;
  holder.totalLive = nfts.length;
  tokenCache.set(`${contractAddress}-${walletLower}-nfts`, nfts);

  if (nfts.length === 0) {
    return null;
  }

  const bigIntTokenIds = nfts.map(nft => BigInt(nft.tokenId));
  const calls = [];
  bigIntTokenIds.forEach(tokenId => {
    calls.push({
      address: contractAddress,
      abi: element280MainAbi,
      functionName: 'getNftTier',
      args: [tokenId],
    });
    calls.push({
      address: vaultAddresses.element280.address,
      abi: element280VaultAbi,
      functionName: 'getRewards',
      args: [[tokenId], walletLower],
    });
  });

  const results = await retry(() => client.multicall({ contracts: calls }));
  const finalTokenIds = [];
  let totalRewards = 0n;
  nfts.forEach((nft, index) => {
    const tierResult = results[index * 2];
    const rewardResult = results[index * 2 + 1];
    if (tierResult.status === 'success') {
      const tier = Number(tierResult.result);
      if (tier >= 1 && tier <= 6) {
        nft.tier = tier;
        holder.tiers[tier - 1]++;
        finalTokenIds.push(BigInt(nft.tokenId));
        tokenCache.set(`${contractAddress}-${nft.tokenId}-tier`, tier);
      }
    }
    if (rewardResult.status === 'success') {
      const rewardValue = BigInt(rewardResult.result[1] || 0);
      totalRewards += rewardValue;
      tokenCache.set(`${contractAddress}-${nft.tokenId}-single-reward`, rewardValue);
    }
  });
  holder.tokenIds = finalTokenIds;
  holder.claimableRewards = Number(totalRewards) / 1e18;
  if (isNaN(holder.claimableRewards)) {
    holder.claimableRewards = 0;
  }
  tokenCache.set(`${contractName}-${walletLower}-reward`, holder.claimableRewards);

  const multipliers = Object.values(tiers).map(t => t.multiplier);
  holder.multiplierSum = holder.tiers.reduce(
    (sum, count, index) => sum + count * (multipliers[index] || 0),
    0
  );
  holder.displayMultiplierSum = holder.multiplierSum / 10;

  const allHolders = await getAllHolders(contractAddress, tiers, 0, 100);
  const totalMultiplierSum = allHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
  const existingHolder = allHolders.holders.find(h => h.wallet === walletLower);
  holder.rank = existingHolder ? existingHolder.rank : allHolders.holders.length + 1;

  if (holder.total > 0) {
    holdersMapCache?.set(walletLower, holder);
    cache[cacheKey] = { timestamp: now, data: holder };
    return serializeBigInt(holder);
  }
  return null;
}

// Fetch all holders (paginated)
async function getAllHolders(contractAddress, tiers, page = 0, pageSize = 100, refresh = false) {
  const contractName = 'element280';
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (!refresh && cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  let holdersMap = holdersMapCache;
  if (refresh || !holdersMap || isCachePopulating) {
    while (isCachePopulating) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (refresh || !holdersMap) {
      await populateHoldersMapCache(contractAddress, tiers);
      holdersMap = holdersMapCache;
      if (!holdersMap) {
        log(`[element280] Error: holdersMapCache is null after population`);
        throw new Error('Failed to populate holdersMapCache');
      }
    }
  }

  const totalTokens = await getTotalSupply(contractAddress, []);
  const holders = Array.from(holdersMap.values());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, holders.length);
  const paginatedHolders = holders.slice(start, end);

  const result = {
    holders: paginatedHolders,
    totalTokens: holdersMap.size > 0 ? holders.reduce((sum, h) => sum + h.total, 0) : totalTokens,
    totalHolders: holders.length,
    page,
    pageSize,
    totalPages: Math.ceil(holders.length / pageSize),
    summary: {
      totalLive: totalTokens,
      totalBurned: totalBurnedCache || 0,
      multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      totalRewardPool: holders.reduce((sum, h) => sum + h.claimableRewards, 0),
    },
  };

  cache[cacheKey] = { timestamp: now, data: result };
  log(`[element280] Paginated ${paginatedHolders.length} holders: totalHolders=${holders.length}, totalBurned=${result.summary.totalBurned}, multiplierPool=${result.summary.multiplierPool}`);
  return serializeBigInt(result);
}

// GET handler
export async function GET(request) {
  const contractName = 'element280';
  let url = request.url || (request.nextUrl && request.nextUrl.toString());
  if (!url) {
    log(`[element280] Error: Both request.url and request.nextUrl are undefined`);
    return NextResponse.json({ error: 'Invalid request: URL is undefined' }, { status: 400 });
  }

  try {
    const { searchParams } = new URL(url);
    const wallet = searchParams.get('wallet');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
    const refresh = searchParams.get('refresh') === 'true';

    const address = contractAddresses.element280.address;
    if (!address) {
      log(`[element280] Error: Element280 contract address not found`);
      return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
    }

    const startTime = Date.now();
    if (wallet) {
      const holderData = await getHolderData(address, wallet, contractTiers.element280);
      log(`[element280] GET /api/holders/Element280?wallet=${wallet} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt({ holders: holderData ? [holderData] : [] }));
    } else {
      const result = await getAllHolders(address, contractTiers.element280, page, pageSize, refresh);
      log(`[element280] GET /api/holders/Element280?page=${page}&pageSize=${pageSize} completed in ${Date.now() - startTime}ms`);
      return NextResponse.json(serializeBigInt(result));
    }
  } catch (error) {
    log(`[element280] Error in GET /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

// POST handler
export async function POST() {
  const contractName = 'element280';
  const address = contractAddresses.element280.address;
  if (!address) {
    log(`[element280] Error: Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    await populateHoldersMapCache(address, contractTiers.element280);
    log(`[element280] Cache preload completed, total holders: ${holdersMapCache?.size || 0}`);
    return NextResponse.json({ message: 'Cache preload completed', totalHolders: holdersMapCache?.size || 0 });
  } catch (error) {
    log(`[element280] Error in POST /api/holders/Element280: ${error.message}`);
    return NextResponse.json({ error: `Cache preload failed: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Element369/route.js
// app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import { contractDetails, nftContracts } from '../../../nft-contracts';
import { client, alchemy, cache, CACHE_TTL, log, batchMulticall, element369VaultAbi, element369Abi } from '../../utils';

const contractAddress = nftContracts.element369?.address;
const vaultAddress = nftContracts.element369?.vaultAddress;
const tiersConfig = nftContracts.element369?.tiers;
const defaultPageSize = contractDetails.element369?.pageSize || 1000;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || defaultPageSize);
  const wallet = searchParams.get('wallet');

  log(`[Element369] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress) {
      throw new Error('Element369 contract or vault address missing');
    }

    const cacheKey = `element369_holders_${page}_${pageSize}_${wallet || 'all'}`;
    if (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < CACHE_TTL) {
      log(`[Element369] Cache hit: ${cacheKey}`);
      return NextResponse.json(cache[cacheKey].data);
    }
    log(`[Element369] Cache miss: ${cacheKey}`);

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Element369] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const filteredOwners = ownersResponse.owners.filter(
      owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0
    );
    log(`[Element369] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const wallet = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
      ownerTokens.set(wallet, tokenIds);
    });
    log(`[Element369] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Element369] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: element369Abi,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Element369] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const wallet = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && wallet) {
          if (!holdersMap.has(wallet)) {
            holdersMap.set(wallet, {
              wallet,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier + 1).fill(0),
              infernoRewards: 0,
              fluxRewards: 0,
              e280Rewards: 0,
            });
          }
          const holder = holdersMap.get(wallet);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier] += 1;
        } else {
          log(`[Element369] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Element369] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch current cycle for debugging
    let currentCycle = 0;
    try {
      currentCycle = await client.readContract({
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getCurrentE369Cycle',
      });
      log(`[Element369] Current cycle: ${currentCycle}`);
    } catch (error) {
      log(`[Element369] Error fetching cycle: ${error.message}`);
    }

    // Fetch rewards
    const holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: element369VaultAbi,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet, false], // isBacking: false for claimable rewards
      };
    });

    log(`[Element369] Fetching rewards for ${holders.length} holders`);
    const rewardsResults = await batchMulticall(rewardCalls);

    holders.forEach((holder, i) => {
      if (rewardsResults[i]?.status === 'success' && rewardsResults[i].result) {
        const [availability, burned, infernoPool, fluxPool, e280Pool] = rewardsResults[i].result;
        holder.infernoRewards = Number(infernoPool) / 1e18;
        holder.fluxRewards = Number(fluxPool) / 1e18;
        holder.e280Rewards = Number(e280Pool) / 1e18;
        log(
          `[Element369] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Inferno=${holder.infernoRewards.toFixed(4)}, ` +
          `Flux=${holder.fluxRewards.toFixed(4)}, ` +
          `E280=${holder.e280Rewards.toFixed(4)}, ` +
          `Tokens=${availability.length}, Burned=${burned.filter(b => b).length}, ` +
          `Availability=${availability.join(',')}`
        );
        if (holder.infernoRewards === 0 && holder.fluxRewards === 0 && holder.e280Rewards === 0) {
          log(`[Element369] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.infernoRewards = 0;
        holder.fluxRewards = 0;
        holder.e280Rewards = 0;
        log(`[Element369] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardsResults[i]?.error || 'Unknown'}`);
      }
      holder.displayMultiplierSum = holder.multiplierSum;
      holder.percentage = 0;
      holder.rank = 0;
    });

    // Calculate percentages and ranks
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holders.forEach((holder, index) => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.rank = index + 1;
      holder.displayMultiplierSum = holder.multiplierSum;
    });

    // Sort holders
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { data: response, timestamp: Date.now() };
    log(`[Element369] Success: ${holders.length} holders`);

    return NextResponse.json(response);
  } catch (error) {
    log(`[Element369] Error: ${error.message}`);
    console.error('[Element369] Error stack:', error.stack);
    return NextResponse.json({ error: 'Failed to fetch Element369 data' }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders copy/Ascendant/route.js
// app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import { alchemy, client, CACHE_TTL, log, batchMulticall } from '../../utils';
import { contractAddresses, contractTiers, contractDetails } from '@/app/nft-contracts';
import { formatUnits, getAddress } from 'viem';
import { v4 as uuidv4 } from 'uuid';
import ascendantABI from '../../../../abi/ascendantNFT.json';

let cache = {};
let tokenCache = new Map();

// Utility to sanitize BigInt values
function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') {
    return obj.toString();
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => sanitizeBigInt(item));
  }
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}

// Utility to serialize response objects
function safeSerialize(obj) {
  return JSON.parse(JSON.stringify(obj, (key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  ));
}

// Fetch data for all holders with pagination
async function getAllHolders(page = 0, pageSize = 1000, requestId = '') {
  const contractAddress = contractAddresses.ascendant.address; // Fix: Use .address
  const tiers = contractTiers.ascendant;
  const defaultPageSize = contractDetails.ascendant?.pageSize || 1000;
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();

  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  if (!contractAddress || !tiers) {
    throw new Error('Missing contract address or tiers');
  }

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  let owners = [];
  let pageKey = null;
  do {
    const response = await retry(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        block: 'latest',
        withTokenBalances: true,
        pageKey,
      })
    );
    owners = owners.concat(response.owners);
    pageKey = response.pageKey;
  } while (pageKey);

  const burnAddress = '0x000000000000000 DOB0000000000000000000000';
  const filteredOwners = owners.filter(
    (owner) => owner?.ownerAddress && owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances?.length > 0
  );

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach((owner) => {
    if (!owner.ownerAddress) return;
    let wallet;
    try {
      wallet = getAddress(owner.ownerAddress);
    } catch (e) {
      return;
    }
    owner.tokenBalances.forEach((tb) => {
      if (!tb.tokenId) return;
      const tokenId = Number(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);

  if (paginatedTokenIds.length === 0) {
    const result = {
      holders: [],
      totalTokens,
      totalLockedAscendant: 0,
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    cache[cacheKey] = { timestamp: now, data: result };
    return result;
  }

  const tierCalls = paginatedTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = paginatedTokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));

  const [rawTierResults, rawRecordResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults);
  const recordResults = sanitizeBigInt(rawRecordResults);

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));
  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));
  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));
  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  const walletTokenIds = new Map();
  paginatedTokenIds.forEach((tokenId) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!walletTokenIds.has(wallet)) {
      walletTokenIds.set(wallet, []);
    }
    walletTokenIds.get(wallet).push(tokenId);
  });

  const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'batchClaimableAmount',
    args: [tokenIds.map((id) => BigInt(id))],
  }));

  const rawClaimableResults = await retry(() => batchMulticall(claimableCalls));
  const claimableResults = sanitizeBigInt(rawClaimableResults);

  paginatedTokenIds.forEach((tokenId, i) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!holdersMap.has(wallet)) {
      holdersMap.set(wallet, {
        wallet,
        total: 0,
        multiplierSum: 0,
        tiers: Array(maxTier + 1).fill(0),
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: 0,
        pendingDay28: 0,
        pendingDay90: 0,
        claimableRewards: 0,
      });
    }
    const holder = holdersMap.get(wallet);

    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      holder.tiers[tier] += 1;
      holder.total += 1;
      holder.multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const shares = parseFloat(formatUnits(sharesRaw, 18));
      const lockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      holder.shares += shares;
      holder.lockedAscendant += lockedAscendant;
      totalLockedAscendant += lockedAscendant;
    }
  });

  let claimableIndex = 0;
  for (const [wallet, tokenIds] of walletTokenIds.entries()) {
    const holder = holdersMap.get(wallet);
    if (!holder) {
      claimableIndex++;
      continue;
    }
    if (claimableResults[claimableIndex]?.status === 'success') {
      const claimableRaw = claimableResults[claimableIndex].result || '0';
      holder.claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
    }
    claimableIndex++;
  }

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach((holder) => {
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders: sanitizeBigInt(holders),
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  cache[cacheKey] = { timestamp: now, data: result };
  return result;
}

// Fetch data for a specific wallet
async function getHolderData(wallet, requestId = '') {
  const contractAddress = contractAddresses.ascendant.address; // Fix: Use .address
  const tiers = contractTiers.ascendant;
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();


  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    return cache[cacheKey].data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  const checksummedWallet = getAddress(wallet);

  const retry = async (fn, attempts = 3, delay = 1000) => {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        if (i === attempts - 1) throw error;
        await new Promise((res) => setTimeout(res, delay * 2 ** i));
      }
    }
  };

  const nfts = await retry(() =>
    alchemy.nft.getNftsForOwner(checksummedWallet, { contractAddresses: [contractAddress] })
  );

  if (nfts.totalCount === 0) return null;

  const tokenIds = nfts.ownedNfts
    .filter((nft) => nft.contract.address.toLowerCase() === contractAddress.toLowerCase())
    .map((nft) => Number(nft.tokenId));

  if (tokenIds.length === 0) return null;

  const tierCalls = tokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = tokenIds.map((tokenId) => ({
    address: contractAddress,
    abi: ascendantABI,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));
  const claimableCall = [
    {
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'batchClaimableAmount',
      args: [tokenIds.map((id) => BigInt(id))],
    },
  ];

  const [rawTierResults, rawRecordResults, rawClaimableResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls)),
    retry(() => batchMulticall(recordCalls)),
    retry(() => batchMulticall(claimableCall)),
  ]);

  const tierResults = sanitizeBigInt(rawTierResults);
  const recordResults = sanitizeBigInt(rawRecordResults);
  const claimableResults = sanitizeBigInt(rawClaimableResults);

  let claimableRewards = 0;
  if (claimableResults[0]?.status === 'success') {
    const claimableRaw = claimableResults[0].result || '0';
    claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
  }

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;
  let shares = 0;
  let lockedAscendant = 0;

  tokenIds.forEach((tokenId, i) => {
    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      tiersArray[tier] += 1;
      total += 1;
      multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const tokenShares = parseFloat(formatUnits(sharesRaw, 18));
      const tokenLockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      shares += tokenShares;
      lockedAscendant += tokenLockedAscendant;
    }
  });

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: ascendantABI,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  const totalMultiplierSum = multiplierSum || 1;
  const percentage = (multiplierSum / totalMultiplierSum) * 100;
  const rank = 1;

  const result = {
    wallet: checksummedWallet,
    rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum,
    percentage,
    tiers: tiersArray,
    shares,
    lockedAscendant,
    pendingDay8: shares * pendingRewardPerShareDay8,
    pendingDay28: shares * pendingRewardPerShareDay28,
    pendingDay90: shares * pendingRewardPerShareDay90,
    claimableRewards,
  };

  const sanitizedResult = sanitizeBigInt(result);
  cache[cacheKey] = { timestamp: now, data: sanitizedResult };
  return sanitizedResult;
}

// API endpoint handler
export async function GET(request) {
  const requestId = uuidv4();
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || contractDetails.ascendant?.pageSize || 1000, 10);

  try {
    if (wallet) {
      const holderData = await getHolderData(wallet, requestId);
      const response = { holders: holderData ? [holderData] : [] };
      return NextResponse.json(safeSerialize(response));
    }

    const result = await getAllHolders(page, pageSize, requestId);
    return NextResponse.json(safeSerialize(result));
  } catch (error) {
    console.error(`[${requestId}] [PROD_ERROR] Ascendant API error: ${error.message}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils.js
// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

// Shared cache for routes that import it
export const cache = {};

// Import all ABI JSON files using @ notation
import staxNFTAbi from '@/abi/staxNFT.json';
import element369Abi from '@/abi/element369.json';
import element369VaultAbi from '@/abi/element369Vault.json';
import staxVaultAbi from '@/abi/staxVault.json';
import ascendantNFTAbi from '@/abi/ascendantNFT.json';
import element280Abi from '@/abi/element280.json';
import element280VaultAbi from '@/abi/element280Vault.json';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(
    process.env.ETH_RPC_URL ||
    `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`,
    { timeout: 60000 } // Added timeout
  ),
});

// Generic NFT ABI for common functions
export const nftAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNftTier(uint256 tokenId) view returns (uint8)',
]);

// Ascendant NFT ABI with specific functions
export const ascendantAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)',
  'function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)',
  'function totalShares() view returns (uint256)',
  'function toDistribute(uint8 pool) view returns (uint256)',
  'function rewardPerShare() view returns (uint256)',
  'error NonExistentToken(uint256 tokenId)',
]);

// Export all ABIs
export {
  staxNFTAbi,
  element369Abi,
  element369VaultAbi,
  staxVaultAbi,
  ascendantNFTAbi,
  element280Abi,
  element280VaultAbi,
};

export const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export function log(message) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [PROD_DEBUG] ${message}`);
}

export async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults.map((result, idx) => ({
        status: result.status,
        result: result.status === 'success' ? result.result : null,
        error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
      })));
      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);
    } catch (error) {
      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);
      results.push(...batch.map(() => ({
        status: 'failure',
        result: null,
        error: error.message || 'Unknown error',
      })));
    }
  }
  log(`batchMulticall: Completed with ${results.length} results`);
  return results;
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              âœ•
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/nft-contracts.js
// app/nft-contracts.js

// Supported blockchain networks
export const supportedChains = ['ETH', 'BASE'];

// ABI for the main Element280 token contract (unchanged)
export const element280MainAbi = [
  {
    name: 'totalSupply',
    outputs: [{ internalType: 'uint256', name: 'result', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    name: 'balanceOf',
    inputs: [{ internalType: 'address', name: 'owner', type: 'address' }],
    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    name: 'ownerOf',
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    outputs: [{ internalType: 'address', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    name: 'getNftTier',
    inputs: [{ internalType: 'uint256', name: 'tokenId', type: 'uint256' }],
    outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],
    stateMutability: 'view',
    type: 'function',
  },
];

// ABI for Element280 vault contract (unchanged)
export const element280VaultAbi = [
  {
    name: 'getRewards',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { name: 'tokenIds', type: 'uint256[]' },
      { name: 'account', type: 'address' },
    ],
    outputs: [
      { name: 'availability', type: 'bool[]' },
      { name: 'totalReward', type: 'uint256' },
    ],
  },
  {
    name: 'totalRewardPool',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: '', type: 'uint256' }],
  },
];

// NFT contract configurations
export const nftContracts = {
  element280: {
    name: 'Element 280',
    symbol: 'ELMNT',
    chain: 'ETH', // Added chain property
    address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
    vaultAddress: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
    deploymentBlock: '20945304',
    tiers: {
      1: { name: 'Common', multiplier: 10, allocation: '100000000000000000000000000' },
      2: { name: 'Common Amped', multiplier: 12, allocation: '100000000000000000000000000' },
      3: { name: 'Rare', multiplier: 100, allocation: '1000000000000000000000000000' },
      4: { name: 'Rare Amped', multiplier: 120, allocation: '1000000000000000000000000000' },
      5: { name: 'Legendary', multiplier: 1000, allocation: '10000000000000000000000000000' },
      6: { name: 'Legendary Amped', multiplier: 1200, allocation: '10000000000000000000000000000' },
    },
    description:
      'Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.',
  },
  element369: {
    name: 'Element 369',
    symbol: 'E369',
    chain: 'ETH',
    address: '0x024D64E2F65747d8bB02dFb852702D588A062575',
    vaultAddress: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',
    deploymentBlock: '21224418',
    tiers: {
      1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
      2: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
      3: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
    },
    description:
      'Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.',
  },
  stax: {
    name: 'Stax',
    symbol: 'STAX',
    chain: 'ETH',
    address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
    vaultAddress: '0x5D27813C32dD705404d1A78c9444dAb523331717',
    deploymentBlock: '21452667',
    tiers: {
      1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
      2: { name: 'Common Amped', multiplier: 1.2, price: '100000000000000000000000000', amplifier: '10000000000000000000000000' },
      3: { name: 'Common Super', multiplier: 1.4, price: '100000000000000000000000000', amplifier: '20000000000000000000000000' },
      4: { name: 'Common LFG', multiplier: 2, price: '100000000000000000000000000', amplifier: '50000000000000000000000000' },
      5: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
      6: { name: 'Rare Amped', multiplier: 12, price: '1000000000000000000000000000', amplifier: '100000000000000000000000000' },
      7: { name: 'Rare Super', multiplier: 14, price: '1000000000000000000000000000', amplifier: '200000000000000000000000000' },
      8: { name: 'Rare LFG', multiplier: 20, price: '1000000000000000000000000000', amplifier: '500000000000000000000000000' },
      9: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
      10: { name: 'Legendary Amped', multiplier: 120, price: '10000000000000000000000000000', amplifier: '1000000000000000000000000000' },
      11: { name: 'Legendary Super', multiplier: 140, price: '10000000000000000000000000000', amplifier: '2000000000000000000000000000' },
      12: { name: 'Legendary LFG', multiplier: 200, price: '10000000000000000000000000000', amplifier: '5000000000000000000000000000' },
    },
    description:
      'Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.',
  },
  ascendant: {
    name: 'Ascendant',
    symbol: 'ASCNFT',
    chain: 'ETH',
    address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f',
    deploymentBlock: '21112535',
    tiers: {
      1: { name: 'Tier 1', price: '7812500000000000000000', multiplier: 1.01 },
      2: { name: 'Tier 2', price: '15625000000000000000000', multiplier: 1.02 },
      3: { name: 'Tier 3', price: '31250000000000000000000', multiplier: 1.03 },
      4: { name: 'Tier 4', price: '62500000000000000000000', multiplier: 1.04 },
      5: { name: 'Tier 5', price: '125000000000000000000000', multiplier: 1.05 },
      6: { name: 'Tier 6', price: '250000000000000000000000', multiplier: 1.06 },
      7: { name: 'Tier 7', price: '500000000000000000000000', multiplier: 1.07 },
      8: { name: 'Tier 8', price: '1000000000000000000000000', multiplier: 1.08 },
    },
    description:
      'Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.',
  },
  e280: {
    name: 'E280',
    symbol: 'E280',
    chain: 'BASE',
    address: null,
    deploymentBlock: null,
    tiers: {},
    description: 'E280 NFTs on BASE chain. Contract not yet deployed.',
  },
};

// Contract addresses (updated to include chain)
export const contractAddresses = {
  element280: { chain: nftContracts.element280.chain, address: nftContracts.element280.address },
  element369: { chain: nftContracts.element369.chain, address: nftContracts.element369.address },
  stax: { chain: nftContracts.stax.chain, address: nftContracts.stax.address },
  ascendant: { chain: nftContracts.ascendant.chain, address: nftContracts.ascendant.address },
  e280: { chain: nftContracts.e280.chain, address: nftContracts.e280.address },
};

// Vault addresses (updated to include chain)
export const vaultAddresses = {
  element280: { chain: nftContracts.element280.chain, address: nftContracts.element280.vaultAddress },
  element369: { chain: nftContracts.element369.chain, address: nftContracts.element369.vaultAddress },
  stax: { chain: nftContracts.stax.chain, address: nftContracts.stax.vaultAddress },
  e280: { chain: nftContracts.e280.chain, address: null },
};

// Deployment blocks (updated to include chain)
export const deploymentBlocks = {
  element280: { chain: nftContracts.element280.chain, block: nftContracts.element280.deploymentBlock },
  element369: { chain: nftContracts.element369.chain, block: nftContracts.element369.deploymentBlock },
  stax: { chain: nftContracts.stax.chain, block: nftContracts.stax.deploymentBlock },
  ascendant: { chain: nftContracts.ascendant.chain, block: nftContracts.ascendant.deploymentBlock },
  e280: { chain: nftContracts.e280.chain, block: nftContracts.e280.deploymentBlock },
};

// Contract tiers (unchanged)
export const contractTiers = {
  element280: {
    1: { name: nftContracts.element280.tiers[1].name, multiplier: nftContracts.element280.tiers[1].multiplier },
    2: { name: nftContracts.element280.tiers[2].name, multiplier: nftContracts.element280.tiers[2].multiplier },
    3: { name: nftContracts.element280.tiers[3].name, multiplier: nftContracts.element280.tiers[3].multiplier },
    4: { name: nftContracts.element280.tiers[4].name, multiplier: nftContracts.element280.tiers[4].multiplier },
    5: { name: nftContracts.element280.tiers[5].name, multiplier: nftContracts.element280.tiers[5].multiplier },
    6: { name: nftContracts.element280.tiers[6].name, multiplier: nftContracts.element280.tiers[6].multiplier },
  },
  element369: nftContracts.element369.tiers,
  stax: nftContracts.stax.tiers,
  ascendant: nftContracts.ascendant.tiers,
  e280: nftContracts.e280.tiers,
};

// Contract details (updated to include chain)
export const contractDetails = {
  element280: {
    name: nftContracts.element280.name,
    chain: nftContracts.element280.chain,
    pageSize: 100,
    apiEndpoint: '/api/holders/Element280',
    rewardToken: 'ELMNT',
  },
  element369: {
    name: nftContracts.element369.name,
    chain: nftContracts.element369.chain,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Element369',
    rewardToken: 'INFERNO/FLUX/E280',
  },
  stax: {
    name: nftContracts.stax.name,
    chain: nftContracts.stax.chain,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Stax',
    rewardToken: 'X28',
  },
  ascendant: {
    name: nftContracts.ascendant.name,
    chain: nftContracts.ascendant.chain,
    pageSize: 1000,
    apiEndpoint: '/api/holders/Ascendant',
    rewardToken: 'DRAGONX',
  },
  e280: {
    name: nftContracts.e280.name,
    chain: nftContracts.e280.chain,
    pageSize: 1000,
    apiEndpoint: '/api/holders/E280',
    rewardToken: 'E280',
    disabled: true,
  },
};

// Utility function to get contract details by name
export function getContractDetails(contractName) {
  return nftContracts[contractName] || null;
}-e 
---
File: ./app/ClientProvider.js
// app/ClientProvider.js
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 60 * 1000, // 30 minutes
      cacheTime: 60 * 60 * 1000, // 1 hour
    },
  },
});

export default function ClientProvider({ children }) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.

const config = {
  plugins: ["tailwindcss"],
};
export default config;-e 
---
File: ./bak/ETH/Stax/page.js
// app/nft/ETH/Stax/page.js
import NFTPage from '@/components/NFTPage';

export default function StaxPage({ params }) {
  return <NFTPage params={params} />;
}-e 
---
File: ./bak/ETH/Element280/page.js
// app/nft/ETH/Element280/page.js
import NFTPage from '@/components/NFTPage';

export default function Element280Page({ params }) {
  return <NFTPage params={params} />;
}-e 
---
File: ./bak/ETH/Element369/page.js
// app/nft/ETH/Element369/page.js
import NFTPage from '@/components/NFTPage';

export default function Element369Page({ params }) {
  return <NFTPage params={params} />;
}-e 
---
File: ./bak/ETH/Ascendant/page.js
// app/nft/ETH/Ascendant/page.js
import NFTPage from '@/components/NFTPage';

export default function AscendantPage({ params }) {
  return <NFTPage params={params} />;
}-e 
---
File: ./bak/BASE/E280/page.js
// app/nft/BASE/E280/page.js
import NFTPage from '@/components/NFTPage';

export default function E280Page({ params }) {
  return <NFTPage params={params} />;
}-e 
---
File: ./next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
-e 
---
File: ./README.md
Please find below my Nextjs project TitanXUtils.  This part is concentrating on 4 NFT colections and analysing their data.

Element369, Stax and Ascendant are complete.

I am still trying to perfect the Element280 NFT collection.
All 4 of these are on Ethereum.
I also have a placeholder for future collection E280; this will be deployed on BASE

I have a few components that are important for this analysis.
It shoud be noted that any code changes and enhancements/testing scripts should not risk breaking the work we've already done for  Element369, Stax and Ascendant 


Please let me know if you need me to share the contents of any source file to help your analysis.


  We've just finished the population of a database for Element280 NFTs data.
  We used the scripts // scripts/trackElement280NFTs.js

The below is definite states for the following 3 wallets so that we can test and check output.
We have run through  the tests and the database seems to match up so we good to move forward.

These 3 are the wallets that I own:
0x15702443110894B26911B913b17ea4931F803B02
0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
0x9D641961a31B3eED46e664fA631aAD3021323862

wallet: 0x15702443110894B26911B913b17ea4931F803B02
this output should be the following:
Element 280, live nfts count 29, 5 amped legendary, 1 legendary, 6 rare amped and 17 amp common: 
Minted 2  
Tiers minted  [0,0,0,0,0,2]
Transferred in  28
Transferred out  1
Burned 0

wallet: 0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
this output should be the following:
Element 280, live nfts count 0
Minted 22 
Tiers minted  [[0,17,0,3,0,2]
Transferred in 6
Transferred out 27
Burned 1

wallet: 0x9D641961a31B3eED46e664fA631aAD3021323862
this output should be the following:
Element 280, live nfts count 0
Minted 0
Tiers minted   [0,0,0,0,0,0]
Transferred in 2
Transferred out 2
Burned 0

The current claimable reward Element280 tokens for wallet 0x15702443110894B26911B913b17ea4931F803B02 is currently 1,301,036,482 and my current % of rewards is 1.199%

This is because it is only valid for wallets that currently own at least bone element280 NFT to have a current claimable amount.  This information can be used with the Element280Vault contract and abi to calculate the Claimable value for a wallet.  

The project code and data sources that I think we need for our further analysis is below.

public/data/element280_nft_status.json
public/data/element280.db

components/HolderTable.js
components/NFTPage.js
components/Navbar.jsx
components/SearchResultsModal.js

app/holders/Element280/route.js
app/holders/utils.js

nft/ETH/page.js
nft/ETH/layout.js
nft/ETH/Element280/page.js

app/nft-contracts.js  - contains all the contracts - should not be changed
app/page.js
app/layout.js

.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI

project includes below

{
  "name": "titanx-utility",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@covalenthq/client-sdk": "^2.2.5",
    "@tanstack/react-query": "^5.72.1",
    "@wagmi/connectors": "^5.7.11",
    "alchemy-sdk": "^3.5.6",
    "chart.js": "^4.4.9",
    "dotenv": "^16.5.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.3",
    "minimist": "^1.2.8",
    "next": "14.2.15",
    "node-fetch": "^3.3.2",
    "p-limit": "^6.2.0",
    "pino": "^9.6.0",
    "pino-pretty": "^13.0.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-virtualized": "^9.22.6",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.1.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.15",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^3.4.17"
  }
}

===========next

Thank you for the additional requirements. To summarize, the solution must:
Be specific to Element 280, ensuring no impact on other NFT collections.

Address potential database staleness by querying the blockchain for the latest data while using the element280.db database for wallet-specific data and complex aggregates.

Update the element280.db database with any new data obtained from the blockchain to keep it as up-to-date as possible.

Resolve the SQLITE_ERROR: table element280_summary has no column named totalRewardPool issue for the NFT->ETH->Element280 page.

Ensure the solution is quick, easy, and verifies the three walletsâ€™ data from wallets.json.

Weâ€™ll implement a hybrid approach that:
Fetches real-time data (totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, tierDistribution) from the Element 280 NFT and vault contracts using a single multicall and Alchemyâ€™s getOwnersForContract.

Queries the database (element280.db) for wallet-specific data (element280_wallets) and burnedDistribution, as computing historical burn data on-chain is complex.

Updates the element280_summary table with fresh blockchain data to keep it up-to-date.

Ensures all changes are isolated to Element 280-specific code (/api/holders/Element280, public/data/element280.db, and optionally trackElement280NFTs.js).

This approach resolves the SQLITE_ERROR, ensures real-time accuracy, keeps the database updated, and remains specific to Element 280.
Key Considerations
Element 280 Specificity:
Modify only /api/holders/Element280 (or equivalent, e.g., app/api/holders/Element280/route.js or pages/api/holders/Element280.js).

Use public/data/element280.db, isolated from other collectionsâ€™ databases.

Reference only Element 280â€™s CONTRACT_ADDRESS (NFT) and VAULT_CONTRACT_ADDRESS (vault).

Avoid shared utilities or ABIs used by other collections.

Handling Database Staleness:
Fetch totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, and tierDistribution from the blockchain for real-time data.

Query element280_wallets for wallet data and element280_summary for burnedDistribution (historical data).

Update element280_summary with new blockchain data to keep it current.

Database Updates:
Add totalRewardPool to element280_summary schema to store blockchain-fetched data.

Update totalWallets, tierDistribution, and other fields in element280_summary with blockchain data.

Ensure element280_wallets updates are handled by trackElement280NFTs.js (existing script).

Solution Goals:
Resolve SQLITE_ERROR by adding totalRewardPool to the database and fetching it on-chain.

Ensure real-time data for critical metrics.

Maintain performance by leveraging the database for wallet data.

Keep changes minimal and Element 280-specific.

Implementation
Step 1: Update the Database Schema
Since the SQLITE_ERROR indicates element280_summary lacks a totalRewardPool column, weâ€™ll add it to the schema. This requires updating trackElement280NFTs.js to include totalRewardPool and ensure the database is ready for updates from the API handler.
Update initDb in trackElement280NFTs.js:


its not just the summary table that needs to be updated with the latet data.  All the tables in the batabase need to be aswell.  These tables can be seen in the file scripts/trackElement280NFTs.jsspecifically the tables are described by the creation code in this file:


      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);```



  Element 369: show Unique Wallets, Active NFTs, Inferno , Flux and Element 280 Rewards
Element 280: show unique wallets, NUmber live NFTs, number burned NFTs,  keep the live NFTs distribution list
Stax:  Unique wallets, NUm live NFTs, NUmber of burned NFts, the live NFTs distribution list if available
Ascendant:  Unique wallets, Active NFTs, Total Ascendant Locked, Total Claimable rewards, Total Pending REwards


-e 
---
File: ./components/NFTPage copy.js
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from './LoadingIndicator';
import { contractDetails, contractTiers, contractAddresses, vaultAddresses } from '@/app/nft-contracts';
import { Bar } from 'react-chartjs-2';
import Chart from 'chart.js/auto';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// Contract ABIs for Element280
const element280Abi = [
  { name: 'totalSupply', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'totalBurned', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getTotalNftsPerTiers', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256[]' }] },
  { name: 'multiplierPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];
const element280VaultAbi = [
  { name: 'totalRewardPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];

// Retry utility
async function retry(fn, attempts = 5, delay = retryCount => Math.min(2000 * 2 ** retryCount, 10000)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = contractAddresses.element280.address;
  const vaultAddress = vaultAddresses.element280.address;
  console.log('[fetchContractData] contractAddress:', contractAddress);
  console.log('[fetchContractData] vaultAddress:', vaultAddress);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI`, { timeout: 60000 }),
  });

  try {
    const [totalSupply, totalBurned, tierCounts, multiplierPool, totalRewardPool] = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: element280Abi, functionName: 'totalSupply' },
          { address: contractAddress, abi: element280Abi, functionName: 'totalBurned' },
          { address: contractAddress, abi: element280Abi, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: element280Abi, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: element280VaultAbi, functionName: 'totalRewardPool' },
        ],
      })
    );
    return {
      totalMinted: Number(totalSupply.result) + Number(totalBurned.result),
      totalBurned: Number(totalBurned.result),
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.result.map(Number),
      multiplierPool: Number(multiplierPool.result),
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution: [0, 0, 0, 0, 0, 0],
    };
  } catch (error) {
    console.error('[fetchContractData] Error:', error.message);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  console.log('[NFTPage] Received props:', { chain, contract });

  // Derive contract identifier (convert to lowercase)
  const contractId = contract ? contract.toLowerCase() : null;
  console.log('[NFTPage] Derived contractId:', contractId);

  // Validate contract
  if (!contractId || !contractDetails[contractId]) {
    console.error('[NFTPage] Invalid or missing contract:', { chain, contract });
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">Error</h1>
        <p className="text-red-500 text-lg">Invalid contract: {contractId || 'none specified'}</p>
      </div>
    );
  }

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [cache, setCache] = useState({});

  const contractConfig = contractDetails[contractId];
  console.log('[NFTPage] contractConfig:', contractConfig);
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  // Load HolderTable with error handling
  let HolderTable = holderTableComponents[contractId];
  if (!HolderTable) {
    console.error(`[NFTPage] HolderTable for ${contractId} not found`);
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-red-500 text-lg">Error: Holder table component for {contractId} not found</p>
      </div>
    );
  }
  console.log('[NFTPage] Selected HolderTable:', HolderTable.name);

  // Cache helpers
  const getCache = (key) => cache[key];
  const updateCache = (key, value) => setCache(prev => ({ ...prev, [key]: value }));

  // Check for disabled contract (e.g., E280)
  useEffect(() => {
    if (disabled) {
      console.log(`[NFTPage] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    }
  }, [disabled, name]);

  // Fetch data function
  const fetchData = async () => {
    if (disabled || !apiEndpoint) {
      if (!disabled) {
        console.log('[NFTPage] Invalid contract configuration');
        setError('Invalid contract configuration');
      }
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      if (isElement280) {
        console.log(`[NFTPage] Fetching progress from ${apiEndpoint}/progress`);
        const res = await fetch(`${apiEndpoint}/progress`, { cache: 'no-store' });
        console.log('[NFTPage] Progress response status:', res.status);
        if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
        const progressData = await res.json();
        console.log('[NFTPage] Progress data:', progressData);
        setProgress(progressData);
      }
      await fetchAllHolders();
    } catch (err) {
      console.error('[NFTPage] Fetch error:', err.message);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  };

  // Initial data fetch (no polling)
  useEffect(() => {
    fetchData();
  }, [apiEndpoint, contractId, isElement280, disabled]);

  async function fetchAllHolders() {
    const cachedData = getCache(contractId);
    if (cachedData) {
      console.log('[NFTPage] Using cached data for:', contractId);
      setData(cachedData);
      setLoading(false);
      return;
    }

    try {
      console.log(`[NFTPage] Starting fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || 100;

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = 5;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            console.log(`[NFTPage] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { signal: AbortSignal.timeout(60000) });
            console.log('[NFTPage] Fetch response status:', res.status);
            if (!res.ok) {
              const errorText = await res.text();
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            console.log('[NFTPage] Fetch response data:', json);
            const newHolders = json.holders || [];
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            console.log(`[NFTPage] Fetched page ${page}: ${newHolders.length} holders, totalPages: ${totalPages}`);
            page++;
            success = true;
            if (!newHolders || newHolders.length === 0) break;
          } catch (err) {
            attempts++;
            if (err.message.includes('Rate limit') || err.name === 'TimeoutError') {
              console.log(`[NFTPage] Retry ${attempts} for ${contractId} page ${page}: ${err.message}`);
              await new Promise(resolve => setTimeout(resolve, 2000 * 2 ** attempts));
            } else {
              throw err;
            }
          }
        }
        if (!success) {
          throw new Error(`Failed to fetch page ${page} for ${contractId} after ${maxAttempts} attempts`);
        }
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) {
          holder.shares = holder.shares || holder.totalShares || 0;
          holder.totalNfts = holder.totalNfts || holder.total || 0;
          uniqueHoldersMap.set(holder.wallet, holder);
        }
      });
      const uniqueHolders = Array.from(uniqueHoldersMap.values());

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      if (contractId === 'element369') {
        totalInfernoRewards = uniqueHolders.reduce((sum, h) => sum + (h.infernoRewards || 0), 0);
        totalFluxRewards = uniqueHolders.reduce((sum, h) => sum + (h.fluxRewards || 0), 0);
        totalE280Rewards = uniqueHolders.reduce((sum, h) => sum + (h.e280Rewards || 0), 0);
      } else {
        totalClaimableRewards = uniqueHolders.reduce((sum, h) => sum + (h.claimableRewards || 0), 0);
      }
      if (!totalTokens && uniqueHolders.length > 0) {
        totalTokens = uniqueHolders.reduce((sum, h) => sum + (isElement280 ? h.totalLive || 0 : h.totalNfts || 0), 0);
      }

      uniqueHolders.forEach(holder => {
        holder.sharesPercentage = totalShares > 0 ? ((holder.shares || 0) / totalShares) * 100 : 0;
      });

      if (contractId === 'ascendant') {
        uniqueHolders.sort((a, b) => {
          const sharesDiff = (b.shares || 0) - (a.shares || 0);
          if (sharesDiff !== 0) return sharesDiff;
          return (b.totalNfts || 0) - (a.totalNfts || 0);
        });
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.totalLive || b.total || 0) - (a.totalLive || a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      }

      let fetchedData = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      if (isElement280) {
        try {
          const blockchainSummary = await fetchContractData();
          fetchedData.summary = { ...fetchedData.summary, ...blockchainSummary };
          fetchedData.totalTokens = blockchainSummary.totalLive || fetchedData.totalTokens;
          fetchedData.totalShares = blockchainSummary.multiplierPool || fetchedData.totalShares;
          fetchedData.totalClaimableRewards = blockchainSummary.totalRewardPool || fetchedData.totalClaimableRewards;
        } catch (err) {
          console.error('[NFTPage] Blockchain Summary Fetch Error:', err.message);
        }
      }

      updateCache(contractId, fetchedData);
      setData(fetchedData);
      setLoading(false);
      console.log(`[NFTPage] Successfully fetched ${uniqueHolders.length} holders for ${contractId}`);
    } catch (err) {
      console.error('[NFTPage] Fetch Error:', err.message);
      setError(`Failed to load ${name} holders: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }

  const renderSummary = () => {
    if (!data) return null;
  
    const totalMultiplierSum = data.totalShares || data.holders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
    const totalTokens = data.totalTokens || 0;
    const totalClaimableRewards = data.totalClaimableRewards || 0;
    const totalInfernoRewards = data.totalInfernoRewards || 0;
    const totalFluxRewards = data.totalFluxRewards || 0;
    const totalE280Rewards = data.totalE280Rewards || 0;
  
    if (contractId === 'element280') {
      const summary = data.summary || {};
      const totalSupply = Number(summary.totalLive || totalTokens || 0);
      const totalBurned = Number(summary.totalBurned || 0);
      const totalInitialSupply = totalSupply + totalBurned;
      const percentBurned = totalInitialSupply > 0 ? ((totalBurned / totalInitialSupply) * 100).toFixed(2) : '0.00';
      const tierDistribution = summary.tierDistribution || [0, 0, 0, 0, 0, 0];
      const burnedDistribution = summary.burnedDistribution || [0, 0, 0, 0, 0, 0];
      const multiplierPool = Number(summary.multiplierPool || totalShares || 0);
      const totalRewardPool = Number(summary.totalRewardPool || totalClaimableRewards || 0);
  
      const tierData = Object.values(contractTiers.element280).map((tier, index) => {
        const remainingCount = Number(tierDistribution[index] || 0);
        const burnedCount = Number(burnedDistribution[index] || 0);
        const initialCount = remainingCount + burnedCount;
        const burnedPercentage = initialCount > 0 ? ((burnedCount / initialCount) * 100).toFixed(2) : '0.00';
        return {
          name: tier.name,
          count: remainingCount,
          percentage: totalSupply > 0 ? ((remainingCount / totalSupply) * 100).toFixed(2) : '0.00',
          multiplier: tier.multiplier,
          burned: burnedCount,
          burnedPercentage,
        };
      });
  
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element280 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Initial Supply</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalInitialSupply.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Minted NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Burned</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalBurned.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Burned NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Remaining</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalSupply.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Circulating NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Burned Percentage</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{percentBurned}%</p>
              <p className="text-sm text-gray-400">Of Total Minted</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Multiplier Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{multiplierPool.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Sum of Multipliers</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Reward Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </p>
              <p className="text-sm text-gray-400">Claimable Rewards</p>
            </div>
          </div>
          <div>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-lg font-semibold text-gray-300">Tier distribution of remaining live NFTs</h3>
              <motion.button
                className="px-4 py-2 bg-gray-700 text-gray-300 rounded-lg hover:bg-gray-600 focus:outline-none"
                onClick={() => setShowChart(!showChart)}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                {showChart ? 'Hide Chart' : 'Show Chart'}
              </motion.button>
            </div>
            <div className="overflow-x-auto">
              <table className="w-full text-left border-collapse bg-gray-800 rounded-lg">
                <thead>
                  <tr className="bg-gray-700 text-gray-300">
                    <th className="p-3 text-sm font-semibold">Tier</th>
                    <th className="p-3 text-sm font-semibold text-right">Count</th>
                    <th className="p-3 text-sm font-semibold text-right">% remaining NFTs</th>
                    <th className="p-3 text-sm font-semibold text-right">Multiplier</th>
                    <th className="p-3 text-sm font-semibold text-right">Burned</th>
                    <th className="p-3 text-sm font-semibold text-right">% Burned</th>
                  </tr>
                </thead>
                <tbody>
                  {tierData.map((tier, index) => (
                    <tr
                      key={tier.name}
                      className={`border-b border-gray-700 ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
                    >
                      <td className="p-3 text-gray-300">{tier.name}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.count.toLocaleString('en-US')}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.percentage}%</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.multiplier}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burned.toLocaleString('en-US')}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burnedPercentage}%</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
          <AnimatePresence>
            {showChart && (
              <motion.div
                className="bg-gray-800 p-4 rounded-lg shadow-md"
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <h3 className="text-lg font-semibold text-gray-300 mb-3">Tier Distribution Chart</h3>
                <div className="w-full max-w-[800px] mx-auto" style={{ height: '300px' }}>
                  <Bar
                    data={{
                      labels: tierData.map(t => t.name),
                      datasets: [
                        {
                          label: 'Remaining NFTs',
                          data: tierData.map(t => t.count),
                          backgroundColor: 'rgba(75, 192, 192, 0.6)',
                          borderColor: 'rgba(75, 192, 192, 1)',
                          borderWidth: 1,
                        },
                        {
                          label: 'Burned NFTs',
                          data: tierData.map(t => t.burned),
                          backgroundColor: 'rgba(255, 99, 132, 0.6)',
                          borderColor: 'rgba(255, 99, 132, 1)',
                          borderWidth: 1,
                        },
                      ],
                    }}
                    options={{
                      maintainAspectRatio: false,
                      scales: {
                        y: {
                          beginAtZero: true,
                          title: { display: true, text: 'Number of NFTs', color: '#d1d5db' },
                          ticks: { color: '#d1d5db', callback: value => value.toLocaleString('en-US') },
                          grid: { color: '#4b5563' },
                        },
                        x: {
                          title: { display: true, text: 'Tier', color: '#d1d5db' },
                          ticks: { color: '#d1d5db' },
                          grid: { display: false },
                        },
                      },
                      plugins: { legend: { labels: { color: '#d1d5db' } } },
                    }}
                  />
                </div>
              </motion.div>
            )}
          </AnimatePresence>
          <div className="bg-gray-800 p-4 rounded-lg shadow-md">
            <p className="text-gray-300">
              Number of Unique Wallets Holding NFTs: <span className="font-bold text-white font-mono">{data.holders.length.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Number of Active NFTs in Circulation: <span className="font-bold text-white font-mono">{totalSupply.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Multiplier Sum: <span className="font-bold text-white font-mono">{multiplierPool.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Reward Pool: <span className="font-bold text-white font-mono">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </span>
            </p>
          </div>
        </div>
      );
    } else if (contractId === 'ascendant') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Ascendant Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Locked</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.totalLockedAscendant || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Ascendant NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Shares</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.totalShares || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'DRAGONX'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Pending Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.pendingRewards || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">DragonX Rewards</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'element369') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element369 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Inferno Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalInfernoRewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Flux Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalFluxRewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">E280 Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalE280Rewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'stax') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Stax Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'X28'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    } else {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">{name} Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'Unknown'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    }
  };

  const getLoadingMessage = () => {
    if (!isElement280) {
      return `Loading all ${name || 'contract'} holders (may take up to 60 seconds)...`;
    }
    if (progress.isPopulating) {
      return `Fetching ${name} data: ${progress.phase} (${progress.progressPercentage}%)...`;
    }
    return `Finalizing ${name} data...`;
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      {loading ? (
        <LoadingIndicator status={getLoadingMessage()} progress={progress} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : data.message ? (
        <p className="text-gray-400 text-lg">{data.message}</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractId}
            summary={data.summary}
            loading={loading}
            totalShares={isElement280 ? data.summary?.multiplierPool : data.totalShares}
            totalLockedAscendant={data.totalLockedAscendant}
            toDistributeDay8={data.toDistributeDay8}
            toDistributeDay28={data.toDistributeDay28}
            toDistributeDay90={data.toDistributeDay90}
            pendingRewards={data.pendingRewards}
            totalClaimableRewards={data.totalClaimableRewards}
            totalInfernoRewards={data.totalInfernoRewards}
            totalFluxRewards={data.totalFluxRewards}
            totalE280Rewards={data.totalE280Rewards}
            burnedNfts={data.burnedNfts}
          />
          <div className="mt-8">
            <h3 className="text-xl font-bold mb-2">Raw Data:</h3>
            <pre className="text-sm bg-gray-800 p-4 rounded-lg shadow-md overflow-auto">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/loadElement280NFTsDB.js
// components/loadElement280NFTsDB.js

// Global error handlers
process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
  process.exit(1);
});
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

import { createPublicClient, http, parseAbiItem } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import path from 'path';
import pLimit from 'p-limit';
import { execSync } from 'child_process';
import pino from 'pino';
import { fileURLToPath } from 'url';
import minimist from 'minimist';
import { contractAddresses, vaultAddresses, deploymentBlocks, contractTiers } from '../app/nft-contracts.js';
import { Semaphore } from 'async-mutex';

// Initialize environment
dotenv.config({ path: path.join(process.cwd(), '.env.local') });

// Parse command-line arguments
const args = minimist(process.argv.slice(2), {
  alias: { h: 'help', v: 'verbose', q: 'quiet' },
  boolean: ['verbose', 'quiet'],
});
const FORCE_REFRESH = args.refresh || (args.wallets ? true : false);
const FULL_MODE = args.full || !args.wallets;
const CUSTOM_WALLETS = args.wallets ? args.wallets.split(',').map(addr => addr.trim().toLowerCase()) : [];
const SHOW_HELP = args.help || false;
const SHOW_SUMMARY = args.summary || false;
const VERBOSE_MODE = args.verbose || true;
const QUIET_MODE = args.quiet || false;

// Validate logging options
if (VERBOSE_MODE && QUIET_MODE) {
  console.error('Error: Cannot use both --verbose (-v) and --quiet (-q) together');
  process.exit(1);
}

// Logger setup
const logLevel = VERBOSE_MODE ? 'debug' : QUIET_MODE ? 'error' : 'info';
const logger = pino({
  level: logLevel,
  transport: {
    target: 'pino-pretty',
    options: { colorize: true, translateTime: 'SYS:standard' },
  },
});

// Semaphore for database transaction serialization
const dbSemaphore = new Semaphore(1);

// Constants
const CONTRACT_ADDRESS = contractAddresses.element280;
const VAULT_CONTRACT_ADDRESS = vaultAddresses.element280;
const DEPLOYMENT_BLOCK = Number(deploymentBlocks.element280);
const CACHE_FILE = path.join(process.cwd(), 'public', 'data', 'element280_nft_status.json');
const DB_FILE = path.join(process.cwd(), 'public', 'data', 'element280.db');
const CHECKPOINT_FILE = path.join(process.cwd(), 'public', 'data', 'element280_checkpoint.json');
const FAILED_TOKENS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_tokens.json');
const SKIPPED_TOKENS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_tokens.json');
const SKIPPED_TOKENS_DETAILED_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_tokens_detailed.json');
const FAILED_INSERTS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_inserts.json');
const FAILED_BLOCKS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_blocks.json');
const SKIPPED_WALLETS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_wallets.json');
const COLLECTED_WALLETS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_collected_wallets.json');
const BACKUP_DIR = path.join(process.cwd(), 'scripts', 'backups');
const MAX_BLOCK_RANGE = 5000;
const MAX_CONCURRENT_BLOCKS = 3;
const MAX_CONCURRENT_WALLETS = 1;
const MAX_MULTICALL_BATCH = 50;
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const ELMNT_DECIMALS = 18;
const BLOCK_STEP = 1000;
const DEBUG_WALLETS = [
  '0x15702443110894b26911b913b17ea4931f803b02',
  '0xf98f0ee190d9f2e6531e226933f1e47a2890cbda',
  '0x9d641961a31b3eed46e664fa631aad3021323862',
];
const DEBUG_TOKEN_IDS = [16028, 630, 631, 632];

// Verify environment
const ALCHEMY_API_KEY = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!ALCHEMY_API_KEY) {
  logger.error('ALCHEMY_API_KEY not defined in .env.local');
  process.exit(1);
}

// Contract ABIs
const element280Abi = [
  { name: 'totalSupply', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'totalBurned', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getTotalNftsPerTiers', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256[]' }] },
  { name: 'multiplierPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getNftTier', type: 'function', stateMutability: 'view', inputs: [{ type: 'uint256' }], outputs: [{ type: 'uint8' }] },
  { name: 'balanceOf', type: 'function', stateMutability: 'view', inputs: [{ type: 'address' }], outputs: [{ type: 'uint256' }] },
  { name: 'ownerOf', type: 'function', stateMutability: 'view', inputs: [{ type: 'uint256' }], outputs: [{ type: 'address' }] },
  {
    name: 'getClaimableRewardsForTokens',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'uint256[]' }],
    outputs: [{ type: 'uint256' }],
  },
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      { indexed: true, name: 'from', type: 'address' },
      { indexed: true, name: 'to', type: 'address' },
      { indexed: true, name: 'tokenId', type: 'uint256' },
    ],
  },
  { type: 'error', name: 'NonexistentToken', inputs: [] },
];

const element280VaultAbi = [
  { name: 'totalRewardPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  {
    name: 'getRewards',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { type: 'uint256[]', name: 'tokenIds' },
      { type: 'address', name: 'account' },
    ],
    outputs: [
      { type: 'bool[]', name: 'availability' },
      { type: 'uint256', name: 'totalReward' },
    ],
  },
];

// Clients
const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`, { timeout: 60000 }),
});
const alchemy = new Alchemy({ apiKey: ALCHEMY_API_KEY, network: Network.ETH_MAINNET });

// Utility Functions
async function retry(fn, attempts = 5, delay = retryCount => Math.min(1000 * 2 ** retryCount, 10000)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        logger.error(`Failed after ${attempts} attempts: ${error.message}`);
        throw error;
      }
      logger.warn(`Retry ${i + 1}/${attempts}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

async function executeDbTransaction(db, fn) {
  const [value, release] = await dbSemaphore.acquire();
  try {
    await db.run('BEGIN TRANSACTION');
    const result = await fn();
    await db.run('COMMIT');
    return result;
  } catch (error) {
    await db.run('ROLLBACK');
    logger.error(`Transaction failed: ${error.message}`);
    throw error;
  } finally {
    release();
  }
}

async function clearDatabase() {
  logger.debug('Clearing database');
  const backupFile = path.join(BACKUP_DIR, `element280_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.sql`);
  await fs.mkdir(BACKUP_DIR, { recursive: true });
  try {
    execSync(`sqlite3 ${DB_FILE} .dump > ${backupFile}`);
    logger.info(`Backup created: ${backupFile}`);
  } catch (error) {
    logger.warn(`Backup failed: ${error.message}`);
  }
  const db = await open({ filename: DB_FILE, driver: sqlite3.Database });
  await db.exec('DROP TABLE IF EXISTS element280_summary; DROP TABLE IF EXISTS element280_transfers; DROP TABLE IF EXISTS element280_wallets;');
  await db.close();
}

async function initDb() {
  const db = await open({
    filename: DB_FILE,
    driver: sqlite3.Database,
  });
  await db.configure('busyTimeout', 60000);
  await db.run('PRAGMA journal_mode = WAL;');
  await db.exec(`
    CREATE TABLE IF NOT EXISTS element280_summary (
      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      totalRewardPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL,
      claimableRewards REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);
  logger.info('Database initialized');
  return db;
}

async function migrateDb(db) {
  try {
    await db.exec(`
      ALTER TABLE element280_summary ADD COLUMN totalRewardPool INTEGER DEFAULT 0;
      ALTER TABLE element280_wallets ADD COLUMN claimableRewards REAL DEFAULT 0;
      ALTER TABLE element280_wallets ADD COLUMN tiersMinted TEXT DEFAULT '[0,0,0,0,0,0]';
      ALTER TABLE element280_wallets ADD COLUMN tiersTransferredIn TEXT DEFAULT '[0,0,0,0,0,0]';
      ALTER TABLE element280_wallets ADD COLUMN tiersTransferredOut TEXT DEFAULT '[0,0,0,0,0,0]';
    `);
    logger.info('Database migrated');
  } catch (error) {
    if (!error.message.includes('duplicate column name')) {
      logger.error(`Migration failed: ${error.message}`);
      throw error;
    }
  }
}

async function loadCheckpoint() {
  try {
    const data = await fs.readFile(CHECKPOINT_FILE, 'utf8');
    const checkpoint = JSON.parse(data);
    logger.info(`Loaded checkpoint: lastBlock=${checkpoint.lastBlock}`);
    return checkpoint;
  } catch {
    logger.info(`No checkpoint file found, starting from deployment block ${DEPLOYMENT_BLOCK - 1}`);
    return { lastBlock: DEPLOYMENT_BLOCK - 1 };
  }
}

async function saveCheckpoint(lastBlock) {
  await fs.writeFile(CHECKPOINT_FILE, JSON.stringify({ lastBlock }));
  logger.info(`Checkpoint saved: lastBlock=${lastBlock}`);
}

async function loadFailedTokens() {
  try {
    return new Set(JSON.parse(await fs.readFile(FAILED_TOKENS_FILE, 'utf8')));
  } catch {
    return new Set();
  }
}

async function saveFailedTokens(failedTokenIds) {
  await fs.writeFile(FAILED_TOKENS_FILE, JSON.stringify([...failedTokenIds]));
  logger.info('Saved failed tokens');
}

async function loadSkippedTokens() {
  try {
    return new Set(JSON.parse(await fs.readFile(SKIPPED_TOKENS_FILE, 'utf8')));
  } catch {
    return new Set();
  }
}

async function saveSkippedTokens(skippedTokenIds, skippedDetails = []) {
  await fs.writeFile(SKIPPED_TOKENS_FILE, JSON.stringify([...skippedTokenIds]));
  await fs.appendFile(SKIPPED_TOKENS_DETAILED_FILE, JSON.stringify(skippedDetails, null, 2) + '\n');
  logger.info('Saved skipped tokens');
}

async function createScriptBackup() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupFile = path.join(BACKUP_DIR, `trackElement280NFTs_${timestamp}.js`);
  await fs.mkdir(BACKUP_DIR, { recursive: true });
  await fs.copyFile(fileURLToPath(import.meta.url), backupFile);
  logger.info(`Script backup created: ${backupFile}`);
}

async function batchMulticall(contracts) {
  const results = [];
  for (let i = 0; i < contracts.length; i += MAX_MULTICALL_BATCH) {
    const batch = contracts.slice(i, i + MAX_MULTICALL_BATCH);
    results.push(...(await retry(() => client.multicall({ contracts: batch }))));
  }
  return results;
}

async function validateTokenOwnership(owner, tokenId, blockNumber) {
  try {
    const currentOwner = await retry(() =>
      client.readContract({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'ownerOf',
        args: [BigInt(tokenId)],
        blockNumber: BigInt(blockNumber),
      })
    );
    return currentOwner && currentOwner.toLowerCase() === owner.toLowerCase();
  } catch (error) {
    logger.warn(`Token ${tokenId} validation failed: ${error.message}`);
    return false;
  }
}

async function fetchContractData() {
  try {
    const [totalSupply, totalBurned, tierCounts, multiplierPool, totalRewardPool] = await retry(() =>
      client.multicall({
        contracts: [
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalSupply' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalBurned' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'getTotalNftsPerTiers' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'multiplierPool' },
          { address: VAULT_CONTRACT_ADDRESS, abi: element280VaultAbi, functionName: 'totalRewardPool' },
        ],
      })
    );
    return {
      totalMinted: Number(totalSupply.result) + Number(totalBurned.result),
      totalBurned: Number(totalBurned.result),
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.result.map(Number),
      multiplierPool: Number(multiplierPool.result),
      totalRewardPool: Number(totalRewardPool.result),
    };
  } catch (error) {
    logger.error(`Failed to fetch contract data: ${error.message}`);
    throw error;
  }
}

async function fetchAndStoreEvents(db, startBlock, endBlock, skippedTokenIds, skippedDetails) {
  const burnedDistribution = [0, 0, 0, 0, 0, 0];
  const limit = pLimit(MAX_CONCURRENT_BLOCKS);
  const ranges = [];
  for (let fromBlock = startBlock; fromBlock <= endBlock; fromBlock += MAX_BLOCK_RANGE) {
    const toBlock = Math.min(fromBlock + MAX_BLOCK_RANGE - 1, endBlock);
    ranges.push({ fromBlock, toBlock });
  }

  const failedBlocks = [];
  await Promise.all(
    ranges.map(({ fromBlock, toBlock }) =>
      limit(async () => {
        try {
          const logs = await retry(() =>
            client.getLogs({
              address: CONTRACT_ADDRESS,
              event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
              fromBlock: BigInt(fromBlock),
              toBlock: BigInt(toBlock),
            })
          );

          const uniqueBlocks = [...new Set(logs.map(log => Number(log.blockNumber)))];
          const blockTimestamps = new Map();
          await Promise.all(
            uniqueBlocks.map(blockNumber =>
              retry(() =>
                client.getBlock({ blockNumber: BigInt(blockNumber) }).then(block =>
                  blockTimestamps.set(blockNumber, Number(block.timestamp))
                )
              )
            )
          );

          for (const log of logs) {
            const { from, to, tokenId } = log.args;
            const tokenIdNum = tokenId.toString();
            const blockNumber = Number(log.blockNumber);
            const transactionHash = log.transactionHash.toLowerCase();
            let tier = 0;
            let eventType = 'transfer';
            let ownerAddr = '';

            if (from.toLowerCase() === ZERO_ADDRESS.toLowerCase()) {
              eventType = 'mint';
            } else if (to.toLowerCase() === ZERO_ADDRESS.toLowerCase()) {
              eventType = 'burn';
            }

            try {
              tier = Number(
                await retry(() =>
                  client.readContract({
                    address: CONTRACT_ADDRESS,
                    abi: element280Abi,
                    functionName: 'getNftTier',
                    args: [tokenId],
                    blockNumber: BigInt(blockNumber),
                  })
                )
              );
            } catch (error) {
              logger.warn(`Skipping token ${tokenIdNum} at block ${blockNumber}: Failed to fetch tier (${error.message})`);
              skippedTokenIds.add(tokenIdNum);
              skippedDetails.push({ tokenId: tokenIdNum, blockNumber, reason: `Failed to fetch tier: ${error.message}` });
              continue;
            }

            try {
              ownerAddr = await retry(() =>
                client.readContract({
                  address: CONTRACT_ADDRESS,
                  abi: element280Abi,
                  functionName: 'ownerOf',
                  args: [tokenId],
                  blockNumber: BigInt(blockNumber),
                })
              );
            } catch (error) {
              logger.warn(`Token ${tokenIdNum} owner fetch failed: ${error.message}`);
            }

            const [multiplierPool, totalSupply, totalBurned] = await retry(() =>
              client.multicall({
                contracts: [
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'multiplierPool', blockNumber: BigInt(blockNumber) },
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalSupply', blockNumber: BigInt(blockNumber) },
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalBurned', blockNumber: BigInt(blockNumber) },
                ],
              })
            );

            try {
              await executeDbTransaction(db, async () => {
                await db.run(
                  `INSERT OR REPLACE INTO element280_transfers (
                    tokenId, fromAddr, toAddr, tier, blockNumber, transactionHash,
                    blockTimestamp, eventType, multiplierPool, totalSupply, totalBurned, ownerAddr
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                  [
                    tokenIdNum,
                    from.toLowerCase(),
                    to.toLowerCase(),
                    tier,
                    blockNumber,
                    transactionHash,
                    blockTimestamps.get(blockNumber) || 0,
                    eventType,
                    multiplierPool.status === 'success' ? Number(multiplierPool.result) : 0,
                    totalSupply.status === 'success' ? Number(totalSupply.result) : 0,
                    totalBurned.status === 'success' ? Number(totalBurned.result) : 0,
                    ownerAddr.toLowerCase(),
                  ]
                );
              });
            } catch (error) {
              logger.error(`Failed to insert transfer for token ${tokenIdNum}: ${error.message}`);
              await fs.appendFile(FAILED_INSERTS_FILE, JSON.stringify({ tokenId: tokenIdNum, error: error.message }) + '\n');
            }

            if (eventType === 'burn' && tier >= 1 && tier <= 6) {
              burnedDistribution[tier - 1]++;
            }
          }
        } catch (error) {
          logger.error(`Failed to process block range ${fromBlock}-${toBlock}: ${error.message}`);
          failedBlocks.push({ fromBlock, toBlock, error: error.message });
        }
      })
    )
  );

  if (failedBlocks.length > 0) {
    await fs.writeFile(FAILED_BLOCKS_FILE, JSON.stringify(failedBlocks, null, 2));
  }

  return burnedDistribution;
}

async function processWallet(owner, db, failedTokenIds, skippedTokenIds, skippedDetails) {
  if (owner.toLowerCase() === ZERO_ADDRESS.toLowerCase()) return null;

  logger.info(`Processing wallet ${owner}`);
  if (DEBUG_WALLETS.includes(owner.toLowerCase())) {
    logger.debug(`Processing debug wallet ${owner}`);
  }

  const wallet = {
    wallet: owner.toLowerCase(),
    totalLive: 0,
    totalBurned: 0,
    totalBought: 0,
    totalSold: 0,
    minted: 0,
    tiersLive: [0, 0, 0, 0, 0, 0],
    tiersBurned: [0, 0, 0, 0, 0, 0],
    tiersMinted: [0, 0, 0, 0, 0, 0],
    tiersTransferredIn: [0, 0, 0, 0, 0, 0],
    tiersTransferredOut: [0, 0, 0, 0, 0, 0],
    nfts: [],
    multiplierSum: 0,
    displayMultiplierSum: 0,
    claimableRewards: 0,
  };

  // NEW: Fetch current balance
  try {
    const balance = await retry(() =>
      client.readContract({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'balanceOf',
        args: [owner],
      })
    );
    wallet.totalLive = Number(balance);
  } catch (error) {
    logger.warn(`Failed to get balance for ${owner}: ${error.message}`);
    wallet.totalLive = 0;
  }

  // NEW: Fetch owned NFTs
  let nfts = [];
  if (wallet.totalLive > 0) {
    try {
      const nftsResponse = await retry(() =>
        alchemy.nft.getNftsForOwner(owner, {
          contractAddresses: [CONTRACT_ADDRESS],
        })
      );
      nfts = nftsResponse.ownedNfts.map(nft => ({
        tokenId: nft.tokenId,
        status: 'live',
        tier: 0,
        tierName: '',
      }));

      const tokenIds = nfts.map(nft => BigInt(nft.tokenId));
      const tierCalls = tokenIds.map(tokenId => ({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'getNftTier',
        args: [tokenId],
      }));

      const tierResults = await retry(() => client.multicall({ contracts: tierCalls }));
      const validTokenIds = [];
      nfts.forEach((nft, index) => {
        if (tierResults[index].status === 'success') {
          const tier = Number(tierResults[index].result);
          if (tier >= 1 && tier <= 6) {
            nft.tier = tier;
            nft.tierName = contractTiers.element280[tier].name;
            wallet.tiersLive[tier - 1]++;
            validTokenIds.push(BigInt(nft.tokenId));
          }
        }
      });

      wallet.nfts = nfts;

      // Calculate multiplier sum
      const multipliers = Object.values(contractTiers.element280).map(t => t.multiplier);
      wallet.multiplierSum = nfts.reduce((sum, nft) => sum + (nft.tier > 0 ? multipliers[nft.tier - 1] : 0), 0);
      wallet.displayMultiplierSum = wallet.multiplierSum / 100;

      // Calculate claimable rewards
      if (validTokenIds.length > 0) {
        try {
          const rewards = await retry(
            () =>
              client.readContract({
                address: CONTRACT_ADDRESS,
                abi: element280Abi,
                functionName: 'getClaimableRewardsForTokens',
                args: [validTokenIds],
              }),
            2,
            1000,
            true
          );
          wallet.claimableRewards = Number(rewards) / 1e18;
        } catch (error) {
          logger.warn(`Rewards query failed for ${owner}: ${error.message}`);
          wallet.claimableRewards = 0;
        }
      }
    } catch (error) {
      logger.warn(`Failed to process NFTs for ${owner}: ${error.message}`);
    }
  }

  // NEW: Process transfers to calculate minted, bought, sold, burned
  try {
    const transfers = await db.all(
      `SELECT tokenId, transactionHash, blockNumber, eventType, tier, fromAddr, toAddr
       FROM element280_transfers
       WHERE lower(fromAddr) = ? OR lower(toAddr) = ?
       ORDER BY blockNumber ASC`,
      [owner.toLowerCase(), owner.toLowerCase()]
    );
    logger.debug(`Fetched ${transfers.length} transfers for ${owner}`);
    if (transfers.length === 0) {
      logger.warn(`No transfers found for ${owner}`);
    } else {
      logger.trace(`Transfers for ${owner}: ${JSON.stringify(transfers, null, 2)}`);
    }

    for (const log of transfers) {
      const { fromAddr, toAddr, tokenId, tier, eventType } = log;
      if (tier < 1 || tier > 6) continue;

      if (eventType === 'mint') {
        wallet.minted += 1;
        wallet.tiersMinted[tier - 1]++;
      } else if (eventType === 'burn') {
        wallet.totalBurned += 1;
        wallet.tiersBurned[tier - 1]++;
      } else if (eventType === 'transfer') {
        if (fromAddr.toLowerCase() === owner.toLowerCase()) {
          wallet.totalSold += 1;
          wallet.tiersTransferredOut[tier - 1]++;
        }
        if (toAddr.toLowerCase() === owner.toLowerCase()) {
          wallet.totalBought += 1;
          wallet.tiersTransferredIn[tier - 1]++;
        }
      }
    }
  } catch (error) {
    logger.error(`Failed to fetch transfers for ${owner}: ${error.message}`);
  }

  return wallet;
}

async function trackElement280NFTs() {
  if (SHOW_HELP) {
    console.log(`
      Usage: node scripts/trackElement280NFTs.js [options]
      Options:
        --help, -h          Show this help message
        --verbose, -v       Enable verbose logging
        --quiet, -q         Enable quiet mode (errors only)
        --full              Run full sync from deployment block
        --refresh           Force refresh of wallet data
        --summary           Show summary only
        --wallets=addr1,addr2 Process specific wallets (comma-separated)
    `);
    process.exit(0);
  }

  const result = {
    summary: {
      totalMinted: 0,
      totalBurned: 0,
      totalLive: 0,
      totalWallets: 0,
      tierDistribution: [0, 0, 0, 0, 0, 0],
      burnedDistribution: [0, 0, 0, 0, 0, 0],
      multiplierPool: 0,
      totalRewardPool: 0,
    },
    wallets: [],
    burnedNfts: [],
  };

  const failedTokenIds = await loadFailedTokens();
  const skippedTokenIds = await loadSkippedTokens();
  const skippedDetails = [];

  let db;
  try {
    if (FULL_MODE) {
      await clearDatabase();
    }
    await createScriptBackup();
    db = await initDb();
    await migrateDb(db);

    const checkpoint = await loadCheckpoint();
    const contractData = await fetchContractData();
    Object.assign(result.summary, contractData);

    const endBlock = Number(await client.getBlockNumber());
    result.summary.burnedDistribution = await fetchAndStoreEvents(db, DEPLOYMENT_BLOCK, endBlock, skippedTokenIds, skippedDetails);
    await db.run('UPDATE element280_summary SET lastBlock = ? WHERE id = 1', endBlock);

    const wallets = new Map();
    let owners = [];

    // NEW: Fetch current owners using Alchemy
    if (CUSTOM_WALLETS.length === 0) {
      logger.info('Fetching owners with NFTs');
      try {
        const ownersResponse = await retry(() => alchemy.nft.getOwnersForContract(CONTRACT_ADDRESS));
        owners = ownersResponse.owners
          .filter(owner => owner.toLowerCase() !== ZERO_ADDRESS.toLowerCase())
          .map(owner => owner.toLowerCase());
        logger.info(`Found ${owners.length} owners`);
      } catch (error) {
        logger.error(`Failed to fetch owners: ${error.message}`);
      }
    } else {
      owners = CUSTOM_WALLETS;
      logger.info(`Processing custom wallets: ${CUSTOM_WALLETS.join(', ')}`);
    }

    // MODIFIED: Initialize wallets from owners and transfers
    for (const owner of owners) {
      wallets.set(owner.toLowerCase(), {
        wallet: owner.toLowerCase(),
        totalLive: 0,
        totalBurned: 0,
        totalBought: 0,
        totalSold: 0,
        minted: 0,
        tiersLive: [0, 0, 0, 0, 0, 0],
        tiersBurned: [0, 0, 0, 0, 0, 0],
        tiersMinted: [0, 0, 0, 0, 0, 0],
        tiersTransferredIn: [0, 0, 0, 0, 0, 0],
        tiersTransferredOut: [0, 0, 0, 0, 0, 0],
        nfts: [],
        multiplierSum: 0,
        displayMultiplierSum: 0,
        claimableRewards: 0,
      });
    }

    // NEW: Add wallets from transfers
    const transferWallets = await db.all(`
      SELECT DISTINCT address
      FROM (
        SELECT lower(fromAddr) AS address FROM element280_transfers WHERE fromAddr != ?
        UNION
        SELECT lower(toAddr) AS address FROM element280_transfers WHERE toAddr != ?
      )`,
      [ZERO_ADDRESS.toLowerCase(), ZERO_ADDRESS.toLowerCase()]
    );
    for (const { address } of transferWallets) {
      if (!wallets.has(address.toLowerCase())) {
        wallets.set(address.toLowerCase(), {
          wallet: address.toLowerCase(),
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }
    }

    logger.info(`Collected ${wallets.size} unique wallets`);
    await fs.writeFile(COLLECTED_WALLETS_FILE, JSON.stringify([...wallets.keys()], null, 2));

    // Verify debug wallets
    DEBUG_WALLETS.forEach(wallet => {
      if (!wallets.has(wallet.toLowerCase())) {
        logger.warn(`Debug wallet ${wallet} not found in wallets Map`);
      } else {
        logger.info(`Debug wallet ${wallet} included in wallets Map`);
      }
    });

    // Process wallets
    const walletLimit = pLimit(MAX_CONCURRENT_WALLETS);
    const walletResults = [];
    let walletCount = 0;
    for (const walletAddr of wallets.keys()) {
      logger.debug(`Processing wallet ${walletAddr}`);
      const wallet = await walletLimit(() => processWallet(walletAddr, db, failedTokenIds, skippedTokenIds, skippedDetails));
      if (wallet) {
        walletResults.push(wallet);
        await retry(
          async () => {
            await executeDbTransaction(db, async () => {
              await db.run(
                `INSERT OR REPLACE INTO element280_wallets (
                  address, totalLive, totalBurned, totalBought, totalSold, minted,
                  tiersLive, tiersBurned, tiersMinted, tiersTransferredIn, tiersTransferredOut,
                  nfts, multiplierSum, displayMultiplierSum, claimableRewards
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                  wallet.wallet.toLowerCase(),
                  wallet.totalLive,
                  wallet.totalBurned,
                  wallet.totalBought,
                  wallet.totalSold,
                  wallet.minted,
                  JSON.stringify(wallet.tiersLive),
                  JSON.stringify(wallet.tiersBurned),
                  JSON.stringify(wallet.tiersMinted),
                  JSON.stringify(wallet.tiersTransferredIn),
                  JSON.stringify(wallet.tiersTransferredOut),
                  JSON.stringify(wallet.nfts),
                  wallet.multiplierSum,
                  wallet.displayMultiplierSum,
                  wallet.claimableRewards,
                ]
              );
            });
            logger.debug(`Inserted/updated wallet ${walletAddr}`);
          },
          3,
          1000
        );
        walletCount++;
        logger.info(`Processed ${walletCount}/${wallets.size} wallets: ${walletAddr}`);
      } else {
        logger.warn(`No wallet data returned for ${walletAddr}`);
        await fs.appendFile(
          SKIPPED_WALLETS_FILE,
          JSON.stringify({ wallet: walletAddr, timestamp: new Date().toISOString() }) + '\n'
        );
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // NEW: Process transfers in memory for historical stats
    const logs = await db.all('SELECT * FROM element280_transfers ORDER BY blockNumber ASC');
    for (const log of logs) {
      const from = log.fromAddr.toLowerCase();
      const to = log.toAddr.toLowerCase();
      const tokenIdNum = log.tokenId;
      const tier = log.tier;
      const eventType = log.eventType;

      if (from !== ZERO_ADDRESS.toLowerCase() && !wallets.has(from)) {
        wallets.set(from, {
          wallet: from,
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }
      if (to !== ZERO_ADDRESS.toLowerCase() && !wallets.has(to)) {
        wallets.set(to, {
          wallet: to,
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }

      if (eventType === 'mint' && tier >= 1 && tier <= 6) {
        const wallet = wallets.get(to);
        wallet.minted += 1;
        wallet.totalBought += 1;
        wallet.tiersMinted[tier - 1]++;
      } else if (eventType === 'burn' && tier >= 1 && tier <= 6) {
        const wallet = wallets.get(from);
        wallet.totalBurned += 1;
        wallet.totalSold += 1;
        wallet.tiersBurned[tier - 1]++;
        result.burnedNfts.push({
          tokenId: tokenIdNum,
          tier,
          tierName: contractTiers.element280[tier].name,
          burnerWallet: from,
          transactionHash: log.transactionHash,
          blockTimestamp: log.blockTimestamp,
          ownerAddr: log.ownerAddr,
        });
      } else if (eventType === 'transfer' && tier >= 1 && tier <= 6) {
        const fromWallet = wallets.get(from);
        const toWallet = wallets.get(to);
        fromWallet.totalSold += 1;
        toWallet.totalBought += 1;
        fromWallet.tiersTransferredOut[tier - 1]++;
        toWallet.tiersTransferredIn[tier - 1]++;
      }
    }

    // NEW: Finalize wallet data
    result.wallets = Array.from(wallets.values())
      .filter(w => w.totalLive > 0 || w.totalBurned > 0 || w.totalBought > 0 || w.totalSold > 0 || w.minted > 0)
      .map((w, index) => ({
        ...w,
        rank: index + 1,
        percentage: result.summary.multiplierPool > 0 ? (w.multiplierSum / result.summary.multiplierPool) * 100 : 0,
      }));
    result.summary.totalWallets = result.wallets.length;

    // Update summary
    await executeDbTransaction(db, async () => {
      await db.run(
        `INSERT OR REPLACE INTO element280_summary (
          id, totalMinted, totalBurned, totalLive, totalWallets,
          tierDistribution, burnedDistribution, multiplierPool, totalRewardPool, lastBlock
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          1,
          result.summary.totalMinted,
          result.summary.totalBurned,
          result.summary.totalLive,
          result.summary.totalWallets,
          JSON.stringify(result.summary.tierDistribution),
          JSON.stringify(result.summary.burnedDistribution),
          result.summary.multiplierPool,
          result.summary.totalRewardPool,
          endBlock,
        ]
      );
    });

    // Save failed and skipped tokens
    await saveFailedTokens(failedTokenIds);
    await saveSkippedTokens(skippedTokenIds, skippedDetails);

    // Save output
    await fs.writeFile(CACHE_FILE, JSON.stringify(result, null, 2));
    await saveCheckpoint(endBlock);

    logger.info(`Completed: Processed ${result.wallets.length} wallets, ${result.burnedNfts.length} burned NFTs`);
    logger.info(`Summary: totalMinted=${result.summary.totalMinted}, totalLive=${result.summary.totalLive}, totalBurned=${result.summary.totalBurned}, totalWallets=${result.summary.totalWallets}`);
  } catch (error) {
    logger.error(`Error: ${error.message}`);
    throw error;
  } finally {
    if (db) await db.close();
  }

  return result;
}

trackElement280NFTs().catch(error => {
  logger.error('Script failed:', error);
  process.exit(1);
});-e 
---
File: ./components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status, progress }) {
  const percentage = progress?.totalOwners > 0 ? (progress.totalWallets / progress.totalOwners) * 100 : 0;
  return (
    <div className="flex flex-col items-center justify-center gap-3 animate-fade-in w-full flex-1">
      <motion.svg
        className="h-6 w-6 sm:h-8 sm:w-8 text-blue-400"
        animate={{ scale: [1, 1.2, 1], rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </motion.svg>
      <p className="text-sm sm:text-base text-gray-300">{status}</p>
      {progress?.totalOwners > 0 && (
        <div className="w-64 bg-gray-700 rounded-full h-2.5 mt-2">
          <div className="bg-blue-400 h-2.5 rounded-full" style={{ width: `${percentage}%` }}></div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/NFTPage.js
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from './LoadingIndicator';
import { contractDetails, contractTiers, contractAddresses, vaultAddresses } from '@/app/nft-contracts';
import { Bar } from 'react-chartjs-2';
import Chart from 'chart.js/auto';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// Contract ABIs for Element280
const element280Abi = [
  { name: 'totalSupply', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'totalBurned', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getTotalNftsPerTiers', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256[]' }] },
  { name: 'multiplierPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];
const element280VaultAbi = [
  { name: 'totalRewardPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];

// Retry utility
async function retry(fn, attempts = 5, delay = retryCount => Math.min(2000 * 2 ** retryCount, 10000)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = contractAddresses.element280.address;
  const vaultAddress = vaultAddresses.element280.address;
  console.log('[fetchContractData] contractAddress:', contractAddress);
  console.log('[fetchContractData] vaultAddress:', vaultAddress);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI`, { timeout: 60000 }),
  });

  try {
    const [totalSupply, totalBurned, tierCounts, multiplierPool, totalRewardPool] = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: element280Abi, functionName: 'totalSupply' },
          { address: contractAddress, abi: element280Abi, functionName: 'totalBurned' },
          { address: contractAddress, abi: element280Abi, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: element280Abi, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: element280VaultAbi, functionName: 'totalRewardPool' },
        ],
      })
    );
    return {
      totalMinted: Number(totalSupply.result) + Number(totalBurned.result),
      totalBurned: Number(totalBurned.result),
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.result.map(Number),
      multiplierPool: Number(multiplierPool.result),
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution: [0, 0, 0, 0, 0, 0],
    };
  } catch (error) {
    console.error('[fetchContractData] Error:', error.message);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  console.log('[NFTPage] Received props:', { chain, contract });

  // Derive contract identifier (convert to lowercase)
  const contractId = contract ? contract.toLowerCase() : null;
  console.log('[NFTPage] Derived contractId:', contractId);

  // Validate contract
  if (!contractId || !contractDetails[contractId]) {
    console.error('[NFTPage] Invalid or missing contract:', { chain, contract });
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">Error</h1>
        <p className="text-red-500 text-lg">Invalid contract: {contractId || 'none specified'}</p>
      </div>
    );
  }

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [cache, setCache] = useState({});

  const contractConfig = contractDetails[contractId];
  console.log('[NFTPage] contractConfig:', contractConfig);
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  // Load HolderTable with error handling
  let HolderTable = holderTableComponents[contractId];
  if (!HolderTable) {
    console.error(`[NFTPage] HolderTable for ${contractId} not found`);
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-red-500 text-lg">Error: Holder table component for {contractId} not found</p>
      </div>
    );
  }
  console.log('[NFTPage] Selected HolderTable:', HolderTable.name);

  // Cache helpers
  const getCache = (key) => cache[key];
  const updateCache = (key, value) => setCache(prev => ({ ...prev, [key]: value }));

  // Check for disabled contract (e.g., E280)
  useEffect(() => {
    if (disabled) {
      console.log(`[NFTPage] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    }
  }, [disabled, name]);

  // Fetch data function
  const fetchData = async () => {
    if (disabled || !apiEndpoint) {
      if (!disabled) {
        console.log('[NFTPage] Invalid contract configuration');
        setError('Invalid contract configuration');
      }
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      if (isElement280) {
        console.log(`[NFTPage] Fetching progress from ${apiEndpoint}/progress`);
        const res = await fetch(`${apiEndpoint}/progress`, { cache: 'no-store' });
        console.log('[NFTPage] Progress response status:', res.status);
        if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
        const progressData = await res.json();
        console.log('[NFTPage] Progress data:', progressData);
        setProgress(progressData);
      }
      await fetchAllHolders();
    } catch (err) {
      console.error('[NFTPage] Fetch error:', err.message);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  };

  // Initial data fetch (no polling)
  useEffect(() => {
    fetchData();
  }, [apiEndpoint, contractId, isElement280, disabled]);

  async function fetchAllHolders() {
    const cachedData = getCache(contractId);
    if (cachedData) {
      console.log('[NFTPage] Using cached data for:', contractId);
      setData(cachedData);
      setLoading(false);
      return;
    }

    try {
      console.log(`[NFTPage] Starting fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || 100;

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = 5;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            console.log(`[NFTPage] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { signal: AbortSignal.timeout(60000) });
            console.log('[NFTPage] Fetch response status:', res.status);
            if (!res.ok) {
              const errorText = await res.text();
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            console.log('[NFTPage] Fetch response data:', json);
            const newHolders = json.holders || [];
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            console.log(`[NFTPage] Fetched page ${page}: ${newHolders.length} holders, totalPages: ${totalPages}`);
            page++;
            success = true;
            if (!newHolders || newHolders.length === 0) break;
          } catch (err) {
            attempts++;
            if (err.message.includes('Rate limit') || err.name === 'TimeoutError') {
              console.log(`[NFTPage] Retry ${attempts} for ${contractId} page ${page}: ${err.message}`);
              await new Promise(resolve => setTimeout(resolve, 2000 * 2 ** attempts));
            } else {
              throw err;
            }
          }
        }
        if (!success) {
          throw new Error(`Failed to fetch page ${page} for ${contractId} after ${maxAttempts} attempts`);
        }
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) {
          holder.shares = holder.shares || holder.totalShares || 0;
          holder.totalNfts = holder.totalNfts || holder.total || 0;
          uniqueHoldersMap.set(holder.wallet, holder);
        }
      });
      const uniqueHolders = Array.from(uniqueHoldersMap.values());

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      if (contractId === 'element369') {
        totalInfernoRewards = uniqueHolders.reduce((sum, h) => sum + (h.infernoRewards || 0), 0);
        totalFluxRewards = uniqueHolders.reduce((sum, h) => sum + (h.fluxRewards || 0), 0);
        totalE280Rewards = uniqueHolders.reduce((sum, h) => sum + (h.e280Rewards || 0), 0);
      } else {
        totalClaimableRewards = uniqueHolders.reduce((sum, h) => sum + (h.claimableRewards || 0), 0);
      }
      if (!totalTokens && uniqueHolders.length > 0) {
        totalTokens = uniqueHolders.reduce((sum, h) => sum + (isElement280 ? h.totalLive || 0 : h.totalNfts || 0), 0);
      }

      uniqueHolders.forEach(holder => {
        holder.sharesPercentage = totalShares > 0 ? ((holder.shares || 0) / totalShares) * 100 : 0;
      });

      if (contractId === 'ascendant') {
        uniqueHolders.sort((a, b) => {
          const sharesDiff = (b.shares || 0) - (a.shares || 0);
          if (sharesDiff !== 0) return sharesDiff;
          return (b.totalNfts || 0) - (a.totalNfts || 0);
        });
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.totalLive || b.total || 0) - (a.totalLive || a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      }

      let fetchedData = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      if (isElement280) {
        try {
          const blockchainSummary = await fetchContractData();
          fetchedData.summary = { ...fetchedData.summary, ...blockchainSummary };
          fetchedData.totalTokens = blockchainSummary.totalLive || fetchedData.totalTokens;
          fetchedData.totalShares = blockchainSummary.multiplierPool || fetchedData.totalShares;
          fetchedData.totalClaimableRewards = blockchainSummary.totalRewardPool || fetchedData.totalClaimableRewards;
        } catch (err) {
          console.error('[NFTPage] Blockchain Summary Fetch Error:', err.message);
        }
      }

      updateCache(contractId, fetchedData);
      setData(fetchedData);
      setLoading(false);
      console.log(`[NFTPage] Successfully fetched ${uniqueHolders.length} holders for ${contractId}`);
    } catch (err) {
      console.error('[NFTPage] Fetch Error:', err.message);
      setError(`Failed to load ${name} holders: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }

  const renderSummary = () => {
    if (!data) return null;

    const totalMultiplierSum = data.totalShares || data.holders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
    const totalTokens = data.totalTokens || 0;
    const totalClaimableRewards = data.totalClaimableRewards || 0;
    const totalInfernoRewards = data.totalInfernoRewards || 0;
    const totalFluxRewards = data.totalFluxRewards || 0;
    const totalE280Rewards = data.totalE280Rewards || 0;

    if (contractId === 'element280') {
      const summary = data.summary || {};
      const totalSupply = Number(summary.totalLive || totalTokens || 0);
      const totalBurned = Number(summary.totalBurned || 0);
      const totalInitialSupply = totalSupply + totalBurned;
      const percentBurned = totalInitialSupply > 0 ? ((totalBurned / totalInitialSupply) * 100).toFixed(2) : '0.00';
      const tierDistribution = summary.tierDistribution || [0, 0, 0, 0, 0, 0];
      const burnedDistribution = summary.burnedDistribution || [0, 0, 0, 0, 0, 0];
      const multiplierPool = Number(summary.multiplierPool || totalShares || 0);
      const totalRewardPool = Number(summary.totalRewardPool || totalClaimableRewards || 0);

      // Define tier order to match HolderTable/Element280.js
      const element280TierOrder = [
        { tierId: '6', name: 'Legendary Amped', index: 5 },
        { tierId: '5', name: 'Legendary', index: 4 },
        { tierId: '4', name: 'Rare Amped', index: 3 },
        { tierId: '2', name: 'Common Amped', index: 1 },
        { tierId: '3', name: 'Rare', index: 2 },
        { tierId: '1', name: 'Common', index: 0 },
      ];

      const tierData = element280TierOrder.map(tier => {
        const index = tier.index;
        const tierConfig = contractTiers.element280[tier.tierId];
        const remainingCount = Number(tierDistribution[index] || 0);
        const burnedCount = Number(burnedDistribution[index] || 0);
        const initialCount = remainingCount + burnedCount;
        const burnedPercentage = initialCount > 0 ? ((burnedCount / initialCount) * 100).toFixed(2) : '0.00';
        return {
          name: tier.name,
          count: remainingCount,
          percentage: totalSupply > 0 ? ((remainingCount / totalSupply) * 100).toFixed(2) : '0.00',
          multiplier: tierConfig.multiplier,
          burned: burnedCount,
          burnedPercentage,
        };
      });

      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element280 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Initial Supply</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalInitialSupply.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Minted NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Burned</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalBurned.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Burned NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Remaining</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalSupply.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Circulating NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Burned Percentage</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{percentBurned}%</p>
              <p className="text-sm text-gray-400">Of Total Minted</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Multiplier Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{multiplierPool.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Sum of Multipliers</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Reward Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </p>
              <p className="text-sm text-gray-400">Claimable Rewards</p>
            </div>
          </div>
          <div>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-lg font-semibold text-gray-300">Tier distribution of remaining live NFTs</h3>
              <motion.button
                className="px-4 py-2 bg-gray-700 text-gray-300 rounded-lg hover:bg-gray-600 focus:outline-none"
                onClick={() => setShowChart(!showChart)}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                {showChart ? 'Hide Chart' : 'Show Chart'}
              </motion.button>
            </div>
            <div className="overflow-x-auto">
              <table className="w-full text-left border-collapse bg-gray-800 rounded-lg">
                <thead>
                  <tr className="bg-gray-700 text-gray-300">
                    <th className="p-3 text-sm font-semibold">Tier</th>
                    <th className="p-3 text-sm font-semibold text-right">Count</th>
                    <th className="p-3 text-sm font-semibold text-right">% remaining NFTs</th>
                    <th className="p-3 text-sm font-semibold text-right">Multiplier</th>
                    <th className="p-3 text-sm font-semibold text-right">Burned</th>
                    <th className="p-3 text-sm font-semibold text-right">% Burned</th>
                  </tr>
                </thead>
                <tbody>
                  {tierData.map((tier, index) => (
                    <tr
                      key={tier.name}
                      className={`border-b border-gray-700 ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
                    >
                      <td className="p-3 text-gray-300">{tier.name}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.count.toLocaleString('en-US')}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.percentage}%</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.multiplier}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burned.toLocaleString('en-US')}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burnedPercentage}%</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
          <AnimatePresence>
            {showChart && (
              <motion.div
                className="bg-gray-800 p-4 rounded-lg shadow-md"
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <h3 className="text-lg font-semibold text-gray-300 mb-3">Tier Distribution Chart</h3>
                <div className="w-full max-w-[800px] mx-auto" style={{ height: '300px' }}>
                  <Bar
                    data={{
                      labels: tierData.map(t => t.name),
                      datasets: [
                        {
                          label: 'Remaining NFTs',
                          data: tierData.map(t => t.count),
                          backgroundColor: 'rgba(75, 192, 192, 0.6)',
                          borderColor: 'rgba(75, 192, 192, 1)',
                          borderWidth: 1,
                        },
                        {
                          label: 'Burned NFTs',
                          data: tierData.map(t => t.burned),
                          backgroundColor: 'rgba(255, 99, 132, 0.6)',
                          borderColor: 'rgba(255, 99, 132, 1)',
                          borderWidth: 1,
                        },
                      ],
                    }}
                    options={{
                      maintainAspectRatio: false,
                      scales: {
                        y: {
                          beginAtZero: true,
                          title: { display: true, text: 'Number of NFTs', color: '#d1d5db' },
                          ticks: { color: '#d1d5db', callback: value => value.toLocaleString('en-US') },
                          grid: { color: '#4b5563' },
                        },
                        x: {
                          title: { display: true, text: 'Tier', color: '#d1d5db' },
                          ticks: { color: '#d1d5db' },
                          grid: { display: false },
                        },
                      },
                      plugins: { legend: { labels: { color: '#d1d5db' } } },
                    }}
                  />
                </div>
              </motion.div>
            )}
          </AnimatePresence>
          <div className="bg-gray-800 p-4 rounded-lg shadow-md">
            <p className="text-gray-300">
              Number of Unique Wallets Holding NFTs: <span className="font-bold text-white font-mono">{data.holders.length.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Number of Active NFTs in Circulation: <span className="font-bold text-white font-mono">{totalSupply.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Multiplier Sum: <span className="font-bold text-white font-mono">{multiplierPool.toLocaleString('en-US')}</span>
            </p>
            <p className="text-gray-300">
              Total Reward Pool: <span className="font-bold text-white font-mono">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </span>
            </p>
          </div>
        </div>
      );
    } else if (contractId === 'ascendant') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Ascendant Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Locked</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.totalLockedAscendant || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Ascendant NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Shares</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.totalShares || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'DRAGONX'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Pending Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{(data.pendingRewards || 0).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">DragonX Rewards</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'element369') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element369 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Inferno Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalInfernoRewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Flux Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalFluxRewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">E280 Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{Math.floor(totalE280Rewards).toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'stax') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Stax Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'X28'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    } else {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">{name} Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{data.holders.length.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalTokens.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">{totalMultiplierSum.toLocaleString('en-US')}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right tracking-tight">
                {Math.floor(totalClaimableRewards).toLocaleString('en-US')} {rewardToken || 'Unknown'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    }
  };

  const getLoadingMessage = () => {
    if (!isElement280) {
      return `Loading all ${name || 'contract'} holders (may take up to 60 seconds)...`;
    }
    if (progress.isPopulating) {
      return `Fetching ${name} data: ${progress.phase} (${progress.progressPercentage}%)...`;
    }
    return `Finalizing ${name} data...`;
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      {loading ? (
        <LoadingIndicator status={getLoadingMessage()} progress={progress} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : data.message ? (
        <p className="text-gray-400 text-lg">{data.message}</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractId}
            summary={data.summary}
            loading={loading}
            totalShares={isElement280 ? data.summary?.multiplierPool : data.totalShares}
            totalLockedAscendant={data.totalLockedAscendant}
            toDistributeDay8={data.toDistributeDay8}
            toDistributeDay28={data.toDistributeDay28}
            toDistributeDay90={data.toDistributeDay90}
            pendingRewards={data.pendingRewards}
            totalClaimableRewards={data.totalClaimableRewards}
            totalInfernoRewards={data.totalInfernoRewards}
            totalFluxRewards={data.totalFluxRewards}
            totalE280Rewards={data.totalE280Rewards}
            burnedNfts={data.burnedNfts}
          />
          <div className="mt-8">
            <h3 className="text-xl font-bold mb-2">Raw Data:</h3>
            <pre className="text-sm bg-gray-800 p-4 rounded-lg shadow-md overflow-auto">
              {JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { contractDetails } from '@/app/nft-contracts';

// Define holder table components for each contract
const holderTableComponents = {
  element280: dynamic(
    () =>
      import('./HolderTable/Element280').catch(err => {
        console.error('Failed to load Element280 HolderTable:', err);
        return () => <div>Error loading holder table for Element280</div>;
      }),
    {
      ssr: false,
      loading: () => <div className="text-gray-400">Loading Element280 holder table...</div>,
    }
  ),
  element369: dynamic(
    () =>
      import('./HolderTable/Element369').catch(err => {
        console.error('Failed to load Element369 HolderTable:', err);
        return () => <div>Error loading holder table for Element369</div>;
      }),
    {
      ssr: false,
      loading: () => <div className="text-gray-400">Loading Element369 holder table...</div>,
    }
  ),
  stax: dynamic(
    () =>
      import('./HolderTable/Stax').catch(err => {
        console.error('Failed to load Stax HolderTable:', err);
        return () => <div>Error loading holder table for Stax</div>;
      }),
    {
      ssr: false,
      loading: () => <div className="text-gray-400">Loading Stax holder table...</div>,
    }
  ),
  ascendant: dynamic(
    () =>
      import('./HolderTable/Ascendant').catch(err => {
        console.error('Failed to load Ascendant HolderTable:', err);
        return () => <div>Error loading holder table for Ascendant</div>;
      }),
    {
      ssr: false,
      loading: () => <div className="text-gray-400">Loading Ascendant holder table...</div>,
    }
  ),
  e280: dynamic(
    () =>
      import('./HolderTable/E280').catch(err => {
        console.error('Failed to load E280 HolderTable:', err);
        return () => <div>Error loading holder table for E280</div>;
      }),
    {
      ssr: false,
      loading: () => <div className="text-gray-400">Loading E280 holder table...</div>,
    }
  ),
};

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      onClick={handleBackgroundClick}
    >
      <motion.div
        className="bg-gray-800 text-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={e => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Search Results for {searchAddress}</h2>
          <button onClick={closeModal} className="text-gray-400 hover:text-white text-2xl">
            Ã—
          </button>
        </div>

        {Object.keys(searchResult).length === 0 ? (
          <p className="text-gray-400">No results available.</p>
        ) : (
          Object.entries(searchResult).map(([contract, data]) => {
            const HolderTable = holderTableComponents[contract] || (() => <div>Holder table not found for {contract}</div>);
            return (
              <div key={contract} className="mb-6">
                <h3 className="text-xl font-semibold mb-2">{contractDetails[contract]?.name || contract}</h3>
                {data === null ? (
                  <p className="text-gray-400">Wallet not found in this collection.</p>
                ) : data.error ? (
                  <p className="text-red-500">Error: {data.error}</p>
                ) : data.message ? (
                  <p className="text-gray-400">{data.message}</p>
                ) : (
                  <HolderTable
                    holders={[data]}
                    contract={contract}
                    loading={false}
                    totalShares={data.totalShares}
                  />
                )}
              </div>
            );
          })
        )}
      </motion.div>
    </div>
  );
}-e 
---
File: ./components/HolderTable copy/E280.js
// components/HolderTable/E280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';
  const isElement369 = contract === 'element369';
  const isElement280 = contract === 'element280';
  const isE280 = contract === 'e280';
  const isStax = contract === 'staxNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isElement369 ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                  </>
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                )}
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {(isElement280 || isElement369) && tiers ? (
                      Object.keys(tiers)
                        .sort((a, b) => b - a)
                        .map(tier => (
                          <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                            {tiers[tier].name}
                          </th>
                        ))
                    ) : (
                      <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]"></th>
                    )}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isElement369 ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  )}
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers && !isAscendant && !isStax) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isElement369 ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
              </>
            ) : (
              <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            )}
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {(isElement280 || isElement369) && tiers ? (
                  Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                        {tiers[tier].name}
                      </th>
                    ))
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]"></th>
                )}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              {isElement369 ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.infernoRewards || 0).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.fluxRewards || 0).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.e280Rewards || 0).toLocaleString()}
                  </td>
                </>
              ) : (
                <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {isElement280
                    ? (holder.claimableRewards || 0).toFixed(2).toLocaleString()
                    : (holder.claimableRewards || 0).toLocaleString()}
                </td>
              )}
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : '0.00'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.shares || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay8 || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay28 || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay90 || 0).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
                  </td>
                  {(isElement280 || isElement369) && tiers ? (
                    Object.keys(tiers)
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                          {holder.tiers?.[tier] || 0}
                        </td>
                      ))
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">-</td>
                  )}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable copy/Ascendant.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from '@/app/nft-contracts';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  // Define Ascendant tier order (descending: Tier 8 to Tier 1)
  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      // Compute tier counts and sum
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) || // Zero-based array
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) || // One-based array
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) || // Object
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {
                    // Try zero-based array (tiers[0] = Tier 1)
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    // Try one-based array (tiers[1] = Tier 1)
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    // Try object (tiers["1"] = Tier 1)
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    // Fallback to 0
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable copy/Stax.js
// components/HolderTable/Element369.js
import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';
  const isElement369 = contract === 'element369';
  const isStax = contract === 'staxNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isElement369 ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                  </>
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                )}
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {Object.keys(contractTiers[contract] || {})
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                          {contractTiers[contract][tier].name}
                        </th>
                      ))}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isElement369 ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  )}
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isElement369 ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
              </>
            ) : (
              <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            )}
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(tiers)
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {tiers[tier].name}
                    </th>
                  ))}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total}</td>
              {isElement369 ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.infernoRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.fluxRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.e280Rewards).toLocaleString()}
                  </td>
                </>
              ) : (
                <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {(isStax || isAscendant
                    ? Math.floor(holder.claimableRewards)
                    : holder.claimableRewards.toFixed(2)
                  ).toLocaleString()}
                </td>
              )}
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : '0.00'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.shares).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay8).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay28).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay90).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.percentage.toFixed(2)}%</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.multiplierSum.toFixed(2)}</td>
                  {Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                        {holder.tiers?.[tier] || 0}
                      </td>
                    ))}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable copy/Element369.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(contractTiers.element369 || {})
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {contractTiers.element369[tier].name}
                    </th>
                  ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {Object.keys(contractTiers.element369 || {}).map(tier => (
                    <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.element369;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for Element369.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
            {Object.keys(tiers)
              .sort((a, b) => b - a)
              .map(tier => (
                <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                  {tiers[tier].name}
                </th>
              ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.infernoRewards || 0).toLocaleString()}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.fluxRewards || 0).toLocaleString()}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.e280Rewards || 0).toLocaleString()}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {Object.keys(tiers)
                .sort((a, b) => b - a)
                .map(tier => (
                  <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {holder.tiers?.[tier] || 0}
                  </td>
                ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable copy/Element280.js
// components/HolderTable/Element280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';
  const isElement369 = contract === 'element369';
  const isElement280 = contract === 'element280';
  const isStax = contract === 'staxNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isElement369 ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                  </>
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                )}
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {(isElement280 || isElement369) && tiers ? (
                      Object.keys(tiers)
                        .sort((a, b) => b - a)
                        .map(tier => (
                          <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                            {tiers[tier].name}
                          </th>
                        ))
                    ) : (
                      <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]"></th>
                    )}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isElement369 ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  )}
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers && !isAscendant && !isStax) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isElement369 ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
              </>
            ) : (
              <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            )}
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {(isElement280 || isElement369) && tiers ? (
                  Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                        {tiers[tier].name}
                      </th>
                    ))
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]"></th>
                )}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              {isElement369 ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.infernoRewards || 0).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.fluxRewards || 0).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.e280Rewards || 0).toLocaleString()}
                  </td>
                </>
              ) : (
                <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {isElement280
                    ? (holder.claimableRewards || 0).toFixed(2).toLocaleString()
                    : (holder.claimableRewards || 0).toLocaleString()}
                </td>
              )}
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : '0.00'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.shares || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay8 || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay28 || 0).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay90 || 0).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
                  </td>
                  {(isElement280 || isElement369) && tiers ? (
                    Object.keys(tiers)
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                          {holder.tiers?.[tier] || 0}
                        </td>
                      ))
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">-</td>
                  )}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/Navbar.jsx
// components/Navbar.jsx
'use client';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10 },
    visible: { opacity: 1, y: 0 },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0 },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining' },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [
            { name: 'E280', href: '/nft/BASE/E280' },
          ],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="bg-gradient-to-r from-gray-900 to-gray-800 text-white p-4 sticky top-0 z-50 shadow-md">
      <div className="max-w-7xl mx-auto flex justify-between items-center">
        {/* Logo */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="text-2xl font-bold"
        >
          <Link href="/">TitanXUtils</Link>
        </motion.div>

        {/* Desktop Links */}
        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative text-gray-300 hover:text-white transition-colors duration-200 group"
              whileHover={{ scale: 1.1, color: '#f97316' }}
              whileTap={{ scale: 0.95 }}
            >
              {item.external ? (
                <a href={item.href} target="_blank" rel="noopener noreferrer">
                  {item.name}
                </a>
              ) : (
                <Link href={item.href}>{item.name}</Link>
              )}
              {item.subItems && (
                <motion.div
                  className="absolute left-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg hidden group-hover:block"
                  variants={dropdownVariants}
                  initial="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white">
                        {subItem.href ? (
                          <Link href={subItem.href}>{subItem.name}</Link>
                        ) : (
                          <span>{subItem.name}</span>
                        )}
                      </div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <div
                              key={nestedItem.name}
                              className="px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white"
                            >
                              <Link href={nestedItem.href}>
                                {nestedItem.name}
                              </Link>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
        </div>

        {/* Mobile Menu Toggle */}
        <button
          className="md:hidden p-2 focus:outline-none"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      {/* Mobile Menu */}
      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="block py-2 px-4 text-gray-300 hover:text-white hover:bg-gray-700 rounded-md transition-colors duration-200"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      {item.name}
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2">
                              {subItem.href ? (
                                <Link href={subItem.href} onClick={() => setIsOpen(false)}>
                                  {subItem.name}
                                </Link>
                              ) : (
                                <span>{subItem.name}</span>
                              )}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <div
                                    key={nestedItem.name}
                                    className="py-2"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    <Link href={nestedItem.href}>
                                      {nestedItem.name}
                                    </Link>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : item.external ? (
                  <a
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={() => setIsOpen(false)}
                  >
                    {item.name}
                  </a>
                ) : (
                  <Link href={item.href} onClick={() => setIsOpen(false)}>
                    {item.name}
                  </Link>
                )}
              </motion.div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./components/HolderTable/E280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from '@/app/nft-contracts';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  // Define E280 tier order (same as Element280; adjust if different)
  const e280TierOrder = [
    { tierId: '6', name: 'Legendary Amped', index: 5 },
    { tierId: '5', name: 'Legendary', index: 4 },
    { tierId: '4', name: 'Rare Amped', index: 3 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '3', name: 'Rare', index: 2 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {e280TierOrder.map(tier => (
                  <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {e280TierOrder.map(tier => (
                    <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.e280;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for E280.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
            {e280TierOrder.map(tier => (
              <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {e280TierOrder.map(tier => (
                <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Ascendant.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from '@/app/nft-contracts';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  // Define Ascendant tier order (descending: Tier 8 to Tier 1)
  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Ascendant] Tiers Length:', targetHolder.tiers?.length);
      // Compute tier counts and sum
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          // Try one-based array (tiers[8] = Tier 8)
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) ||
          // Try zero-based array (tiers[7] = Tier 8)
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) ||
          // Try object (tiers["8"] = Tier 8)
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) ||
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 8) {
        console.warn('[Ascendant] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 8');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {
                    // Try one-based array (tiers[8] = Tier 8)
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    // Try zero-based array (tiers[7] = Tier 8)
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    // Try object (tiers["8"] = Tier 8)
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    // Fallback to 0
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Stax.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from '@/app/nft-contracts';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  // Define Stax tier order (highest to lowest: Legendary LFG to Common)
  const staxTierOrder = [
    { tierId: '12', name: 'Legendary LFG', index: 11 },
    { tierId: '11', name: 'Legendary Super', index: 10 },
    { tierId: '10', name: 'Legendary Amped', index: 9 },
    { tierId: '9', name: 'Legendary', index: 8 },
    { tierId: '8', name: 'Rare LFG', index: 7 },
    { tierId: '7', name: 'Rare Super', index: 6 },
    { tierId: '6', name: 'Rare Amped', index: 5 },
    { tierId: '5', name: 'Rare', index: 4 },
    { tierId: '4', name: 'Common LFG', index: 3 },
    { tierId: '3', name: 'Common Super', index: 2 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0x15702443110894B26911B913b17ea4931F803B02';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Stax] Holder Data for Wallet:', targetHolder);
      console.log('[Stax] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Stax] Tiers Length:', targetHolder.tiers?.length);
      // Compute tier counts
      const tierCounts = staxTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && Number(targetHolder.tiers[Number(tier.tierId) - 1]) || 0);
        return { tier: tier.name, count };
      });
      console.log('[Stax] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Stax] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      // Calculate expected multiplier sum
      const multipliers = {
        '12': 200, '11': 140, '10': 120, '9': 100, '8': 20, '7': 14, '6': 12, '5': 10,
        '4': 2, '3': 1.4, '2': 1.2, '1': 1
      };
      const expectedMultiplierSum = tierCounts.reduce((sum, { count }, idx) => {
        const tierId = staxTierOrder[idx].tierId;
        return sum + count * multipliers[tierId];
      }, 0);
      console.log('[Stax] Multiplier Sum:', {
        actual: targetHolder.multiplierSum,
        expected: expectedMultiplierSum
      });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 12) {
        console.warn('[Stax] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 12');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Stax] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
      if (targetHolder.multiplierSum !== expectedMultiplierSum) {
        console.warn('[Stax] Warning: Multiplier sum mismatch for wallet', targetWallet, {
          actual: targetHolder.multiplierSum,
          expected: expectedMultiplierSum
        });
      }
    } else {
      console.warn('[Stax] Warning: Wallet not found in holders:', targetWallet);
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {staxTierOrder.map(tier => (
                  <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {staxTierOrder.map(tier => (
                    <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.stax;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for Stax.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
            {staxTierOrder.map(tier => (
              <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.multiplierSum === 'number' ? holder.multiplierSum.toFixed(2) : '-'}
              </td>
              {staxTierOrder.map(tier => (
                <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {Array.isArray(holder.tiers) ? Number(holder.tiers[Number(tier.tierId) - 1]) || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element369.js
// components/HolderTable/Element369.js
import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, contract, loading, totalShares }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];
  const isAscendant = contract === 'ascendantNFT';
  const isElement369 = contract === 'element369';
  const isStax = contract === 'staxNFT';

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                {isElement369 ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
                  </>
                ) : (
                  <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                )}
                {isAscendant ? (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
                  </>
                ) : (
                  <>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                    <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                    {Object.keys(contractTiers[contract] || {})
                      .sort((a, b) => b - a)
                      .map(tier => (
                        <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                          {contractTiers[contract][tier].name}
                        </th>
                      ))}
                  </>
                )}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {isElement369 ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  )}
                  {isAscendant ? (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                    </>
                  ) : (
                    <>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      {Object.keys(contractTiers[contract] || {}).map(tier => (
                        <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                      ))}
                    </>
                  )}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers[contract];
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for {contract}.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            {isElement369 ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">E280 Rewards</th>
              </>
            ) : (
              <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            )}
            {isAscendant ? (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Shares</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">DAY90 Rewards</th>
              </>
            ) : (
              <>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {Object.keys(tiers)
                  .sort((a, b) => b - a)
                  .map(tier => (
                    <th key={tier} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                      {tiers[tier].name}
                    </th>
                  ))}
              </>
            )}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total}</td>
              {isElement369 ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.infernoRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.fluxRewards).toLocaleString()}
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {Math.floor(holder.e280Rewards).toLocaleString()}
                  </td>
                </>
              ) : (
                <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {(isStax || isAscendant
                    ? Math.floor(holder.claimableRewards)
                    : holder.claimableRewards.toFixed(2)
                  ).toLocaleString()}
                </td>
              )}
              {isAscendant ? (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                    {totalShares ? ((holder.shares / totalShares) * 100).toFixed(2) : '0.00'}%
                  </td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.shares).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay8).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay28).toLocaleString()}</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{Math.floor(holder.pendingDay90).toLocaleString()}</td>
                </>
              ) : (
                <>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.percentage.toFixed(2)}%</td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.multiplierSum.toFixed(2)}</td>
                  {Object.keys(tiers)
                    .sort((a, b) => b - a)
                    .map(tier => (
                      <td key={tier} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                        {holder.tiers?.[tier] || 0}
                      </td>
                    ))}
                </>
              )}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import { contractTiers } from "@/app/nft-contracts";

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  // Define custom tier order for Element280
  const element280TierOrder = [
    { tierId: "6", name: "Legendary Amped" },
    { tierId: "5", name: "Legendary" },
    { tierId: "4", name: "Rare Amped" },
    { tierId: "2", name: "Common Amped" },
    { tierId: "3", name: "Rare" },
    { tierId: "1", name: "Common" },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="overflow-x-auto w-full rounded-lg shadow-lg">
          <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
            <thead>
              <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
                <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
                {element280TierOrder.map(tier => (
                  <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="text-gray-300 text-xs md:text-sm">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="animate-pulse"
                >
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  {element280TierOrder.map(tier => (
                    <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700"><div className="h-4 bg-gray-600 rounded w-3/4"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-center text-gray-400 py-4 w-full">No holders found.</div>;
  }

  const tiers = contractTiers.element280;
  if (!tiers) {
    return <div className="text-center text-red-500 py-4 w-full">Error: Contract tiers not found for Element280.</div>;
  }

  return (
    <div className="overflow-x-auto w-full rounded-lg shadow-lg">
      <table className="w-full bg-gray-800 text-white table-auto md:table-fixed">
        <thead>
          <tr className="bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base">
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[120px] md:w-[200px]">Wallet</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Reward %</th>
            <th className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">Total Multiplier</th>
            {element280TierOrder.map(tier => (
              <th key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 text-left font-semibold w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="text-gray-300 text-xs md:text-sm">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02, backgroundColor: '#1e3a8a' }}
              transition={{ delay: index * 0.05 }}
              className={`transition-colors ${index % 2 === 0 ? "bg-gray-800" : "bg-gray-900"}`}
            >
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.rank || '-'}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 hover:underline break-all"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">{holder.total || 0}</td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {element280TierOrder.map(tier => (
                <td key={tier.tierId} className="py-2 px-2 md:py-4 md:px-6 border-b border-gray-700">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/NFTPage cache db.js
'use client';

import { useState, useEffect, useCallback } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from './LoadingIndicator';
import { contractDetails, contractTiers, contractAddresses, vaultAddresses } from '@/app/nft-contracts';
import { Bar } from 'react-chartjs-2';
import Chart from 'chart.js/auto';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// Contract ABIs for Element280
const element280Abi = [
  { name: 'totalSupply', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'totalBurned', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
  { name: 'getTotalNftsPerTiers', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256[]' }] },
  { name: 'multiplierPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];
const element280VaultAbi = [
  { name: 'totalRewardPool', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'uint256' }] },
];

// Constants
const MAX_INITIAL_SUPPLY = 16883; // Only hardcoded constant
const FALLBACK_TOTAL_SUPPLY = 8137; // Current, may decrease
const FALLBACK_TOTAL_BURNED = 8746; // Current, may increase
const FALLBACK_EXPECTED_HOLDERS = 921; // Current, may change

// Retry utility
async function retry(fn, attempts = 3, delay = retryCount => Math.min(1000 * 2 ** retryCount, 5000)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch blockchain summary for Element280
async function fetchContractData() {
  const contractAddress = contractAddresses.element280.address;
  const vaultAddress = vaultAddresses.element280.address;
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI`, { timeout: 60000 }),
  });

  try {
    const [totalSupply, totalBurned, tierCounts, multiplierPool, totalRewardPool] = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: element280Abi, functionName: 'totalSupply' },
          { address: contractAddress, abi: element280Abi, functionName: 'totalBurned' },
          { address: contractAddress, abi: element280Abi, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: element280Abi, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: element280VaultAbi, functionName: 'totalRewardPool' },
        ],
      })
    );
    const totalSupplyNum = Number(totalSupply.result);
    const totalBurnedNum = Number(totalBurned.result);
    if (totalSupplyNum + totalBurnedNum > MAX_INITIAL_SUPPLY || totalSupplyNum < 0 || totalBurnedNum < 0) {
      throw new Error(`Invalid supply: totalSupply=${totalSupplyNum}, totalBurned=${totalBurnedNum}`);
    }
    const data = {
      totalMinted: totalSupplyNum + totalBurnedNum,
      totalBurned: totalBurnedNum,
      totalLive: totalSupplyNum,
      tierDistribution: tierCounts.result.map(Number),
      multiplierPool: Number(multiplierPool.result),
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution: [0, 0, 0, 0, 0, 0],
    };
    return data;
  } catch (error) {
    console.error('[fetchContractData] Error:', error.message);
    return {
      totalMinted: MAX_INITIAL_SUPPLY,
      totalBurned: FALLBACK_TOTAL_BURNED,
      totalLive: FALLBACK_TOTAL_SUPPLY,
      tierDistribution: [0, 0, 0, 0, 0, 0],
      multiplierPool: 0,
      totalRewardPool: 0,
      burnedDistribution: [0, 0, 0, 0, 0, 0],
    };
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  const contractId = contract ? contract.toLowerCase() : null;
  if (!contractId || !contractDetails[contractId]) {
    console.error('[NFTPage] Invalid contract:', { chain, contract });
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">Error</h1>
        <p className="text-red-500 text-lg">Invalid contract: {contractId || 'none'}</p>
      </div>
    );
  }

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({
    isPopulating: true,
    totalWallets: 0,
    totalOwners: 0,
    phase: 'Initializing',
    progressPercentage: 0,
  });
  const [cache, setCache] = useState({});
  const [isFetching, setIsFetching] = useState(false);
  const [hasPolled, setHasPolled] = useState(false);

  const contractConfig = contractDetails[contractId];
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  let HolderTable = holderTableComponents[contractId];
  if (!HolderTable) {
    console.error(`[NFTPage] HolderTable for ${contractId} not found`);
    return (
      <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
        <h1 className="text-4xl font-bold mb-6">{name} Holders</h1>
        <p className="text-red-500 text-lg">Error: Holder table for {contractId} not found</p>
      </div>
    );
  }

  const getCache = (key) => cache[key];
  const updateCache = (key, value) => setCache(prev => ({ ...prev, [key]: value }));

  useEffect(() => {
    if (disabled) {
      setError(`${name} is not yet supported`);
      setLoading(false);
    }
  }, [disabled, name]);

  const fetchAllHolders = useCallback(async () => {
    if (isFetching) return;
    setIsFetching(true);
    const cachedData = getCache(contractId);
    if (cachedData) {
      setData(cachedData);
      setLoading(false);
      setIsFetching(false);
      return;
    }

    try {
      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || 100;

      while (page < totalPages) {
        try {
          const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
          const res = await retry(() => fetch(url, { signal: AbortSignal.timeout(60000) }));
          if (!res.ok) {
            throw new Error(`Page ${page} failed with status: ${res.status}`);
          }
          const json = await res.json();
          const newHolders = json.holders || [];
          allHolders = allHolders.concat(newHolders);
          totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
          totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
          totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
          toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
          toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
          toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
          pendingRewards = json.pendingRewards || pendingRewards;
          summary = json.summary || summary;
          burnedNfts = json.burnedNfts || burnedNfts;
          totalPages = json.totalPages || 1;
          page++;
          if (!newHolders.length) break;
        } catch (err) {
          console.error(`[NFTPage] Fetch page ${page} error: ${err.message}`);
          throw err;
        }
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder?.wallet) {
          holder.shares = holder.shares || holder.totalShares || holder.multiplierSum || 0;
          holder.totalNfts = holder.totalNfts || holder.total || holder.totalLive || 0;
          const existing = uniqueHoldersMap.get(holder.wallet);
          if (existing) {
            existing.totalNfts += holder.totalNfts;
            existing.shares += holder.shares;
            existing.claimableRewards = (existing.claimableRewards || 0) + (holder.claimableRewards || 0);
            existing.tiers = existing.tiers.map((count, i) => count + (holder.tiers ? holder.tiers[i] : 0));
            existing.tokenIds = [...new Set([...existing.tokenIds, ...(holder.tokenIds || [])])];
          } else {
            uniqueHoldersMap.set(holder.wallet, { ...holder });
          }
        }
      });
      const uniqueHolders = Array.from(uniqueHoldersMap.values());

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      if (contractId === 'element369') {
        totalInfernoRewards = uniqueHolders.reduce((sum, h) => sum + (h.infernoRewards || 0), 0);
        totalFluxRewards = uniqueHolders.reduce((sum, h) => sum + (h.fluxRewards || 0), 0);
        totalE280Rewards = uniqueHolders.reduce((sum, h) => sum + (h.e280Rewards || 0), 0);
      } else {
        totalClaimableRewards = uniqueHolders.reduce((sum, h) => sum + (h.claimableRewards || 0), 0);
      }
      if (!totalTokens && uniqueHolders.length > 0) {
        totalTokens = uniqueHolders.reduce((sum, h) => sum + (isElement280 ? h.totalLive || 0 : h.totalNfts || 0), 0);
      }

      uniqueHolders.forEach(holder => {
        holder.sharesPercentage = totalShares > 0 ? ((holder.shares || 0) / totalShares) * 100 : 0;
      });

      if (contractId === 'ascendant') {
        uniqueHolders.sort((a, b) => {
          const sharesDiff = (b.shares || 0) - (a.shares || 0);
          if (sharesDiff !== 0) return sharesDiff;
          return (b.totalNfts || 0) - (a.totalNfts || 0);
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.totalLive || b.total || 0) - (a.totalLive || a.total || 0));
      }
      uniqueHolders.forEach((holder, index) => {
        holder.rank = index + 1;
        holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      });

      let fetchedData = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      if (isElement280) {
        const blockchainSummary = await fetchContractData();
        fetchedData.summary = { ...fetchedData.summary, ...blockchainSummary };
        fetchedData.totalTokens = blockchainSummary.totalLive || fetchedData.totalTokens;
        fetchedData.totalShares = blockchainSummary.multiplierPool || fetchedData.totalShares;
        fetchedData.totalClaimableRewards = blockchainSummary.totalRewardPool || fetchedData.totalClaimableRewards;
        if (fetchedData.totalTokens + fetchedData.summary.totalBurned > MAX_INITIAL_SUPPLY || fetchedData.totalTokens < 0) {
          console.error(`[NFTPage] Validation failed: totalTokens=${fetchedData.totalTokens}, totalBurned=${fetchedData.summary.totalBurned}`);
          setError(`Invalid data: total supply (${fetchedData.totalTokens}) + burned (${fetchedData.summary.totalBurned}) exceeds ${MAX_INITIAL_SUPPLY}`);
          setLoading(false);
          setIsFetching(false);
          return;
        }
      }

      console.log(`[NFTPage] Fetched ${uniqueHolders.length} holders, totalTokens=${totalTokens}`);
      updateCache(contractId, fetchedData);
      setData(fetchedData);
      setLoading(false);
    } catch (err) {
      console.error('[NFTPage] Fetch error:', err.message);
      setError(`Failed to load ${name} holders: ${err.message}`);
      setLoading(false);
    } finally {
      setIsFetching(false);
    }
  }, [contractId, apiEndpoint, isElement280, name, pageSize]);

  useEffect(() => {
    if (!isElement280 || disabled || !apiEndpoint || hasPolled) return;

    let timeoutId;
    let intervalId;
    const pollProgress = async () => {
      try {
        const res = await retry(() => fetch(`${apiEndpoint}/progress`, { cache: 'no-store' }));
        if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
        const progressData = await res.json();
        setProgress({
          ...progressData,
          phase: progressData.step || 'Processing',
          progressPercentage: progressData.progressPercentage || 0,
        });

        if (!progressData.isPopulating && progressData.totalWallets >= FALLBACK_EXPECTED_HOLDERS) {
          setHasPolled(true);
          await fetchAllHolders();
          clearInterval(intervalId);
          clearTimeout(timeoutId);
        } else if (!progressData.isPopulating && progressData.totalWallets < FALLBACK_EXPECTED_HOLDERS) {
          setError(`Incomplete data: ${progressData.totalWallets}/${FALLBACK_EXPECTED_HOLDERS} wallets`);
          setLoading(false);
          setHasPolled(true);
          clearInterval(intervalId);
          clearTimeout(timeoutId);
        }
      } catch (err) {
        console.error('[NFTPage] Progress error:', err.message);
        try {
          const blockchainSummary = await fetchContractData();
          setData({
            holders: [],
            totalTokens: blockchainSummary.totalLive,
            totalShares: blockchainSummary.multiplierPool,
            totalClaimableRewards: blockchainSummary.totalRewardPool,
            summary: blockchainSummary,
            burnedNfts: [],
          });
          setLoading(false);
          setHasPolled(true);
          clearInterval(intervalId);
          clearTimeout(timeoutId);
        } catch (fallbackErr) {
          console.error('[NFTPage] Fallback error:', fallbackErr.message);
          setError(`Failed to load ${name}: ${err.message}`);
          setLoading(false);
          setHasPolled(true);
          clearInterval(intervalId);
          clearTimeout(timeoutId);
        }
      }
    };

    pollProgress();
    intervalId = setInterval(pollProgress, 1000);
    timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      setError(`Failed to load ${name}: Progress check timed out`);
      setLoading(false);
      setHasPolled(true);
    }, 30000);

    return () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
  }, [isElement280, apiEndpoint, disabled, name, fetchAllHolders, hasPolled]);

  useEffect(() => {
    if (isElement280 || disabled || !apiEndpoint) return;
    fetchAllHolders();
  }, [isElement280, apiEndpoint, disabled, fetchAllHolders]);

  const renderSummary = () => {
    if (!data) return null;

    const totalMultiplierSum = data.totalShares || data.holders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
    const totalTokens = data.totalTokens || 0;
    const totalClaimableRewards = data.totalClaimableRewards || 0;
    const totalInfernoRewards = data.totalInfernoRewards || 0;
    const totalFluxRewards = data.totalFluxRewards || 0;
    const totalE280Rewards = data.totalE280Rewards || 0;

    if (contractId === 'element280') {
      const summary = data.summary || {};
      const totalSupply = Number(summary.totalLive || totalTokens || FALLBACK_TOTAL_SUPPLY);
      const totalBurned = Number(summary.totalBurned || FALLBACK_TOTAL_BURNED);
      const totalInitialSupply = MAX_INITIAL_SUPPLY;
      const percentBurned = totalInitialSupply > 0 ? ((totalBurned / totalInitialSupply) * 100).toFixed(2) : '0.00';
      const tierDistribution = summary.tierDistribution || [0, 0, 0, 0, 0, 0];
      const burnedDistribution = summary.burnedDistribution || [0, 0, 0, 0, 0, 0];
      const multiplierPool = Number(summary.multiplierPool || totalShares || 0);
      const totalRewardPool = Number(summary.totalRewardPool || totalClaimableRewards || 0);

      const tierData = Object.values(contractTiers.element280).map((tier, index) => {
        const remainingCount = Number(tierDistribution[index] || 0);
        const burnedCount = Number(burnedDistribution[index] || 0);
        const initialCount = remainingCount + burnedCount;
        const burnedPercentage = initialCount > 0 ? ((burnedCount / initialCount) * 100).toFixed(2) : '0.00';
        return {
          name: tier.name,
          count: remainingCount,
          percentage: totalSupply > 0 ? ((remainingCount / totalSupply) * 100).toFixed(2) : '0.00',
          multiplier: tier.multiplier,
          burned: burnedCount,
          burnedPercentage,
        };
      });

      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element280 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Initial Supply</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalInitialSupply.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Minted NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Burned</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalBurned.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Burned NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total NFTs Remaining</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalSupply.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Circulating NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Burned Percentage</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{percentBurned}%</p>
              <p className="text-sm text-gray-400">Of Total Minted</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Multiplier Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{multiplierPool.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Sum of Multipliers</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Reward Pool</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </p>
              <p className="text-sm text-gray-400">Claimable Rewards</p>
            </div>
          </div>
          <div>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-lg font-semibold text-gray-300">Tier Distribution</h3>
              <motion.button
                className="px-4 py-2 bg-gray-700 text-gray-300 rounded-lg hover:bg-gray-600 focus:outline-none"
                onClick={() => setShowChart(!showChart)}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                {showChart ? 'Hide Chart' : 'Show Chart'}
              </motion.button>
            </div>
            <div className="overflow-x-auto">
              <table className="w-full text-left border-collapse bg-gray-800 rounded-lg">
                <thead>
                  <tr className="bg-gray-700 text-gray-300">
                    <th className="p-3 text-sm font-semibold">Tier</th>
                    <th className="p-3 text-sm font-semibold text-right">Count</th>
                    <th className="p-3 text-sm font-semibold text-right">% Remaining</th>
                    <th className="p-3 text-sm font-semibold text-right">Multiplier</th>
                    <th className="p-3 text-sm font-semibold text-right">Burned</th>
                    <th className="p-3 text-sm font-semibold text-right">% Burned</th>
                  </tr>
                </thead>
                <tbody>
                  {tierData.map((tier, index) => (
                    <tr
                      key={tier.name}
                      className={`border-b border-gray-700 ${index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-900'}`}
                    >
                      <td className="p-3 text-gray-300">{tier.name}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.count.toLocaleString()}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.percentage}%</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.multiplier}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burned.toLocaleString()}</td>
                      <td className="p-3 text-gray-300 font-mono text-right">{tier.burnedPercentage}%</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
          <AnimatePresence>
            {showChart && (
              <motion.div
                className="bg-gray-800 p-4 rounded-lg shadow-md"
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <h3 className="text-lg font-semibold text-gray-300 mb-3">Tier Distribution Chart</h3>
                <div className="w-full max-w-[800px] mx-auto" style={{ height: '300px' }}>
                  <Bar
                    data={{
                      labels: tierData.map(t => t.name),
                      datasets: [
                        {
                          label: 'Remaining NFTs',
                          data: tierData.map(t => t.count),
                          backgroundColor: 'rgba(75, 192, 192, 0.6)',
                          borderColor: 'rgba(75, 192, 192, 1)',
                          borderWidth: 1,
                        },
                        {
                          label: 'Burned NFTs',
                          data: tierData.map(t => t.burned),
                          backgroundColor: 'rgba(255, 99, 132, 0.6)',
                          borderColor: 'rgba(255, 99, 132, 1)',
                          borderWidth: 1,
                        },
                      ],
                    }}
                    options={{
                      maintainAspectRatio: false,
                      scales: {
                        y: {
                          beginAtZero: true,
                          title: { display: true, text: 'Number of NFTs', color: '#d1d5db' },
                          ticks: { color: '#d1d5db', callback: value => value.toLocaleString() },
                          grid: { color: '#4b5563' },
                        },
                        x: {
                          title: { display: true, text: 'Tier', color: '#d1d5db' },
                          ticks: { color: '#d1d5db' },
                          grid: { display: false },
                        },
                      },
                      plugins: { legend: { labels: { color: '#d1d5db' } } },
                    }}
                  />
                </div>
              </motion.div>
            )}
          </AnimatePresence>
          <div className="bg-gray-800 p-4 rounded-lg shadow-md">
            <p className="text-gray-300">
              Unique Wallets: <span className="font-bold text-white font-mono">{data.holders.length.toLocaleString()}</span>
            </p>
            <p className="text-gray-300">
              Active NFTs: <span className="font-bold text-white font-mono">{totalSupply.toLocaleString()}</span>
            </p>
            <p className="text-gray-300">
              Total Multiplier Sum: <span className="font-bold text-white font-mono">{multiplierPool.toLocaleString()}</span>
            </p>
            <p className="text-gray-300">
              Total Reward Pool: <span className="font-bold text-white font-mono">
                {totalRewardPool.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} {rewardToken || 'ELMNT'}
              </span>
            </p>
          </div>
        </div>
      );
    } else if (contractId === 'ascendant') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Ascendant Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{data.holders.length.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalTokens.toLocaleString()}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Locked</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{(data.totalLockedAscendant || 0).toLocaleString()}</p>
              <p className="text-sm text-gray-400">Ascendant NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Shares</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{(data.totalShares || 0).toLocaleString()}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">
                {Math.floor(totalClaimableRewards).toLocaleString()} {rewardToken || 'DRAGONX'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Pending Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{(data.pendingRewards || 0).toLocaleString()}</p>
              <p className="text-sm text-gray-400">DragonX Rewards</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'element369') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Element369 Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{data.holders.length.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalTokens.toLocaleString()}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalMultiplierSum.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Inferno Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{Math.floor(totalInfernoRewards).toLocaleString()}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Flux Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{Math.floor(totalFluxRewards).toLocaleString()}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">E280 Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{Math.floor(totalE280Rewards).toLocaleString()}</p>
              <p className="text-sm text-gray-400">Claimable</p>
            </div>
          </div>
        </div>
      );
    } else if (contractId === 'stax') {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">Stax Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{data.holders.length.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalTokens.toLocaleString()}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalMultiplierSum.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">
                {Math.floor(totalClaimableRewards).toLocaleString()} {rewardToken || 'X28'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    } else {
      return (
        <div className="space-y-6">
          <h2 className="text-2xl font-semibold mb-2">{name} Summary</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Unique Wallets</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{data.holders.length.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Holding NFTs</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Active NFTs</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalTokens.toLocaleString()}</p>
              <p className="text-sm text-gray-400">In Circulation</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Total Multiplier</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">{totalMultiplierSum.toLocaleString()}</p>
              <p className="text-sm text-gray-400">Multiplier Sum</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
              <h3 className="text-lg font-semibold text-gray-300">Claimable Rewards</h3>
              <p className="text-2xl font-bold text-white font-mono text-right">
                {Math.floor(totalClaimableRewards).toLocaleString()} {rewardToken || 'Unknown'}
              </p>
              <p className="text-sm text-gray-400">Total Rewards</p>
            </div>
          </div>
        </div>
      );
    }
  };

  const getLoadingMessage = () => {
    if (!isElement280) {
      return `Loading ${name} holders...`;
    }
    if (progress.isPopulating) {
      return `Populating ${name} holders: ${progress.totalWallets} wallets`;
    }
    return `Finalizing ${name} data: ${progress.totalWallets} wallets...`;
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name} Holders</h1>
      {loading ? (
        <LoadingIndicator status={getLoadingMessage()} progress={progress} />
      ) : error ? (
        <p className="text-red-500 text-lg">Error: {error}</p>
      ) : !data ? (
        <p className="text-gray-400 text-lg">No data for {name}.</p>
      ) : data.message ? (
        <p className="text-gray-400 text-lg">{data.message}</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary()}</div>
          <HolderTable
            holders={data.holders || []}
            contract={contractId}
            summary={data.summary}
            loading={loading}
            totalShares={isElement280 ? data.summary?.multiplierPool : data.totalShares}
            totalLockedAscendant={data.totalLockedAscendant}
            toDistributeDay8={data.toDistributeDay8}
            toDistributeDay28={data.toDistributeDay28}
            toDistributeDay90={data.toDistributeDay90}
            pendingRewards={data.pendingRewards}
            totalClaimableRewards={data.totalClaimableRewards}
            totalInfernoRewards={data.totalInfernoRewards}
            totalFluxRewards={data.totalFluxRewards}
            totalE280Rewards={data.totalE280Rewards}
            burnedNfts={data.burnedNfts}
          />
        </div>
      )}
    </div>
  );
}-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts*.sqlite
*.db
output.txt
scripts/backups/
-e 
---
File: ./eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [...compat.extends("next/core-web-vitals")];

export default eslintConfig;
