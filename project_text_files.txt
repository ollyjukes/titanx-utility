-e 
---
File: ./tailwind.config.js


/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};

-e 
---
File: ./.env.local
# File: .env.local
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
UPSTASH_REDIS_REST_URL=https://splendid-sunbird-26504.upstash.io
UPSTASH_REDIS_REST_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_URL=https://splendid-sunbird-26504.upstash.io
KV_REST_API_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_READ_ONLY_TOKEN=AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg
KV_URL=rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379
PERSIST_CACHE=true
DEBUG=true
LOG_LEVEL=info
USE_FALLBACK_DATA=false
ESLINT_NO_DEV_ERRORS=true
USE_ALCHEMY_FOR_OWNERS=true
NEXT_NO_WORKER_THREADS=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:3000
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true
DISABLE_ELEMENT280_REDIS=false-e 
---
File: ./app/layout.js
'use client';
import '@/app/global.css';
import { Inter } from 'next/font/google';
import Navbar from '@/components/Navbar';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en" className="bg-gray-900 text-gray-100">
      <body className={inter.className}>
        <Navbar />
        <main className="flex-grow container page-content">{children}</main>
        <footer className="footer">
          <p>© {new Date().getFullYear()} TitanXUtils by KetoNatural and JukesTheGreat.</p>
        </footer>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js

'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-gray-100">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-body">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, mining, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-green-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-green-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/mining">Mining</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
'use client';
import { useState, useCallback } from 'react';
import SearchResultsModal from '@/components/SearchResultsModal';
import config from '@/config';
import dynamic from 'next/dynamic';

// Dynamic HolderTable components
const holderTableComponents = {
  element280: dynamic(
    () => import('@/components/HolderTable/Element280').catch((err) => {
      console.error('Failed to load Element280 HolderTable:', err);
      return { default: () => <div className="text-error">Error loading data for Element280</div> };
    }),
    { ssr: false, loading: () => <div className="text-body">Loading Element280 data...</div> }
  ),
  element369: dynamic(
    () => import('@/components/HolderTable/Element369').catch((err) => {
      console.error('Failed to load Element369 HolderTable:', err);
      return { default: () => <div className="text-error">Error loading data for Element369</div> };
    }),
    { ssr: false, loading: () => <div className="text-body">Loading Element369 data...</div> }
  ),
  stax: dynamic(
    () => import('@/components/HolderTable/Stax').catch((err) => {
      console.error('Failed to load Stax HolderTable:', err);
      return { default: () => <div className="text-error">Error loading data for Stax</div> };
    }),
    { ssr: false, loading: () => <div className="text-body">Loading Stax data...</div> }
  ),
  ascendant: dynamic(
    () => import('@/components/HolderTable/Ascendant').catch((err) => {
      console.error('Failed to load Ascendant HolderTable:', err);
      return { default: () => <div className="text-error">Error loading data for Ascendant</div> };
    }),
    { ssr: false, loading: () => <div className="text-body">Loading Ascendant data...</div> }
  ),
};

export default function NFTLayout({ children }) {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResult, setSearchResult] = useState({});
  const [selectedChain, setSelectedChain] = useState(null);
  const [selectedCollection, setSelectedCollection] = useState(null);
  const [collectionData, setCollectionData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchSearchResults = useCallback(async (address) => {
    const collections = [
      { apiKey: 'element280', name: 'Element280' },
      { apiKey: 'element369', name: 'Element369' },
      { apiKey: 'stax', name: 'Stax' },
      { apiKey: 'ascendant', name: 'Ascendant' },
    ];

    const results = {};
    for (const { apiKey } of collections) {
      try {
        const contractConfig = config.contractDetails[apiKey];
        if (!contractConfig || contractConfig.disabled) {
          results[apiKey] = { message: `${apiKey} is disabled` };
          continue;
        }

        const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
        const url = `${baseUrl}/api/holders/${apiKey}`;
        console.log(`Fetching holders for ${apiKey}: ${url}`);
        const response = await fetch(url, { cache: 'no-store' });
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Fetch failed for ${apiKey}: ${response.status} - ${errorText}`);
          results[apiKey] = { error: `Failed to fetch data: ${response.status} - ${errorText}` };
          continue;
        }
        const data = await response.json();
        console.log(`Holders data for ${apiKey}:`, data);
        if (data.holders && data.holders.length > 0) {
          console.log(`First holder for ${apiKey}:`, data.holders[0]);
        }

        // Check if holders is an array
        if (!Array.isArray(data.holders)) {
          console.error(`Invalid holders format for ${apiKey}:`, data.holders);
          results[apiKey] = { error: 'Invalid holders data format' };
          continue;
        }

        // Filter holders by address
        const filteredHolders = data.holders.filter(
          (holder) => {
            const holderAddress = holder.address || holder.ownerAddress;
            if (!holderAddress) {
              console.warn(`No address field in holder for ${apiKey}:`, holder);
              return false;
            }
            return holderAddress.toLowerCase() === address.toLowerCase();
          }
        );
        results[apiKey] = filteredHolders.length > 0
          ? {
              holders: filteredHolders,
              totalBurned: data.totalBurned || 0,
              timestamp: data.timestamp || Date.now(),
            }
          : { message: 'No NFTs owned in this collection' };
      } catch (error) {
        console.error(`Error fetching ${apiKey} data for ${address}:`, error);
        results[apiKey] = { error: error.message };
      }
    }
    setSearchResult(results);
  }, []);

  const fetchCollectionData = useCallback(async (apiKey, retries = 2) => {
    setLoading(true);
    setError(null);
    setCollectionData(null);

    const contractConfig = config.contractDetails[apiKey];
    if (!contractConfig || contractConfig.disabled) {
      setError(`${apiKey} is disabled`);
      setLoading(false);
      return;
    }

    const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
    const endpoints = [
      `${baseUrl}/api/holders/${apiKey}`,
    ];

    for (let attempt = 1; attempt <= retries; attempt++) {
      for (const url of endpoints) {
        try {
          console.log(`Fetching collection data (attempt ${attempt}) for ${apiKey}: ${url}`);
          const response = await fetch(url, { cache: 'force-cache' });
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`Fetch failed for ${apiKey}: ${response.status} - ${errorText}`);
            throw new Error(`Failed to fetch data: ${response.status} - ${errorText}`);
          }
          const data = await response.json();
          console.log(`Collection data for ${apiKey}:`, data);
          if (data.holders && data.holders.length > 0) {
            console.log(`First holder for ${apiKey}:`, data.holders[0]);
          }

          if (!data || !Array.isArray(data.holders)) {
            console.warn(`No valid holders data for ${apiKey}:`, data);
            setError(`No holder data available for ${config.nftContracts[apiKey].name}`);
            setCollectionData({
              holders: [],
              totalTokens: data.totalTokens || data.totalBurned || 0,
              totalShares: data.totalBurned || 0,
              summary: data.summary || {},
            });
            setLoading(false);
            return;
          }

          setCollectionData({
            holders: data.holders.map((holder) => ({
              ...holder,
              address: holder.address || holder.ownerAddress,
            })) || [],
            totalTokens: data.totalTokens || data.totalBurned || 0,
            totalShares: data.totalBurned || 0,
            summary: data.summary || {},
          });
          setLoading(false);
          return;
        } catch (error) {
          console.error(`Attempt ${attempt} failed for ${apiKey} at ${url}:`, error);
          if (attempt === retries && url === endpoints[endpoints.length - 1]) {
            setError(error.message || `Failed to fetch data for ${config.nftContracts[apiKey].name}`);
            setCollectionData({
              holders: [],
              totalTokens: 0,
              totalShares: 0,
              summary: {},
            });
            setLoading(false);
          }
        }
      }
    }
  }, []);

  const openSearchModal = async () => {
    if (searchAddress && searchAddress.length === 42 && searchAddress.startsWith('0x')) {
      await fetchSearchResults(searchAddress);
      setIsSearchOpen(true);
    }
  };

  const closeSearchModal = () => {
    setIsSearchOpen(false);
    setSearchAddress('');
    setSearchResult({});
  };

  const handleBackgroundClick = (e) => {
    if (e.target.classList.contains('modal-overlay')) {
      closeSearchModal();
    }
  };

  const handleChainSelect = (chain) => {
    setSelectedChain(chain);
    setSelectedCollection(null);
    setCollectionData(null);
  };

  const handleCollectionSelect = (collection) => {
    setSelectedCollection(collection);
    fetchCollectionData(collection);
  };

  const availableCollections = Object.keys(config.nftContracts)
    .filter(
      (key) => !config.nftContracts[key].disabled && config.nftContracts[key].chain === selectedChain
    )
    .map((key) => ({
      apiKey: key,
      name: config.nftContracts[key].name,
    }));

  return (
    <>
      <div className="container mx-auto py-4">
        {/* Centered Search Box */}
        <div className="flex justify-center mb-4">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Enter wallet address (0x...)"
            className="px-4 py-2 bg-gray-800 text-gray-100 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-600 w-64"
          />
          <button
            onClick={openSearchModal}
            disabled={!searchAddress || searchAddress.length !== 42 || !searchAddress.startsWith('0x')}
            className="px-4 py-2 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
          >
            Search
          </button>
        </div>

        {/* Chain Buttons */}
        <div className="flex justify-center gap-4 mb-4">
          {config.supportedChains.map((chain) => (
            <button
              key={chain}
              onClick={() => handleChainSelect(chain)}
              className={`px-4 py-2 rounded-md ${
                selectedChain === chain
                  ? 'bg-blue-700 text-white'
                  : 'bg-blue-600 text-white hover:bg-blue-700'
              } transition`}
            >
              {chain}
            </button>
          ))}
        </div>

        {/* NFT Collection Buttons */}
        {selectedChain && (
          <div className="flex justify-center flex-wrap gap-4 mb-4">
            {availableCollections.length > 0 ? (
              availableCollections.map(({ apiKey, name }) => (
                <button
                  key={apiKey}
                  onClick={() => handleCollectionSelect(apiKey)}
                  className={`px-4 py-2 rounded-md ${
                    selectedCollection === apiKey
                      ? 'bg-blue-700 text-white'
                      : 'bg-blue-600 text-white hover:bg-blue-700'
                  } transition`}
                >
                  {name}
                </button>
              ))
            ) : (
              <p className="text-gray-100">No collections available for {selectedChain}</p>
            )}
          </div>
        )}
      </div>

      {/* Holder Table for Selected Collection */}
      <main className="flex-grow container page-content">
        {selectedCollection && (
          <div className="mb-4">
            {loading ? (
              <p className="text-body">Loading {config.nftContracts[selectedCollection].name} data...</p>
            ) : error ? (
              <p className="text-error">{error}</p>
            ) : collectionData ? (
              (() => {
                const HolderTable = holderTableComponents[selectedCollection];
                return (
                  <HolderTable
                    holders={collectionData.holders || []}
                    contract={selectedCollection}
                    loading={false}
                    totalTokens={collectionData.totalTokens || 0}
                    totalShares={collectionData.totalShares || 0}
                    rewardToken={config.contractDetails[selectedCollection]?.rewardToken}
                  />
                );
              })()
            ) : (
              <p className="text-body">No data available for ${config.nftContracts[selectedCollection].name}</p>
            )}
          </div>
        )}
      </main>

      {/* Search Modal */}
      {isSearchOpen && (
        <SearchResultsModal
          searchResult={searchResult}
          searchAddress={searchAddress}
          closeModal={closeSearchModal}
          handleBackgroundClick={handleBackgroundClick}
        />
      )}
    </>
  );
}-e 
---
File: ./app/nft/page.js
// app/nft/page.js
'use client';
import { motion } from 'framer-motion';
import { fetchCollectionData } from '@/lib/fetchCollectionData';
import config from '@/config';
import LoadingIndicator from '@/components/LoadingIndicator';
import NFTSummary from '@/components/NFTSummary';
import React from 'react';


const collections = Object.entries(config.contractDetails).map(([apiKey, { name, apiEndpoint, pageSize, disabled }]) => ({
  apiKey,
  name,
  apiEndpoint,
  pageSize,
  disabled,
}));

export default function NFTOverview() {
  const [collectionsData, setCollectionsData] = React.useState([]);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(null);

  const handleCollectionClick = async (apiKey, apiEndpoint, pageSize, disabled) => {
    if (disabled) return;
    setLoading(true);
    setError(null);
    try {
      const data = await fetchCollectionData(apiKey, apiEndpoint, pageSize);
      if (data.error) {
        setError(data.error);
      } else {
        setCollectionsData([{ apiKey, data }]);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 p-6 flex flex-col items-center">
      <h1 className="title mb-6">NFT Collections</h1>
      <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl mb-6">
        {collections.map(({ apiKey, name, apiEndpoint, pageSize, disabled }) => (
          <motion.button
            key={apiKey}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleCollectionClick(apiKey, apiEndpoint, pageSize, disabled)}
            className={`btn btn-secondary w-full ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
            disabled={disabled}
          >
            {name}
          </motion.button>
        ))}
      </div>
      {loading && <LoadingIndicator status="Loading collection..." />}
      {error && <p className="text-error">{error}</p>}
      {collectionsData.some(c => c.data.error?.includes('Cache is populating') || c.data.error?.includes('Failed to fetch cache progress') || c.data.error?.includes('timed out')) && (
        <p className="text-body">Data is being loaded, please wait a moment...</p>
      )}
      {collectionsData.length > 0 && !loading && <NFTSummary collectionsData={collectionsData} />}
    </div>
  );
}-e 
---
File: ./app/nft/[chain]/[contract]/page.js
'use client';
import { useState, useEffect } from 'react';
import { notFound } from 'next/navigation';
import nextDynamic from 'next/dynamic';
import Head from 'next/head'; // Add next/head for client-side metadata
import config from '@/config';
import LoadingIndicator from '@/components/LoadingIndicator';
import { useNFTStore } from '@/app/store';
import { HoldersResponseSchema } from '@/lib/schemas';
import { use } from 'react';

const NFTPageWrapper = nextDynamic(() => import('@/components/NFTPageWrapper'), { ssr: false });
export const dynamic = 'force-dynamic';

async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  console.log(`[NFTContractPage] [INFO] Fetching data for ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      console.log(`[NFTContractPage] [INFO] ${apiKey} is disabled`);
      return { error: `${apiKey} is not available` };
    }

    const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
    const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${baseUrl}${apiEndpoint}`;

    const pollProgress = async () => {
      const progressUrl = `${endpoint}/progress`;
      const res = await fetch(progressUrl, { cache: 'no-store', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
      if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
      const progress = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Progress: ${JSON.stringify(progress)}`);
      return progress;
    };

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;

    const maxPollTime = 180000;
    const startTime = Date.now();
    let progress = await pollProgress();

    while (progress.isPopulating || progress.phase !== 'Completed') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[NFTContractPage] [ERROR] Cache population timeout for ${apiKey}`);
        return { error: 'Cache population timed out' };
      }
      console.log(`[NFTContractPage] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%)`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      progress = await pollProgress();
      if (progress.phase === 'Error') {
        console.error(`[NFTContractPage] [ERROR] Cache population failed: ${progress.error || 'Unknown error'}`);
        return { error: `Cache population failed: ${progress.error || 'Unknown error'}` };
      }
    }

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      console.log(`[NFTContractPage] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      console.log(`[NFTContractPage] [DEBUG] Response status: ${res.status}`);

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[NFTContractPage] [ERROR] Failed to fetch ${url}: ${res.status} ${errorText}`);
        return { error: `Failed to fetch data: ${res.status}` };
      }

      const json = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Response body: ${JSON.stringify(json, (key, value) => typeof value === 'bigint' ? value.toString() : value)}`);

      if (json.isCachePopulating) {
        return { isCachePopulating: true, progress };
      }

      const validation = HoldersResponseSchema.safeParse(json);
      if (!validation.success) {
        console.error(`[NFTContractPage] [ERROR] Invalid holders data: ${JSON.stringify(validation.error.errors)}`);
        if (apiKey === 'ascendant') {
          console.log(`[NFTContractPage] [INFO] Triggering POST for ${apiKey}`);
          await fetch(endpoint, { method: 'POST', cache: 'no-store', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ forceUpdate: false }) });
          const retryRes = await fetch(url, { cache: 'no-store' });
          if (!retryRes.ok) {
            const retryError = await retryRes.text();
            console.error(`[NFTContractPage] [ERROR] Retry failed: ${retryRes.status} ${retryError}`);
            return { error: `Retry failed: ${retryRes.status}` };
          }
          const retryJson = await retryRes.json();
          const retryValidation = HoldersResponseSchema.safeParse(retryJson);
          if (!retryValidation.success) {
            console.error(`[NFTContractPage] [ERROR] Retry invalid holders data: ${JSON.stringify(retryValidation.error.errors)}`);
            return { error: 'Invalid holders data after retry' };
          }
          json.holders = retryJson.holders;
          json.totalTokens = retryJson.totalTokens;
          json.totalShares = retryJson.totalShares;
          json.totalBurned = retryJson.totalBurned;
          json.summary = retryJson.summary;
          json.totalPages = retryJson.totalPages;
        } else {
          return { error: 'Invalid holders data' };
        }
      }

      allHolders = allHolders.concat(json.holders);
      totalTokens = json.totalTokens || totalTokens;
      totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
      totalBurned = json.totalBurned || totalBurned;
      summary = json.summary || summary;
      totalPages = json.totalPages || 1;
      page++;
      console.log(`[NFTContractPage] [INFO] Fetched page ${page} for ${apiKey}: ${json.holders.length} holders`);
    }

    return {
      holders: allHolders,
      totalTokens,
      totalShares,
      totalBurned,
      summary,
    };
  } catch (error) {
    console.error(`[NFTContractPage] [ERROR] Error fetching ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { error: error.message };
  }
}

export default function NFTContractPage({ params }) {
  const resolvedParams = use(params);
  const { chain, contract } = resolvedParams;
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [progress, setProgress] = useState(null);

  const { getCache, setCache } = useNFTStore();

  const apiKeyMap = {
    Element280: 'element280',
    Element369: 'element369',
    Stax: 'stax',
    Ascendant: 'ascendant',
    E280: 'e280',
  };
  const apiKey = apiKeyMap[contract];

  useEffect(() => {
    if (!config.supportedChains.includes(chain) || !apiKey) {
      console.log(`[NFTContractPage] [ERROR] Invalid chain=${chain} or contract=${contract}`);
      notFound();
    }

    async function fetchData() {
      setLoading(true);
      setError(null);
      setData(null);

      const contractConfig = config.contractDetails[apiKey] || {};
      const cacheKey = `contract_${apiKey}`;
      const cachedData = getCache(cacheKey);

      if (cachedData) {
        console.log(`[NFTContractPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      console.log(`[NFTContractPage] [INFO] Cache miss for ${cacheKey}, fetching data`);
      const result = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);

      if (result.isCachePopulating) {
        const poll = async () => {
          const progressResult = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);
          setProgress(progressResult.progress);
          if (progressResult.isCachePopulating) {
            setTimeout(poll, config.alchemy.batchDelayMs);
          } else if (progressResult.error) {
            setError(progressResult.error);
            setLoading(false);
          } else {
            setCache(cacheKey, progressResult);
            setData(progressResult);
            setLoading(false);
          }
        };
        poll();
      } else if (result.error) {
        setError(result.error);
        setLoading(false);
      } else {
        setCache(cacheKey, result);
        setData(result);
        setLoading(false);
      }
    }

    fetchData();
  }, [chain, contract, apiKey, getCache, setCache]);

  if (!config.supportedChains.includes(chain) || !apiKey) {
    notFound();
  }

  // Dynamic metadata
  const pageTitle = `${contract} Collection | TitanXUtils`;
  const pageDescription = `NFT tracking for ${contract} on ${chain} in the TitanX ecosystem`;

  return (
    <>
      <Head>
        <title>{pageTitle}</title>
        <meta name="description" content={pageDescription} />
      </Head>
      <div className="container page-content">
        <h1 className="title mb-6">{contract} Collection</h1>
        {loading ? (
          <LoadingIndicator
            status={`Loading ${contract} data... ${progress ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''}`}
            progress={progress}
          />
        ) : error ? (
          <p className="text-error">{error}</p>
        ) : (
          <NFTPageWrapper
            chain={chain}
            contract={apiKey}
            data={data}
            rewardToken={config.contractDetails[apiKey]?.rewardToken}
          />
        )}
      </div>
    </>
  );
}-e 
---
File: ./app/global.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base Styles */
html {
  @apply scroll-smooth;
}

body {
  @apply min-h-screen flex flex-col bg-gray-900 text-gray-100 antialiased;
}

/* Component Classes */
@layer components {
  /* Layout */
  .container {
    @apply mx-auto max-w-7xl px-4 sm:px-6 lg:px-8;
  }

  .page-content {
    @apply py-8;
  }

  /* Cards */
  .card {
    @apply rounded-lg shadow-lg p-6 bg-gray-800 border border-gray-700;
  }

  /* Buttons */
  .btn {
    @apply inline-flex items-center px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }

  .btn-primary {
    @apply bg-blue-500 text-white hover:bg-blue-600;
  }

  .btn-secondary {
    @apply bg-gray-700 text-gray-100 hover:bg-gray-600;
  }

  /* Typography */
  .title {
    @apply text-3xl font-bold tracking-tight text-gray-100;
  }

  .subtitle {
    @apply text-2xl font-semibold text-gray-100;
  }

  .text-body {
    @apply text-sm sm:text-base text-gray-300;
  }

  .text-error {
    @apply text-red-400;
  }

  /* Tables */
  .table-container {
    @apply overflow-x-auto w-full rounded-lg shadow-lg animate-fade-in;
  }

  .table {
    @apply w-full table-auto md:table-fixed bg-gray-800 text-gray-100;
  }

  .table-head {
    @apply bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base text-white;
  }

  .table-body {
    @apply text-xs md:text-sm text-gray-300;
  }

  .table-row {
    @apply transition-colors border-b border-gray-700;
  }

  .table-row-even {
    @apply bg-gray-800;
  }

  .table-row-odd {
    @apply bg-gray-900;
  }

  .table-row:hover {
    @apply bg-blue-900/30 shadow-sm;
  }

  .table-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold;
  }

  .table-link {
    @apply text-blue-400 hover:text-blue-300 hover:underline break-all;
  }

  .table-pulse {
    @apply animate-pulse;
  }

  .table-pulse-placeholder {
    @apply h-4 bg-gray-600 rounded w-3/4;
  }

  /* Reward Columns (for Element369.js) */
  .reward-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold text-blue-400;
  }

  /* Chart Container */
  .chart-container {
    @apply bg-gray-800 p-4 rounded-lg;
  }

  /* Loading Indicator */
  .loading-container {
    @apply flex flex-col items-center justify-center gap-3 w-full flex-1;
  }

  .spinner {
    @apply h-6 w-6 sm:h-8 sm:w-8 text-blue-400;
  }

  .progress-bar {
    @apply w-64 bg-gray-700 rounded-full h-2.5 mt-2;
  }

  .progress-fill {
    @apply bg-blue-400 h-2.5 rounded-full;
  }

  /* Navbar */
  .nav {
    @apply bg-gray-900 text-gray-100 sticky top-0 z-50 shadow-lg;
  }

  .nav-container {
    @apply container py-4 flex justify-between items-center;
  }

  .nav-logo {
    @apply text-2xl font-bold;
  }

  .nav-link {
    @apply text-gray-300 hover:text-blue-400 transition-colors duration-200;
  }

  .nav-dropdown {
    @apply absolute left-0 mt-2 w-56 bg-gray-800 rounded-lg shadow-xl;
  }

  .nav-dropdown-item {
    @apply block px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md transition-colors;
  }

  .nav-toggle {
    @apply p-2 rounded-full bg-gray-700 text-gray-100 hover:bg-gray-600 transition-colors;
  }

  /* Footer */
  .footer {
    @apply bg-gray-800 py-4 text-center text-gray-400;
  }

  /* Search Input */
  .search-input {
    @apply w-full p-2 bg-gray-700 text-gray-100 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500;
  }

  /* Modal Overlay */
  .modal-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4;
  }

  /* Animations */
  .animate-fade-in {
    animation: fade-in 0.3s ease-out;
  }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Utility Classes */
@layer utilities {
  .grid-responsive {
    @apply grid grid-cols-1 sm:grid-cols-2 gap-4;
  }

  .space-y-section {
    @apply space-y-6;
  }

  .text-center-section {
    @apply text-center py-12;
  }
}-e 
---
File: ./app/store.js
import { getCache, setCache } from '@/app/api/utils/index.js';

export const useNFTStore = create((set, get) => ({
  cache: {},
  getCache: async (key) => {
    const cacheData = await getCache(key, 'global');
    return cacheData;
  },
  setCache: async (key, value) => {
    await setCache(key, value, 0, 'global');
    set(state => ({
      cache: { ...state.cache, [key]: value },
    }));
  },
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          May add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/lib/schemas.js
export const HoldersResponseSchema = {
    safeParse: data => ({
      success: true,
      data,
    }),
  };-e 
---
File: ./app/api/init/route.js
// File: app/api/init/route.js
import { NextResponse } from 'next/server';
import { logger } from '@/lib/logger';
import { initializeCache } from '@/app/api/utils';
import chalk from 'chalk';

console.log(chalk.cyan('[Init Route] Importing logger and utils'));
logger.info('init', 'Init route module loaded', 'eth', 'general').catch(console.error);

export async function GET() {
  await logger.info('init', 'Init endpoint called', 'eth', 'general');
  await initializeCache();
  return NextResponse.json({
    message: 'Initialization triggered',
    debug: process.env.DEBUG,
    nodeEnv: process.env.NODE_ENV,
  });
}-e 
---
File: ./app/api/init/_init.js
// File: app/api/_init.js
import '../utils/serverInit';-e 
---
File: ./app/api/holders/Element280/validate-burned/route.js
// app/api/holders/Element280/validate-burned/route.js
import { NextResponse } from 'next/server';
import config from '@/config';
import { client, logger, getCache, setCache } from '@/app/api/utils';
import { parseAbiItem } from 'viem';

export async function POST(request) {
  if (process.env.DEBUG === 'true') {
    logger.debug('element280-validate-burned', 'Processing POST request for validate-burned', 'eth', 'element280');
  }

  try {
    const { transactionHash } = await request.json();
    if (!transactionHash || typeof transactionHash !== 'string' || !transactionHash.match(/^0x[a-fA-F0-9]{64}$/)) {
      logger.warn('element280-validate-burned', `Invalid transaction hash: ${transactionHash || 'undefined'}`, 'eth', 'element280');
      return NextResponse.json({ error: 'Invalid transaction hash' }, { status: 400 });
    }

    const contractAddress = config.nftContracts?.element280?.address;
    if (!contractAddress) {
      logger.error('element280-validate-burned', 'Element280 contract address not configured', {}, 'eth', 'element280');
      return NextResponse.json({ error: 'Contract address not configured' }, { status: 500 });
    }

    const cacheKey = `element280_burn_validation_${transactionHash}`;
    const cachedResult = await getCache(cacheKey, 'element280');
    if (cachedResult) {
      if (process.env.DEBUG === 'true') {
        logger.debug('element280-validate-burned', `Cache hit for burn validation: ${transactionHash}`, 'eth', 'element280');
      }
      return NextResponse.json(cachedResult);
    }

    if (process.env.DEBUG === 'true') {
      logger.debug('element280-validate-burned', `Fetching transaction receipt for hash: ${transactionHash}`, 'eth', 'element280');
    }
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    if (!receipt) {
      logger.warn('element280-validate-burned', `Transaction receipt not found for hash: ${transactionHash}`, 'eth', 'element280');
      return NextResponse.json({ error: 'Transaction not found' }, { status: 404 });
    }

    const burnAddress = config.burnAddress;
    const transferEvent = parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)');
    const burnedTokenIds = [];

    for (const logEntry of receipt.logs) {
      if (
        logEntry.address.toLowerCase() === contractAddress.toLowerCase() &&
        logEntry.topics[0] === transferEvent.topics[0]
      ) {
        try {
          const decodedLog = client.decodeEventLog({
            abi: [transferEvent],
            data: logEntry.data,
            topics: logEntry.topics,
          });
          if (decodedLog.args.to.toLowerCase() === burnAddress) {
            burnedTokenIds.push(decodedLog.args.tokenId.toString());
          }
        } catch (decodeError) {
          logger.error('element280-validate-burned', `Failed to decode log entry for transaction ${transactionHash}: ${decodeError.message}`, { stack: decodeError.stack }, 'eth', 'element280');
        }
      }
    }

    if (burnedTokenIds.length === 0) {
      logger.warn('element280-validate-burned', `No burn events found in transaction: ${transactionHash}`, 'eth', 'element280');
      return NextResponse.json({ error: 'No burn events found in transaction' }, { status: 400 });
    }

    const result = {
      transactionHash,
      burnedTokenIds,
      blockNumber: receipt.blockNumber.toString(),
    };

    await setCache(cacheKey, result, config.cache.nodeCache.stdTTL, 'element280');
    if (process.env.DEBUG === 'true') {
      logger.debug('element280-validate-burned', `Found ${burnedTokenIds.length} burned tokens in transaction: ${transactionHash}`, 'eth', 'element280');
    }
    return NextResponse.json(result);
  } catch (error) {
    logger.error('element280-validate-burned', `Error processing transaction: ${error.message}`, { stack: error.stack }, 'eth', 'element280');
    return NextResponse.json({ error: 'Failed to validate transaction', details: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/[contract]/route.js
import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits, getAddress } from 'viem';
import pLimit from 'p-limit';
import config from '@/config.js';
import {
  client,
  retry,
  logger,
  getCache,
  setCache,
  saveCacheState,
  loadCacheState,
  batchMulticall,
  getOwnersForContract,
  getHoldersMap,
} from '@/app/api/utils';
import { HoldersResponseSchema } from '@/lib/schemas';
import { initServer } from '@/app/api/utils/serverInit.js';

let isInitialized = false;

const limit = pLimit(5);

// Utility to sanitize BigInt values
function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') return obj.toString();
  if (Array.isArray(obj)) return obj.map(item => sanitizeBigInt(item));
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}

// Get cache state for a contract
async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    totalLiveHolders: 0,
    progressState: {
      step: 'idle',
      processedNfts: 0,
      totalNfts: 0,
      processedTiers: 0,
      totalTiers: 0,
      error: null,
      errorLog: [],
    },
    lastUpdated: null,
    lastProcessedBlock: null,
    globalMetrics: {},
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      Object.assign(cacheState, {
        isPopulating: savedState.isPopulating ?? false,
        totalOwners: savedState.totalOwners ?? 0,
        totalLiveHolders: savedState.totalLiveHolders ?? 0,
        progressState: {
          step: savedState.progressState?.step ?? 'idle',
          processedNfts: savedState.progressState?.processedNfts ?? 0,
          totalNfts: savedState.progressState?.totalNfts ?? 0,
          processedTiers: savedState.progressState?.processedTiers ?? 0,
          totalTiers: savedState.progressState?.totalTiers ?? 0,
          error: savedState.progressState?.error ?? null,
          errorLog: savedState.progressState?.errorLog ?? [],
        },
        lastUpdated: savedState.lastUpdated ?? null,
        lastProcessedBlock: savedState.lastProcessedBlock ?? null,
        globalMetrics: savedState.globalMetrics ?? {},
      });
      logger.debug(
        'route',
        `Loaded cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`,
        'eth',
        contractKey
      );
    }
  } catch (error) {
    logger.error(
      'route',
      `Failed to load cache state: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
  }
  return cacheState;
}

// Save cache state for a contract
async function saveCacheStateContract(contractKey, cacheState) {
  try {
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
    logger.debug(
      'route',
      `Saved cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`,
      'eth',
      contractKey
    );
  } catch (error) {
    logger.error(
      'route',
      `Failed to save cache state: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
  }
}

// Fetch new Transfer events (burns and transfers)
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) {
  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const cacheKey = `${contractKey.toLowerCase()}_events_${contractAddress}_${fromBlock}`;
  let cachedEvents = await getCache(cacheKey, contractKey.toLowerCase());

  if (cachedEvents) {
    logger.info(
      'route',
      `Events cache hit: ${cacheKey}, count: ${cachedEvents.burnedTokenIds.length + (cachedEvents.transferTokenIds?.length || 0)}`,
      'eth',
      contractKey
    );
    return cachedEvents;
  }

  let burnedTokenIds = [];
  let transferTokenIds = [];
  let endBlock;
  try {
    endBlock = await client.getBlockNumber();
  } catch (error) {
    logger.error(
      'route',
      `Failed to fetch block number: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    errorLog.push({
      timestamp: new Date().toISOString(),
      phase: 'fetch_block_number',
      error: error.message,
    });
    throw error;
  }

  if (fromBlock >= endBlock) {
    logger.info(
      'route',
      `No new blocks: fromBlock ${fromBlock} >= endBlock ${endBlock}`,
      'eth',
      contractKey
    );
    return { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock) };
  }

  try {
    const logs = await client.getLogs({
      address: contractAddress,
      event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
      fromBlock: BigInt(fromBlock),
      toBlock: endBlock,
    });
    burnedTokenIds = logs
      .filter(log => log.args.to.toLowerCase() === burnAddress.toLowerCase())
      .map(log => Number(log.args.tokenId));
    transferTokenIds = logs
      .filter(log => log.args.to.toLowerCase() !== burnAddress.toLowerCase())
      .map(log => ({
        tokenId: Number(log.args.tokenId),
        from: log.args.from.toLowerCase(),
        to: log.args.to.toLowerCase(),
      }));
    const cacheData = {
      burnedTokenIds,
      transferTokenIds,
      lastBlock: Number(endBlock),
      timestamp: Date.now(),
    };
    await setCache(cacheKey, cacheData, config.cache.nodeCache.stdTTL, contractKey.toLowerCase());
    logger.info(
      'route',
      `Cached events: ${cacheKey}, burns: ${burnedTokenIds.length}, transfers: ${transferTokenIds.length}`,
      'eth',
      contractKey
    );
    return cacheData;
  } catch (error) {
    logger.error(
      'route',
      `Failed to fetch events: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    errorLog.push({
      timestamp: new Date().toISOString(),
      phase: 'fetch_events',
      error: error.message,
    });
    throw error;
  }
}

// Populate holders map cache
async function populateHoldersMapCache(
  contractKey,
  contractAddress,
  abi,
  vaultAddress,
  vaultAbi,
  forceUpdate = false,
  addressFilter = null
) {
  let cacheState = await getCacheState(contractKey);
  if (cacheState.isPopulating && !forceUpdate) {
    logger.info('route', 'Cache population already in progress', 'eth', contractKey);
    return { status: 'in_progress', holders: null };
  }

  cacheState.isPopulating = true;
  cacheState.progressState.step = 'starting';
  cacheState.progressState.error = null;
  cacheState.progressState.errorLog = [];
  await saveCacheStateContract(contractKey, cacheState);

  const errorLog = [];

  try {
    const cachedData = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
    const isCacheValid =
      cachedData &&
      Array.isArray(cachedData.holders) &&
      Number.isInteger(cachedData.totalBurned) &&
      !forceUpdate &&
      !addressFilter;

    if (isCacheValid) {
      const fromBlock = cacheState.lastProcessedBlock || config.deploymentBlocks[contractKey].block;
      const { burnedTokenIds, transferTokenIds, lastBlock } = await getNewEvents(
        contractKey,
        contractAddress,
        fromBlock,
        errorLog
      );

      let currentBlock;
      try {
        currentBlock = await client.getBlockNumber();
      } catch (error) {
        errorLog.push({
          timestamp: new Date().toISOString(),
          phase: 'fetch_block_number',
          error: error.message,
        });
        throw error;
      }

      if (burnedTokenIds.length > 0 || transferTokenIds.length > 0) {
        const holdersMap = new Map();
        let totalBurned = cachedData.totalBurned || 0;
        logger.debug('route', `Initial totalBurned from cache: ${totalBurned}`, 'eth', contractKey);

        for (const holder of cachedData.holders) {
          const updatedTokenIds = holder.tokenIds.filter(id => !burnedTokenIds.includes(id));
          if (updatedTokenIds.length > 0) {
            const updatedHolder = {
              ...holder,
              tokenIds: updatedTokenIds,
              total: updatedTokenIds.length,
              tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
              multiplierSum: 0,
              ...(contractKey === 'element369'
                ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 }
                : {}),
              ...(contractKey === 'element280' || contractKey === 'stax'
                ? { claimableRewards: 0 }
                : {}),
              ...(contractKey === 'ascendant'
                ? {
                    shares: 0,
                    lockedAscendant: 0,
                    pendingDay8: 0,
                    pendingDay28: 0,
                    pendingDay90: 0,
                    claimableRewards: 0,
                  }
                : {}),
            };
            const tierCalls = updatedTokenIds.map(tokenId => ({
              address: contractAddress,
              abi,
              functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
              args: [BigInt(tokenId)],
            }));
            const tierResults = await retry(
              () => batchMulticall(tierCalls, config.alchemy.batchSize),
              {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              }
            );
            tierResults.forEach((result, index) => {
              if (result.status === 'success' && result.result) {
                const tier =
                  contractKey === 'ascendant'
                    ? Number(result.result.tier || 0)
                    : Number(result.result);
                const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                if (tier >= 1 && tier <= maxTier) {
                  updatedHolder.tiers[tier - 1]++;
                  updatedHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                  logger.debug(
                    'route',
                    `Tier ${tier} for token ${updatedTokenIds[index]} assigned to wallet ${holder.wallet}`,
                    'eth',
                    contractKey
                  );
                } else {
                  logger.warn(
                    'route',
                    `Invalid tier ${tier} for token ${updatedTokenIds[index]}, wallet ${holder.wallet}`,
                    'eth',
                    contractKey
                  );
                  errorLog.push({
                    timestamp: new Date().toISOString(),
                    phase: 'fetch_tier',
                    tokenId: updatedTokenIds[index],
                    error: `Invalid tier ${tier}`,
                  });
                }
              } else {
                logger.warn(
                  'route',
                  `Failed to fetch tier for token ${updatedTokenIds[index]}: ${result.error || 'unknown error'}`,
                  'eth',
                  contractKey
                );
                errorLog.push({
                  timestamp: new Date().toISOString(),
                  phase: 'fetch_tier',
                  tokenId: updatedTokenIds[index],
                  error: result.error || 'unknown error',
                });
              }
            });

            if (contractKey === 'ascendant') {
              const recordCalls = updatedTokenIds.map(tokenId => ({
                address: contractAddress,
                abi,
                functionName: 'userRecords',
                args: [BigInt(tokenId)],
              }));
              const recordResults = await retry(
                () => batchMulticall(recordCalls, config.alchemy.batchSize),
                {
                  retries: config.alchemy.maxRetries,
                  delay: config.alchemy.batchDelayMs,
                }
              );
              recordResults.forEach((result, index) => {
                if (result.status === 'success' && Array.isArray(result.result)) {
                  updatedHolder.shares += parseFloat(formatUnits(result.result[0] || 0, 18));
                  updatedHolder.lockedAscendant += parseFloat(
                    formatUnits(result.result[1] || 0, 18)
                  );
                  logger.debug(
                    'route',
                    `userRecords for token ${updatedTokenIds[index]}: shares=${updatedHolder.shares}, lockedAscendant=${updatedHolder.lockedAscendant}`,
                    'eth',
                    contractKey
                  );
                } else {
                  logger.error(
                    'route',
                    `Failed to fetch userRecords for token ${updatedTokenIds[index]}: ${result.error || 'unknown error'}`,
                    'eth',
                    contractKey
                  );
                  errorLog.push({
                    timestamp: new Date().toISOString(),
                    phase: 'fetch_records',
                    tokenId: updatedTokenIds[index],
                    error: result.error || 'unknown error',
                  });
                }
              });

              const claimableCall = [
                {
                  address: contractAddress,
                  abi,
                  functionName: 'batchClaimableAmount',
                  args: [updatedTokenIds.map(id => BigInt(id))],
                },
              ];
              const claimableResults = await retry(
                () => batchMulticall(claimableCall, config.alchemy.batchSize),
                {
                  retries: config.alchemy.maxRetries,
                  delay: config.alchemy.batchDelayMs,
                }
              );
              if (claimableResults[0]?.status === 'success') {
                updatedHolder.claimableRewards = parseFloat(
                  formatUnits(claimableResults[0].result || 0, 18)
                );
                logger.debug(
                  'route',
                  `Claimable rewards for wallet ${holder.wallet}: ${updatedHolder.claimableRewards}`,
                  'eth',
                  contractKey
                );
              } else {
                logger.error(
                  'route',
                  `Failed to fetch claimableRewards for wallet ${holder.wallet}: ${claimableResults[0]?.error || 'unknown error'}`,
                  'eth',
                  contractKey
                );
                errorLog.push({
                  timestamp: new Date().toISOString(),
                  phase: 'fetch_claimable',
                  wallet: holder.wallet,
                  error: claimableResults[0]?.error || 'unknown error',
                });
              }

              const totalSharesRaw = await retry(
                async () => {
                  const result = await client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: 'totalShares',
                  });
                  if (result === null || result === undefined)
                    throw new Error('totalShares returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

              const toDistributeDay8Raw = await retry(
                async () => {
                  const result = await client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: 'toDistribute',
                    args: [0],
                  });
                  if (result === null || result === undefined)
                    throw new Error('toDistribute day8 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

              const toDistributeDay28Raw = await retry(
                async () => {
                  const result = await client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: 'toDistribute',
                    args: [1],
                  });
                  if (result === null || result === undefined)
                    throw new Error('toDistribute day28 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

              const toDistributeDay90Raw = await retry(
                async () => {
                  const result = await client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: 'toDistribute',
                    args: [2],
                  });
                  if (result === null || result === undefined)
                    throw new Error('toDistribute day90 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

              const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
              const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
              const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

              updatedHolder.pendingDay8 = updatedHolder.shares * pendingRewardPerShareDay8;
              updatedHolder.pendingDay28 = updatedHolder.shares * pendingRewardPerShareDay28;
              updatedHolder.pendingDay90 = updatedHolder.shares * pendingRewardPerShareDay90;
            }

            holdersMap.set(holder.wallet, updatedHolder);
          } else {
            totalBurned += holder.total;
            logger.debug(
              'route',
              `Incremented totalBurned by ${holder.total} for wallet ${holder.wallet}`,
              'eth',
              contractKey
            );
          }
        }

        for (const transfer of transferTokenIds) {
          const fromHolder = holdersMap.get(transfer.from);
          if (fromHolder) {
            fromHolder.tokenIds = fromHolder.tokenIds.filter(id => id !== transfer.tokenId);
            fromHolder.total = fromHolder.tokenIds.length;
            if (fromHolder.total === 0) {
              holdersMap.delete(transfer.from);
              logger.debug('route', `Removed empty holder: ${transfer.from}`, 'eth', contractKey);
            } else {
              fromHolder.tiers = Array(Object.keys(config.contractTiers[contractKey]).length).fill(0);
              fromHolder.multiplierSum = 0;
              const tierResult = await retry(
                () =>
                  client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
                    args: [BigInt(transfer.tokenId)],
                  }),
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const tier =
                contractKey === 'ascendant'
                  ? Number(tierResult.tier || 0)
                  : Number(tierResult);
              if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
                fromHolder.tiers[tier - 1]++;
                fromHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                logger.debug(
                  'route',
                  `Tier ${tier} for token ${transfer.tokenId} updated for wallet ${transfer.from}`,
                  'eth',
                  contractKey
                );
              }
              if (contractKey === 'ascendant') {
                fromHolder.shares = 0;
                fromHolder.lockedAscendant = 0;
                fromHolder.pendingDay8 = 0;
                fromHolder.pendingDay28 = 0;
                fromHolder.pendingDay90 = 0;
                fromHolder.claimableRewards = 0;

                const recordResult = await retry(
                  () =>
                    client.readContract({
                      address: contractAddress,
                      abi,
                      functionName: 'userRecords',
                      args: [BigInt(transfer.tokenId)],
                    }),
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                if (Array.isArray(recordResult)) {
                  fromHolder.shares += parseFloat(formatUnits(recordResult[0] || 0, 18));
                  fromHolder.lockedAscendant += parseFloat(
                    formatUnits(recordResult[1] || 0, 18)
                  );
                  logger.debug(
                    'route',
                    `userRecords for token ${transfer.tokenId}: shares=${fromHolder.shares}, lockedAscendant=${fromHolder.lockedAscendant}`,
                    'eth',
                    contractKey
                  );
                }

                const claimableCall = [
                  {
                    address: contractAddress,
                    abi,
                    functionName: 'batchClaimableAmount',
                    args: [fromHolder.tokenIds.map(id => BigInt(id))],
                  },
                ];
                const claimableResults = await retry(
                  () => batchMulticall(claimableCall, config.alchemy.batchSize),
                  {
                    retries: config.alchemy.maxRetries,
                    delay: config.alchemy.batchDelayMs,
                  }
                );
                if (claimableResults[0]?.status === 'success') {
                  fromHolder.claimableRewards = parseFloat(
                    formatUnits(claimableResults[0].result || 0, 18)
                  );
                  logger.debug(
                    'route',
                    `Claimable rewards for wallet ${transfer.from}: ${fromHolder.claimableRewards}`,
                    'eth',
                    contractKey
                  );
                }

                const totalSharesRaw = await retry(
                  async () => {
                    const result = await client.readContract({
                      address: contractAddress,
                      abi,
                      functionName: 'totalShares',
                    });
                    if (result === null || result === undefined)
                      throw new Error('totalShares returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

                const toDistributeDay8Raw = await retry(
                  async () => {
                    const result = await client.readContract({
                      address: contractAddress,
                      abi,
                      functionName: 'toDistribute',
                      args: [0],
                    });
                    if (result === null || result === undefined)
                      throw new Error('toDistribute day8 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

                const toDistributeDay28Raw = await retry(
                  async () => {
                    const result = await client.readContract({
                      address: contractAddress,
                      abi,
                      functionName: 'toDistribute',
                      args: [1],
                    });
                    if (result === null || result === undefined)
                      throw new Error('toDistribute day28 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

                const toDistributeDay90Raw = await retry(
                  async () => {
                    const result = await client.readContract({
                      address: contractAddress,
                      abi,
                      functionName: 'toDistribute',
                      args: [2],
                    });
                    if (result === null || result === undefined)
                      throw new Error('toDistribute day90 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

                const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
                const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
                const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

                fromHolder.pendingDay8 = fromHolder.shares * pendingRewardPerShareDay8;
                fromHolder.pendingDay28 = fromHolder.shares * pendingRewardPerShareDay28;
                fromHolder.pendingDay90 = fromHolder.shares * pendingRewardPerShareDay90;
              }
              holdersMap.set(transfer.from, fromHolder);
            }
          }

          const toHolder =
            holdersMap.get(transfer.to) ||
            {
              wallet: transfer.to,
              tokenIds: [],
              tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
              total: 0,
              multiplierSum: 0,
              ...(contractKey === 'element369'
                ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 }
                : {}),
              ...(contractKey === 'element280' || contractKey === 'stax'
                ? { claimableRewards: 0 }
                : {}),
              ...(contractKey === 'ascendant'
                ? {
                    shares: 0,
                    lockedAscendant: 0,
                    pendingDay8: 0,
                    pendingDay28: 0,
                    pendingDay90: 0,
                    claimableRewards: 0,
                  }
                : {}),
            };
          toHolder.tokenIds.push(transfer.tokenId);
          toHolder.total = toHolder.tokenIds.length;
          const tierResult = await retry(
            () =>
              client.readContract({
                address: contractAddress,
                abi,
                functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
                args: [BigInt(transfer.tokenId)],
              }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const tier =
            contractKey === 'ascendant' ? Number(tierResult.tier || 0) : Number(tierResult);
          if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
            toHolder.tiers[tier - 1]++;
            toHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
            logger.debug(
              'route',
              `Tier ${tier} for token ${transfer.tokenId} assigned to wallet ${transfer.to}`,
              'eth',
              contractKey
            );
          }
          if (contractKey === 'ascendant') {
            const recordResult = await retry(
              () =>
                client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'userRecords',
                  args: [BigInt(transfer.tokenId)],
                }),
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            if (Array.isArray(recordResult)) {
              toHolder.shares += parseFloat(formatUnits(recordResult[0] || 0, 18));
              toHolder.lockedAscendant += parseFloat(formatUnits(recordResult[1] || 0, 18));
              logger.debug(
                'route',
                `userRecords for token ${transfer.tokenId}: shares=${toHolder.shares}, lockedAscendant=${toHolder.lockedAscendant}`,
                'eth',
                contractKey
              );
            }

            const claimableCall = [
              {
                address: contractAddress,
                abi,
                functionName: 'batchClaimableAmount',
                args: [toHolder.tokenIds.map(id => BigInt(id))],
              },
            ];
            const claimableResults = await retry(
              () => batchMulticall(claimableCall, config.alchemy.batchSize),
              {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              }
            );
            if (claimableResults[0]?.status === 'success') {
              toHolder.claimableRewards = parseFloat(
                formatUnits(claimableResults[0].result || 0, 18)
              );
              logger.debug(
                'route',
                `Claimable rewards for wallet ${transfer.to}: ${toHolder.claimableRewards}`,
                'eth',
                contractKey
              );
            }

            const totalSharesRaw = await retry(
              async () => {
                const result = await client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'totalShares',
                });
                if (result === null || result === undefined)
                  throw new Error('totalShares returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

            const toDistributeDay8Raw = await retry(
              async () => {
                const result = await client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'toDistribute',
                  args: [0],
                });
                if (result === null || result === undefined)
                  throw new Error('toDistribute day8 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

            const toDistributeDay28Raw = await retry(
              async () => {
                const result = await client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'toDistribute',
                  args: [1],
                });
                if (result === null || result === undefined)
                  throw new Error('toDistribute day28 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

            const toDistributeDay90Raw = await retry(
              async () => {
                const result = await client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: 'toDistribute',
                  args: [2],
                });
                if (result === null || result === undefined)
                  throw new Error('toDistribute day90 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

            const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
            const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
            const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

            toHolder.pendingDay8 = toHolder.shares * pendingRewardPerShareDay8;
            toHolder.pendingDay28 = toHolder.shares * pendingRewardPerShareDay28;
            toHolder.pendingDay90 = toHolder.shares * pendingRewardPerShareDay90;
          }
          holdersMap.set(transfer.to, toHolder);
        }

        const holderList = Array.from(holdersMap.values());
        const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
        holderList.forEach(holder => {
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
          logger.debug(
            'route',
            `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, displayMultiplierSum=${holder.displayMultiplierSum}`,
            'eth',
            contractKey
          );
        });

        holderList.sort((a, b) =>
          contractKey === 'ascendant'
            ? b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total
            : b.multiplierSum - a.multiplierSum || b.total - a.total
        );
        holderList.forEach((holder, index) => (holder.rank = index + 1));

        let burnedCountContract;
        try {
          burnedCountContract = await retry(
            async () => {
              const result = await client.readContract({
                address: contractAddress,
                abi,
                functionName: 'totalBurned',
              });
              return Number(result);
            },
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          logger.debug(
            'route',
            `Fetched burnedCountContract: ${burnedCountContract}`,
            'eth',
            contractKey
          );
        } catch (error) {
          logger.error(
            'route',
            `Failed to fetch totalBurned: ${error.message}`,
            { stack: error.stack },
            'eth',
            contractKey
          );
          burnedCountContract = 0;
        }
        totalBurned = burnedCountContract || totalBurned;
        logger.debug('route', `Final totalBurned: ${totalBurned}`, 'eth', contractKey);

        const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
        await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
        cacheState.lastUpdated = Date.now();
        cacheState.totalOwners = holderList.length;
        cacheState.totalLiveHolders = holderList.length;
        cacheState.lastProcessedBlock = lastBlock;
        cacheState.progressState = {
          step: 'completed',
          processedNfts: cacheState.progressState.totalNfts,
          totalNfts: cacheState.progressState.totalNfts,
          processedTiers: cacheState.progressState.totalTiers,
          totalTiers: cacheState.progressState.totalTiers,
          error: null,
          errorLog,
        };
        if (contractKey === 'ascendant') {
          cacheState.globalMetrics = {
            totalTokens: holderList.reduce((sum, h) => sum + h.total, 0),
            totalLockedAscendant: holderList.reduce((sum, h) => sum + h.lockedAscendant, 0),
            totalShares,
            toDistributeDay8,
            toDistributeDay28,
            toDistributeDay90,
            pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
          };
        }
        await saveCacheStateContract(contractKey, cacheState);
        logger.info(
          'route',
          `Cache updated: ${holderList.length} holders, totalBurned: ${totalBurned}`,
          'eth',
          contractKey
        );
        return { status: 'updated', holders: holderList };
      } else {
        cacheState.isPopulating = false;
        cacheState.progressState.step = 'completed';
        cacheState.lastProcessedBlock = Number(currentBlock);
        await saveCacheStateContract(contractKey, cacheState);
        logger.info('route', 'Cache is up to date', 'eth', contractKey);
        return { status: 'up_to_date', holders: cachedData.holders };
      }
    }

    const result = await getHoldersMap(
      contractKey,
      contractAddress,
      abi,
      vaultAddress,
      vaultAbi,
      cacheState,
      addressFilter
    );
    const holderList = Array.from(result.holdersMap.values());
    const totalBurned = result.totalBurned || 0;
    logger.debug('route', `getHoldersMap returned totalBurned: ${totalBurned}`, 'eth', contractKey);
    const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
    await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
    cacheState.lastUpdated = Date.now();
    cacheState.totalOwners = holderList.length;
    cacheState.totalLiveHolders = holderList.length;
    cacheState.lastProcessedBlock = result.lastBlock;
    cacheState.progressState = {
      step: 'completed',
      processedNfts: cacheState.progressState.totalNfts,
      totalNfts: cacheState.progressState.totalNfts,
      processedTiers: cacheState.progressState.totalTiers,
      totalTiers: cacheState.progressState.totalTiers,
      error: null,
      errorLog: result.errorLog || [],
    };
    if (contractKey === 'ascendant') {
      cacheState.globalMetrics = cacheState.globalMetrics || {};
    }
    await saveCacheStateContract(contractKey, cacheState);
    logger.info(
      'route',
      `Cache populated: ${holderList.length} holders, totalBurned: ${totalBurned}`,
      'eth',
      contractKey
    );
    return { status: 'populated', holders: holderList };
  } catch (error) {
    cacheState.isPopulating = false;
    cacheState.progressState.error = error.message;
    cacheState.progressState.errorLog.push({
      timestamp: new Date().toISOString(),
      error: error.message,
    });
    await saveCacheStateContract(contractKey, cacheState);
    logger.error(
      'route',
      `Failed to populate cache: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    throw error;
  }
}

// GET endpoint
export async function GET(request, { params }) {
  if (!isInitialized) {
    await initServer();
    isInitialized = true;
  }
  const contractKey = params.contract.toLowerCase();
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page')) || 1;
  const pageSize = parseInt(searchParams.get('pageSize')) || config.contractDetails[contractKey]?.pageSize || 10;
  const address = searchParams.get('address');

  if (!config.nftContracts[contractKey]) {
    logger.error('route', `Invalid contract: ${contractKey}`, {}, 'eth', contractKey);
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  const { address: contractAddress, vaultAddress, disabled } = config.nftContracts[contractKey];
  const abi = config.abis[contractKey]?.main || [];
  const vaultAbi = config.abis[contractKey]?.vault || [];

  if (disabled) {
    logger.warn('route', `Contract ${contractKey} is disabled`, {}, 'eth', contractKey);
    return NextResponse.json({ error: `Contract ${contractKey} is disabled` }, { status: 403 });
  }

  if (!contractAddress || !abi) {
    logger.error(
      'route',
      `Configuration missing for ${contractKey}: address=${contractAddress}, abi=${!!abi}`,
      {},
      'eth',
      contractKey
    );
    return NextResponse.json({ error: `Configuration missing for ${contractKey}` }, { status: 400 });
  }

  try {
    const cacheState = await getCacheState(contractKey);
    const { status, holders } = await limit(() =>
      populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, false, address)
    );

    if (!holders) {
      logger.info('route', `Returning in-progress response for ${contractKey}`, 'eth', contractKey);
      return NextResponse.json(
        { status: 'in_progress', cacheState: sanitizeBigInt(cacheState) },
        { status: 202 }
      );
    }

    const totalItems = address ? holders.length : cacheState.totalOwners;
    const totalPages = Math.ceil(totalItems / pageSize);
    const start = address ? 0 : (page - 1) * pageSize;
    const paginatedHolders = address ? holders : holders.slice(start, start + pageSize);

    const response = {
      holders: paginatedHolders,
      totalItems,
      totalPages,
      currentPage: page,
      pageSize,
      totalBurned:
        (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalBurned || 0,
      totalTokens: cacheState.progressState.totalNfts || 0,
      totalShares: contractKey === 'ascendant' ? cacheState.globalMetrics.totalShares || 0 : undefined,
      pendingRewards: contractKey === 'ascendant' ? cacheState.globalMetrics.pendingRewards || 0 : undefined,
      status,
      cacheState: sanitizeBigInt(cacheState),
    };

    const parsed = HoldersResponseSchema.safeParse(response);
    if (!parsed.success) {
      logger.error(
        'route',
        `Response validation failed: ${JSON.stringify(parsed.error)}`,
        { errors: parsed.error },
        'eth',
        contractKey
      );
      return NextResponse.json(
        { error: 'Invalid response format', details: parsed.error },
        { status: 500 }
      );
    }

    logger.info(
      'route',
      `Returning ${paginatedHolders.length} holders for ${contractKey}, page ${page}`,
      'eth',
      contractKey
    );
    return NextResponse.json(parsed.data);
  } catch (error) {
    logger.error(
      'route',
      `GET error: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/[contract]/progress/route.js
import { NextResponse } from 'next/server';
import { logger, loadCacheState } from '@/app/api/utils';
import config from '@/config';

async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.progressState = {
        step: savedState.progressState?.step ?? 'idle',
        processedNfts: savedState.progressState?.processedNfts ?? 0,
        totalNfts: savedState.progressState?.totalNfts ?? 0,
        processedTiers: savedState.progressState?.processedTiers ?? 0,
        totalTiers: savedState.progressState?.totalTiers ?? 0,
        error: savedState.progressState?.error ?? null,
        errorLog: savedState.progressState?.errorLog ?? [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
    }
  } catch (error) {
    logger.error(contractKey, `Failed to load cache state: ${error.message}`, { stack: error.stack });
  }
  return cacheState;
}

export async function GET(_request, { params }) {
  const { contract } = await params; // Await params
  const contractKey = contract.toLowerCase();

  if (!config.contractDetails[contractKey]) {
    logger.error(contractKey, `Invalid contract: ${contractKey}`);
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  try {
    const state = await getCacheState(contractKey);
    if (!state || !state.progressState) {
      logger.error(contractKey, 'Invalid cache state');
      return NextResponse.json({ error: 'Cache state not initialized' }, { status: 500 });
    }

    let progressPercentage = '0.0';
    if (state.progressState.error) {
      progressPercentage = '0.0';
    } else if (state.progressState.step === 'completed') {
      progressPercentage = '100.0';
    } else if (state.progressState.totalNfts > 0) {
      if (state.progressState.step === 'fetching_owners') {
        const ownerProgress = (state.progressState.processedNfts / state.progressState.totalNfts) * 50;
        progressPercentage = Math.min(ownerProgress, 50).toFixed(1);
      } else if (state.progressState.step === 'fetching_tiers') {
        const tierProgress = (state.progressState.processedTiers / state.progressState.totalTiers) * 50;
        progressPercentage = Math.min(50 + tierProgress, 100).toFixed(1);
      }
    }

    return NextResponse.json({
      isPopulating: state.isPopulating,
      totalLiveHolders: state.totalOwners,
      totalOwners: state.totalOwners,
      phase: state.progressState.step.charAt(0).toUpperCase() + state.progressState.step.slice(1),
      progressPercentage,
      lastProcessedBlock: state.lastProcessedBlock,
      error: state.progressState.error || null,
      errorLog: state.progressState.errorLog || [],
    });
  } catch (error) {
    logger.error(contractKey, `Progress endpoint error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to fetch ${contractKey} cache state`, details: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils/cache.js
// app/api/utils/cache.js
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { Redis } from '@upstash/redis';
import config from '@/config';
import { logger } from '@/lib/logger.js';

const cacheDir = path.join(process.cwd(), 'cache');
const isDebug = process.env.DEBUG === 'true';

const cache = new NodeCache({
  stdTTL: config.cache.nodeCache.stdTTL || 3600,
  checkperiod: 120,
});

// Check Redis environment variables
const redisEnabled =
  process.env.UPSTASH_REDIS_REST_URL &&
  process.env.UPSTASH_REDIS_REST_TOKEN &&
  Object.keys(config.nftContracts).some(
    contract => process.env[`DISABLE_${contract.toUpperCase()}_REDIS`] !== 'true'
  );

let redis = null;

async function initializeCache() {
  try {
    logger.info('cache', 'Starting cache initialization', 'eth', 'general');
    if (redisEnabled && !redis) {
      try {
        redis = Redis.fromEnv();
        logger.info('cache', 'Upstash Redis initialized', 'eth', 'general');
      } catch (error) {
        logger.error('cache', `Failed to initialize Upstash Redis: ${error.message}`, { stack: error.stack }, 'eth', 'general');
        redis = null;
      }
    }

    await ensureCacheDir();

    // Test node-cache
    const testKey = 'test_node_cache';
    const testValue = { ready: true };
    const nodeCacheSuccess = cache.set(testKey, testValue);
    if (nodeCacheSuccess) {
      logger.info('cache', 'Node-cache is ready', 'eth', 'general');
      cache.del(testKey);
    } else {
      logger.error('cache', 'Node-cache failed to set test key', {}, 'eth', 'general');
      throw new Error('Node-cache initialization failed');
    }

    // Test Redis
    if (redisEnabled && redis) {
      try {
        await redis.set('test_redis', JSON.stringify(testValue));
        const redisData = await redis.get('test_redis');
        if (redisData && JSON.parse(redisData).ready) {
          logger.info('cache', 'Redis cache is ready', 'eth', 'general');
          await redis.del('test_redis');
        } else {
          logger.warn('cache', 'Redis cache test failed: invalid data', {}, 'eth', 'general');
        }
      } catch (error) {
        logger.warn('cache', `Redis cache test failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      }
    }

    // Initialize cache files
    const collections = Object.keys(config.nftContracts)
      .filter(key => !config.nftContracts[key].disabled)
      .map(key => key.toLowerCase());
    for (const collection of collections) {
      const cacheFile = path.join(cacheDir, `${collection}_holders.json`);
      try {
        await fs.access(cacheFile);
        logger.info('cache', `Cache file exists: ${cacheFile}`, 'eth', collection);
      } catch (error) {
        if (error.code === 'ENOENT') {
          await fs.writeFile(cacheFile, JSON.stringify({ holders: [], totalBurned: 0, timestamp: Date.now() }));
          await fs.chmod(cacheFile, 0o644);
          logger.info('cache', `Created empty cache file: ${cacheFile}`, 'eth', collection);
        } else {
          logger.error('cache', `Failed to access cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', collection);
        }
      }
    }

    logger.info('cache', 'Cache initialization completed', 'eth', 'general');
    return true;
  } catch (error) {
    logger.error('cache', `Cache initialization error: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return false;
  }
}

async function ensureCacheDir() {
  try {
    await fs.mkdir(cacheDir, { recursive: true });
    await fs.chmod(cacheDir, 0o755);
    logger.info('cache', `Created/chmod cache directory: ${cacheDir}`, 'eth', 'general');
  } catch (error) {
    logger.error('cache', `Failed to create/chmod cache directory ${cacheDir}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function setCache(key, value, ttl, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    const nodeCacheSuccess = cache.set(cacheKey, value, ttl || config.cache.nodeCache.stdTTL);
    logger.info('cache', `Set node-cache: ${cacheKey}, success: ${nodeCacheSuccess}, holders: ${value.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());

    if (!nodeCacheSuccess) {
      logger.error('cache', `Failed to set node-cache: ${cacheKey}`, {}, 'eth', prefix.toLowerCase());
      return false;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      const normalizedPrefix = prefix.toLowerCase();
      if (redisEnabled && !redis) {
        try {
          redis = Redis.fromEnv();
          logger.info('cache', 'Reinitialized Upstash Redis in setCache', 'eth', normalizedPrefix);
        } catch (error) {
          logger.error('cache', `Failed to reinitialize Upstash Redis in setCache: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
          redis = null;
        }
      }
      if (redisEnabled && redis && process.env[`DISABLE_${normalizedPrefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          await redis.set(cacheKey, JSON.stringify(value));
          if (ttl > 0) await redis.expire(cacheKey, Math.floor(ttl / 1000)); // Convert ms to seconds
          logger.info('cache', `Persisted ${cacheKey} to Redis, holders: ${value.holders?.length || 'unknown'}`, 'eth', normalizedPrefix);
        } catch (error) {
          logger.error('cache', `Failed to persist ${cacheKey} to Redis: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
          // Continue with node-cache
        }
      }

      const cacheFile = path.join(cacheDir, `${normalizedPrefix}_holders.json`);
      logger.info('cache', `Writing to cache file: ${cacheFile}`, 'eth', normalizedPrefix);
      await ensureCacheDir();
      try {
        await fs.writeFile(cacheFile, JSON.stringify(value));
        await fs.chmod(cacheFile, 0o644);
        logger.info('cache', `Persisted ${cacheKey} to ${cacheFile}, holders: ${value.holders?.length || 'unknown'}`, 'eth', normalizedPrefix);
      } catch (error) {
        logger.error('cache', `Failed to write cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
      }
    }
    return nodeCacheSuccess;
  } catch (error) {
    logger.error('cache', `Failed to set cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return false;
  }
}

async function getCache(key, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    let data = cache.get(cacheKey);
    if (data !== undefined) {
      logger.debug('cache', `Node-cache hit: ${cacheKey}, holders: ${data.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());
      return data;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      const normalizedPrefix = prefix.toLowerCase();
      if (redisEnabled && !redis) {
        try {
          redis = Redis.fromEnv();
          logger.info('cache', 'Reinitialized Upstash Redis in getCache', 'eth', normalizedPrefix);
        } catch (error) {
          logger.error('cache', `Failed to reinitialize Upstash Redis in getCache: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
          redis = null;
        }
      }
      if (redisEnabled && redis && process.env[`DISABLE_${normalizedPrefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          const redisData = await redis.get(cacheKey);
          if (redisData) {
            const parsed = JSON.parse(redisData);
            if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
              const success = cache.set(cacheKey, parsed);
              logger.info('cache', `Loaded ${cacheKey} from Redis, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', normalizedPrefix);
              return parsed;
            } else {
              logger.warn('cache', `Invalid data in Redis for ${cacheKey}`, 'eth', normalizedPrefix);
            }
          }
        } catch (error) {
          logger.error('cache', `Failed to load cache from Redis for ${cacheKey}: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
        }
      }

      const cacheFile = path.join(cacheDir, `${normalizedPrefix}_holders.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        const parsed = JSON.parse(fileData);
        if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
          const success = cache.set(cacheKey, parsed);
          logger.info('cache', `Loaded ${cacheKey} from ${cacheFile}, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', normalizedPrefix);
          return parsed;
        } else {
          logger.warn('cache', `Invalid data in ${cacheFile}`, 'eth', normalizedPrefix);
        }
      } catch (error) {
        if (error.code !== 'ENOENT') {
          logger.error('cache', `Failed to load cache from ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', normalizedPrefix);
        } else {
          logger.debug('cache', `No cache file at ${cacheFile}`, 'eth', normalizedPrefix);
        }
      }
    }

    logger.info('cache', `Cache miss: ${cacheKey}`, 'eth', prefix.toLowerCase());
    return null;
  } catch (error) {
    logger.error('cache', `Failed to get cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function saveCacheState(collection, state, prefix) {
  try {
    const normalizedPrefix = prefix.toLowerCase();
    const cacheFile = path.join(cacheDir, `cache_state_${normalizedPrefix}.json`);
    await ensureCacheDir();
    await fs.writeFile(cacheFile, JSON.stringify(state));
    await fs.chmod(cacheFile, 0o644);
    logger.debug('cache', `Saved cache state for ${normalizedPrefix}: ${cacheFile}`, 'eth', normalizedPrefix);
  } catch (error) {
    logger.error('cache', `Failed to save cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
  }
}

async function loadCacheState(collection, prefix) {
  try {
    const normalizedPrefix = prefix.toLowerCase();
    const cacheFile = path.join(cacheDir, `cache_state_${normalizedPrefix}.json`);
    const data = await fs.readFile(cacheFile, 'utf8');
    const parsed = JSON.parse(data);
    logger.debug('cache', `Loaded cache state for ${normalizedPrefix}: ${cacheFile}`, 'eth', normalizedPrefix);
    return parsed;
  } catch (error) {
    if (error.code === 'ENOENT') {
      logger.debug('cache', `No cache state found for ${prefix}`, 'eth', prefix.toLowerCase());
      return null;
    }
    logger.error('cache', `Failed to load cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

export { initializeCache, setCache, getCache, saveCacheState, loadCacheState };-e 
---
File: ./app/api/utils/serverInit.js
import { initializeCache } from './cache.js';
import { logger } from '@/lib/logger';

export async function initServer() {
  try {
    const cacheInitialized = await initializeCache();
    if (!cacheInitialized) {
      logger.error('server', 'Cache initialization failed', {}, 'eth', 'general');
      throw new Error('Cache initialization failed');
    }
    logger.info('server', 'Cache initialized successfully', 'eth', 'general');
  } catch (error) {
    logger.error('server', `Server initialization failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}-e 
---
File: ./app/api/utils/multicall.js
// app/api/utils/multicall.js
import { client } from './blockchain.js';
import { logger } from '@/lib/logger.js';

export async function batchMulticall(calls, batchSize = 50) {
  logger.debug('multicall', `Processing ${calls.length} calls in batches of ${batchSize}`, 'eth', 'general');
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      logger.debug('multicall', `Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`, 'eth', 'general');
    } catch (error) {
      logger.error('multicall', `Batch ${i}-${i + batchSize - 1} failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      results.push(...batch.map(() => ({ status: 'failure', result: null })));
    }
  }
  logger.debug('multicall', `Completed with ${results.length} results`, 'eth', 'general');
  return results;
}-e 
---
File: ./app/api/utils/index.js
// File: app/api/utils/index.js
// app/api/utils/index.js
export * from './helpers.js';
export * from './blockchain.js';
export * from './contracts.js';
export * from './cache.js';
export * from './serverInit.js';
export * from './multicall.js';
export * from './abis.js';
export { logger, log } from '@/lib/logger.js';-e 
---
File: ./app/api/utils/abis.js
// app/api/utils/abis.js
import { parseAbi } from 'viem';
import config from '@/config';

export const nftAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNftTier(uint256 tokenId) view returns (uint8)',
]);

export const ascendantAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)',
  'function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)',
  'function totalShares() view returns (uint256)',
  'function toDistribute(uint8 pool) view returns (uint256)',
  'function rewardPerShare() view returns (uint256)',
  'error NonExistentToken(uint256 tokenId)',
]);

// Export ABIs from config
export const staxNFTAbi = config.abis.stax.main;
export const element369Abi = config.abis.element369.main;
export const element369VaultAbi = config.abis.element369.vault;
export const staxVaultAbi = config.abis.stax.vault;
export const ascendantNFTAbi = config.abis.ascendant.main;
export const element280Abi = config.abis.element280.main;
export const element280VaultAbi = config.abis.element280.vault;-e 
---
File: ./app/api/utils/helpers.js
const defaultConfig = {
    alchemy: {
      maxRetries: 2,
      batchDelayMs: 500,
      retryMaxDelayMs: 10000,
    },
  };
  
  export async function retry(
    fn,
    attempts = defaultConfig.alchemy.maxRetries,
    delay = (retryCount) =>
      Math.min(
        defaultConfig.alchemy.batchDelayMs * 2 ** retryCount,
        defaultConfig.alchemy.retryMaxDelayMs
      )
  ) {
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        console.error(`[Helpers] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
        if (i === attempts - 1) {
          throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
        }
        await new Promise((resolve) => setTimeout(resolve, delay(i)));
      }
    }
  }
  
  export function isValidAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
  }
  
  export function timeout(ms) {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)
    );
  }
  
  export function normalizeAddress(address) {
    if (!isValidAddress(address)) {
      throw new Error('Invalid Ethereum address');
    }
    return address.toLowerCase();
  }
  
  export function formatNumber(value, decimals = 2) {
    if (typeof value !== 'number') return 'N/A';
    return value.toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
  }-e 
---
File: ./app/api/utils/blockchain.js
// File: app/api/utils/blockchain.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy } from 'alchemy-sdk';
import config from '@/config';
import { logger } from '@/lib/logger.js';
import chalk from 'chalk';

const alchemyApiKey = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  logger.error('blockchain', 'Alchemy API key is missing', {}, 'eth', 'general');
  throw new Error('Alchemy API key is missing');
}

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`),
});

const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: 'eth-mainnet',
});

logger.info('blockchain', 'Blockchain clients initialized', 'eth', 'general');

export { client, alchemy };-e 
---
File: ./app/api/utils/contracts.js
import { parseAbiItem, formatUnits, getAddress } from 'viem';
import pLimit from 'p-limit';
import config from '@/config';
import { client, alchemy } from './blockchain.js';
import { retry, batchMulticall, logger, saveCacheState } from './index.js';

const concurrencyLimit = pLimit(4);

async function getOwnersForContract(contractAddress, abi, options = {}) {
  let owners = [];
  let pageKey = options.pageKey || null;
  const maxPages = options.maxPages || 10;
  let pageCount = 0;

  logger.debug('contracts', `Fetching owners for contract: ${contractAddress}`, 'eth', 'general');

  do {
    try {
      const response = await alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: options.withTokenBalances || false,
        pageKey,
      });

      if (!response?.owners || !Array.isArray(response.owners)) {
        logger.warn('contracts', `Invalid Alchemy response for ${contractAddress}`, {}, 'eth', 'general');
        return owners;
      }

      for (const owner of response.owners) {
        const tokenBalances = owner.tokenBalances || [];
        if (tokenBalances.length > 0) {
          const validBalances = tokenBalances.filter(tb => tb.tokenId && Number(tb.balance) > 0);
          if (validBalances.length > 0) {
            owners.push({
              ownerAddress: owner.ownerAddress.toLowerCase(),
              tokenBalances: validBalances.map(tb => ({
                tokenId: Number(tb.tokenId),
                balance: Number(tb.balance),
              })),
            });
          }
        }
      }

      pageKey = response.pageKey || null;
      pageCount++;
    } catch (error) {
      logger.error('contracts', `Failed to fetch owners for ${contractAddress}: ${error.message}`, {}, 'eth', 'general');
      return owners;
    }
  } while (pageKey && pageCount < maxPages);

  logger.info('contracts', `Fetched ${owners.length} owners for contract: ${contractAddress}`, 'eth', 'general');
  return owners;
}

async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState, addressFilter = null) {
  if (!contractAddress || !abi) {
    throw new Error('Contract address or ABI missing');
  }

  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const holdersMap = new Map();
  let totalBurned = 0;
  const errorLog = [];

  cacheState.progressState.step = 'fetching_supply';
  await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());

  let currentBlock;
  try {
    currentBlock = await client.getBlockNumber();
    logger.debug('contracts', `Fetched current block: ${currentBlock}`, 'eth', contractKey);
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (contractKey === 'ascendant') {
    let transferLogs = [];
    try {
      transferLogs = await retry(
        async () => {
          const logs = await client.getLogs({
            address: contractAddress,
            event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
            fromBlock: BigInt(config.deploymentBlocks[contractKey]?.block || 0),
            toBlock: currentBlock,
          });
          return logs;
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
    } catch (error) {
      logger.error('contracts', `Failed to fetch transfer logs for ${contractAddress}: ${error.message}`, {}, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_logs', error: error.message });
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    if (!Array.isArray(transferLogs)) {
      logger.warn('contracts', `No valid transfer logs for ${contractAddress}`, {}, 'eth', contractKey);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    for (const log of transferLogs) {
      const from = log.args.from.toLowerCase();
      const to = log.args.to.toLowerCase();
      const tokenId = Number(log.args.tokenId);

      if (to === burnAddress.toLowerCase()) {
        totalBurned += 1;
        holdersMap.delete(tokenId);
        logger.debug('contracts', `Token ${tokenId} burned`, 'eth', contractKey);
        continue;
      }

      if (addressFilter && to !== addressFilter.toLowerCase()) {
        continue;
      }

      holdersMap.set(tokenId, { owner: to, balance: 1 });
      logger.debug('contracts', `Token ${tokenId} assigned to ${to}`, 'eth', contractKey);
    }

    cacheState.progressState.totalNfts = holdersMap.size;
    cacheState.progressState.totalTiers = holdersMap.size;
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());

    if (holdersMap.size === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
  } else {
    let totalSupply = 0;
    try {
      totalSupply = await retry(
        async () => {
          const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalSupply' });
          if (result === null || result === undefined) throw new Error('totalSupply returned null');
          return Number(result);
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      logger.debug('contracts', `Total supply: ${totalSupply}`, 'eth', contractKey);
    } catch (error) {
      logger.error('contracts', `Failed to fetch totalSupply: ${error.message}`, {}, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_supply', error: error.message });
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    let burnedCountContract = 0;
    try {
      burnedCountContract = await retry(
        async () => {
          const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalBurned' });
          if (result === null || result === undefined) throw new Error('totalBurned returned null');
          return Number(result);
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      logger.debug('contracts', `Burned count from contract: ${burnedCountContract}`, 'eth', contractKey);
    } catch (error) {
      logger.error('contracts', `Failed to fetch totalBurned: ${error.message}`, {}, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned', error: error.message });
    }
    totalBurned = burnedCountContract;

    cacheState.progressState.totalNfts = totalSupply;
    cacheState.progressState.totalTiers = totalSupply;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());

    if (totalSupply === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
      logger.debug('contracts', `No NFTs (totalSupply=0) for ${contractAddress}`, 'eth', contractKey);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    cacheState.progressState.step = 'fetching_owners';
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());

    let owners = [];
    try {
      owners = await retry(
        () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true }),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
    } catch (error) {
      logger.error('contracts', `Failed to fetch owners: ${error.message}`, {}, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_owners', error: error.message });
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    if (!Array.isArray(owners)) {
      logger.warn('contracts', `No valid owners found for ${contractAddress}`, {}, 'eth', contractKey);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    logger.debug('contracts', `Fetched owners: count=${owners.length}`, 'eth', contractKey);

    let processedTokens = 0;
    for (const owner of owners) {
      const wallet = owner.ownerAddress.toLowerCase();
      if (addressFilter && wallet !== addressFilter.toLowerCase()) {
        continue;
      }

      const tokenIds = owner.tokenBalances
        .map(tb => Number(tb.tokenId))
        .filter(id => !isNaN(id) && id >= 0);

      if (tokenIds.length === 0) {
        logger.debug('contracts', `No valid token IDs for wallet ${wallet}`, 'eth', contractKey);
        continue;
      }

      if (wallet === burnAddress.toLowerCase()) {
        totalBurned += owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0);
        logger.debug('contracts', `Burned tokens: ${owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0)}`, 'eth', contractKey);
        continue;
      }

      processedTokens += tokenIds.length;

      const holder = holdersMap.get(wallet) || {
        wallet,
        tokenIds: [],
        tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
        total: 0,
        multiplierSum: 0,
      };
      holder.tokenIds.push(...tokenIds);
      holder.total += tokenIds.length;
      holdersMap.set(wallet, holder);
      logger.debug('contracts', `Added wallet ${wallet} with ${tokenIds.length} tokens`, 'eth', contractKey);

      cacheState.progressState.processedNfts = processedTokens;
      if (processedTokens % 1000 === 0) {
        await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
      }
    }

    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = processedTokens;
    cacheState.progressState.processedTiers = processedTokens;
    cacheState.totalOwners = holdersMap.size;
    cacheState.totalLiveHolders = holdersMap.size;
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());

    return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
  }
}

export { getHoldersMap, getOwnersForContract };-e 
---
File: ./app/api/utils.js
// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

// Shared cache for routes that import it
export const cache = {};

// Import all ABI JSON files using @ notation
import staxNFTAbi from '@/abi/staxNFT.json';
import element369Abi from '@/abi/element369.json';
import element369VaultAbi from '@/abi/element369Vault.json';
import staxVaultAbi from '@/abi/staxVault.json';
import ascendantNFTAbi from '@/abi/ascendantNFT.json';
import element280Abi from '@/abi/element280.json';
import element280VaultAbi from '@/abi/element280Vault.json';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(
    process.env.ETH_RPC_URL ||
    `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`
  ),
});

// Generic NFT ABI for common functions
export const nftAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNftTier(uint256 tokenId) view returns (uint8)',
]);

// Ascendant NFT ABI with specific functions
export const ascendantAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)',
  'function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)',
  'function totalShares() view returns (uint256)',
  'function toDistribute(uint8 pool) view returns (uint256)',
  'function rewardPerShare() view returns (uint256)',
  'error NonExistentToken(uint256 tokenId)',
]);

// Export all ABIs
export {
  staxNFTAbi,
  element369Abi,
  element369VaultAbi,
  staxVaultAbi,
  ascendantNFTAbi,
  element280Abi,
  element280VaultAbi,
};

export const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export function log(message) {
  console.log(`[PROD_DEBUG] ${message}`);
}

export async function batchMulticall(calls, batchSize = 50) {
  log(`batchMulticall: Processing ${calls.length} calls in batches of ${batchSize}`);
  const results = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      log(`batchMulticall: Batch ${i}-${i + batchSize - 1} completed with ${batchResults.length} results`);
    } catch (error) {
      console.error(`[PROD_ERROR] batchMulticall failed for batch ${i}-${i + batchSize - 1}: ${error.message}`);
      results.push(...batch.map(() => ({ status: 'failure', result: null })));
    }
  }
  log(`batchMulticall: Completed with ${results.length} results`);
  return results;
}-e 
---
File: ./app/api/debug/route.js
import { NextResponse } from 'next/server';
import { logger } from '@/lib/logger';

console.log('[Debug Route] Importing logger');
logger.info('debug', 'Debug route module loaded').catch(console.error);

export async function GET() {
  await logger.info('debug', 'Debug endpoint called');
  return NextResponse.json({
    message: 'Debug endpoint triggered',
    debug: process.env.DEBUG,
    nodeEnv: process.env.NODE_ENV,
  });
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global resets */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #111827; /* Gray-900 */
  color: #ffffff; /* White text */
  min-height: 100vh;
}

/* Animation for fade-in */
.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Highlight row for tables */
.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.
const config = {
  plugins: ["tailwindcss"],
};
export default config;
-e 
---
File: ./test-alchemy.js
import { Alchemy } from 'alchemy-sdk';
import dotenv from 'dotenv';
dotenv.config();

const alchemy = new Alchemy({
  apiKey: process.env.ALCHEMY_API_KEY,
  network: 'eth-mainnet',
});

async function testOwners(contractAddress, contractName) {
  try {
    console.log(`Testing ${contractName} at ${contractAddress}`);
    const response = await alchemy.nft.getOwnersForContract(contractAddress, {
      withTokenBalances: true,
    });
    console.log(`[${contractName}] Owners exists: ${!!response.owners}, Is array: ${Array.isArray(response.owners)}, Length: ${response.owners?.length || 0}`);
    if (!response.owners || !Array.isArray(response.owners)) {
      console.log(`[${contractName}] Response keys: ${Object.keys(response || {})}`);
    }
  } catch (error) {
    console.log(`[${contractName}] Error: ${error.message}`);
  }
}

async function runTests() {
  const contracts = [
    { name: 'Stax', address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1' },
    { name: 'element369', address: '0x024D64E2F65747d8bB02dFb852702D588A062575' },
    { name: 'element280', address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    { name: 'ascendant', address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f' },
  ];
  for (const { name, address } of contracts) {
    await testOwners(address, name);
    console.log('---');
  }
}

runTests();-e 
---
File: ./next.config.mjs
// File: next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  serverExternalPackages: ['viem', 'alchemy-sdk'],
  webpack: (config) => {
    config.resolve.fallback = { fs: false, path: false };
    return config;
  },
};

export default nextConfig;-e 
---
File: ./jest.config.js
// jest.config.js
export default {
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  transform: {
    '^.+\\.js$': 'babel-jest',
  },
  transformIgnorePatterns: [
    '/node_modules/(?!(@upstash/redis|viem|alchemy-sdk|node-cache|p-limit|chalk|yocto-queue)/)',
  ],
  testMatch: ['**/tests/**/*.test.js'],
  verbose: true,
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js']
};-e 
---
File: ./tests/__mocks__/@/app/api/utils/logger.js
export const logger = {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  };-e 
---
File: ./tests/__mocks__/@/config.js
export default {
  nftContracts: {
    element280: { disabled: false },
    ascendant: { disabled: false },
  },
  alchemy: {
    apiKey: 'test-key',
    maxRetries: 2,
    batchDelayMs: 500,
    batchSize: 100,
  },
  burnAddress: '0x0000000000000000000000000000000000000000',
  deploymentBlocks: { ascendant: { block: 0 } },
  contractTiers: {
    ascendant: { 1: { multiplier: 1 }, 2: { multiplier: 2 } },
    element280: { 1: { multiplier: 1 } },
  },
};-e 
---
File: ./tests/__mocks__/@/lib/logger.js
export const logger = {
  info: jest.fn().mockResolvedValue(undefined),
  error: jest.fn().mockResolvedValue(undefined),
  warn: jest.fn().mockResolvedValue(undefined),
  debug: jest.fn().mockResolvedValue(undefined),
};-e 
---
File: ./tests/utils.test.js
// tests/utils.test.js
import { jest } from '@jest/globals';

// Mock modules at the top to ensure they’re applied before imports
jest.mock('@/config', () => {
  const mockConfig = {
    cache: {
      nodeCache: {
        stdTTL: 3600,
        checkperiod: 120,
      },
      redis: {
        disableElement280: false,
        disableElement369: true,
        disableStax: true,
        disableAscendant: true,
        disableE280: true,
      },
    },
    nftContracts: {
      element280: { disabled: false },
      element369: { disabled: false },
      stax: { disabled: false },
      ascendant: { disabled: false },
      e280: { disabled: true },
    },
  };
  console.log('Config mock:', mockConfig);
  return mockConfig;
});

jest.mock('node-cache', () => {
  const mockCache = {
    set: jest.fn().mockReturnValue(true),
    get: jest.fn().mockReturnValue(undefined),
    del: jest.fn().mockReturnValue(1),
  };
  return jest.fn(() => mockCache);
});

jest.mock('fs/promises', () => ({
  mkdir: jest.fn().mockResolvedValue(undefined),
  chmod: jest.fn().mockResolvedValue(undefined),
  writeFile: jest.fn().mockResolvedValue(undefined),
  readFile: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
  access: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
}));

jest.mock('@/lib/logger.js', () => ({
  logger: {
    info: jest.fn().mockResolvedValue(undefined),
    error: jest.fn().mockResolvedValue(undefined),
    warn: jest.fn().mockResolvedValue(undefined),
    debug: jest.fn().mockResolvedValue(undefined),
  },
}));

jest.mock('@upstash/redis', () => {
  const mockRedisData = new Map();
  let mockQuotaExceeded = false;

  const mockRedis = {
    get: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) {
        throw new Error('Redis quota exceeded');
      }
      return mockRedisData.get(key) || null;
    }),
    set: jest.fn().mockImplementation(async (key, value) => {
      if (mockQuotaExceeded) {
        throw new Error('Redis quota exceeded');
      }
      mockRedisData.set(key, value);
      return 'OK';
    }),
    expire: jest.fn().mockImplementation(async (key, seconds) => {
      if (mockQuotaExceeded) {
        throw new Error('Redis quota exceeded');
      }
      return 1;
    }),
    del: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) {
        throw new Error('Redis quota exceeded');
      }
      return mockRedisData.delete(key) ? 1 : 0;
    }),
  };

  const Redis = {
    fromEnv: jest.fn(() => {
      console.log('Redis.fromEnv called');
      return mockRedis;
    }),
  };

  return {
    Redis,
    clearMockRedis: jest.fn(() => {
      mockRedisData.clear();
    }),
    setMockQuotaExceeded: jest.fn((state) => {
      mockQuotaExceeded = state;
    }),
  };
});

describe('Cache', () => {
  let mockNodeCacheInstance;
  let redisMock;
  let redis;
  let logger;

  beforeAll(() => {
    jest.resetModules(); // Clear module cache once before all tests
  });

  beforeEach(async () => {
    jest.clearAllMocks();

    // Mock node-cache
    const nodeCache = (await import('node-cache')).default;
    mockNodeCacheInstance = new nodeCache();
    mockNodeCacheInstance.set.mockReset().mockReturnValue(true);
    mockNodeCacheInstance.get.mockReset().mockReturnValue(undefined);
    mockNodeCacheInstance.del.mockReset().mockReturnValue(1);

    // Mock @upstash/redis
    redis = await import('@upstash/redis');
    redisMock = redis.Redis.fromEnv();
    redis.clearMockRedis();

    logger = (await import('@/lib/logger.js')).logger;

    // Mock environment variables
    process.env.UPSTASH_REDIS_REST_URL = 'https://splendid-sunbird-26504.upstash.io';
    process.env.UPSTASH_REDIS_REST_TOKEN = 'AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA';
    process.env.DISABLE_ELEMENT280_REDIS = 'false'; // Enable Redis for testing
    process.env.DEBUG = 'true';

    // Initialize cache before tests
    const { initializeCache } = await import('@/app/api/utils/cache.js');
    await initializeCache();
  });

  afterEach(() => {
    jest.restoreAllMocks();
    delete process.env.UPSTASH_REDIS_REST_URL;
    delete process.env.UPSTASH_REDIS_REST_TOKEN;
    delete process.env.DISABLE_ELEMENT280_REDIS;
    delete process.env.DEBUG;
  });

  it('should initialize node-cache and Redis', async () => {
    const { initializeCache } = await import('@/app/api/utils/cache.js');
    redisMock.set.mockResolvedValue('OK');
    redisMock.get.mockResolvedValue(JSON.stringify({ ready: true }));
    redisMock.del.mockResolvedValue(1);

    const result = await initializeCache();
    expect(result).toBe(true);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith('test_node_cache', { ready: true });
    expect(mockNodeCacheInstance.del).toHaveBeenCalledWith('test_node_cache');
    expect(redisMock.set).toHaveBeenCalledWith('test_redis', expect.any(String));
    expect(redisMock.get).toHaveBeenCalledWith('test_redis');
    expect(redisMock.del).toHaveBeenCalledWith('test_redis');
    expect(logger.info).toHaveBeenCalledWith(
      'cache',
      'Cache initialization completed',
      'eth',
      'general'
    );
  });

  it('should set and get small dataset in node-cache', async () => {
    const { setCache, getCache } = await import('@/app/api/utils/cache.js');
    const key = 'element280_holders';
    const value = { holders: [{ wallet: '0x123', tokenIds: [1], total: 1 }], totalBurned: 0, timestamp: Date.now() }; // ~100 bytes
    const prefix = 'element280';
    const ttl = 3600;

    const setResult = await setCache(key, value, ttl, prefix);
    expect(setResult).toBe(true);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(`${prefix}_${key}`, value, ttl);
    const fsMock = await import('fs/promises');
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      expect.stringContaining(`${prefix.toLowerCase()}_holders.json`),
      JSON.stringify(value)
    );

    mockNodeCacheInstance.get.mockReturnValueOnce(value);
    const getResult = await getCache(key, prefix);
    expect(getResult).toEqual(value);
    expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(`${prefix}_${key}`);
  });

  it('should set and get tiny dataset in Redis when enabled', async () => {
    const { setCache, getCache } = await import('@/app/api/utils/cache.js');
    const key = 'element280_holders';
    const value = { holders: [{ wallet: '0x123', tokenIds: [1], total: 1 }], totalBurned: 0, timestamp: Date.now() }; // ~100 bytes
    const prefix = 'element280';
    const ttl = 3600;

    redisMock.set.mockResolvedValue('OK');
    redisMock.get.mockResolvedValue(JSON.stringify(value));
    redisMock.expire.mockResolvedValue(1);

    const setResult = await setCache(key, value, ttl, prefix);
    expect(setResult).toBe(true);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(`${prefix}_${key}`, value, ttl);
    expect(redisMock.set).toHaveBeenCalledWith(`${prefix}_${key}`, JSON.stringify(value));
    expect(redisMock.expire).toHaveBeenCalledWith(`${prefix}_${key}`, Math.floor(ttl / 1000));

    const getResult = await getCache(key, prefix);
    expect(getResult).toEqual(value);
    expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(`${prefix}_${key}`);
    expect(redisMock.get).toHaveBeenCalledWith(`${prefix}_${key}`);
  });

  it('should skip Redis when disabled via env variable', async () => {
    // Directly modify process.env to disable redisEnabled
    process.env.UPSTASH_REDIS_REST_URL = undefined; // Disable redisEnabled
    process.env.DISABLE_ELEMENT280_REDIS = 'true';

    const { setCache, getCache } = await import('@/app/api/utils/cache.js');
    const key = 'element280_holders';
    const value = { holders: [{ wallet: '0x123', tokenIds: [1], total: 1 }], totalBurned: 0, timestamp: Date.now() };
    const prefix = 'element280';
    const ttl = 3600;

    // Skip initializeCache since redisEnabled is false
    const setResult = await setCache(key, value, ttl, prefix);
    expect(setResult).toBe(true);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(`${prefix}_${key}`, value, ttl);
    expect(redisMock.set).not.toHaveBeenCalled();

    mockNodeCacheInstance.get.mockReturnValueOnce(value);
    const getResult = await getCache(key, prefix);
    expect(getResult).toEqual(value);
    expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(`${prefix}_${key}`);
    expect(redisMock.get).not.toHaveBeenCalled();
  });

  it('should fallback to node-cache on Redis quota exceeded', async () => {
    const { setCache, getCache } = await import('@/app/api/utils/cache.js');
    const key = 'element280_holders';
    const value = { holders: [{ wallet: '0x123', tokenIds: [1], total: 1 }], totalBurned: 0, timestamp: Date.now() };
    const prefix = 'element280';
    const ttl = 3600;

    // Clear previous mocks
    redisMock.set.mockReset();
    redisMock.get.mockReset();
    redisMock.del.mockReset();

    // Mock redis.set to succeed for initializeCache
    redisMock.set.mockResolvedValueOnce('OK');
    redisMock.get.mockResolvedValueOnce(JSON.stringify({ ready: true }));
    redisMock.del.mockResolvedValueOnce(1);

    // Reinitialize cache to ensure redis is set
    const { initializeCache } = await import('@/app/api/utils/cache.js');
    await initializeCache();

    // Set quota exceeded for setCache
    redis.setMockQuotaExceeded(true);

    mockNodeCacheInstance.get.mockReturnValueOnce(value);

    const setResult = await setCache(key, value, ttl, prefix);
    expect(setResult).toBe(true);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(`${prefix}_${key}`, value, ttl);
    expect(redisMock.set).toHaveBeenCalled();
    expect(logger.error).toHaveBeenCalledWith(
      'cache',
      `Failed to persist ${prefix}_${key} to Redis: Redis quota exceeded`,
      expect.any(Object),
      'eth',
      prefix.toLowerCase()
    );

    const getResult = await getCache(key, prefix);
    expect(getResult).toEqual(value);
    expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(`${prefix}_${key}`);
    expect(redisMock.get).toHaveBeenCalled();
  });

  it('should save and load cache state', async () => {
    const { saveCacheState, loadCacheState } = await import('@/app/api/utils/cache.js');
    const collection = 'element280';
    const prefix = 'element280';
    const state = { progressState: { step: 'completed', processedNfts: 1, totalNfts: 1 } };

    const fsMock = await import('fs/promises');
    fsMock.writeFile.mockResolvedValue();
    fsMock.readFile.mockResolvedValueOnce(JSON.stringify(state));

    await saveCacheState(collection, state, prefix);
    expect(fsMock.writeFile).toHaveBeenCalledWith(
      expect.stringContaining(`cache_state_${prefix.toLowerCase()}.json`),
      JSON.stringify(state)
    );

    const loadedState = await loadCacheState(collection, prefix);
    expect(loadedState).toEqual(state);
    expect(fsMock.readFile).toHaveBeenCalledWith(
      expect.stringContaining(`cache_state_${prefix.toLowerCase()}.json`),
      'utf8'
    );
  });

  it('should handle node-cache failure', async () => {
    const { setCache } = await import('@/app/api/utils/cache.js');
    const key = 'element280_holders';
    const value = { holders: [{ wallet: '0x123', tokenIds: [1], total: 1 }], totalBurned: 0, timestamp: Date.now() };
    const prefix = 'element280';
    const ttl = 3600;

    mockNodeCacheInstance.set.mockReturnValueOnce(false);

    const setResult = await setCache(key, value, ttl, prefix);
    expect(setResult).toBe(false);
    expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(`${prefix}_${key}`, value, ttl);
    expect(logger.error).toHaveBeenCalledWith(
      'cache',
      `Failed to set node-cache: ${prefix}_${key}`,
      expect.any(Object),
      'eth',
      prefix.toLowerCase()
    );
  });
});-e 
---
File: ./tests/setup.js
// tests/setup.js
console.log('Jest setup: Root directory:', process.cwd());-e 
---
File: ./config.js
// config.js
import element280MainAbi from './abi/element280.json' assert { type: 'json' };
import element280VaultAbi from './abi/element280Vault.json' assert { type: 'json' };
import element369MainAbi from './abi/element369.json' assert { type: 'json' };
import element369VaultAbi from './abi/element369Vault.json' assert { type: 'json' };
import staxMainAbi from './abi/staxNFT.json' assert { type: 'json' };
import staxVaultAbi from './abi/staxVault.json' assert { type: 'json' };
import ascendantMainAbi from './abi/ascendantNFT.json' assert { type: 'json' };
// E280 ABI placeholder (not deployed)
const e280MainAbi = [];

const config = {
  // Supported blockchain networks
  supportedChains: ['ETH', 'BASE'],

  // ABIs for all collections
  abis: {
    element280: {
      main: element280MainAbi,
      vault: element280VaultAbi,
    },
    element369: {
      main: element369MainAbi,
      vault: element369VaultAbi,
    },
    stax: {
      main: staxMainAbi,
      vault: staxVaultAbi,
    },
    ascendant: {
      main: ascendantMainAbi,
      vault: [], // No vault ABI provided for Ascendant
    },
    e280: {
      main: e280MainAbi,
      vault: [],
    },
  },

  // NFT contract configurations
  nftContracts: {
    element280: {
      name: 'Element 280',
      symbol: 'ELMNT',
      chain: 'ETH',
      address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
      vaultAddress: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
      deploymentBlock: '20945304',
      tiers: {
        1: { name: 'Common', multiplier: 10, allocation: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 12, allocation: '100000000000000000000000000' },
        3: { name: 'Rare', multiplier: 100, allocation: '1000000000000000000000000000' },
        4: { name: 'Rare Amped', multiplier: 120, allocation: '1000000000000000000000000000' },
        5: { name: 'Legendary', multiplier: 1000, allocation: '10000000000000000000000000000' },
        6: { name: 'Legendary Amped', multiplier: 1200, allocation: '10000000000000000000000000000' },
      },
      description:
        'Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.',
      expectedTotalSupply: 8107,
      expectedBurned: 8776,
      maxTokensPerOwnerQuery: 100,
    },
    element369: {
      name: 'Element 369',
      symbol: 'E369',
      chain: 'ETH',
      address: '0x024D64E2F65747d8bB02dFb852702D588A062575',
      vaultAddress: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',
      deploymentBlock: '21224418',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        3: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
      },
      description:
        'Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.',
    },
    stax: {
      name: 'Stax',
      symbol: 'STAX',
      chain: 'ETH',
      address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
      vaultAddress: '0x5D27813C32dD705404d1A78c9444dAb523331717',
      deploymentBlock: '21452667',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 1.2, price: '100000000000000000000000000', amplifier: '10000000000000000000000000' },
        3: { name: 'Common Super', multiplier: 1.4, price: '100000000000000000000000000', amplifier: '20000000000000000000000000' },
        4: { name: 'Common LFG', multiplier: 2, price: '100000000000000000000000000', amplifier: '50000000000000000000000000' },
        5: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        6: { name: 'Rare Amped', multiplier: 12, price: '1000000000000000000000000000', amplifier: '100000000000000000000000000' },
        7: { name: 'Rare Super', multiplier: 14, price: '1000000000000000000000000000', amplifier: '200000000000000000000000000' },
        8: { name: 'Rare LFG', multiplier: 20, price: '1000000000000000000000000000', amplifier: '500000000000000000000000000' },
        9: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
        10: { name: 'Legendary Amped', multiplier: 120, price: '10000000000000000000000000000', amplifier: '1000000000000000000000000000' },
        11: { name: 'Legendary Super', multiplier: 140, price: '10000000000000000000000000000', amplifier: '2000000000000000000000000000' },
        12: { name: 'Legendary LFG', multiplier: 200, price: '10000000000000000000000000000', amplifier: '5000000000000000000000000000' },
      },
      description:
        'Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.',
    },
    ascendant: {
      name: 'Ascendant',
      symbol: 'ASCNFT',
      chain: 'ETH',
      address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f',
      deploymentBlock: '21112535',
      tiers: {
        1: { name: 'Tier 1', price: '7812500000000000000000', multiplier: 1.01 },
        2: { name: 'Tier 2', price: '15625000000000000000000', multiplier: 1.02 },
        3: { name: 'Tier 3', price: '31250000000000000000000', multiplier: 1.03 },
        4: { name: 'Tier 4', price: '62500000000000000000000', multiplier: 1.04 },
        5: { name: 'Tier 5', price: '125000000000000000000000', multiplier: 1.05 },
        6: { name: 'Tier 6', price: '250000000000000000000000', multiplier: 1.06 },
        7: { name: 'Tier 7', price: '500000000000000000000000', multiplier: 1.07 },
        8: { name: 'Tier 8', price: '1000000000000000000000000', multiplier: 1.08 },
      },
      description:
        'Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.',
    },
    e280: {
      name: 'E280',
      symbol: 'E280',
      chain: 'BASE',
      address: null,
      deploymentBlock: null,
      tiers: {},
      description: 'E280 NFTs on BASE chain. Contract not yet deployed.',
      disabled: true,
    },
  },

  // Contract addresses
  contractAddresses: {
    element280: { chain: 'ETH', address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    element369: { chain: 'ETH', address: '0x024D64E2F65747d8bB02dFb852702D588A062575' },
    stax: { chain: 'ETH', address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1' },
    ascendant: { chain: 'ETH', address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f' },
    e280: { chain: 'BASE', address: null },
  },

  // Vault addresses
  vaultAddresses: {
    element280: { chain: 'ETH', address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97' },
    element369: { chain: 'ETH', address: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5' },
    stax: { chain: 'ETH', address: '0x5D27813C32dD705404d1A78c9444dAb523331717' },
    e280: { chain: 'BASE', address: null },
  },

  // Deployment blocks
  deploymentBlocks: {
    element280: { chain: 'ETH', block: '20945304' },
    element369: { chain: 'ETH', block: '21224418' },
    stax: { chain: 'ETH', block: '21452667' },
    ascendant: { chain: 'ETH', block: '21112535' },
    e280: { chain: 'BASE', block: null },
  },

  // Contract tiers
  contractTiers: {
    element280: {
      1: { name: 'Common', multiplier: 10 },
      2: { name: 'Common Amped', multiplier: 12 },
      3: { name: 'Rare', multiplier: 100 },
      4: { name: 'Rare Amped', multiplier: 120 },
      5: { name: 'Legendary', multiplier: 1000 },
      6: { name: 'Legendary Amped', multiplier: 1200 },
    },
    element369: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Rare', multiplier: 10 },
      3: { name: 'Legendary', multiplier: 100 },
      tierOrder: [
        { tierId: '3', name: 'Legendary' },
        { tierId: '2', name: 'Rare' },
        { tierId: '1', name: 'Common' },
      ],
    },
    stax: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Common Amped', multiplier: 1.2 },
      3: { name: 'Common Super', multiplier: 1.4 },
      4: { name: 'Common LFG', multiplier: 2 },
      5: { name: 'Rare', multiplier: 10 },
      6: { name: 'Rare Amped', multiplier: 12 },
      7: { name: 'Rare Super', multiplier: 14 },
      8: { name: 'Rare LFG', multiplier: 20 },
      9: { name: 'Legendary', multiplier: 100 },
      10: { name: 'Legendary Amped', multiplier: 120 },
      11: { name: 'Legendary Super', multiplier: 140 },
      12: { name: 'Legendary LFG', multiplier: 200 },
    },
    ascendant: {
      1: { name: 'Tier 1', multiplier: 1.01 },
      2: { name: 'Tier 2', multiplier: 1.02 },
      3: { name: 'Tier 3', multiplier: 1.03 },
      4: { name: 'Tier 4', multiplier: 1.04 },
      5: { name: 'Tier 5', multiplier: 1.05 },
      6: { name: 'Tier 6', multiplier: 1.06 },
      7: { name: 'Tier 7', multiplier: 1.07 },
      8: { name: 'Tier 8', multiplier: 1.08 },
    },
    e280: {},
  },

  // Contract details
  contractDetails: {
    element280: {
      name: 'Element 280',
      chain: 'ETH',
      pageSize: 100,
      apiEndpoint: '/api/holders/Element280',
      rewardToken: 'ELMNT',
    },
    element369: {
      name: 'Element 369',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Element369',
      rewardToken: 'INFERNO/FLUX/E280',
    },
    stax: {
      name: 'Stax',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Stax',
      rewardToken: 'X28',
    },
    ascendant: {
      name: 'Ascendant',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Ascendant',
      rewardToken: 'DRAGONX',
    },
    e280: {
      name: 'E280',
      chain: 'BASE',
      pageSize: 1000,
      apiEndpoint: '/api/holders/E280',
      rewardToken: 'E280',
      disabled: true,
    },
  },

  // Utility function to get contract details by name
  getContractDetails: (contractName) => {
    return config.nftContracts[contractName] || null;
  },

  alchemy: {
    apiKey: process.env.ALCHEMY_API_KEY || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
    network: 'eth-mainnet',
    batchSize: 50, // Increased for larger batches
    batchDelayMs: 500, // Reduced for speed
    retryMaxDelayMs: 10000, // Reduced to fail faster
    maxRetries: 2, // Reduced to minimize retry overhead
    timeoutMs: 30000,
  },
  
  // Cache settings
  cache: {
    redis: {
      disableElement280: process.env.DISABLE_ELEMENT280_REDIS === 'true',
      disableElement369: process.env.DISABLE_ELEMENT369_REDIS === 'true',
      disableStax: process.env.DISABLE_STAX_REDIS === 'true',
      disableAscendant: process.env.DISABLE_ASCENDANT_REDIS === 'true',
      disableE280: process.env.DISABLE_E280_REDIS === 'true' || true,
    },
    nodeCache: {
      stdTTL: 3600,
      checkperiod: 120,
    },
  },

  // Debug settings
  debug: {
    enabled: process.env.DEBUG === 'true',
    logLevel: 'debug',
  },

  // Fallback data (optional, for testing)
  fallbackData: {
    element280: process.env.USE_FALLBACK_DATA === 'true' ? element280NftStatus : null,
  },
};

export default config;-e 
---
File: ./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
-e 
---
File: ./README.md
Please find below my Nextjs project TitanXUtils.  This part is concentrating on 4 NFT colections and analysing their data.

Element369, Stax and Ascendant are complete.

I am still trying to perfect the Element280 NFT collection.
All 4 of these are on Ethereum.
I also have a placeholder for future collection E280; this will be deployed on BASE

I have a few components that are important for this analysis.
It shoud be noted that any code changes and enhancements/testing scripts should not risk breaking the work we've already done for  Element369, Stax and Ascendant 


These 3 are the wallets that I own:
0x15702443110894B26911B913b17ea4931F803B02
0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
0x9D641961a31B3eED46e664fA631aAD3021323862

wallet: 0x15702443110894B26911B913b17ea4931F803B02
this output should be the following:
Element 280, live nfts count 29, 5 amped legendary, 1 legendary, 6 rare amped and 17 amp common: 
Minted 2  
Tiers minted  [0,0,0,0,0,2]
Transferred in  28
Transferred out  1
Burned 0

wallet: 0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
this output should be the following:
Element 280, live nfts count 0
Minted 22 
Tiers minted  [[0,17,0,3,0,2]
Transferred in 6
Transferred out 27
Burned 1

wallet: 0x9D641961a31B3eED46e664fA631aAD3021323862
this output should be the following:
Element 280, live nfts count 0
Minted 0
Tiers minted   [0,0,0,0,0,0]
Transferred in 2
Transferred out 2
Burned 0

The current claimable reward Element280 tokens for wallet 0x15702443110894B26911B913b17ea4931F803B02 is currently 1,301,036,482 and my current % of rewards is 1.199%

This is because it is only valid for wallets that currently own at least bone element280 NFT to have a current claimable amount.  This information can be used with the Element280Vault contract and abi to calculate the Claimable value for a wallet.  

The project code and data sources that I think we need for our further analysis is below.



.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI

project includes below

{
  "name": "titanx-utility",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@covalenthq/client-sdk": "^2.2.5",
    "@tanstack/react-query": "^5.72.1",
    "@wagmi/connectors": "^5.7.11",
    "alchemy-sdk": "^3.5.6",
    "chart.js": "^4.4.9",
    "dotenv": "^16.5.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.3",
    "minimist": "^1.2.8",
    "next": "14.2.15",
    "node-fetch": "^3.3.2",
    "p-limit": "^6.2.0",
    "pino": "^9.6.0",
    "pino-pretty": "^13.0.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-virtualized": "^9.22.6",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.1.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.15",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^3.4.17"
  }


===========next

Thank you for the additional requirements. To summarize, the solution must:
Be specific to Element 280, ensuring no impact on other NFT collections.

Address potential database staleness by querying the blockchain for the latest data while using the element280.db database for wallet-specific data and complex aggregates.

Update the element280.db database with any new data obtained from the blockchain to keep it as up-to-date as possible.

Resolve the SQLITE_ERROR: table element280_summary has no column named totalRewardPool issue for the NFT->ETH->Element280 page.

Ensure the solution is quick, easy, and verifies the three wallets’ data from wallets.json.

We’ll implement a hybrid approach that:
Fetches real-time data (totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, tierDistribution) from the Element 280 NFT and vault contracts using a single multicall and Alchemy’s getOwnersForContract.

Queries the database (element280.db) for wallet-specific data (element280_wallets) and burnedDistribution, as computing historical burn data on-chain is complex.

Updates the element280_summary table with fresh blockchain data to keep it up-to-date.

Ensures all changes are isolated to Element 280-specific code (/api/holders/Element280, public/data/element280.db, and optionally trackElement280NFTs.js).

This approach resolves the SQLITE_ERROR, ensures real-time accuracy, keeps the database updated, and remains specific to Element 280.
Key Considerations
Element 280 Specificity:
Modify only /api/holders/Element280 (or equivalent, e.g., app/api/holders/Element280/route.js or pages/api/holders/Element280.js).

Use public/data/element280.db, isolated from other collections’ databases.

Reference only Element 280’s CONTRACT_ADDRESS (NFT) and VAULT_CONTRACT_ADDRESS (vault).

Avoid shared utilities or ABIs used by other collections.

Handling Database Staleness:
Fetch totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, and tierDistribution from the blockchain for real-time data.

Query element280_wallets for wallet data and element280_summary for burnedDistribution (historical data).

Update element280_summary with new blockchain data to keep it current.

Database Updates:
Add totalRewardPool to element280_summary schema to store blockchain-fetched data.

Update totalWallets, tierDistribution, and other fields in element280_summary with blockchain data.

Ensure element280_wallets updates are handled by trackElement280NFTs.js (existing script).

Solution Goals:
Resolve SQLITE_ERROR by adding totalRewardPool to the database and fetching it on-chain.

Ensure real-time data for critical metrics.

Maintain performance by leveraging the database for wallet data.

Keep changes minimal and Element 280-specific.

Implementation
Step 1: Update the Database Schema
Since the SQLITE_ERROR indicates element280_summary lacks a totalRewardPool column, we’ll add it to the schema. This requires updating trackElement280NFTs.js to include totalRewardPool and ensure the database is ready for updates from the API handler.
Update initDb in trackElement280NFTs.js:


its not just the summary table that needs to be updated with the latet data.  All the tables in the batabase need to be aswell.  These tables can be seen in the file scripts/trackElement280NFTs.jsspecifically the tables are described by the creation code in this file:


      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);```



===
old
cat components/NFTPage.js  components/NFTPageWrapper.js components/NFTSummary.js components/HolderTable/Ascendant.js components/HolderTable/Element369.js components/HolderTable/Element280.js components/HolderTable/E280.js components/HolderTable/Stax.js components/SearchResultsModal.js config.js app/store.js  app/page.js app/layout.js app/nft/page.js app/nft/\[chain\]/\[contract\]/page.js   > ClientStuff.txt
===

========================
Summary for README
========================
Current State: The application fetches and displays NFT holder data for collections (Element369, Element280, Stax, Ascendant, E280) using Alchemy and viem, with server-side caching (NodeCache) and client-side caching (useNFTStore). Element280’s cache population is slow (fetching_supply), causing delays.


Logging: Ensure DEBUG=false outputs only [ERROR] and [VALIDATION] logs, using pino-pretty in debug for readability.( this doesn't work in prod)
Enhance Caching: Use independent caches per collection, polling /progress endpoints to wait for server-side cache completion.
Improve Loading: Display loading states (<LoadingIndicator>) until each collection’s cache is ready, ensuring smooth switching between collections.
Support All Collections: Implement consistent /progress endpoints for Element369, Stax, Ascendant, and E280, Element280

Goal:
data is fetched for NFT collections when the button for that collection is clicked.  the cache should be checked first to make sure the data is available in the cache. The cache needs to contain all the data for that NFT collection ( wallets with live NFTs, their owned tiers, etc) and should either be written to file( node-cache) for quick access or Redit Upstash(controlled by env vars).  the cache needs to persist across server restarts.  If its not then the browser should give an animated loading message and then load the data when its fully available and only then render the page.  THe user can switch between NFT colections smoothly and each time its individual memory cache should be queried for complete data and only render once complete. Each NFT colection has its own memoey cache managed my node-cache (written to file) or Redis Upstash depending on whether an env variable is true or false.  I want to ensure the caching is correct before moving to redis upstash.
when a user switches to a different nft collection that data fetch should start. if the user switches back to the original nft collection the data fetch should continue from where it left off.
if a user uses the search functionality then this requires that all the data caches are completed before returning results.  The results should be one row for each NFT collection with its corresponding data and displayed on top of each other in a modal dialog.  The data for each collection is usually different.
If data is in the cache the system should load this but if there any more potential data on the block chain this should be checked first before displaying the data in the holder table. The cache should always be updated with the latest data from the blockchain when a user uses the Browser.  The cache should hold the lastBlock processed info)

Frontend Validation:
Verify HolderTable components (components/HolderTable/Element280.js, HolderTable/Element369.js, etc.) display data correctly (e.g., multiplierSum, shares, rewards).
i need help debugging the code to ensure this happens.
this project uses the free vercel tier and alchemy
Centralized configuration in config.js with ES Modules.
Moved ABIs to config.js for consistency.
Optimized Alchemy settings (batchSize: 10, batchDelayMs: 1000).
Caching Implementation
All collections (Element280, Element369, Stax, Ascendant) support Redis caching (via Upstash) and in-memory/file caching (node-cache) with toggles (DISABLE_*_REDIS in .env.local).

Testing:
Run the following commands to verify API endpoints:

curl -X POST http://localhost:3000/api/holders/Element280"
curl "http://localhost:3000/api/holders/Element280/progress"
curl "http://localhost:3000/api/holders/Element280"
curl "http://localhost:3000/api/holders/Stax"
curl "http://localhost:3000/api/holders/Element369"
curl "http://localhost:3000/api/holders/Ascendant"


*Data**:
  - Total Minted: 16,883 NFTs. ( this will never changed and shoud be hardcoded)
  - Total Live: 8,107 NFTs.  ( this is the current niumber as of a few days ago.  maybe less the next time we check. can only go down to 0)
  - Total Burned: 8,776 NFTs (via `Transfer` events to `0x0000...0000`). ( this is the current number as of a few days ago.  maybe more the next time we check. can only go up to a max of Total Minted)
  - Total Holders: 920 wallets ( as of now)

============
Server code
============
cat \
app/api/holders/\[contract\]/route.js \
app/api/holders/\[contract\]/progress/route.js \
app/api/holders/Element280/validate-burned/route.js \
app/api/debug/route.js \
app/api/init/* \
app/store.js \
config.js \
app/api/utils.js \
lib/* > ./routes.txt

============
Client code
============
cat components/*.js  components/*.jsx components/HolderTable/*.js config.js app/store.js  \
app/page.js app/layout.js app/nft/layout.js app/nft/page.js  lib/* \
app/nft/\[chain\]/\[contract\]/page.js   > ./ClientStuff.txt

============
Envs vars
============
cat package.json next.config.mjs jsconfig.json  \
tailwind.config.js .env.local .env.development.local \
lib/*  app/store.js config.js app/api/utils.js \
.babelrc   jest.config.js \
 > ./envs.txt

=============
Better concats
=============
find ./tests .babelrc jest.config.js -type d \( -name node_modules -o -name .next \) -prune -false -o -type f -exec cat {} + > ./testing_code.txt
find ./app/api/utils -type d \( -name node_modules -o -name .next \) -prune -false -o -type f -exec cat {} + > ./utils_code.txt
find ./app/api  -type d \( -name node_modules -o -name .next \) -prune -false -o -type f -exec cat {} + > ./server_code.txt
find ./app ./components ./lib  -type d \( -name node_modules -o -name .next -name ./app/api \) -prune -false -o -type f -exec cat {} + > ./client_code.txt
find ./abi -type d \( -name node_modules -o -name .next \) -prune -false -o -type f -exec cat {} + > ./abis_code.txt

cat app/api/utils.js app/api/utils/*  lib/logger.js  components/*.js  > utils.txt

clear; cat envs.txt
clear; cat envs.txt ./routes.txt

clear;  cat ./routes.txt 
clear; cat envs.txt ClientStuff.txt
clear; cat ClientStuff.txt


clear;npm run build


time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/e280;
time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/ascendant;

time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/e280;
time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/ascendant;

time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/e280;
time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/ascendant;

curl http://localhost:3000/api/holders/Stax/progress
curl http://localhost:3000/api/holders/element369/progress
curl http://localhost:3000/api/holders/e280/progress
curl http://localhost:3000/api/holders/element280/progress
curl http://localhost:3000/api/holders/ascendant/progress


route file basic structure

import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits } from 'viem';
import pLimit from 'p-limit';
import config from '@/config.js';
import { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract } from '@/app/api/utils';
import { HoldersResponseSchema } from '@/lib/schemas';

const limit = pLimit(5);

// Helper functions
async function getCacheState(contractKey) { ... }
async function saveCacheStateContract(contractKey, cacheState) { ... }
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) { ... }
async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState) { ... }
async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) { ... }

// GET handler
export async function GET(request, { params }) { ... }

// POST handler
export async function POST(request, { params }) { ... }-e 
---
File: ./test-logger.js
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const logDir = path.join(__dirname, '../logs');

async function testLogger() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log('Created log directory:', logDir);

    const logFile = path.join(logDir, `test-${new Date().toISOString().split('T')[0]}.log`);
    await fs.appendFile(logFile, 'Test log entry\n');
    console.log('Wrote to log file:', logFile);

    await fs.chmod(logFile, 0o644);
    console.log('Set file permissions for:', logFile);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

testLogger();-e 
---
File: ./not-found.js
// File: app/not-found.js

import Link from 'next/link';

export default function NotFound() {
  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 flex flex-col items-center justify-center p-6">
      <h1 className="text-4xl font-bold mb-4">Page Not Found</h1>
      <p className="text-lg mb-6">Sorry, the page you&apos;re looking for doesn&apos;t exist.</p>
      <Link href="/nft" className="btn btn-primary">
        Return to NFT Collections
      </Link>
    </div>
  );
}-e 
---
File: ./components/NFTLayout.js
// File: components/NFTLayout.js
'use client';

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import dynamic from 'next/dynamic';
import config from '@/config.js';
import { useNFTStore } from '@/app/store';
import { useDebounce } from 'use-debounce';

// Dynamically import SearchResultsModal
const SearchResultsModal = dynamic(() => import('@/components/SearchResultsModal'), { ssr: false });

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [debouncedAddress] = useDebounce(searchAddress, 500);
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isClient, setIsClient] = useState(false);

  const { getCache, setCache } = useNFTStore();

  useEffect(() => {
    setIsClient(true);
  }, []);

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'stax' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendant' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(config.contractDetails).map((key) => ({
    name: config.contractDetails[key].name,
    apiKey: key,
    href:
      key === 'e280'
        ? null
        : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${config.contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchSearchData = async (address, apiKey, apiEndpoint) => {
    console.log(`[NFTLayout] Fetching search data for ${apiKey} with address: ${address}`);
    try {
      if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
        console.log(`[NFTLayout] ${apiKey} is disabled`);
        return { error: `${apiKey} is not available` };
      }

      let endpoint = apiEndpoint;
      if (!endpoint || !endpoint.startsWith('http')) {
        const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
        endpoint = `${baseUrl}${apiEndpoint}`;
        console.log(`[NFTLayout] Adjusted endpoint: ${endpoint}`);
      }

      const url = `${endpoint}?address=${encodeURIComponent(address)}`;
      console.log(`[NFTLayout] Fetching ${url}`);
      const res = await fetch(url, {
        cache: 'no-store', // Ensure fresh data for address-specific queries
        signal: AbortSignal.timeout(config.alchemy.timeoutMs || 30000),
      });

      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Failed to fetch ${url}: ${res.status} ${errorText}`);
      }

      const json = await res.json();
      console.log(`[NFTLayout] Response for ${apiKey}:`, json);

      if (json.error) {
        console.log(`[NFTLayout] API error for ${apiKey}: ${json.error}`);
        return { error: json.error };
      }

      if (!json.holders || !Array.isArray(json.holders)) {
        throw new Error(`Invalid holders data for ${url}`);
      }

      return {
        holders: json.holders,
        totalTokens: json.totalTokens || json.summary?.totalLive || 0,
        totalShares: json.totalShares || json.summary?.multiplierPool || 0,
        totalBurned: json.totalBurned || 0,
        summary: json.summary || {},
      };
    } catch (error) {
      console.error(`[NFTLayout] Error fetching ${apiKey}: ${error.message}`);
      return { error: error.message };
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      setIsModalOpen(false);
      return;
    }
  
    setSearchLoading(true);
    setError(null);
    setSearchResults({});
  
    try {
      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
  
      for (const { apiKey } of allNFTs) {
        if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
          searchResults[apiKey] = { error: `${apiKey} is not available` };
          console.log(`[NFTLayout] Skipping disabled contract ${apiKey}`);
          continue;
        }
  
        const contractConfig = config.contractDetails[apiKey] || {};
        const data = await fetchSearchData(lowerSearchAddress, apiKey, contractConfig.apiEndpoint);
  
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else {
          searchResults[apiKey] = {
            holders: data.holders || [],
            totalTokens: data.totalTokens,
            totalShares: apiKey === 'ascendant' ? data.totalShares : undefined,
            totalBurned: data.totalBurned,
            rewardToken: config.contractDetails[apiKey]?.rewardToken,
            summary: data.summary,
          };
          console.log(`[NFTLayout] ${apiKey} search result:`, searchResults[apiKey]);
        }
      }
  
      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err.message, err.stack);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  useEffect(() => {
    if (debouncedAddress && /^0x[a-fA-F0-9]{40}$/.test(debouncedAddress)) {
      handleSearch();
    }
  }, [debouncedAddress]);

  const handleChainSelect = (chainId) => {
    console.log('[NFTLayout] Chain selected:', chainId);
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    console.log('[NFTLayout] E280 button clicked, selectedChain:', selectedChain);
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  const handleCollectionClick = (name, href) => {
    console.log(`[NFTLayout] Collection button clicked: ${name}, href: ${href}`);
    setShowE280Message(false);
  };

  if (!isClient) {
    return (
      <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
        <h1 className="title mb-8">TitanX NFT Protocols</h1>
        <p>Loading...</p>
      </div>
    );
  }

  return (
    <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
      <h1 className="title mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value.trim())}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="search-input"
            disabled={searchLoading}
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`btn btn-primary ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-error mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`btn btn-secondary ${
              selectedChain === chain.id ? 'bg-blue-500 text-gray-100' : ''
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => handleCollectionClick(nft.name, nft.href)}
                className="btn btn-secondary w-full"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) =>
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => handleCollectionClick(nft.name, nft.href)}
                  className="btn btn-secondary w-full"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="btn btn-secondary flex-1 w-full"
              >
                {nft.name}
              </motion.button>
            )
          )}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-gray-100">
          <p className="text-body">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      <SearchResultsModal
        searchResult={searchResults}
        searchAddress={searchAddress}
        closeModal={() => setIsModalOpen(false)}
        handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        isOpen={isModalOpen}
        isLoading={searchLoading}
      />

      <div className="w-full max-w-6xl mt-6">{children}</div>
    </div>
  );
}-e 
---
File: ./components/NFTSummary.js
// File: components/NFTSummary.js

'use client';

import { useState, useEffect } from 'react';
import config from '@/config';

export default function NFTSummary({ collectionsData }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return <div>Loading...</div>;
  }

  return (
    <div className="space-y-section w-full max-w-6xl">
      {collectionsData.map(({ apiKey, data }) => (
        <div key={apiKey} className="card">
          <h2 className="subtitle">{config.contractDetails[apiKey]?.name || apiKey}</h2>
          {data.error ? (
            <p className="text-error">{data.error}</p>
          ) : (
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Tokens:</strong> {data.totalTokens?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Holders:</strong> {data.holders?.length || 0}
                </p>
              </div>
              {data.totalLockedAscendant > 0 && (
                <p>
                  <strong>Total Locked Ascendant:</strong>{' '}
                  {data.totalLockedAscendant?.toLocaleString() || 'N/A'}
                </p>
              )}
              {data.pendingRewards > 0 && (
                <p>
                  <strong>Pending Rewards:</strong>{' '}
                  {data.pendingRewards?.toLocaleString() || 'N/A'}
                </p>
              )}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}-e 
---
File: ./components/LoadingIndicator.js
import { memo } from 'react';

function LoadingIndicator({ status, progress }) {
  return (
    <div className="flex flex-col items-center justify-center p-6 bg-gray-800 rounded-lg">
      <svg className="animate-spin h-8 w-8 text-blue-500" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z" />
      </svg>
      <p className="mt-4 text-gray-200">{status}</p>
      {progress && (
        <div className="mt-2 w-64 bg-gray-700 rounded-full h-2.5">
          <div
            className="bg-blue-600 h-2.5 rounded-full"
            style={{ width: `${progress.progressPercentage}%` }}
          />
        </div>
      )}
    </div>
  );
}

export default memo(LoadingIndicator);-e 
---
File: ./components/NFTPage.js
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from '@/components/LoadingIndicator';
import config from '@/config.js';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { useNFTStore } from '@/app/store';
import { barChartOptions } from '@/lib/chartOptions';
import { retry } from '@/app/api/utils/helpers.js'; // Updated import
import { clientLogger } from '@/lib/clientLogger.js';

// Dynamically import chart component
const Bar = dynamic(() => import('react-chartjs-2').then(mod => mod.Bar), { ssr: false });

// Default timeout for fetches
const DEFAULT_TIMEOUT_MS = 30000; // 30 seconds


// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = config.contractAddresses.element280.address;
  const vaultAddress = config.vaultAddresses.element280.address;
  clientLogger.info('NFTPage', `Fetching contract data for Element280: contract=${contractAddress}, vault=${vaultAddress}`);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }
  if (!config.alchemy.apiKey) {
    throw new Error('Alchemy API key not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`, { timeout: Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS }),
  });

  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'totalSupply' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: config.abis.element280.vault, functionName: 'totalRewardPool' },
        ],
      })
    );
    clientLogger.info(`[NFTPage] [DEBUG] multicall results: ${JSON.stringify(results, (k, v) => (typeof v === 'bigint' ? v.toString() : v), 2)}`);
    const [totalSupply, tierCounts, multiplierPool, totalRewardPool] = results;
    if (totalSupply.status === 'failure') {
      throw new Error(`totalSupply call failed: ${totalSupply.error}`);
    }
    if (tierCounts.status === 'failure' || !tierCounts.result) {
      console.warn(`[NFTPage] [WARN] getTotalNftsPerTiers failed or returned no data: ${tierCounts.error || 'empty result'}`);
    }
    if (multiplierPool.status === 'failure' || !multiplierPool.result) {
      console.warn(`[NFTPage] [WARN] multiplierPool failed or returned no data: ${multiplierPool.error || 'empty result'}`);
    }
    if (totalRewardPool.status === 'failure') {
      throw new Error(`totalRewardPool call failed: ${totalRewardPool.error}`);
    }

    let burnedDistribution = [0, 0, 0, 0, 0, 0];
    let totalBurned = 0;
    try {
      const res = await fetch('/api/holders/Element280/validate-burned', { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
      if (res.ok) {
        const reader = res.body.getReader();
        let events = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line);
          for (const line of lines) {
            const data = JSON.parse(line);
            if (data.event) {
              const tier = data.event.tier;
              if (tier >= 1 && tier <= 6) {
                burnedDistribution[tier - 1]++;
              }
            }
            if (data.complete) {
              events = data.result.events;
              totalBurned = data.result.burnedCount;
            }
          }
        }
        clientLogger.info(`[NFTPage] [DEBUG] Burned distribution: ${burnedDistribution}, total events: ${events.length}, totalBurned: ${totalBurned}`);
      } else {
        console.error(`[NFTPage] [ERROR] Failed to fetch burned distribution: ${res.status}`);
      }
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Burned distribution fetch error: ${err.message}, stack: ${err.stack}`);
    }

    return {
      totalMinted: Number(totalSupply.result) + totalBurned,
      totalBurned,
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.status === 'success' && tierCounts.result ? tierCounts.result.map(Number) : [0, 0, 0, 0, 0, 0],
      multiplierPool: multiplierPool.status === 'success' && multiplierPool.result ? Number(multiplierPool.result) : 0,
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution,
    };
  } catch (error) {
    console.error(`[NFTPage] [ERROR] fetchContractData failed: ${error.message}, stack: ${error.stack}`);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  clientLogger.info(`[NFTPage] [INFO] Received props: chain=${chain}, contract=${contract}`);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [isInvalidContract, setIsInvalidContract] = useState(false);
  const [isClient, setIsClient] = useState(false);

  // Call useNFTStore unconditionally
  const { getCache, setCache } = useNFTStore();
  // Use useMemo to stabilize effectiveGetCache and effectiveSetCache
  const effectiveGetCache = useMemo(() => (isClient ? getCache : () => null), [isClient, getCache]);
  const effectiveSetCache = useMemo(() => (isClient ? setCache : () => {}), [isClient, setCache]);

  useEffect(() => {
    setIsClient(true);
  }, []);

  const contractId = contract ? contract.toLowerCase() : null;
  clientLogger.info(`[NFTPage] [INFO] Derived contractId: ${contractId}`);

  const contractConfig = config.contractDetails[contractId] || {};
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  const fetchData = useCallback(async () => {
    if (!apiEndpoint) {
      console.error(`[NFTPage] [ERROR] Invalid contract configuration for ${contractId}`);
      setError('Invalid contract configuration');
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      let progressData = { isPopulating: false, phase: 'Idle', progressPercentage: 0, totalOwners: 0 };
      if (isElement280) {
        try {
          clientLogger.info(`[NFTPage] [INFO] Fetching progress from ${apiEndpoint}/progress`);
          const res = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
          if (!res.ok) {
            console.error(`[NFTPage] [ERROR] Progress fetch failed: ${res.status}`);
          } else {
            progressData = await res.json();
            if (progressData.totalOwners === 0 && progressData.phase === 'Idle') {
              clientLogger.info(`[NFTPage] [INFO] Stale progress, triggering cache refresh`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              const retryRes = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
              if (retryRes.ok) progressData = await retryRes.json();
            }
          }
        } catch (err) {
          console.error(`[NFTPage] [ERROR] Progress fetch error: ${err.message}, stack: ${err.stack}`);
        }
        setProgress(progressData);
      }

      const cacheKey = `contract_data_${contractId}`;
      const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
      if (cachedData && cachedData.totalMinted > 0) {
        console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      let contractData;
      if (isElement280) {
        contractData = await fetchContractData();
      } else {
        contractData = {
          totalMinted: 0,
          totalBurned: 0,
          totalLive: 0,
          tierDistribution: [0, 0, 0, 0, 0, 0],
          multiplierPool: 0,
          totalRewardPool: 0,
          burnedDistribution: [0, 0, 0, 0, 0, 0],
        };
        clientLogger.info(`[NFTPage] [INFO] Using placeholder data for non-Element280 contract: ${contractId}`);
      }

      if (isClient) {
        effectiveSetCache(cacheKey, contractData);
      }
      setData(contractData);
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isElement280, isClient, effectiveGetCache, effectiveSetCache, name]);

  const fetchAllHolders = useCallback(async () => {
    const cacheKey = `holders_${contractId}`;
    const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
    if (cachedData) {
      clientLogger.info(`[NFTPage] [INFO] Cache hit for ${cacheKey}, holders: ${cachedData.holders.length}`);
      setData(prev => ({ ...prev, holders: cachedData.holders, summary: cachedData.summary }));
      setLoading(false);
      return;
    }
    clientLogger.info(`[NFTPage] [INFO] Cache miss for ${cacheKey}, fetching holders`);

    try {
      clientLogger.info(`[NFTPage] [INFO] Starting holders fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || config.contractDetails[contractId]?.pageSize;

      let progressData = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) }).then(res => res.json()).catch(() => ({}));
      if (progressData.phase === 'Idle' || progressData.totalOwners === 0) {
        clientLogger.info(`[NFTPage] [INFO] Cache is Idle or empty, triggering POST`);
        await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
      }

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            clientLogger.info(`[NFTPage] [INFO] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[NFTPage] [ERROR] Fetch failed for ${url}: ${res.status} - ${errorText}`);
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            clientLogger.info(`[NFTPage] [DEBUG] API response for ${url}: holders=${json.holders?.length}, totalTokens=${json.totalTokens}`);
            if (json.error) {
              console.error(`[NFTPage] [ERROR] API error for ${url}: ${json.error}`);
              throw new Error(json.error);
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              console.error(`[NFTPage] [ERROR] Invalid holders data for ${url}: ${JSON.stringify(json, null, 2)}`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              throw new Error(`Invalid holders data: retrying after POST`);
            }
            const newHolders = json.holders;
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            totalClaimableRewards = json.totalClaimableRewards || totalClaimableRewards;
            totalInfernoRewards = json.totalInfernoRewards || totalInfernoRewards;
            totalFluxRewards = json.totalFluxRewards || totalFluxRewards;
            totalE280Rewards = json.totalE280Rewards || totalE280Rewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            if (!newHolders.length && json.totalPages === 0) {
              clientLogger.info(`[NFTPage] [INFO] Empty holders with zero pages, accepting as valid`);
              break;
            }
          } catch (err) {
            attempts++;
            console.error(`[NFTPage] [ERROR] Attempt ${attempts}/${maxAttempts} failed for page ${page}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page} after ${maxAttempts} attempts: ${err.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs * attempts));
          }
        }
      }

      const holdersData = {
        holders: allHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      clientLogger.info(`[NFTPage] [INFO] Fetched ${allHolders.length} holders for ${contractId}`);
      if (isClient) {
        effectiveSetCache(cacheKey, holdersData);
      }
      setData(prev => ({ ...prev, ...holdersData }));
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Holders fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isClient, effectiveGetCache, effectiveSetCache, name, pageSize]);

  useEffect(() => {
    if (!contractId || !config.contractDetails[contractId]) {
      console.error(`[NFTPage] [ERROR] Invalid or missing contract: chain=${chain}, contract=${contract}`);
      setIsInvalidContract(true);
      setLoading(false);
    } else if (disabled) {
      clientLogger.info(`[NFTPage] [INFO] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    } else {
      setIsInvalidContract(false);
      fetchData();
      fetchAllHolders();
    }
  }, [contractId, chain, contract, disabled, name, fetchData, fetchAllHolders]);

  if (!isClient) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{name || 'Unknown Contract'} Holders</h1>
        <p>Loading...</p>
      </div>
    );
  }

  const HolderTable = holderTableComponents[contractId] || null;

  const chartData = data && isElement280 ? {
    labels: ['Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Tier 5', 'Tier 6'],
    datasets: [
      {
        label: 'Live NFTs',
        data: data.tierDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(96, 165, 250, 0.6)', // text-blue-400
      },
      {
        label: 'Burned NFTs',
        data: data.burnedDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(248, 113, 113, 0.6)', // text-red-400
      },
    ],
  } : null;

  if (isInvalidContract) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">Invalid Contract</h1>
        <p className="text-error text-lg">
          The contract "{contractId || 'none specified'}" is not supported.
        </p>
      </motion.div>
    );
  }

  if (!HolderTable) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-error text-lg">
          Error: Holder table component for {contractId} not found.
        </p>
      </motion.div>
    );
  }

  // Define props for each HolderTable component
  const holderTableProps = {
    e280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    ascendant: { holders: data?.holders || [], loading, totalShares: data?.totalShares || 0, totalTokens: data?.totalTokens || 0, rewardToken },
    element280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    element369: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    stax: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
  };

  return (
    <div className="container page-content">
      <motion.h1
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="title mb-6"
      >
        {name || 'Unknown Contract'} Holders
      </motion.h1>

      <AnimatePresence>
        {loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="card text-center-section"
          >
            <LoadingIndicator
              status={`Loading ${name} data... ${
                isElement280 ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''
              }`}
              progress={progress}
            />
          </motion.div>
        )}
      </AnimatePresence>

      {error && (
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
          className="text-error text-lg mb-6 text-center"
        >
          {error}
        </motion.p>
      )}

      {!loading && !error && data && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="space-y-section"
        >
          <div className="card">
            <h2 className="subtitle mb-4">Contract Summary</h2>
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Minted:</strong> {data.totalMinted?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Live:</strong> {data.totalLive?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Burned:</strong> {data.totalBurned?.toLocaleString() || 'N/A'}
                </p>
              </div>
              <div>
                <p>
                  <strong>Multiplier Pool:</strong>{' '}
                  {data.multiplierPool?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Reward Pool:</strong>{' '}
                  {data.totalRewardPool?.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  }) || 'N/A'}{' '}
                  {rewardToken}
                </p>
                <p>
                  <strong>Total Holders:</strong>{' '}
                  {progress.totalOwners?.toLocaleString() || 'N/A'}
                </p>
              </div>
            </div>
            {isElement280 && (
              <div className="mt-6">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowChart(!showChart)}
                  className="btn btn-primary"
                >
                  {showChart ? 'Hide Tier Distribution' : 'Show Tier Distribution'}
                </motion.button>
                <AnimatePresence>
                  {showChart && chartData && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      transition={{ duration: 0.3 }}
                      className="chart-container mt-6"
                    >
                      <Bar data={chartData} options={barChartOptions} />
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            )}
          </div>

          <div className="card">
            <h2 className="subtitle mb-4">Holders</h2>
            <HolderTable {...holderTableProps[contractId]} />
          </div>
        </motion.div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
// File: components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import config from '@/config';

// Loading components
const Element280Loading = () => <div className="text-body">Loading Element280 data...</div>;
Element280Loading.displayName = 'Element280Loading';

const Element369Loading = () => <div className="text-body">Loading Element369 data...</div>;
Element369Loading.displayName = 'Element369Loading';

const StaxNFTLoading = () => <div className="text-body">Loading Stax data...</div>;
StaxNFTLoading.displayName = 'StaxNFTLoading';

const AscendantNFTLoading = () => <div className="text-body">Loading Ascendant data...</div>;
AscendantNFTLoading.displayName = 'AscendantNFTLoading';

const E280Loading = () => <div className="text-body">Loading E280 data...</div>;
E280Loading.displayName = 'E280Loading';

// Fallback components
const Element280Fallback = () => <div className="text-error">Error loading data for Element280</div>;
Element280Fallback.displayName = 'Element280ErrorFallback';

const Element369Fallback = () => <div className="text-error">Error loading data for Element369</div>;
Element369Fallback.displayName = 'Element369ErrorFallback';

const StaxNFTFallback = () => <div className="text-error">Error loading data for Stax</div>;
StaxNFTFallback.displayName = 'StaxNFTErrorFallback';

const AscendantNFTFallback = () => <div className="text-error">Error loading data for Ascendant</div>;
AscendantNFTFallback.displayName = 'AscendantNFTErrorFallback';

const E280Fallback = () => <div className="text-error">Error loading data for E280</div>;
E280Fallback.displayName = 'E280ErrorFallback';

const holderTableComponents = {
  element280: dynamic(
    () => import('@/components/HolderTable/Element280').catch((err) => {
      console.error('Failed to load Element280 HolderTable:', err);
      return { default: Element280Fallback };
    }),
    { ssr: false, loading: Element280Loading }
  ),
  element369: dynamic(
    () => import('@/components/HolderTable/Element369').catch((err) => {
      console.error('Failed to load Element369 HolderTable:', err);
      return { default: Element369Fallback };
    }),
    { ssr: false, loading: Element369Loading }
  ),
  stax: dynamic(
    () => import('@/components/HolderTable/Stax').catch((err) => {
      console.error('Failed to load Stax HolderTable:', err);
      return { default: StaxNFTFallback };
    }),
    { ssr: false, loading: StaxNFTLoading }
  ),
  ascendant: dynamic(
    () => import('@/components/HolderTable/Ascendant').catch((err) => {
      console.error('Failed to load Ascendant HolderTable:', err);
      return { default: AscendantNFTFallback };
    }),
    { ssr: false, loading: AscendantNFTLoading }
  ),
  e280: dynamic(
    () => import('@/components/HolderTable/E280').catch((err) => {
      console.error('Failed to load E280 HolderTable:', err);
      return { default: E280Fallback };
    }),
    { ssr: false, loading: E280Loading }
  ),
};

Object.keys(holderTableComponents).forEach((key) => {
  holderTableComponents[key].displayName = `${key}HolderTable`;
});

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick, isOpen, isLoading }) {
  if (!isOpen) return null;

  console.log('[SearchResultsModal] Props:', { searchResult, searchAddress, isOpen, isLoading });

  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  const collections = Object.keys(config.nftContracts)
  .filter((key) => !config.nftContracts[key].disabled)
  .map((key) => ({
    apiKey: key,
    name: config.nftContracts[key].name,
  }));

  if (isLoading) {
    return (
      <div className="modal-overlay" onClick={handleBackgroundClick}>
        <motion.div
          className="card w-full max-w-4xl max-h-[90vh] overflow-y-auto border-gray-700 p-6"
          variants={modalVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={(e) => e.stopPropagation()}
        >
          <p className="text-body">Loading search results...</p>
        </motion.div>
      </div>
    );
  }

  if (!searchResult || Object.keys(searchResult).length === 0) {
    return (
      <div className="modal-overlay" onClick={handleBackgroundClick}>
        <motion.div
          className="card w-full max-w-4xl max-h-[90vh] overflow-y-auto border-gray-700 p-6"
          variants={modalVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          onClick={(e) => e.stopPropagation()}
        >
          <div className="flex justify-between items-center mb-4">
            <h2 className="subtitle">Search Error</h2>
            <button onClick={closeModal} className="text-gray-300 hover:text-gray-100 text-2xl">
              ×
            </button>
          </div>
          <p className="text-error">No search results available. Please try again.</p>
        </motion.div>
      </div>
    );
  }

  return (
    <div className="modal-overlay" onClick={handleBackgroundClick}>
      <motion.div
        className="card w-full max-w-4xl max-h-[90vh] overflow-y-auto border-gray-700 p-6"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="subtitle">
            {searchAddress
              ? `NFT Ownership for ${searchAddress.slice(0, 6)}...${searchAddress.slice(-4)}`
              : 'NFT Ownership'}
          </h2>
          <button onClick={closeModal} className="text-gray-300 hover:text-gray-100 text-2xl">
            ×
          </button>
        </div>

        <div className="space-y-section">
          {collections.map(({ apiKey, name }) => {
            const data = searchResult[apiKey];
            console.log(`[SearchResultsModal] Collection ${apiKey} data:`, data);
            const HolderTable = holderTableComponents[apiKey] || (() => <div>Holder table not found for ${apiKey}</div>);
            return (
              <div key={apiKey} className="border-b border-gray-700 pb-4">
                <h3 className="subtitle mb-2">{name}</h3>
                {data === null || data === undefined ? (
                  <p className="text-body">No NFTs owned in this collection.</p>
                ) : data?.error ? (
                  <p className="text-error">Error: {data.error}</p>
                ) : data?.message ? (
                  <p className="text-body">{data.message}</p>
                ) : (
                  <HolderTable
                    holders={data.holders?.map((holder) => ({
                      ...holder,
                      wallet: holder.wallet || holder.address || holder.ownerAddress || '',
                    })) || []}
                    contract={apiKey}
                    loading={false}
                    totalTokens={data.totalTokens || data.totalBurned || 0}
                    totalShares={data.totalShares || data.totalBurned || 0}
                    rewardToken={config.contractDetails[apiKey]?.rewardToken || 'Unknown'}
                  />
                )}
              </div>
            );
          })}
        </div>
      </motion.div>
    </div>
  );
}-e 
---
File: ./components/NFTPageWrapper.js
// File: components/NFTPageWrapper.js

'use client';

import { useState, useEffect } from 'react';
import HolderTable from './HolderTable';

export default function NFTPageWrapper({ chain, contract, data, rewardToken }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return (
      <div>
        <p>Loading...</p>
      </div>
    );
  }

  if (!data || data.error) {
    return (
      <div>
        <p className="text-error">
          {data?.error || 'Failed to load collection data'}
        </p>
      </div>
    );
  }

  return (
    <HolderTable
      chain={chain}
      contract={contract}
      holders={data.holders}
      totalTokens={data.totalTokens}
      totalShares={data.totalShares}
      rewardToken={rewardToken}
      totalBurned={data.totalBurned}
    />
  );
}-e 
---
File: ./components/Navbar.jsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { CurrencyDollarIcon } from '@heroicons/react/24/solid';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);
  const pathname = usePathname();

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10, scale: 0.95 },
    visible: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.2 } },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0, transition: { duration: 0.2 } },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining', icon: CurrencyDollarIcon },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [{ name: 'E280', href: '/nft/BASE/E280' }],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="nav bg-gray-800 text-white">
      <div className="nav-container">
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="nav-logo"
        >
          <Link href="/" className="nav-link">
            TitanXUtils
          </Link>
        </motion.div>

        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative group"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Link
                href={item.href}
                className={`nav-link flex items-center space-x-1 ${
                  pathname === item.href ? 'text-orange-500' : 'text-gray-300 hover:text-orange-500'
                }`}
              >
                {item.icon && <item.icon className="h-5 w-5" />}
                <span>{item.name}</span>
              </Link>
              {item.subItems && (
                <motion.div
                  className="nav-dropdown opacity-0 group-hover:opacity-100 group-hover:mt-3 transition-all duration-200 pointer-events-none group-hover:pointer-events-auto bg-gray-700 text-white"
                  variants={dropdownVariants}
                  initial="hidden"
                  animate="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="nav-dropdown-item font-semibold">{subItem.name}</div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <Link
                              key={nestedItem.name}
                              href={nestedItem.href}
                              className="nav-dropdown-item hover:text-orange-500"
                            >
                              {nestedItem.name}
                            </Link>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
          {/* Removed theme toggle button */}
        </div>

        <button
          className="md:hidden p-2 focus:outline-none text-gray-300 hover:text-white"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2 px-4"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="nav-dropdown-item"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer text-gray-300 hover:text-orange-500"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      <span>{item.name}</span>
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                          transition={{ duration: 0.2 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2 text-gray-300 font-semibold">
                              {subItem.name}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <Link
                                    key={nestedItem.name}
                                    href={nestedItem.href}
                                    className="nav-dropdown-item hover:text-orange-500"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    {nestedItem.name}
                                  </Link>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : (
                  <Link
                    href={item.href}
                    className={`block flex items-center space-x-1 ${
                      pathname === item.href ? 'text-orange-500' : 'text-gray-300 hover:text-orange-500'
                    }`}
                    onClick={() => setIsOpen(false)}
                  >
                    {item.icon && <item.icon className="h-5 w-5" />}
                    <span>{item.name}</span>
                  </Link>
                )}
              </motion.div>
            ))}
            {/* Removed theme toggle button */}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./components/HolderTable/E280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const e280TierOrder = [
    { tierId: '1', name: 'Common' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '6', name: 'Legendary Amped' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {e280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {e280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.e280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for E280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {e280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {e280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/index.js
// components/HolderTable/index.js
'use client';

import Element280 from './Element280';
import Element369 from './Element369';
import Stax from './Stax';
import Ascendant from './Ascendant';
import E280 from './E280';

const HolderTable = ({ chain, contract, holders, totalTokens, totalShares, rewardToken, totalBurned }) => {
  const components = {
    element280: Element280,
    element369: Element369,
    stax: Stax,
    ascendant: Ascendant,
    e280: E280,
  };

  const TableComponent = components[contract];
  if (!TableComponent) {
    return <div>Invalid contract: {contract}</div>;
  }

  return (
    <TableComponent
      chain={chain}
      holders={holders}
      totalTokens={totalTokens}
      totalShares={totalShares}
      rewardToken={rewardToken}
      totalBurned={totalBurned}
    />
  );
};

export default HolderTable;-e 
---
File: ./components/HolderTable/Ascendant.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Ascendant] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) ||
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) ||
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) ||
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 8) {
        console.warn('[Ascendant] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 8');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
          <p><strong>Total Shares:</strong> {totalShares?.toLocaleString() || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="table-cell">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Stax.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const staxTierOrder = [
    { tierId: '12', name: 'Legendary LFG', index: 11 },
    { tierId: '11', name: 'Legendary Super', index: 10 },
    { tierId: '10', name: 'Legendary Amped', index: 9 },
    { tierId: '9', name: 'Legendary', index: 8 },
    { tierId: '8', name: 'Rare LFG', index: 7 },
    { tierId: '7', name: 'Rare Super', index: 6 },
    { tierId: '6', name: 'Rare Amped', index: 5 },
    { tierId: '5', name: 'Rare', index: 4 },
    { tierId: '4', name: 'Common LFG', index: 3 },
    { tierId: '3', name: 'Common Super', index: 2 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0x15702443110894B26911B913b17ea4931F803B02';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Stax] Holder Data for Wallet:', targetHolder);
      console.log('[Stax] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Stax] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = staxTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && Number(targetHolder.tiers[Number(tier.tierId) - 1]) || 0);
        return { tier: tier.name, count };
      });
      console.log('[Stax] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Stax] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      const multipliers = {
        '12': 200, '11': 140, '10': 120, '9': 100, '8': 20, '7': 14, '6': 12, '5': 10,
        '4': 2, '3': 1.4, '2': 1.2, '1': 1
      };
      const expectedMultiplierSum = tierCounts.reduce((sum, { count }, idx) => {
        const tierId = staxTierOrder[idx].tierId;
        return sum + count * multipliers[tierId];
      }, 0);
      console.log('[Stax] Multiplier Sum:', {
        actual: targetHolder.multiplierSum,
        expected: expectedMultiplierSum
      });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 12) {
        console.warn('[Stax] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 12');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Stax] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
      if (targetHolder.multiplierSum !== expectedMultiplierSum) {
        console.warn('[Stax] Warning: Multiplier sum mismatch for wallet', targetWallet, {
          actual: targetHolder.multiplierSum,
          expected: expectedMultiplierSum
        });
      }
    } else {
      console.warn('[Stax] Warning: Wallet not found in holders:', targetWallet);
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {staxTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {staxTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.stax;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Stax.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {staxTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.multiplierSum === 'number' ? holder.multiplierSum.toFixed(2) : '-'}
              </td>
              {staxTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? Number(holder.tiers[Number(tier.tierId) - 1]) || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element369.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

const element369TierOrder = config.contractTiers.element369.tierOrder || [
  { tierId: '3', name: 'Legendary' },
  { tierId: '2', name: 'Rare' },
  { tierId: '1', name: 'Common' },
];

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">E280 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element369TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element369TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element369;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element369.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Flux Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">E280 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element369TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="reward-cell">
                {(holder.infernoRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.fluxRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.e280Rewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {(holder.percentage || 0).toFixed(2)}%
              </td>
              <td className="table-cell">
                {(holder.multiplierSum || 0).toFixed(2)}
              </td>
              {element369TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? holder.tiers[Number(tier.tierId) - 1] || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const element280TierOrder = [
    { tierId: '6', name: 'Legendary Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '1', name: 'Common' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {element280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts*.sqlite
*.db
output.txt
scripts/backups/
.env*.local

cache_*.json
burned_events_*.json-e 
---
File: ./testcontract.js
// testContract.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import staxMainAbi from './abi/staxNFT.json' with { type: 'json' };
import pLimit from 'p-limit';

const limit = pLimit(5); // Limit concurrent requests to 5
const client = createPublicClient({
  chain: mainnet,
  transport: http('https://eth-mainnet.g.alchemy.com/v2/rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI', { timeout: 60000 }),
});

async function retry(fn, retries = 3, delayMs = 1000) {
  let lastError;
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      console.error(`Retry ${i + 1}/${retries} failed for ${fn.name || 'fn'}: ${error.message}`);
      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }
  throw lastError;
}

async function test() {
  try {
    // Fetch totalSupply
    const totalSupply = await retry(async () => {
      const result = await client.readContract({
        address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
        abi: staxMainAbi,
        functionName: 'totalSupply',
      });
      console.log('Total Supply:', result);
      return result;
    });
    
    // Fetch totalBurned
    const burnedCount = await retry(async () => {
      const result = await client.readContract({
        address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
        abi: staxMainAbi,
        functionName: 'totalBurned',
      });
      console.log('Burned Count:', result);
      return result;
    });

    // Fetch tiers for all token IDs
    console.log('Fetching tiers for all tokens...');
    const tokenIds = Array.from({ length: Number(totalSupply) }, (_, i) => i); // tokenId 0 to totalSupply-1
    const tierPromises = tokenIds.map(tokenId =>
      limit(() =>
        retry(async () => {
          try {
            const tier = await client.readContract({
              address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
              abi: staxMainAbi,
              functionName: 'getNftTier',
              args: [tokenId],
            });
            return { tokenId, tier: Number(tier) };
          } catch (error) {
            // Handle non-existent tokens
            if (error.message.includes('OwnerQueryForNonexistentToken')) {
              return { tokenId, tier: null, error: 'Non-existent token' };
            }
            throw error;
          }
        })
      )
    );

    const tiers = await Promise.all(tierPromises);
    
    // Log results
    console.log('\nTier Results:');
    tiers.forEach(({ tokenId, tier, error }) => {
      if (error) {
        console.log(`Token ${tokenId}: ${error}`);
      } else {
        console.log(`Token ${tokenId}: Tier ${tier}`);
      }
    });

    // Summarize tiers
    const tierSummary = tiers.reduce((acc, { tier }) => {
      if (tier !== null) {
        acc[tier] = (acc[tier] || 0) + 1;
      }
      return acc;
    }, {});
    console.log('\nTier Summary:');
    Object.entries(tierSummary).forEach(([tier, count]) => {
      console.log(`Tier ${tier}: ${count} tokens`);
    });

    // Log invalid tiers
    const invalidTiers = tiers.filter(({ tier }) => tier !== null && (tier < 1 || tier > 12));
    if (invalidTiers.length > 0) {
      console.log('\nInvalid Tiers:');
      invalidTiers.forEach(({ tokenId, tier }) => {
        console.log(`Token ${tokenId}: Tier ${tier}`);
      });
    }

  } catch (error) {
    console.error('Error:', error);
  }
}

test();-e 
---
File: ./lib/logger.js
// lib/logger.js
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

// Use process.cwd() to reference the project root
const logDir = path.join(process.cwd(), 'logs');

console.log(chalk.cyan('[Logger] Initializing logger...'));
console.log(chalk.cyan('[Logger] process.env.DEBUG:'), process.env.DEBUG);
console.log(chalk.cyan('[Logger] process.env.NODE_ENV:'), process.env.NODE_ENV);
console.log(chalk.cyan('[Logger] Log directory:'), logDir);

const isDebug = process.env.DEBUG === 'true';
console.log(chalk.cyan('[Logger] isDebug:'), isDebug);

async function ensureLogDir() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log(chalk.cyan('[Logger] Created or verified log directory:'), logDir);
  } catch (error) {
    console.error(chalk.red('[Logger] Failed to create log directory:'), error.message);
  }
}

ensureLogDir().catch(error => {
  console.error(chalk.red('[Logger] ensureLogDir error:'), error.message);
});

export const logger = {
  info: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [INFO] ${message}`;
    console.log(chalk.green(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote INFO log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write INFO log:'), error.message);
      }
    }
  },
  warn: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [WARN] ${message}`;
    console.log(chalk.yellow(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote WARN log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write WARN log:'), error.message);
      }
    }
  },
  error: async (scope, message, details = {}, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [ERROR] ${message} ${JSON.stringify(details)}`;
    console.error(chalk.red(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote ERROR log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write ERROR log:'), error.message);
      }
    }
  },
  debug: async (scope, message, chain = 'eth', collection = 'general') => {
    if (!isDebug) return;
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [DEBUG] ${message}`;
    console.log(chalk.blue(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
      console.log(chalk.cyan('[Logger] Wrote DEBUG log to:'), logFile);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write DEBUG log:'), error.message);
    }
  },
};

try {
  logger.info('startup', 'Logger module loaded').catch(error => {
    console.error(chalk.red('[Logger] Startup log error:'), error.message);
  });
} catch (error) {
  console.error(chalk.red('[Logger] Immediate log error:'), error.message);
}-e 
---
File: ./lib/chartOptions.js
export const barChartOptions = {
    responsive: true,
    plugins: {
      legend: { position: 'top', labels: { color: '#e5e7eb' } }, // Gray-200
      title: {
        display: true,
        text: 'NFT Tier Distribution',
        color: '#e5e7eb',
        font: { size: 16, weight: 'bold' },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: 'Number of NFTs', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' }, // Gray-300
      },
      x: {
        title: { display: true, text: 'Tiers', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' },
      },
    },
  };-e 
---
File: ./lib/schemas.js
// File: lib/schemas.js
import { z } from 'zod';

export const HoldersResponseSchema = z.object({
  holders: z.array(z.object({
    wallet: z.string(),
    total: z.number().optional(),
    tiers: z.array(z.number()).optional(),
    shares: z.number().optional(),
  })),
  totalTokens: z.number().optional(),
  totalShares: z.number().optional(),
  totalBurned: z.number().optional(),
  summary: z.object({}).optional(),
  totalPages: z.number().optional(),
});-e 
---
File: ./lib/clientLogger.js
// lib/clientLogger.js
export const clientLogger = {
    info: (scope, message, chain = 'eth', collection = 'general') => {
      console.log(`[${new Date().toISOString()}] [${scope}] [INFO] ${message}`);
    },
    warn: (scope, message, chain = 'eth', collection = 'general') => {
      console.warn(`[${new Date().toISOString()}] [${scope}] [WARN] ${message}`);
    },
    error: (scope, message, details = {}, chain = 'eth', collection = 'general') => {
      console.error(`[${new Date().toISOString()}] [${scope}] [ERROR] ${message}`, details);
    },
    debug: (scope, message, chain = 'eth', collection = 'general') => {
      if (process.env.DEBUG === 'true') {
        console.log(`[${new Date().toISOString()}] [${scope}] [DEBUG] ${message}`);
      }
    },
  };-e 
---
File: ./lib/fetchCollectionData.js
// lib/fetchCollectionData.js
import config from '@/config';
import { logger } from '@/lib/logger';

export async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  logger.info(`[FetchCollectionData] [INFO] Fetching ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Contract not deployed' };
    }

    let endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;
    
    // Poll /progress until cache is complete
    let progress;
    let attempts = 0;
    const maxAttempts = config.alchemy.maxRetries;
    while (attempts < maxAttempts) {
      try {
        const res = await fetch(`${endpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Progress fetch failed: ${res.status} ${errorText}`);
        }
        progress = await res.json();
        if (progress.phase === 'Idle' || progress.totalOwners === 0) {
          logger.info(`[FetchCollectionData] [INFO] Triggering POST for ${apiKey}`);
          const postRes = await fetch(endpoint, { method: 'POST', cache: 'force-cache' });
          if (!postRes.ok) {
            const errorText = await postRes.text();
            console.error(`[FetchCollectionData] [ERROR] Cache population trigger failed: ${postRes.status} ${errorText}`);
            throw new Error(`Cache population trigger failed: ${postRes.status}`);
          }
        }
        break;
      } catch (error) {
        attempts++;
        console.error(`[FetchCollectionData] [ERROR] Progress fetch attempt ${attempts}/${maxAttempts} failed: ${error.message}`);
        if (attempts >= maxAttempts) {
          return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Failed to fetch cache progress' };
        }
        await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs * attempts));
      }
    }

    const maxPollTime = 60000; // 60 seconds max polling
    const startTime = Date.now();
    while (progress.phase !== 'Completed' && progress.phase !== 'Error') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[FetchCollectionData] [ERROR] Cache population timeout for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Cache population timed out' };
      }
      logger.info(`[FetchCollectionData] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%)`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      const res = await fetch(`${endpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] Progress fetch failed: ${res.status} ${errorText}`);
        return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Failed to fetch cache progress' };
      }
      progress = await res.json();
    }

    if (progress.phase === 'Error') {
      console.error(`[FetchCollectionData] [ERROR] Cache population failed for ${apiKey}: ${progress.error || 'Unknown error'}`);
      return { holders: [], totalTokens: 0, totalBurned: 0, error: `Cache population failed: ${progress.error || 'Unknown error'}` };
    }

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      logger.info(`[FetchCollectionData] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      logger.info(`[FetchCollectionData] [DEBUG] Status: ${res.status}, headers: ${JSON.stringify([...res.headers])}`);

      if (res.status === 202) {
        logger.info(`[FetchCollectionData] [INFO] Cache still populating for ${apiKey}, retrying...`);
        await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
        continue;
      }

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] Failed: ${res.status} ${errorText}`);
        throw new Error(`API request failed: ${res.status}`);
      }

      const json = await res.json();
      logger.info(`[FetchCollectionData] [DEBUG] Response: ${JSON.stringify(json, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);

      if (json.error) {
        console.error(`[FetchCollectionData] [ERROR] API error: ${json.error}`);
        throw new Error(json.error);
      }
      if (!json.holders || !Array.isArray(json.holders)) {
        console.error(`[FetchCollectionData] [ERROR] Invalid holders: ${JSON.stringify(json)}`);
        if (apiKey === 'ascendant') {
          logger.info(`[FetchCollectionData] [INFO] Triggering POST for ${apiKey}`);
          await fetch(endpoint, { method: 'POST', cache: 'force-cache' });
          const retryRes = await fetch(url, { cache: 'no-store' });
          if (!retryRes.ok) {
            const retryError = await retryRes.text();
            console.error(`[FetchCollectionData] [ERROR] Retry failed: ${retryRes.status} ${retryError}`);
            throw new Error(`Retry failed: ${retryRes.status}`);
          }
          const retryJson = await retryRes.json();
          logger.info(`[FetchCollectionData] [DEBUG] Retry response: ${JSON.stringify(retryJson, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);
          if (!retryJson.holders || !Array.isArray(retryJson.holders)) {
            console.error(`[FetchCollectionData] [ERROR] Retry invalid holders: ${JSON.stringify(retryJson)}`);
            throw new Error('Invalid holders data after retry');
          }
          json.holders = retryJson.holders;
          json.totalTokens = retryJson.totalTokens;
          json.totalShares = retryJson.totalShares;
          json.totalBurned = retryJson.totalBurned;
          json.summary = retryJson.summary;
          json.totalPages = retryJson.totalPages;
        } else {
          throw new Error('Invalid holders data');
        }
      }

      allHolders = allHolders.concat(json.holders);
      totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
      totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
      totalBurned = json.totalBurned || totalBurned;
      summary = json.summary || summary;
      totalPages = json.totalPages || 1;
      page++;
      logger.info(`[FetchCollectionData] [INFO] Fetched page ${page}: ${json.holders.length} holders`);
    }

    return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
  } catch (error) {
    console.error(`[FetchCollectionData] [ERROR] ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { holders: [], totalTokens: 0, totalBurned: 0, error: error.message };
  }
}-e 
---
File: ./lib/useNFTData.js
// lib/useNFTData.js
'use client';
import { useQuery } from '@tanstack/react-query';
import { useNFTStore } from '@/app/store';
import config from '@/config';
import { HoldersResponseSchema } from '@/lib/schemas';

async function fetchNFTData(apiKey, apiEndpoint, pageSize, page = 0) {
  if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
    return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Contract not deployed' };
  }

  const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;
  const progressUrl = `${endpoint}/progress`;

  const progressRes = await fetch(progressUrl, { cache: 'no-store' });
  if (!progressRes.ok) throw new Error(`Progress fetch failed: ${progressRes.status}`);
  const progress = await progressRes.json();

  if (progress.isPopulating || progress.phase !== 'Completed') {
    throw new Error('Cache is populating');
  }

  let allHolders = [];
  let totalTokens = 0;
  let totalShares = 0;
  let totalBurned = 0;
  let summary = {};
  let totalPages = Infinity;

  while (page < totalPages) {
    const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error(`API request failed: ${res.status}`);
    const json = await res.json();

    if (json.message === 'Cache is populating' || json.isCachePopulating) {
      throw new Error('Cache is populating');
    }

    const validation = HoldersResponseSchema.safeParse(json);
    if (!validation.success) {
      throw new Error(`Invalid holders schema: ${JSON.stringify(validation.error.errors)}`);
    }

    allHolders = allHolders.concat(json.holders);
    totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
    totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
    totalBurned = json.totalBurned || totalBurned;
    summary = json.summary || summary;
    totalPages = json.totalPages || 1;
    page++;
  }

  return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
}

export function useNFTData(apiKey, pageSize) {
  const { getCache, setCache } = useNFTStore();

  return useQuery({
    queryKey: ['nft', apiKey],
    queryFn: async () => {
      const cachedData = getCache(apiKey);
      if (cachedData) return cachedData;

      const data = await fetchNFTData(apiKey, config.contractDetails[apiKey].apiEndpoint, pageSize);
      setCache(apiKey, data);
      return data;
    },
    retry: config.alchemy.maxRetries,
    retryDelay: attempt => config.alchemy.batchDelayMs * (attempt + 1),
    staleTime: 30 * 60 * 1000, // 30 minutes
    refetchInterval: progress => (progress?.isPopulating ? 2000 : false),
    onError: error => console.error(`[useNFTData] [ERROR] ${apiKey}: ${error.message}`),
  });
}-e 
---
File: ./.env.development.local
# File: .env.local
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
UPSTASH_REDIS_REST_URL=https://splendid-sunbird-26504.upstash.io
UPSTASH_REDIS_REST_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_URL=https://splendid-sunbird-26504.upstash.io
KV_REST_API_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_READ_ONLY_TOKEN=AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg
KV_URL=rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379
PERSIST_CACHE=true
DEBUG=true
LOG_LEVEL=info
USE_FALLBACK_DATA=false
ESLINT_NO_DEV_ERRORS=true
USE_ALCHEMY_FOR_OWNERS=true
NEXT_NO_WORKER_THREADS=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:3000
DISABLE_ELEMENT280_REDIS=false
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true-e 
---
File: ./postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};-e 
---
File: ./README Testing.md
# Testing

## Purpose

The testing suite for `titanx-utility`, a Next.js application for Ethereum NFT contract interactions, ensures the reliability, correctness, and robustness of utility functions in `app/api/utils/` and the `/api/holders/[contract]` endpoint. These utilities handle caching, blockchain interactions, NFT contract operations, and server initialization, supporting endpoints like `/api/holders/[contract]` and `/nft/ETH/Element280`. The tests aim to:
- **Validate Functionality**: Confirm functions (e.g., address validation, cache management, blockchain queries, event fetching) work as expected.
- **Ensure Error Handling**: Test edge cases and errors (e.g., invalid addresses, cache misses, API failures, invalid contract configs).
- **Isolate Dependencies**: Use mocks for external services (e.g., Redis, Alchemy API, viem) for repeatable tests.
- **Support Development**: Provide a maintainable test suite for enhancements and debugging.

## Implementations

The test suite uses **Jest** with **Babel** (`babel-jest`) to transform ES Modules (ESM) syntax, as the project uses `"type": "module"` in `package.json`. Tests are in `tests/utils.test.js`, covering utilities in `app/api/utils/` and the `/api/holders/[contract]` endpoint.

**Modules Tested**:
1. **Helpers (`helpers.js`)**:
   - Functions: `retry`, `isValidAddress`, `normalizeAddress`, `formatNumber`, `timeout`.
   - Purpose: Provides retry logic, Ethereum address validation, formatting, and timeout utilities.
   - Tests: Verify retry behavior, address validation, normalization, number formatting, and timeout errors.
2. **Cache (`cache.js`)**:
   - Functions: `initializeCache`, `setCache`, `getCache`, `saveCacheState`, `loadCacheState`.
   - Purpose: Manages in-memory (`node-cache`), Redis (`@upstash/redis`), and file-based caching for NFT data.
   - Tests: Verify initialization, cache operations, and state persistence using mocked `node-cache`, `@upstash/redis`, and `fs/promises`.
3. **Blockchain (`blockchain.js`)**:
   - Exports: `client` (viem public client), `alchemy` (Alchemy SDK instance).
   - Purpose: Initializes Ethereum/BASE mainnet connections for blockchain queries (BASE support planned, though no BASE contracts are currently analyzed).
   - Tests: Check `client` and `alchemy` initialization.
4. **Contracts (`contracts.js`)**:
   - Functions: `getOwnersForContract`, `getHoldersMap`.
   - Purpose: Fetches NFT contract owners and builds holders maps for `element280`, `ascendant`, `element369`, `stax`, and `e280` contracts.
   - Tests: Validate owner fetching and holders map generation for `element280` and `ascendant` using mocked `alchemy-sdk` and `viem`.
5. **Server Initialization (`serverInit.js`)**:
   - Function: `initServer`.
   - Purpose: Initializes the server by calling `initializeCache` and logging via `logger` from `lib/logger.js`.
   - Tests: Verify `initializeCache` calls and logger output for success/failure cases.
6. **Route (`app/api/holders/[contract]/route.js`)**:
   - Functions: `getCacheState`, `saveCacheStateContract`, `getNewEvents`, `populateHoldersMapCache`, `getHoldersMap`.
   - Purpose: Fetches new transfer/burn events and updates the holders cache with pagination, address filtering, and ascendant-specific metrics (shares, rewards). Supports Ethereum contracts (`element280`, `element369`, `stax`, `ascendant`) and plans to add BASE NFT support (e.g., `e280`, not yet live).
   - Tests: Verify event fetching and cache population for fresh and in-progress states using mocked `viem` and `node-cache`. Validates data saving and retrieval.

**Testing Setup**:
- **Jest Configuration** (`jest.config.js`):
  - Environment: `node`.
  - Module aliases: `@/*` mapped to project root.
  - Transform: `babel-jest` for `.js` files.
  - `transformIgnorePatterns`: Allows ESM transformation for `@upstash/redis`, `viem`, `alchemy-sdk`, `node-cache`, `p-limit`, `chalk`, `yocto-queue`.
- **Babel Configuration** (`.babelrc`):
  - Presets: `@babel/preset-env` with `targets: { node: "current" }` for Node.js v22.15.0.
  - Plugins: `@babel/plugin-transform-modules-commonjs` for ESM support.
- **Mocks**:
  - Mocked: `@/config.js`, `@upstash/redis`, `viem`, `alchemy-sdk`, `node-cache`, `fs/promises`, `chalk`, `p-limit`, `lib/logger.js`, `lib/schemas.js`.
  - Ensures isolation from external services and file operations.

**Challenges Resolved**:
- **ESM Syntax**: Fixed Jest’s handling of ESM imports in `node-cache` and `p-limit` using inline mocks and `transformIgnorePatterns`.
- **Mock Hoisting**: Resolved `ReferenceError: Cannot access 'mockNodeCacheInstance' before initialization` by using inline `node-cache` mocks.
- **Config Imports**: Fixed `Cannot find module '@/config.js'` by using `@/config.js` from the root directory.
- **Test Failures**: Addressed `TypeError` issues in `contracts.js` tests (`Cannot read properties of undefined (reading 'length')` and `transferLogs is not iterable`) with robust checks and updated mocks.
- **Logger Exports**: Restored `logger` export in `app/api/utils/index.js` to support imports in `app/api/holders/[contract]/route.js`.
- **Route Functionality**: Added tests for `getNewEvents` and `populateHoldersMapCache` to cover event fetching and cache updates.
- **Redis Mocking**: Fixed `clearMockRedis` errors with `jest.mock('@upstash/redis')` and ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false`.
- **Config Mocking**: Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()`, and moved `redis` initialization into `initializeCache`.
- **Redis Initialization**: Used `jest.spyOn` for `Redis.fromEnv` to ensure proper mocking.

## Goals

1. **Full Test Coverage**: Achieved for `helpers.js`, `cache.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and key `route.js` functions.
2. **Resolve ESM Issues**: Fixed all ESM-related parsing errors.
3. **Fix Failing Tests**: Address remaining failures in `tests/utils.test.js` for Redis-related tests.
4. **Production Readiness**: Utilities and `/api/holders/[contract]` endpoint support pagination, address filtering, and ascendant-specific metrics.
5. **Documentation**: Consolidated README with comprehensive testing summary.
6. **Redis Testing**: Validate tiny dataset caching (~100 bytes) with Upstash free tier (10,000 requests/day, ~1 MB storage) until production-ready.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. Four tests pass; three Redis-related tests (`initialize node-cache and Redis`, `set and get tiny dataset in Redis when enabled`, `fallback to node-cache on Redis quota exceeded`) fail due to `redisMock.set` not being called, pending `Redis.fromEnv` mock fix.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')` and `tests/__mocks__/@upstash/redis.js`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` for consistent mocks.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Used `jest.spyOn` for `Redis.fromEnv` to address Redis mock issues.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by the utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).

## Next Steps

1. Resolve remaining Redis test failures in `tests/utils.test.js` by ensuring `Redis.fromEnv` mock is correctly applied.
2. Monitor endpoint performance in production, especially for large-scale event fetching.
3. Add tests for additional contracts (`element369`, `stax`, `e280`) and full `route.js` endpoint behavior.
4. Implement BASE NFT support and corresponding tests for `e280` and future BASE contracts.
5. Enhance error logging for better debugging.
6. Validate `HoldersResponseSchema` in production to ensure response consistency.
7. Address npm vulnerabilities (6 moderate, 2 high) with `npm audit fix` and update deprecated packages (e.g., `eslint`, `rimraf`).
8. Investigate `./useful: line 166` error by reviewing the `useful` script.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. Tests currently fail due to `jest.spyOn` error on `Redis.fromEnv`; fixed by reinstating `jest.mock('@upstash/redis')` and removing conflicting `tests/__mocks__/@upstash/redis.js`.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')` and `tests/__mocks__/@upstash/redis.js`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` for consistent mocks.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Replaced `jest.spyOn` with `jest.mock('@upstash/redis')` to fix `fromEnv` property error.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).
- **Redis Testing**: Ongoing, with tiny datasets to ensure compatibility with Upstash free tier. Failures resolved by fixing Redis mock setup.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. Five tests pass; two Redis-related tests (`set and get tiny dataset in Redis when enabled`, `fallback to node-cache on Redis quota exceeded`) fail due to `redisMock.set` not being called, fixed by normalizing `prefix` case in `setCache` and adding debug logging.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` for consistent mocks.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Replaced `jest.spyOn` with `jest.mock('@upstash/redis')` and removed `tests/__mocks__/@upstash/redis.js` to fix `fromEnv` property error.
  - Updated `jest.mock('@upstash/redis')` to export `{ Redis }` for proper `Redis.fromEnv` mocking.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).
- **Redis Testing**: Ongoing, with tiny datasets to ensure compatibility with Upstash free tier. Failures resolved by normalizing prefix case in `cache.js`.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. Five tests pass; two Redis-related tests (`set and get tiny dataset in Redis when enabled`, `fallback to node-cache on Redis quota exceeded`) fail due to `redis` being `null` in `setCache`, fixed by reinitializing `redis` in `setCache` and `getCache` and calling `initializeCache` in `beforeEach`.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` in `beforeAll`.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Replaced `jest.spyOn` with `jest.mock('@upstash/redis')` and removed `tests/__mocks__/@upstash/redis.js` to fix `fromEnv` property error.
  - Updated `jest.mock('@upstash/redis')` to export `{ Redis }` for proper `Redis.fromEnv` mocking.
  - Added `initializeCache` call in `beforeEach` to ensure `redis` persistence.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).
- **Redis Testing**: Ongoing, with tiny datasets to ensure compatibility with Upstash free tier. Failures resolved by reinitializing `redis` and adjusting test setup.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. All tests pass after mocking `redisEnabled` for the skip test and adjusting `redis.set` mocks for the quota test.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` in `beforeAll`.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Replaced `jest.spyOn` with `jest.mock('@upstash/redis')` and removed `tests/__mocks__/@upstash/redis.js` to fix `fromEnv` property error.
  - Updated `jest.mock('@upstash/redis')` to export `{ Redis }` for proper `Redis.fromEnv` mocking.
  - Added `initializeCache` call in `beforeEach` to ensure `redis` persistence.
  - Mocked `redisEnabled` and `redis.set` to fix `should skip Redis` and `quota exceeded` tests.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).
- **Redis Testing**: Completed, with tiny datasets ensuring compatibility with Upstash free tier. All test failures resolved.

## Current Status

As of May 02, 2025, `tests/utils.test.js` contains 7 tests for caching in `app/api/utils/cache.js`:
- **Cache Tests**: Tests for `node-cache` (primary) and Redis Upstash (secondary) using tiny datasets (~100 bytes) to respect Upstash free tier limits (10,000 requests/day, ~1 MB storage). Verifies `node-cache` reliability, Redis persistence (controlled by `UPSTASH_REDIS_REST_URL`, `UPSTASH_REDIS_REST_TOKEN`, and `DISABLE_<CONTRACT>_REDIS`), and fallback on quota errors. All tests pass after fixing `jest.spyOn` error and refining `redis.set` mocks for the quota test.
- **Modularization**: Added `app/api/utils/multicall.js` for `batchMulticall` and `app/api/utils/abis.js` for ABIs. Retained `app/api/utils.js` for reference.
- **Jest Fixes**:
  - Refactored `tests/utils.test.js` to use `import` for ESM compatibility.
  - Fixed `clearMockRedis` error with `jest.mock('@upstash/redis')`.
  - Corrected `@/config` mocking to return `mockConfig` directly, added `jest.resetModules()` in `beforeAll`.
  - Updated `jest.config.js` to use `export default` and fixed `moduleNameMapper` for `@/lib/logger.js`.
  - Removed invalid `extensionsToTreatAsEsm` from `jest.config.js`.
  - Ensured `redisEnabled` by setting `config.cache.redis.disableElement280: false` and moving `redis` initialization into `initializeCache`.
  - Replaced `jest.spyOn` with `jest.mock('@upstash/redis')` and removed `tests/__mocks__/@upstash/redis.js` to fix `fromEnv` property error.
  - Updated `jest.mock('@upstash/redis')` to export `{ Redis }` for proper `Redis.fromEnv` mocking.
  - Added `initializeCache` call in `beforeEach` to ensure `redis` persistence.
  - Fixed `jest.spyOn` error in `should skip Redis` test by directly modifying `process.env`.
  - Refined `redis.set` mocks to fix `should fallback to node-cache on Redis quota exceeded` test.
- **Endpoints**:
  - `/api/holders/[contract]` (e.g., `/api/holders/element280`, `/api/holders/ascendant`) returns cached or freshly fetched holder data with pagination and address filtering.
  - `/nft/ETH/Element280` (and similar) endpoints are supported by utility functions.
  - Responses include holder details, total burned, shares, and rewards (for `ascendant`), validated by `HoldersResponseSchema`.
- **Other Tests**: Existing tests for `helpers.js`, `blockchain.js`, `contracts.js`, `serverInit.js`, and `route.js` remain, with some potentially failing (to be checked).
- **Redis Testing**: Completed, with tiny datasets ensuring compatibility with Upstash free tier. All test failures resolved.