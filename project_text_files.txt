-e 
---
File: ./tailwind.config.js


/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};

-e 
---
File: ./.env.local
# File: .env.local
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
UPSTASH_REDIS_REST_URL=https://splendid-sunbird-26504.upstash.io
UPSTASH_REDIS_REST_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_URL=https://splendid-sunbird-26504.upstash.io
KV_REST_API_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_READ_ONLY_TOKEN=AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg
KV_URL=rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379
PERSIST_CACHE=true
DEBUG=true
LOG_LEVEL=info
USE_FALLBACK_DATA=false
ESLINT_NO_DEV_ERRORS=true
USE_ALCHEMY_FOR_OWNERS=true
NEXT_NO_WORKER_THREADS=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:3000
DISABLE_ELEMENT280_REDIS=true
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true-e 
---
File: ./app/layout.js
// File: app/layout.js

import Navbar from '@/components/Navbar';
import '@/app/global.css'; // Target global.css in app directory
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'TitanXUtils',
  description: 'TitanX ecosystem utilities',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en" className="bg-gray-900 text-gray-100">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={inter.className}>
        <Navbar />
        <main className="flex-grow container page-content">{children}</main>
        <footer className="footer">
          <p>© {new Date().getFullYear()} TitanXUtils. All rights reserved.</p>
        </footer>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js

'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-gray-100">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-body">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, mining, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-green-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-green-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/mining">Mining</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
// File: app/nft/layout.js
'use client';
import Navbar from '@/components/Navbar';
import NFTLayoutWrapper from '@/components/NFTLayoutWrapper';
import '@/app/global.css'; // Target global.css in app directory
import { Inter } from 'next/font/google';
import { Suspense } from 'react';

const inter = Inter({ subsets: ['latin'] });

export default function NFTLayout({ children }) {
  return (
    <NFTLayoutWrapper>
      <main className={`flex-grow container page-content ${inter.className}`}>
        <Suspense fallback={<div>Loading...</div>}>
          {children}
        </Suspense>
      </main>
      <footer className="footer">
        <p>© {new Date().getFullYear()} TitanXUtils. All rights reserved.</p>
      </footer>
    </NFTLayoutWrapper>
  );
}-e 
---
File: ./app/nft/page.js
// app/nft/page.js
'use client';
import { motion } from 'framer-motion';
import { fetchCollectionData } from '@/lib/fetchCollectionData';
import config from '@/config';
import LoadingIndicator from '@/components/LoadingIndicator';
import NFTSummary from '@/components/NFTSummary';
import React from 'react';


const collections = Object.entries(config.contractDetails).map(([apiKey, { name, apiEndpoint, pageSize, disabled }]) => ({
  apiKey,
  name,
  apiEndpoint,
  pageSize,
  disabled,
}));

export default function NFTOverview() {
  const [collectionsData, setCollectionsData] = React.useState([]);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(null);

  const handleCollectionClick = async (apiKey, apiEndpoint, pageSize, disabled) => {
    if (disabled) return;
    setLoading(true);
    setError(null);
    try {
      const data = await fetchCollectionData(apiKey, apiEndpoint, pageSize);
      if (data.error) {
        setError(data.error);
      } else {
        setCollectionsData([{ apiKey, data }]);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 p-6 flex flex-col items-center">
      <h1 className="title mb-6">NFT Collections</h1>
      <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl mb-6">
        {collections.map(({ apiKey, name, apiEndpoint, pageSize, disabled }) => (
          <motion.button
            key={apiKey}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleCollectionClick(apiKey, apiEndpoint, pageSize, disabled)}
            className={`btn btn-secondary w-full ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
            disabled={disabled}
          >
            {name}
          </motion.button>
        ))}
      </div>
      {loading && <LoadingIndicator status="Loading collection..." />}
      {error && <p className="text-error">{error}</p>}
      {collectionsData.some(c => c.data.error?.includes('Cache is populating') || c.data.error?.includes('Failed to fetch cache progress') || c.data.error?.includes('timed out')) && (
        <p className="text-body">Data is being loaded, please wait a moment...</p>
      )}
      {collectionsData.length > 0 && !loading && <NFTSummary collectionsData={collectionsData} />}
    </div>
  );
}-e 
---
File: ./app/nft/[chain]/[contract]/page.js
'use client';
import { useState, useEffect } from 'react';
import { notFound } from 'next/navigation';
import nextDynamic from 'next/dynamic';
import config from '@/config';
import LoadingIndicator from '@/components/LoadingIndicator';
import { useNFTStore } from '@/app/store';
import { HoldersResponseSchema } from '@/lib/schemas';

const NFTPageWrapper = nextDynamic(() => import('@/components/NFTPageWrapper'), { ssr: false });
export const dynamic = 'force-dynamic';

async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  console.log(`[NFTContractPage] [INFO] Fetching data for ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      console.log(`[NFTContractPage] [INFO] ${apiKey} is disabled`);
      return { error: `${apiKey} is not available` };
    }

    const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
    const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${baseUrl}${apiEndpoint}`;

    const pollProgress = async () => {
      const progressUrl = `${endpoint}/progress`;
      const res = await fetch(progressUrl, { cache: 'no-store', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
      if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
      const progress = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Progress: ${JSON.stringify(progress)}`);
      return progress;
    };

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;

    const maxPollTime = 180000; // 180 seconds
    const startTime = Date.now();
    let progress = await pollProgress();

    while (progress.isPopulating || progress.phase !== 'Completed') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[NFTContractPage] [ERROR] Cache population timeout for ${apiKey}`);
        return { error: 'Cache population timed out' };
      }
      console.log(`[NFTContractPage] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%)`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      progress = await pollProgress();
      if (progress.phase === 'Error') {
        console.error(`[NFTContractPage] [ERROR] Cache population failed: ${progress.error || 'Unknown error'}`);
        return { error: `Cache population failed: ${progress.error || 'Unknown error'}` };
      }
    }

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      console.log(`[NFTContractPage] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      console.log(`[NFTContractPage] [DEBUG] Response status: ${res.status}`);

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[NFTContractPage] [ERROR] Failed to fetch ${url}: ${res.status} ${errorText}`);
        return { error: `Failed to fetch data: ${res.status}` };
      }

      const json = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Response body: ${JSON.stringify(json, (key, value) => typeof value === 'bigint' ? value.toString() : value)}`);

      if (json.isCachePopulating) {
        return { isCachePopulating: true, progress }; // Trigger polling
      }

      const validation = HoldersResponseSchema.safeParse(json);
      if (!validation.success) {
        console.error(`[NFTContractPage] [ERROR] Invalid holders data: ${JSON.stringify(validation.error.errors)}`);
        if (apiKey === 'ascendant') {
          console.log(`[NFTContractPage] [INFO] Triggering POST for ${apiKey}`);
          await fetch(endpoint, { method: 'POST', cache: 'no-store', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ forceUpdate: false }) });
          const retryRes = await fetch(url, { cache: 'no-store' });
          if (!retryRes.ok) {
            const retryError = await retryRes.text();
            console.error(`[NFTContractPage] [ERROR] Retry failed: ${retryRes.status} ${retryError}`);
            return { error: `Retry failed: ${retryRes.status}` };
          }
          const retryJson = await retryRes.json();
          const retryValidation = HoldersResponseSchema.safeParse(retryJson);
          if (!retryValidation.success) {
            console.error(`[NFTContractPage] [ERROR] Retry invalid holders data: ${JSON.stringify(retryValidation.error.errors)}`);
            return { error: 'Invalid holders data after retry' };
          }
          json.holders = retryJson.holders;
          json.totalTokens = retryJson.totalTokens;
          json.totalShares = retryJson.totalShares;
          json.totalBurned = retryJson.totalBurned;
          json.summary = retryJson.summary;
          json.totalPages = retryJson.totalPages;
        } else {
          return { error: 'Invalid holders data' };
        }
      }

      allHolders = allHolders.concat(json.holders);
      totalTokens = json.totalTokens || totalTokens;
      totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
      totalBurned = json.totalBurned || totalBurned;
      summary = json.summary || summary;
      totalPages = json.totalPages || 1;
      page++;
      console.log(`[NFTContractPage] [INFO] Fetched page ${page} for ${apiKey}: ${json.holders.length} holders`);
    }

    return {
      holders: allHolders,
      totalTokens,
      totalShares,
      totalBurned,
      summary,
    };
  } catch (error) {
    console.error(`[NFTContractPage] [ERROR] Error fetching ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { error: error.message };
  }
}

export default function NFTContractPage({ params }) {
  const { chain, contract } = params;
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [progress, setProgress] = useState(null);

  const { getCache, setCache } = useNFTStore();

  const apiKeyMap = {
    Element280: 'element280',
    Element369: 'element369',
    Stax: 'stax',
    Ascendant: 'ascendant',
    E280: 'e280',
  };
  const apiKey = apiKeyMap[contract];

  useEffect(() => {
    if (!config.supportedChains.includes(chain) || !apiKey) {
      console.log(`[NFTContractPage] [ERROR] Invalid chain=${chain} or contract=${contract}`);
      notFound();
    }

    async function fetchData() {
      setLoading(true);
      setError(null);
      setData(null);

      const contractConfig = config.contractDetails[apiKey] || {};
      const cacheKey = `contract_${apiKey}`;
      const cachedData = getCache(cacheKey);

      if (cachedData) {
        console.log(`[NFTContractPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      console.log(`[NFTContractPage] [INFO] Cache miss for ${cacheKey}, fetching data`);
      const result = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);

      if (result.isCachePopulating) {
        const poll = async () => {
          const progressResult = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);
          setProgress(progressResult.progress);
          if (progressResult.isCachePopulating) {
            setTimeout(poll, config.alchemy.batchDelayMs);
          } else if (progressResult.error) {
            setError(progressResult.error);
            setLoading(false);
          } else {
            setCache(cacheKey, progressResult);
            setData(progressResult);
            setLoading(false);
          }
        };
        poll();
      } else if (result.error) {
        setError(result.error);
        setLoading(false);
      } else {
        setCache(cacheKey, result);
        setData(result);
        setLoading(false);
      }
    }

    fetchData();
  }, [chain, contract, apiKey, getCache, setCache]);

  if (!config.supportedChains.includes(chain) || !apiKey) {
    notFound();
  }

  if (loading) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{contract} Collection</h1>
        <LoadingIndicator
          status={`Loading ${contract} data... ${progress ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''}`}
          progress={progress}
        />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{contract} Collection</h1>
        <p className="text-error">{error}</p>
      </div>
    );
  }

  return (
    <div className="container page-content">
      <h1 className="title mb-6">{contract} Collection</h1>
      <NFTPageWrapper
        chain={chain}
        contract={apiKey}
        data={data}
        rewardToken={config.contractDetails[apiKey]?.rewardToken}
      />
    </div>
  );
}-e 
---
File: ./app/global.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base Styles */
html {
  @apply scroll-smooth;
}

body {
  @apply min-h-screen flex flex-col bg-gray-900 text-gray-100 antialiased;
}

/* Component Classes */
@layer components {
  /* Layout */
  .container {
    @apply mx-auto max-w-7xl px-4 sm:px-6 lg:px-8;
  }

  .page-content {
    @apply py-8;
  }

  /* Cards */
  .card {
    @apply rounded-lg shadow-lg p-6 bg-gray-800 border border-gray-700;
  }

  /* Buttons */
  .btn {
    @apply inline-flex items-center px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
  }

  .btn-primary {
    @apply bg-blue-500 text-white hover:bg-blue-600;
  }

  .btn-secondary {
    @apply bg-gray-700 text-gray-100 hover:bg-gray-600;
  }

  /* Typography */
  .title {
    @apply text-3xl font-bold tracking-tight text-gray-100;
  }

  .subtitle {
    @apply text-2xl font-semibold text-gray-100;
  }

  .text-body {
    @apply text-sm sm:text-base text-gray-300;
  }

  .text-error {
    @apply text-red-400;
  }

  /* Tables */
  .table-container {
    @apply overflow-x-auto w-full rounded-lg shadow-lg animate-fade-in;
  }

  .table {
    @apply w-full table-auto md:table-fixed bg-gray-800 text-gray-100;
  }

  .table-head {
    @apply bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base text-white;
  }

  .table-body {
    @apply text-xs md:text-sm text-gray-300;
  }

  .table-row {
    @apply transition-colors border-b border-gray-700;
  }

  .table-row-even {
    @apply bg-gray-800;
  }

  .table-row-odd {
    @apply bg-gray-900;
  }

  .table-row:hover {
    @apply bg-blue-900/30 shadow-sm;
  }

  .table-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold;
  }

  .table-link {
    @apply text-blue-400 hover:text-blue-300 hover:underline break-all;
  }

  .table-pulse {
    @apply animate-pulse;
  }

  .table-pulse-placeholder {
    @apply h-4 bg-gray-600 rounded w-3/4;
  }

  /* Reward Columns (for Element369.js) */
  .reward-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold text-blue-400;
  }

  /* Chart Container */
  .chart-container {
    @apply bg-gray-800 p-4 rounded-lg;
  }

  /* Loading Indicator */
  .loading-container {
    @apply flex flex-col items-center justify-center gap-3 w-full flex-1;
  }

  .spinner {
    @apply h-6 w-6 sm:h-8 sm:w-8 text-blue-400;
  }

  .progress-bar {
    @apply w-64 bg-gray-700 rounded-full h-2.5 mt-2;
  }

  .progress-fill {
    @apply bg-blue-400 h-2.5 rounded-full;
  }

  /* Navbar */
  .nav {
    @apply bg-gray-900 text-gray-100 sticky top-0 z-50 shadow-lg;
  }

  .nav-container {
    @apply container py-4 flex justify-between items-center;
  }

  .nav-logo {
    @apply text-2xl font-bold;
  }

  .nav-link {
    @apply text-gray-300 hover:text-blue-400 transition-colors duration-200;
  }

  .nav-dropdown {
    @apply absolute left-0 mt-2 w-56 bg-gray-800 rounded-lg shadow-xl;
  }

  .nav-dropdown-item {
    @apply block px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md transition-colors;
  }

  .nav-toggle {
    @apply p-2 rounded-full bg-gray-700 text-gray-100 hover:bg-gray-600 transition-colors;
  }

  /* Footer */
  .footer {
    @apply bg-gray-800 py-4 text-center text-gray-400;
  }

  /* Search Input */
  .search-input {
    @apply w-full p-2 bg-gray-700 text-gray-100 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500;
  }

  /* Modal Overlay */
  .modal-overlay {
    @apply fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4;
  }

  /* Animations */
  .animate-fade-in {
    animation: fade-in 0.3s ease-out;
  }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Utility Classes */
@layer utilities {
  .grid-responsive {
    @apply grid grid-cols-1 sm:grid-cols-2 gap-4;
  }

  .space-y-section {
    @apply space-y-6;
  }

  .text-center-section {
    @apply text-center py-12;
  }
}-e 
---
File: ./app/store.js
// File: app/store.js

'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {},
  setCache: (contractKey, data) => {
    const key = `nft:${contractKey}`;
    console.log(`[NFTStore] Setting cache for ${key}: ${data.holders?.length || 0} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [key]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const key = `nft:${contractKey}`;
    console.log(`[NFTStore] Getting cache for ${key}`);
    const cachedEntry = get().cache[key];
    if (!cachedEntry) {
      console.log(`[NFTStore] Cache miss for ${key}`);
      return null;
    }
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${key}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[key];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Cache hit for ${key}: ${cachedEntry.data.holders?.length || 0} holders`);
    return cachedEntry.data;
  },
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          May add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/api/init/route.js
// File: app/api/init/route.js
import { NextResponse } from 'next/server';
import { logger } from '@/lib/logger';
import { initializeCache } from '@/app/api/utils';
import chalk from 'chalk';

console.log(chalk.cyan('[Init Route] Importing logger and utils'));
logger.info('init', 'Init route module loaded', 'eth', 'general').catch(console.error);

export async function GET() {
  await logger.info('init', 'Init endpoint called', 'eth', 'general');
  await initializeCache();
  return NextResponse.json({
    message: 'Initialization triggered',
    debug: process.env.DEBUG,
    nodeEnv: process.env.NODE_ENV,
  });
}-e 
---
File: ./app/api/init/_init.js
// File: app/api/_init.js
import '@/lib/serverInit';-e 
---
File: ./app/api/holders/Element280/validate-burned/route.js
// app/api/holders/Element280/validate-burned/route.js
import { NextResponse } from 'next/server';
import config from '@/config';
import { getTransactionReceipt, log, client, getCache, setCache } from '@/app/api/utils.js';
import { parseAbiItem } from 'viem';

export async function POST(request) {
  if (process.env.DEBUG === 'true') {
    log(`[Element280-Validate-Burned] [DEBUG] Processing POST request for validate-burned`);
  }

  try {
    const { transactionHash } = await request.json();
    if (!transactionHash || typeof transactionHash !== 'string' || !transactionHash.match(/^0x[a-fA-F0-9]{64}$/)) {
      log(`[Element280-Validate-Burned] [VALIDATION] Invalid transaction hash: ${transactionHash || 'undefined'}`);
      return NextResponse.json({ error: 'Invalid transaction hash' }, { status: 400 });
    }

    const contractAddress = config.contractAddresses?.element280?.address;
    if (!contractAddress) {
      log(`[Element280-Validate-Burned] [VALIDATION] Element280 contract address not configured in config.js`);
      return NextResponse.json({ error: 'Contract address not configured' }, { status: 500 });
    }

    const cacheKey = `element280_burn_validation_${transactionHash}`;
    const cachedResult = await getCache(cacheKey, 'element280');
    if (cachedResult) {
      if (process.env.DEBUG === 'true') {
        log(`[Element280-Validate-Burned] [DEBUG] Cache hit for burn validation: ${transactionHash}`);
      }
      return NextResponse.json(cachedResult);
    }

    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Fetching transaction receipt for hash: ${transactionHash}`);
    }
    const receipt = await getTransactionReceipt(transactionHash);
    if (!receipt) {
      log(`[Element280-Validate-Burned] [VALIDATION] Transaction receipt not found for hash: ${transactionHash}`);
      return NextResponse.json({ error: 'Transaction not found' }, { status: 404 });
    }

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const transferEvent = parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)');
    const burnedTokenIds = [];

    for (const logEntry of receipt.logs) {
      if (
        logEntry.address.toLowerCase() === contractAddress.toLowerCase() &&
        logEntry.topics[0] === transferEvent.topics[0]
      ) {
        try {
          const decodedLog = client.decodeEventLog({
            abi: [transferEvent],
            data: logEntry.data,
            topics: logEntry.topics,
          });
          if (decodedLog.args.to.toLowerCase() === burnAddress) {
            burnedTokenIds.push(decodedLog.args.tokenId.toString());
          }
        } catch (_decodeError) {
          log(`[Element280-Validate-Burned] [ERROR] Failed to decode log entry for transaction ${transactionHash}: ${_decodeError.message}`);
        }
      }
    }

    if (burnedTokenIds.length === 0) {
      log(`[Element280-Validate-Burned] [VALIDATION] No burn events found in transaction: ${transactionHash}`);
      return NextResponse.json({ error: 'No burn events found in transaction' }, { status: 400 });
    }

    const result = {
      transactionHash,
      burnedTokenIds,
      blockNumber: receipt.blockNumber.toString(),
    };

    await setCache(cacheKey, result, config.cache.nodeCache.stdTTL, 'element280');
    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Found ${burnedTokenIds.length} burned tokens in transaction: ${transactionHash}`);
    }
    return NextResponse.json(result);
  } catch (error) {
    log(`[Element280-Validate-Burned] [ERROR] Error processing transaction: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: 'Failed to validate transaction', details: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/[contract]/route.js
// app/api/holders/[contract]/route.js
import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits } from 'viem';
import pLimit from 'p-limit';
import config from '@/config.js';
import { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract } from '@/app/api/utils';
import { HoldersResponseSchema } from '@/lib/schemas';

const limit = pLimit(5);

// Get cache state for a contract
async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.progressState = {
        step: savedState.progressState?.step ?? 'idle',
        processedNfts: savedState.progressState?.processedNfts ?? 0,
        totalNfts: savedState.progressState?.totalNfts ?? 0,
        processedTiers: savedState.progressState?.processedTiers ?? 0,
        totalTiers: savedState.progressState?.totalTiers ?? 0,
        error: savedState.progressState?.error ?? null,
        errorLog: savedState.progressState?.errorLog ?? [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
      logger.debug(contractKey, `Loaded cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`);
    }
  } catch (error) {
    logger.error(contractKey, `Failed to load cache state: ${error.message}`, { stack: error.stack });
  }
  return cacheState;
}

// Save cache state for a contract
async function saveCacheStateContract(contractKey, cacheState) {
  try {
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
    logger.debug(contractKey, `Saved cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`);
  } catch (error) {
    logger.error(contractKey, `Failed to save cache state: ${error.message}`, { stack: error.stack });
  }
}

// Fetch new Transfer events (burns and transfers)
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) {
  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const cacheKey = `${contractKey.toLowerCase()}_events_${contractAddress}_${fromBlock}`;
  let cachedEvents = await getCache(cacheKey, contractKey.toLowerCase());

  if (cachedEvents) {
    logger.info(contractKey, `Events cache hit: ${cacheKey}, count: ${cachedEvents.burnedTokenIds.length + (cachedEvents.transferTokenIds?.length || 0)}`);
    return cachedEvents;
  }

  let burnedTokenIds = [];
  let transferTokenIds = [];
  let endBlock;
  try {
    endBlock = await client.getBlockNumber();
  } catch (error) {
    logger.error(contractKey, `Failed to fetch block number: ${error.message}`, { stack: error.stack });
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (fromBlock >= endBlock) {
    logger.info(contractKey, `No new blocks: fromBlock ${fromBlock} >= endBlock ${endBlock}`);
    return { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock) };
  }

  try {
    const logs = await client.getLogs({
      address: contractAddress,
      event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
      fromBlock: BigInt(fromBlock),
      toBlock: endBlock,
    });
    burnedTokenIds = logs
      .filter(log => log.args.to.toLowerCase() === burnAddress.toLowerCase())
      .map(log => Number(log.args.tokenId));
    transferTokenIds = logs
      .filter(log => log.args.to.toLowerCase() !== burnAddress.toLowerCase())
      .map(log => ({ tokenId: Number(log.args.tokenId), from: log.args.from.toLowerCase(), to: log.args.to.toLowerCase() }));
    const cacheData = { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock), timestamp: Date.now() };
    await setCache(cacheKey, cacheData, config.cache.nodeCache.stdTTL, contractKey.toLowerCase());
    logger.info(contractKey, `Cached events: ${cacheKey}, burns: ${burnedTokenIds.length}, transfers: ${transferTokenIds.length}`);
    return cacheData;
  } catch (error) {
    logger.error(contractKey, `Failed to fetch events: ${error.message}`, { stack: error.stack });
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_events', error: error.message });
    throw error;
  }
}

// Build holders map from contract data
async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState) {
  if (!contractAddress) throw new Error('Contract address missing');
  if (!abi) throw new Error(`${contractKey} ABI missing`);

  const requiredFunctions = contractKey === 'ascendant' ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute'] : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
  const missingFunctions = requiredFunctions.filter(fn => !abi.some(item => item.name === fn));
  if (missingFunctions.length > 0) throw new Error(`Missing ABI functions: ${missingFunctions.join(', ')}`);

  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const holdersMap = new Map();
  let totalBurned = 0;
  const errorLog = [];

  cacheState.progressState.step = 'fetching_supply';
  await saveCacheStateContract(contractKey, cacheState);

  let currentBlock;
  try {
    currentBlock = await client.getBlockNumber();
    logger.debug(contractKey, `Fetched current block: ${currentBlock}`);
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    logger.error(contractKey, `Failed to fetch block number: ${error.message}`, { stack: error.stack });
    throw error;
  }

  if (contractKey === 'ascendant') {
    const totalShares = await retry(
      async () => {
        const result = await client.readContract({
          address: contractAddress,
          abi,
          functionName: 'totalShares',
        });
        if (result === null || result === undefined) throw new Error('totalShares returned null');
        return Number(result);
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    logger.debug(contractKey, `Total shares: ${totalShares}`);

    cacheState.progressState.totalNfts = totalShares || 0;
    cacheState.progressState.totalTiers = totalShares || 0;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    if (totalShares === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug(contractKey, `No shares (totalShares=0), returning empty holdersMap`);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
    }

    cacheState.progressState.step = 'fetching_holders';
    await saveCacheStateContract(contractKey, cacheState);

    const userRecords = await retry(
      async () => {
        const result = await client.readContract({
          address: contractAddress,
          abi,
          functionName: 'userRecords',
          args: [],
        });
        if (!result) throw new Error('userRecords returned null');
        return result;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );

    let processedShares = 0;
    for (const record of userRecords) {
      const wallet = record.user.toLowerCase();
      if (!wallet || wallet === burnAddress.toLowerCase()) {
        logger.debug(contractKey, `Skipped burn address wallet ${wallet} with shares ${Number(record.shares)}`);
        continue;
      }

      const shares = Number(record.shares);
      processedShares += shares;

      const holder = holdersMap.get(wallet) || {
        wallet,
        tokenIds: [],
        tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
        total: 0,
        multiplierSum: 0,
      };
      holder.total += shares;
      holdersMap.set(wallet, holder);
      logger.debug(contractKey, `Added to holdersMap: wallet=${wallet}, totalShares=${holder.total}`);

      cacheState.progressState.processedNfts = processedShares;
      if (processedShares % 1000 === 0) {
        await saveCacheStateContract(contractKey, cacheState);
      }
    }

    cacheState.progressState.step = 'fetching_tiers';
    cacheState.progressState.processedTiers = 0;
    await saveCacheStateContract(contractKey, cacheState);

    const tierCalls = Array.from(holdersMap.values()).map(holder => ({
      address: contractAddress,
      abi,
      functionName: 'getNFTAttribute',
      args: [holder.wallet],
    }));

    if (tierCalls.length > 0) {
      const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
      const concurrencyLimit = pLimit(4);
      logger.debug(contractKey, `Fetching tiers for ${tierCalls.length} holders in chunks of ${chunkSize}`);
      const tierPromises = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        tierPromises.push(
          concurrencyLimit(async () => {
            logger.debug(contractKey, `Processing tier batch ${i / chunkSize + 1} with ${chunk.length} calls`);
            try {
              const tierResults = await retry(() => batchMulticall(chunk, config.alchemy.batchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });

              tierResults.forEach((result, index) => {
                const wallet = Array.from(holdersMap.values())[i + index].wallet;
                if (result.status === 'success') {
                  const tier = Array.isArray(result.result) ? Number(result.result[1] || 0) : Number(result.result.tier || 0);
                  const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                  if (tier >= 1 && tier <= maxTier) {
                    const holder = holdersMap.get(wallet);
                    holder.tiers[tier - 1] += holder.total;
                    holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier * holder.total || 0;
                    logger.debug(contractKey, `Tier ${tier} assigned to wallet ${wallet}`);
                  } else {
                    logger.warn(contractKey, `Invalid tier ${tier} for wallet ${wallet}`);
                    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', wallet, error: `Invalid tier ${tier}` });
                  }
                } else {
                  logger.error(contractKey, `Failed to fetch tier for wallet ${wallet}: ${result.error || 'unknown error'}`);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', wallet, error: result.error || 'unknown error' });
                }
              });

              cacheState.progressState.processedTiers += chunk.length;
              await saveCacheStateContract(contractKey, cacheState);
              logger.debug(contractKey, `Processed ${cacheState.progressState.processedTiers}/${cacheState.progressState.totalTiers} tiers`);
            } catch (error) {
              logger.error(contractKey, `Tier batch ${i / chunkSize + 1} failed: ${error.message}`, { stack: error.stack });
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier_batch', batch: i / chunkSize + 1, error: error.message });
            }
          })
        );
      }
      await Promise.all(tierPromises);
    }
  } else {
    const totalSupply = await retry(
      async () => {
        const result = await client.readContract({
          address: contractAddress,
          abi,
          functionName: 'totalSupply',
        });
        if (result === null || result === undefined) throw new Error('totalSupply returned null');
        return Number(result);
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    logger.debug(contractKey, `Total supply: ${totalSupply}`);

    let burnedCountContract = 0;
    try {
      burnedCountContract = await retry(
        async () => {
          const result = await client.readContract({
            address: contractAddress,
            abi,
            functionName: 'totalBurned',
          });
          if (result === null || result === undefined) throw new Error('totalBurned returned null');
          return Number(result);
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      logger.debug(contractKey, `Burned count from contract: ${burnedCountContract}`);
    } catch (error) {
      logger.error(contractKey, `Failed to fetch totalBurned: ${error.message}`, { stack: error.stack });
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned', error: error.message });
    }
    totalBurned = burnedCountContract;

    cacheState.progressState.totalNfts = totalSupply || 0;
    cacheState.progressState.totalTiers = totalSupply || 0;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    if (totalSupply === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug(contractKey, `No NFTs (totalSupply=0), returning empty holdersMap`);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
    }

    cacheState.progressState.step = 'fetching_owners';
    await saveCacheStateContract(contractKey, cacheState);

    logger.debug(contractKey, `Fetching owners for ${totalSupply} tokens using Alchemy NFT API`);
    const owners = await retry(
      () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true }),
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    logger.debug(contractKey, `Fetched owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`);

    let processedTokens = 0;
    for (const owner of owners) {
      const wallet = owner.ownerAddress.toLowerCase();
      logger.debug(contractKey, `Processing owner: wallet=${wallet}, tokenBalancesCount=${owner.tokenBalances.length}`);

      const tokenIds = owner.tokenBalances
        .map(tb => {
          const tokenId = Number(tb.tokenId);
          if (isNaN(tokenId) || tokenId < 0) {
            logger.warn(contractKey, `Invalid tokenId ${tb.tokenId} for wallet ${wallet}`);
            return null;
          }
          return tokenId;
        })
        .filter(id => id !== null);

      if (tokenIds.length === 0) {
        logger.warn(contractKey, `No valid token IDs for wallet ${wallet}`);
        continue;
      }

      if (wallet === burnAddress.toLowerCase()) {
        totalBurned += owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0);
        logger.debug(contractKey, `Incremented totalBurned by ${owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0)} for burn address`);
        continue;
      }

      processedTokens += tokenIds.length;

      const holder = holdersMap.get(wallet) || {
        wallet,
        tokenIds: [],
        tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
        total: 0,
        multiplierSum: 0,
        ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
        ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
      };
      holder.tokenIds.push(...tokenIds);
      holder.total += tokenIds.length;
      holdersMap.set(wallet, holder);
      logger.debug(contractKey, `Added to holdersMap: wallet=${wallet}, totalTokens=${holder.total}`);

      cacheState.progressState.processedNfts = processedTokens;
      if (processedTokens % 1000 === 0) {
        await saveCacheStateContract(contractKey, cacheState);
      }
    }
    logger.debug(contractKey, `Holders map size: ${holdersMap.size}, totalBurned: ${totalBurned}, processedTokens: ${processedTokens}`);
    await saveCacheStateContract(contractKey, cacheState);
    await setCache(`${contractKey.toLowerCase()}_holders_partial`, { holders: Array.from(holdersMap.values()), totalBurned, timestamp: Date.now() }, 0, contractKey.toLowerCase());
    logger.info(contractKey, `Fetched ${processedTokens} owners, ${holdersMap.size} unique holders`);

    cacheState.progressState.step = 'fetching_tiers';
    cacheState.progressState.processedTiers = 0;
    await saveCacheStateContract(contractKey, cacheState);

    const tokenIdToOwner = new Map();
    for (const holder of holdersMap.values()) {
      for (const tokenId of holder.tokenIds) {
        tokenIdToOwner.set(tokenId, holder.wallet);
      }
    }

    const validTokenIds = Array.from(tokenIdToOwner.keys());
    logger.debug(contractKey, `Valid token IDs for tier fetching: count=${validTokenIds.length}, sample=${JSON.stringify(validTokenIds.slice(0, 5))}`);
    const tierCalls = validTokenIds.map(tokenId => ({
      address: contractAddress,
      abi,
      functionName: 'getNftTier',
      args: [BigInt(tokenId)],
    }));

    if (tierCalls.length > 0) {
      const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
      const concurrencyLimit = pLimit(4);
      logger.debug(contractKey, `Fetching tiers for ${tierCalls.length} tokens in chunks of ${chunkSize}`);
      const tierPromises = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        tierPromises.push(
          concurrencyLimit(async () => {
            logger.debug(contractKey, `Processing tier batch ${i / chunkSize + 1} with ${chunk.length} calls`);
            try {
              const tierResults = await retry(() => batchMulticall(chunk, config.alchemy.batchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });

              tierResults.forEach((result, index) => {
                const tokenId = validTokenIds[i + index];
                const owner = tokenIdToOwner.get(tokenId);
                if (!owner) {
                  logger.debug(contractKey, `Skipped tier for tokenId ${tokenId}: no owner found`);
                  return;
                }

                const holder = holdersMap.get(owner);
                if (result.status === 'success') {
                  const tier = Number(result.result);
                  const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                  if (tier >= 1 && tier <= maxTier) {
                    holder.tiers[tier - 1]++;
                    holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                    logger.debug(contractKey, `Tier ${tier} for token ${tokenId} assigned to wallet ${owner}`);
                  } else {
                    logger.warn(contractKey, `Invalid tier ${tier} for token ${tokenId}, wallet ${owner}`);
                    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, error: `Invalid tier ${tier}` });
                  }
                } else {
                  logger.warn(contractKey, `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, error: result.error || 'unknown error' });
                }
              });

              cacheState.progressState.processedTiers += chunk.length;
              await saveCacheStateContract(contractKey, cacheState);
              logger.debug(contractKey, `Processed ${cacheState.progressState.processedTiers}/${cacheState.progressState.totalTiers} tiers`);
            } catch (error) {
              logger.error(contractKey, `Tier batch ${i / chunkSize + 1} failed: ${error.message}`, { stack: error.stack });
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier_batch', batch: i / chunkSize + 1, error: error.message });
            }
          })
        );
      }
      await Promise.all(tierPromises);
    } else {
      logger.warn(contractKey, `No valid token IDs found for tier fetching`);
    }

    if (contractKey === 'element369' && vaultAddress && vaultAbi) {
      cacheState.progressState.step = 'fetching_rewards';
      await saveCacheStateContract(contractKey, cacheState);

      const holderList = Array.from(holdersMap.values());
      logger.debug(contractKey, `Fetching rewards for ${holderList.length} holders`);

      const rewardBatchSize = config.alchemy.batchSize || 100;
      const concurrencyLimit = pLimit(4);
      const rewardPromises = [];
      let processedHolders = 0;
      for (let i = 0; i < holderList.length; i += rewardBatchSize) {
        const batchHolders = holderList.slice(i, i + rewardBatchSize);
        const rewardCalls = batchHolders.map(holder => ({
          address: vaultAddress,
          abi: vaultAbi,
          functionName: 'getRewards',
          args: [holder.tokenIds.map(id => BigInt(id)), holder.wallet, false],
        }));

        rewardPromises.push(
          concurrencyLimit(async () => {
            logger.debug(contractKey, `Processing reward batch ${i / rewardBatchSize + 1} with ${rewardCalls.length} calls`);
            try {
              const rewardsResults = await retry(() => batchMulticall(rewardCalls, rewardBatchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });

              batchHolders.forEach((holder, j) => {
                const result = rewardsResults[j];
                if (result?.status === 'success' && result.result) {
                  const [, , infernoPool, fluxPool, e280Pool] = result.result;
                  holder.infernoRewards = Number(infernoPool || 0) / 1e18;
                  holder.fluxRewards = Number(fluxPool || 0) / 1e18;
                  holder.e280Rewards = Number(e280Pool || 0) / 1e18;
                  logger.debug(contractKey, `Rewards for wallet ${holder.wallet}: inferno=${holder.infernoRewards}, flux=${holder.fluxRewards}, e280=${holder.e280Rewards}`);
                } else {
                  holder.infernoRewards = 0;
                  holder.fluxRewards = 0;
                  holder.e280Rewards = 0;
                  const errorMsg = result?.error || 'Unknown error';
                  logger.error(contractKey, `Failed to fetch rewards for wallet ${holder.wallet}: ${errorMsg}`);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', wallet: holder.wallet, error: errorMsg });
                }
                holdersMap.set(holder.wallet, holder);
              });

              processedHolders += batchHolders.length;
              cacheState.progressState.processedNfts = processedHolders;
              cacheState.progressState.processedTiers = processedHolders;
              await saveCacheStateContract(contractKey, cacheState);
              logger.debug(contractKey, `Processed ${processedHolders}/${holderList.length} holders for rewards`);
            } catch (error) {
              logger.error(contractKey, `Reward batch ${i / rewardBatchSize + 1} failed: ${error.message}`, { stack: error.stack });
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards_batch', batch: i / rewardBatchSize + 1, error: error.message });
            }
          })
        );
      }
      await Promise.all(rewardPromises);
    }

    if ((contractKey === 'element280' || contractKey === 'stax') && vaultAddress && vaultAbi) {
      cacheState.progressState.step = 'fetching_rewards';
      await saveCacheStateContract(contractKey, cacheState);

      const holderList = Array.from(holdersMap.values());
      logger.debug(contractKey, `Fetching rewards for ${holderList.length} holders`);

      const rewardBatchSize = config.alchemy.batchSize || 100;
      const concurrencyLimit = pLimit(4);
      const rewardPromises = [];
      let processedHolders = 0;
      for (let i = 0; i < holderList.length; i += rewardBatchSize) {
        const batchHolders = holderList.slice(i, i + rewardBatchSize);
        const rewardCalls = batchHolders.map(holder => ({
          address: vaultAddress,
          abi: vaultAbi,
          functionName: 'getRewards',
          args: [holder.tokenIds.map(id => BigInt(id)), holder.wallet],
        }));

        rewardPromises.push(
          concurrencyLimit(async () => {
            logger.debug(contractKey, `Processing reward batch ${i / rewardBatchSize + 1} with ${rewardCalls.length} calls`);
            try {
              const rewardResults = await retry(() => batchMulticall(rewardCalls, rewardBatchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });

              batchHolders.forEach((holder, j) => {
                const result = rewardResults[j];
                if (result.status === 'success') {
                  const rewardValue = BigInt(result.result[1] || 0);
                  holder.claimableRewards = Number(rewardValue) / 1e18;
                  if (isNaN(holder.claimableRewards)) {
                    holder.claimableRewards = 0;
                  }
                  logger.debug(contractKey, `Rewards for wallet ${holder.wallet}: claimable=${holder.claimableRewards}`);
                } else {
                  holder.claimableRewards = 0;
                  const errorMsg = result?.error || 'Unknown error';
                  logger.error(contractKey, `Failed to fetch rewards for wallet ${holder.wallet}: ${errorMsg}`);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', wallet: holder.wallet, error: errorMsg });
                }
                holdersMap.set(holder.wallet, holder);
              });

              processedHolders += batchHolders.length;
              cacheState.progressState.processedNfts = processedHolders;
              cacheState.progressState.processedTiers = processedHolders;
              await saveCacheStateContract(contractKey, cacheState);
              logger.debug(contractKey, `Processed ${processedHolders}/${holderList.length} holders for rewards`);
            } catch (error) {
              logger.error(contractKey, `Reward batch ${i / rewardBatchSize + 1} failed: ${error.message}`, { stack: error.stack });
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards_batch', batch: i / rewardBatchSize + 1, error: error.message });
            }
          })
        );
      }
      await Promise.all(rewardPromises);
    }

    cacheState.progressState.step = 'calculating_metrics';
    await saveCacheStateContract(contractKey, cacheState);

    const holderList = Array.from(holdersMap.values());
    const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
    holderList.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
      logger.debug(contractKey, `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, displayMultiplierSum=${holder.displayMultiplierSum}`);
    });

    holderList.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holderList.forEach((holder, index) => (holder.rank = index + 1));
    logger.debug(contractKey, `Sorted holders: count=${holderList.length}, topHolder=${JSON.stringify(holderList[0])}`);

    cacheState.totalOwners = holderList.length;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = cacheState.progressState.totalNfts;
    cacheState.progressState.processedTiers = cacheState.progressState.totalTiers;
    cacheState.progressState.error = null;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    logger.info(contractKey, `Completed holders map with ${holderList.length} holders, totalBurned=${totalBurned}`);
    return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
}

// Populate holders map cache
async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) {
  let cacheState = await getCacheState(contractKey);
  if (cacheState.isPopulating && !forceUpdate) {
    logger.info(contractKey, 'Cache population already in progress');
    return { status: 'in_progress', holders: null };
  }

  cacheState.isPopulating = true;
  cacheState.progressState.step = 'starting';
  cacheState.progressState.error = null;
  cacheState.progressState.errorLog = [];
  await saveCacheStateContract(contractKey, cacheState);

  const errorLog = [];

  try {
    const cachedData = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
    const isCacheValid = cachedData && Array.isArray(cachedData.holders) && Number.isInteger(cachedData.totalBurned) && !forceUpdate;

    if (isCacheValid) {
      const fromBlock = cacheState.lastProcessedBlock || config.deploymentBlocks[contractKey].block;
      const { burnedTokenIds, transferTokenIds, lastBlock } = await getNewEvents(contractKey, contractAddress, fromBlock, errorLog);

      let currentBlock;
      try {
        currentBlock = await client.getBlockNumber();
      } catch (error) {
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
        throw error;
      }

      if (burnedTokenIds.length > 0 || transferTokenIds.length > 0) {
        const holdersMap = new Map();
        let totalBurned = cachedData.totalBurned || 0;
        logger.debug(contractKey, `Initial totalBurned from cache: ${totalBurned}`);

        for (const holder of cachedData.holders) {
          const updatedTokenIds = holder.tokenIds.filter(id => !burnedTokenIds.includes(id));
          if (updatedTokenIds.length > 0) {
            const updatedHolder = {
              ...holder,
              tokenIds: updatedTokenIds,
              total: updatedTokenIds.length,
              tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
              multiplierSum: 0,
              ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
              ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
              ...(contractKey === 'ascendant' ? {
                shares: 0,
                lockedAscendant: 0,
                pendingDay8: 0,
                pendingDay28: 0,
                pendingDay90: 0,
                claimableRewards: 0,
              } : {}),
            };
            const tierCalls = updatedTokenIds.map(tokenId => ({
              address: contractAddress,
              abi,
              functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
              args: [BigInt(tokenId)],
            }));
            const tierResults = await retry(() => batchMulticall(tierCalls, config.alchemy.batchSize), {
              retries: config.alchemy.maxRetries,
              delay: config.alchemy.batchDelayMs,
            });
            tierResults.forEach((result, index) => {
              if (result.status === 'success' && result.result) {
                const tier = contractKey === 'ascendant'
                  ? (Array.isArray(result.result) ? Number(result.result[1] || 0) : Number(result.result.tier || 0))
                  : Number(result.result);
                const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                if (tier >= 1 && tier <= maxTier) {
                  updatedHolder.tiers[tier - 1]++;
                  updatedHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                  logger.debug(contractKey, `Tier ${tier} for token ${updatedTokenIds[index]} assigned to wallet ${holder.wallet}`);
                } else {
                  logger.warn(contractKey, `Invalid tier ${tier} for token ${updatedTokenIds[index]}, wallet ${holder.wallet}`);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId: updatedTokenIds[index], error: `Invalid tier ${tier}` });
                }
              } else {
                logger.warn(contractKey, `Failed to fetch tier for token ${updatedTokenIds[index]}: ${result.error || 'unknown error'}`);
                errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId: updatedTokenIds[index], error: result.error || 'unknown error' });
              }
            });
            holdersMap.set(holder.wallet, updatedHolder);
          } else {
            totalBurned += holder.total;
            logger.debug(contractKey, `Incremented totalBurned by ${holder.total} for wallet ${holder.wallet}`);
          }
        }

        for (const transfer of transferTokenIds) {
          const fromHolder = holdersMap.get(transfer.from);
          if (fromHolder) {
            fromHolder.tokenIds = fromHolder.tokenIds.filter(id => id !== transfer.tokenId);
            fromHolder.total = fromHolder.tokenIds.length;
            if (fromHolder.total === 0) {
              holdersMap.delete(transfer.from);
              logger.debug(contractKey, `Removed empty holder: ${transfer.from}`);
            } else {
              fromHolder.tiers = Array(Object.keys(config.contractTiers[contractKey]).length).fill(0);
              fromHolder.multiplierSum = 0;
              const tierResult = await retry(
                () =>
                  client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
                    args: [BigInt(transfer.tokenId)],
                  }),
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const tier = contractKey === 'ascendant'
                ? (Array.isArray(tierResult) ? Number(tierResult[1] || 0) : Number(tierResult.tier || 0))
                : Number(tierResult);
              if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
                fromHolder.tiers[tier - 1]++;
                fromHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                logger.debug(contractKey, `Tier ${tier} for token ${transfer.tokenId} updated for wallet ${transfer.from}`);
              }
              holdersMap.set(transfer.from, fromHolder);
            }
          }

          const toHolder = holdersMap.get(transfer.to) || {
            wallet: transfer.to,
            tokenIds: [],
            tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
            total: 0,
            multiplierSum: 0,
            ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
            ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
            ...(contractKey === 'ascendant' ? {
              shares: 0,
              lockedAscendant: 0,
              pendingDay8: 0,
              pendingDay28: 0,
              pendingDay90: 0,
              claimableRewards: 0,
            } : {}),
          };
          toHolder.tokenIds.push(transfer.tokenId);
          toHolder.total = toHolder.tokenIds.length;
          const tierResult = await retry(
            () =>
              client.readContract({
                address: contractAddress,
                abi,
                functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
                args: [BigInt(transfer.tokenId)],
              }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const tier = contractKey === 'ascendant'
            ? (Array.isArray(tierResult) ? Number(tierResult[1] || 0) : Number(tierResult.tier || 0))
            : Number(tierResult);
          if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
            toHolder.tiers[tier - 1]++;
            toHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
            logger.debug(contractKey, `Tier ${tier} for token ${transfer.tokenId} assigned to wallet ${transfer.to}`);
          }
          holdersMap.set(transfer.to, toHolder);
        }

        const holderList = Array.from(holdersMap.values());

        if (contractKey === 'element369' && vaultAddress && vaultAbi) {
          const rewardCalls = holderList.map(holder => ({
            address: vaultAddress,
            abi: vaultAbi,
            functionName: 'getRewards',
            args: [holder.tokenIds.map(id => BigInt(id)), holder.wallet, false],
          }));
          const rewardsResults = await retry(() => batchMulticall(rewardCalls, config.alchemy.batchSize), {
            retries: config.alchemy.maxRetries,
            delay: config.alchemy.batchDelayMs,
          });
          holderList.forEach((holder, i) => {
            if (rewardsResults[i]?.status === 'success' && rewardsResults[i].result) {
              const [, , infernoPool, fluxPool, e280Pool] = rewardsResults[i].result;
              holder.infernoRewards = Number(infernoPool || 0) / 1e18;
              holder.fluxRewards = Number(fluxPool || 0) / 1e18;
              holder.e280Rewards = Number(e280Pool || 0) / 1e18;
              logger.debug(contractKey, `Rewards for wallet ${holder.wallet}: inferno=${holder.infernoRewards}, flux=${holder.fluxRewards}, e280=${holder.e280Rewards}`);
            } else {
              holder.infernoRewards = 0;
              holder.fluxRewards = 0;
              holder.e280Rewards = 0;
              const errorMsg = rewardsResults[i]?.error || 'Unknown error';
              logger.error(contractKey, `Failed to fetch rewards for wallet ${holder.wallet}: ${errorMsg}`);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_rewards', wallet: holder.wallet, error: errorMsg });
            }
            holdersMap.set(holder.wallet, holder);
          });
        }

        if ((contractKey === 'element280' || contractKey === 'stax') && vaultAddress && vaultAbi) {
          const rewardCalls = holderList.flatMap(holder =>
            holder.tokenIds.map(tokenId => ({
              address: vaultAddress,
              abi: vaultAbi,
              functionName: 'getRewards',
              args: [[BigInt(tokenId)], holder.wallet],
            }))
          );
          const rewardResults = await retry(() => batchMulticall(rewardCalls, config.alchemy.batchSize), {
            retries: config.alchemy.maxRetries,
            delay: config.alchemy.batchDelayMs,
          });
          let resultIndex = 0;
          holderList.forEach(holder => {
            let totalRewards = 0n;
            holder.tokenIds.forEach(() => {
              const result = rewardResults[resultIndex++];
              if (result.status === 'success') {
                const rewardValue = BigInt(result.result[1] || 0);
                totalRewards += rewardValue;
              }
            });
            holder.claimableRewards = Number(totalRewards) / 1e18;
            if (isNaN(holder.claimableRewards)) {
              holder.claimableRewards = 0;
            }
            logger.debug(contractKey, `Rewards for wallet ${holder.wallet}: claimable=${holder.claimableRewards}`);
            holdersMap.set(holder.wallet, holder);
          });
        }

        if (contractKey === 'ascendant') {
          const recordCalls = holderList.flatMap(holder =>
            holder.tokenIds.map(tokenId => ({
              address: contractAddress,
              abi,
              functionName: 'userRecords',
              args: [BigInt(tokenId)],
            }))
          );
          const recordResults = await retry(() => batchMulticall(recordCalls, config.alchemy.batchSize), {
            retries: config.alchemy.maxRetries,
            delay: config.alchemy.batchDelayMs,
          });
          const claimableCalls = holderList.map(holder => ({
            address: contractAddress,
            abi,
            functionName: 'batchClaimableAmount',
            args: [holder.tokenIds.map(id => BigInt(id))],
          }));
          const claimableResults = await retry(() => batchMulticall(claimableCalls, config.alchemy.batchSize), {
            retries: config.alchemy.maxRetries,
            delay: config.alchemy.batchDelayMs,
          });

          const totalSharesRaw = await retry(
            () => client.readContract({ address: contractAddress, abi, functionName: 'totalShares' }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));
          const toDistributeDay8Raw = await retry(
            () => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));
          const toDistributeDay28Raw = await retry(
            () => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));
          const toDistributeDay90Raw = await retry(
            () => client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

          let resultIndex = 0;
          holderList.forEach((holder, i) => {
            holder.shares = 0;
            holder.lockedAscendant = 0;
            holder.tokenIds.forEach(() => {
              const recordResult = recordResults[resultIndex++];
              if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
                const sharesRaw = recordResult.result[0] || '0';
                const lockedAscendantRaw = recordResult.result[1] || '0';
                holder.shares += parseFloat(formatUnits(sharesRaw, 18));
                holder.lockedAscendant += parseFloat(formatUnits(lockedAscendantRaw, 18));
              }
            });
            if (claimableResults[i]?.status === 'success') {
              holder.claimableRewards = parseFloat(formatUnits(claimableResults[i].result || '0', 18));
            }
            const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
            const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
            const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;
            holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
            holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
            holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
            holdersMap.set(holder.wallet, holder);
          });
        }

        let burnedCountContract;
        try {
          burnedCountContract = await retry(
            async () => {
              const result = await client.readContract({
                address: contractAddress,
                abi,
                functionName: 'totalBurned',
              });
              return Number(result);
            },
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          logger.debug(contractKey, `Fetched burnedCountContract: ${burnedCountContract}`);
        } catch (error) {
          logger.error(contractKey, `Failed to fetch totalBurned: ${error.message}`, { stack: error.stack });
          burnedCountContract = 0;
        }
        totalBurned = burnedCountContract || totalBurned;
        logger.debug(contractKey, `Final totalBurned: ${totalBurned}`);

        const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
        holderList.forEach(holder => {
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
          logger.debug(contractKey, `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, displayMultiplierSum=${holder.displayMultiplierSum}`);
        });

        holderList.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
        holderList.forEach((holder, index) => (holder.rank = index + 1));

        const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
        await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
        cacheState.lastUpdated = Date.now();
        cacheState.totalOwners = holderList.length;
        cacheState.lastProcessedBlock = lastBlock;
        cacheState.progressState = {
          step: 'completed',
          processedNfts: cacheState.progressState.totalNfts,
          totalNfts: cacheState.progressState.totalNfts,
          processedTiers: cacheState.progressState.totalTiers,
          totalTiers: cacheState.progressState.totalTiers,
          error: null,
          errorLog,
        };
        await saveCacheStateContract(contractKey, cacheState);
        logger.info(contractKey, `Cache updated: ${holderList.length} holders, totalBurned: ${totalBurned}`);
        return { status: 'updated', holders: holderList };
      } else {
        cacheState.isPopulating = false;
        cacheState.progressState.step = 'completed';
        cacheState.lastProcessedBlock = Number(currentBlock);
        await saveCacheStateContract(contractKey, cacheState);
        logger.info(contractKey, 'Cache is up to date');
        return { status: 'up_to_date', holders: cachedData.holders };
      }
    }

    const result = await getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState);
    const holderList = Array.from(result.holdersMap.values());
    const totalBurned = result.totalBurned || 0;
    logger.debug(contractKey, `getHoldersMap returned totalBurned: ${totalBurned}`);
    const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
    await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
    cacheState.lastUpdated = Date.now();
    cacheState.totalOwners = holderList.length;
    cacheState.lastProcessedBlock = result.lastBlock;
    cacheState.progressState = {
      step: 'completed',
      processedNfts: cacheState.progressState.totalNfts,
      totalNfts: cacheState.progressState.totalNfts,
      processedTiers: cacheState.progressState.totalTiers,
      totalTiers: cacheState.progressState.totalTiers,
      error: null,
      errorLog,
    };
    await saveCacheStateContract(contractKey, cacheState);
    logger.info(contractKey, `Cache populated: ${holderList.length} holders, totalBurned: ${totalBurned}`);
    return { status: 'completed', holders: holderList };
  } catch (error) {
    cacheState.progressState.step = 'error';
    cacheState.progressState.error = error.message;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    logger.error(contractKey, `Cache population failed: ${error.message}`, { stack: error.stack });
    return { status: 'error', holders: null, error: error.message };
  } finally {
    cacheState.isPopulating = false;
    await saveCacheStateContract(contractKey, cacheState);
  }
}

// GET handler
export async function GET(request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();
  if (!config.contractDetails[contractKey]) {
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  const contractAddress = config.contractAddresses[contractKey]?.address;
  const abi = config.abis[contractKey]?.main;
  const vaultAddress = config.vaultAddresses[contractKey]?.address;
  const vaultAbi = config.abis[contractKey]?.vault;

  try {
    const cacheState = await getCacheState(contractKey);
    if (cacheState.isPopulating) {
      return NextResponse.json({
        message: 'Cache is populating',
        isCachePopulating: true,
        totalOwners: cacheState.totalOwners,
        progressState: cacheState.progressState,
        lastProcessedBlock: cacheState.lastProcessedBlock,
        debugId: `state-${Math.random().toString(36).slice(2)}`,
      }, { status: 202 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || config.contractDetails[contractKey].pageSize, 10);
    const wallet = searchParams.get('wallet');

    if (wallet) {
      const cachedData = await getCache(`${contractKey}_holder_${contractAddress}-${wallet.toLowerCase()}`, contractKey.toLowerCase());
      if (cachedData) {
        return NextResponse.json(cachedData);
      }

      const nfts = await retry(
        () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true }),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      ).then(owners =>
        owners.filter(o => o.ownerAddress.toLowerCase() === wallet.toLowerCase() && o.ownerAddress.toLowerCase() !== config.burnAddress.toLowerCase())
      );

      const holder = {
        wallet: wallet.toLowerCase(),
        total: nfts.length,
        tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
        tokenIds: nfts.map(nft => Number(nft.tokenId)),
        multiplierSum: 0,
        displayMultiplierSum: 0,
        percentage: 0,
        rank: 0,
        ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
        ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
        ...(contractKey === 'ascendant' ? {
          shares: 0,
          lockedAscendant: 0,
          pendingDay8: 0,
          pendingDay28: 0,
          pendingDay90: 0,
          claimableRewards: 0,
        } : {}),
      };

      if (nfts.length === 0) {
        return NextResponse.json({ message: 'No holder data found for wallet' }, { status: 404 });
      }

      const calls = [];
      nfts.forEach(nft => {
        calls.push({
          address: contractAddress,
          abi,
          functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
          args: [BigInt(nft.tokenId)],
        });
        if (contractKey === 'ascendant') {
          calls.push({
            address: contractAddress,
            abi,
            functionName: 'userRecords',
            args: [BigInt(nft.tokenId)],
          });
        } else if (contractKey === 'element369' && vaultAddress && vaultAbi) {
          calls.push({
            address: vaultAddress,
            abi: vaultAbi,
            functionName: 'getRewards',
            args: [[BigInt(nft.tokenId)], wallet.toLowerCase(), false],
          });
        } else if ((contractKey === 'element280' || contractKey === 'stax') && vaultAddress && vaultAbi) {
          calls.push({
            address: vaultAddress,
            abi: vaultAbi,
            functionName: 'getRewards',
            args: [[BigInt(nft.tokenId)], wallet.toLowerCase()],
          });
        }
      });

      if (contractKey === 'ascendant') {
        calls.push({
          address: contractAddress,
          abi,
          functionName: 'batchClaimableAmount',
          args: [nfts.map(nft => BigInt(nft.tokenId))],
        });
      }

      const results = await batchMulticall(calls);
      let resultIndex = 0;
      nfts.forEach(() => {
        const tierResult = results[resultIndex++];
        if (tierResult.status === 'success') {
          const tier = contractKey === 'ascendant' 
            ? (Array.isArray(tierResult.result) ? Number(tierResult.result[1] || 0) : Number(tierResult.result.tier || 0))
            : Number(tierResult.result);
          const maxTier = Object.keys(config.contractTiers[contractKey]).length;
          if (tier >= 1 && tier <= maxTier) {
            holder.tiers[tier - 1]++;
            holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
          }
        }

        if (contractKey === 'ascendant') {
          const recordResult = results[resultIndex++];
          if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
            const sharesRaw = recordResult.result[0] || '0';
            const lockedAscendantRaw = recordResult.result[1] || '0';
            holder.shares += parseFloat(formatUnits(sharesRaw, 18));
            holder.lockedAscendant += parseFloat(formatUnits(lockedAscendantRaw, 18));
          }
        } else if (contractKey === 'element369') {
          const rewardResult = results[resultIndex++];
          if (rewardResult.status === 'success' && rewardResult.result) {
            const [, , infernoPool, fluxPool, e280Pool] = rewardResult.result;
            holder.infernoRewards += Number(infernoPool || 0) / 1e18;
            holder.fluxRewards += Number(fluxPool || 0) / 1e18;
            holder.e280Rewards += Number(e280Pool || 0) / 1e18;
          }
        } else if (contractKey === 'element280' || contractKey === 'stax') {
          const rewardResult = results[resultIndex++];
          if (rewardResult.status === 'success') {
            const rewardValue = BigInt(rewardResult.result[1] || 0);
            holder.claimableRewards += Number(rewardValue) / 1e18;
          }
        }
      });

      if (contractKey === 'ascendant') {
        const claimableResult = results[resultIndex];
        if (claimableResult?.status === 'success') {
          holder.claimableRewards = parseFloat(formatUnits(claimableResult.result || '0', 18));
        }

        const totalSharesRaw = await client.readContract({ address: contractAddress, abi, functionName: 'totalShares' });
        const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));
        const toDistributeDay8Raw = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] });
        const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));
        const toDistributeDay28Raw = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] });
        const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));
        const toDistributeDay90Raw = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] });
        const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

        const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
        const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
        const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;
        holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
        holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
        holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
      }

      holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
      const cachedHolders = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
      if (cachedHolders && cachedHolders.holders) {
        const totalMultiplierSum = cachedHolders.holders.reduce((sum, h) => sum + h.multiplierSum, 0);
        holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        const sortedHolders = cachedHolders.holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
        holder.rank = sortedHolders.findIndex(h => h.multiplierSum <= holder.multiplierSum && h.total <= holder.total) + 1;
      }

      await setCache(`${contractKey}_holder_${wallet.toLowerCase()}`, holder, config.cache.nodeCache.stdTTL, contractKey.toLowerCase());
      return NextResponse.json(holder);
    }

    const cachedData = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
    if (cachedData) {
      const holders = cachedData.holders.slice(page * pageSize, (page + 1) * pageSize);
      const totalPages = Math.ceil(cachedData.holders.length / pageSize);
      const response = {
        holders,
        totalPages,
        totalTokens: cachedData.holders.reduce((sum, h) => sum + h.total, 0),
        totalBurned: cachedData.totalBurned,
        summary: {
          totalLive: cachedData.holders.reduce((sum, h) => sum + h.total, 0),
          totalBurned: cachedData.totalBurned,
          totalMinted: config.nftContracts[contractKey].expectedTotalSupply + config.nftContracts[contractKey].expectedBurned,
          tierDistribution: cachedData.holders.reduce((acc, h) => {
            h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
            return acc;
          }, []),
          multiplierPool: cachedData.holders.reduce((sum, h) => sum + h.multiplierSum, 0),
          totalRewardPool: cachedData.holders.reduce((sum, h) => sum + (h.claimableRewards || 0) + (h.infernoRewards || 0) + (h.fluxRewards || 0) + (h.e280Rewards || 0), 0),
        },
      };
      if (contractKey === 'ascendant') {
        response.summary.totalShares = cachedData.totalShares || 0;
        response.summary.pendingRewards = cachedData.pendingRewards || 0;
      }
      return NextResponse.json(response);
    }

    const { status, holders } = await populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi);
    if (status === 'error') throw new Error('Cache population failed');

    const paginatedHolders = holders.slice(page * pageSize, (page + 1) * pageSize);
    const totalPages = Math.ceil(holders.length / pageSize);
    const response = {
      holders: paginatedHolders,
      totalPages,
      totalTokens: holders.reduce((sum, h) => sum + h.total, 0),
      totalBurned: (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalBurned || 0,
      summary: {
        totalLive: holders.reduce((sum, h) => sum + h.total, 0),
        totalBurned: (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalBurned || 0,
        totalMinted: config.nftContracts[contractKey].expectedTotalSupply + config.nftContracts[contractKey].expectedBurned,
        tierDistribution: holders.reduce((acc, h) => {
          h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
          return acc;
        }, []),
        multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
        totalRewardPool: holders.reduce((sum, h) => sum + (h.claimableRewards || 0) + (h.infernoRewards || 0) + (h.fluxRewards || 0) + (h.e280Rewards || 0), 0),
      },
    };
    if (contractKey === 'ascendant') {
      response.summary.totalShares = (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalShares || 0;
      response.summary.pendingRewards = (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.pendingRewards || 0;
    }
    return NextResponse.json(response);
  } catch (error) {
    logger.error(contractKey, `GET error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to fetch ${contractKey} holders`, details: error.message }, { status: 500 });
  }
}

// POST handler
export async function POST(request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();
  if (!config.contractDetails[contractKey]) {
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  const contractAddress = config.contractAddresses[contractKey]?.address;
  const abi = config.abis[contractKey]?.main;
  const vaultAddress = config.vaultAddresses[contractKey]?.address;
  const vaultAbi = config.abis[contractKey]?.vault;

  try {
    const { forceUpdate } = await request.json().catch(() => ({}));
    const cacheState = await getCacheState(contractKey);
    if (cacheState.isPopulating && !forceUpdate) {
      return NextResponse.json({ message: 'Cache population already in progress', status: 'in_progress' }, { status: 202 });
    }
    const { status, error } = await populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate === true);
    if (status === 'error') throw new Error(error || 'Cache population failed');
    return NextResponse.json({ 
      message: status === 'up_to_date' ? 'Cache is up to date' : `${contractKey} cache population triggered`, 
      status 
    });
  } catch (error) {
    logger.error(contractKey, `POST error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to populate ${contractKey} cache`, details: error.message }, { status: 500 });
  }
}
-e 
---
File: ./app/api/holders/[contract]/progress/route.js
import { NextResponse } from 'next/server';
import { logger, loadCacheState } from '@/app/api/utils';
import config from '@/config';

async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.progressState = {
        step: savedState.progressState?.step ?? 'idle',
        processedNfts: savedState.progressState?.processedNfts ?? 0,
        totalNfts: savedState.progressState?.totalNfts ?? 0,
        processedTiers: savedState.progressState?.processedTiers ?? 0,
        totalTiers: savedState.progressState?.totalTiers ?? 0,
        error: savedState.progressState?.error ?? null,
        errorLog: savedState.progressState?.errorLog ?? [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
    }
  } catch (error) {
    logger.error(contractKey, `Failed to load cache state: ${error.message}`, { stack: error.stack });
  }
  return cacheState;
}

export async function GET(_request, { params }) {
  const { contract } = await params; // Await params
  const contractKey = contract.toLowerCase();

  if (!config.contractDetails[contractKey]) {
    logger.error(contractKey, `Invalid contract: ${contractKey}`);
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  try {
    const state = await getCacheState(contractKey);
    if (!state || !state.progressState) {
      logger.error(contractKey, 'Invalid cache state');
      return NextResponse.json({ error: 'Cache state not initialized' }, { status: 500 });
    }

    let progressPercentage = '0.0';
    if (state.progressState.error) {
      progressPercentage = '0.0';
    } else if (state.progressState.step === 'completed') {
      progressPercentage = '100.0';
    } else if (state.progressState.totalNfts > 0) {
      if (state.progressState.step === 'fetching_owners') {
        const ownerProgress = (state.progressState.processedNfts / state.progressState.totalNfts) * 50;
        progressPercentage = Math.min(ownerProgress, 50).toFixed(1);
      } else if (state.progressState.step === 'fetching_tiers') {
        const tierProgress = (state.progressState.processedTiers / state.progressState.totalTiers) * 50;
        progressPercentage = Math.min(50 + tierProgress, 100).toFixed(1);
      }
    }

    return NextResponse.json({
      isPopulating: state.isPopulating,
      totalLiveHolders: state.totalOwners,
      totalOwners: state.totalOwners,
      phase: state.progressState.step.charAt(0).toUpperCase() + state.progressState.step.slice(1),
      progressPercentage,
      lastProcessedBlock: state.lastProcessedBlock,
      error: state.progressState.error || null,
      errorLog: state.progressState.errorLog || [],
    });
  } catch (error) {
    logger.error(contractKey, `Progress endpoint error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to fetch ${contractKey} cache state`, details: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils.js
// File: app/api/utils.js
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { Redis } from '@upstash/redis';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy } from 'alchemy-sdk';
import config from '@/config';
import pLimit from 'p-limit';
import { logger } from '@/lib/logger';
import chalk from 'chalk';

console.log(chalk.cyan('[Utils] Initializing utils...'));
logger.info('utils', 'Utils module loaded', 'eth', 'general').catch(error => {
  console.error(chalk.red('[Utils] Logger error:'), error.message);
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const isDebug = process.env.DEBUG === 'true';
const isProduction = process.env.NODE_ENV === 'production';

const cache = new NodeCache({
  stdTTL: 0,
  checkperiod: 120,
});

const cacheDir = path.join(process.cwd(), 'cache');

const redisEnabled = Object.keys(config.nftContracts).some(
  contract => process.env[`DISABLE_${contract.toUpperCase()}_REDIS`] !== 'true' && process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN
);
let redis = null;

if (redisEnabled) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });
    logger.info('utils', 'Upstash Redis initialized', 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to initialize Upstash Redis: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    redis = null;
  }
}

const alchemyApiKey = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  logger.error('utils', 'Alchemy API key is missing', {}, 'eth', 'general');
  throw new Error('Alchemy API key is missing');
}

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`),
});

const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: 'eth-mainnet',
});

async function ensureCacheDir() {
  try {
    await fs.mkdir(cacheDir, { recursive: true });
    await fs.chmod(cacheDir, 0o755);
    logger.info('utils', `Created/chmod cache directory: ${cacheDir}`, 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to create/chmod cache directory ${cacheDir}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function initializeCache() {
  try {
    logger.info('utils', 'Starting cache initialization', 'eth', 'general');
    await ensureCacheDir();

    // Check node-cache
    const testKey = 'test_node_cache';
    const testValue = { ready: true };
    const nodeCacheSuccess = cache.set(testKey, testValue);
    if (nodeCacheSuccess) {
      logger.info('utils', 'Node-cache is ready', 'eth', 'general');
      cache.del(testKey);
    } else {
      logger.error('utils', 'Node-cache failed to set test key', {}, 'eth', 'general');
    }

    // Check Redis
    if (redisEnabled && redis) {
      try {
        await redis.set('test_redis', JSON.stringify(testValue));
        const redisData = await redis.get('test_redis');
        if (redisData && JSON.parse(redisData).ready) {
          logger.info('utils', 'Redis cache is ready', 'eth', 'general');
          await redis.del('test_redis');
        } else {
          logger.error('utils', 'Redis cache test failed: invalid data', {}, 'eth', 'general');
        }
      } catch (error) {
        logger.error('utils', `Redis cache test failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      }
    }

    // Create empty cache files for each collection
    const collections = Object.keys(config.nftContracts).filter(key => !config.nftContracts[key].disabled).map(key => key.toLowerCase());
    for (const collection of collections) {
      const cacheFile = path.join(cacheDir, `${collection}_holders.json`);
      try {
        await fs.access(cacheFile);
        logger.info('utils', `Cache file exists: ${cacheFile}`, 'eth', collection);
      } catch (error) {
        if (error.code === 'ENOENT') {
          await fs.writeFile(cacheFile, JSON.stringify({ holders: [], totalBurned: 0, timestamp: Date.now() }));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Created empty cache file: ${cacheFile}`, 'eth', collection);
        } else {
          logger.error('utils', `Failed to access cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', collection);
        }
      }
    }

    logger.info('utils', 'Cache initialization completed', 'eth', 'general');
    return true;
  } catch (error) {
    logger.error('utils', `Cache initialization error: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return false;
  }
}

async function retry(operation, { retries, delay = 1000 }) {
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.message.includes('429') && attempt === retries) {
        logger.error('utils', `Circuit breaker: Rate limit exceeded after ${retries} attempts`, {}, 'eth', 'general');
        throw new Error('Rate limit exceeded');
      }
      logger.warn('utils', `Retry attempt ${attempt}/${retries} failed: ${error.message}`, 'eth', 'general');
      await new Promise(resolve => setTimeout(resolve, delay * Math.min(attempt, 3)));
    }
  }
  throw lastError;
}

async function batchMulticall(calls, batchSize = config.alchemy.batchSize || 10) {
  const results = [];
  const delay = async () => new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs || 500));

  const concurrencyLimit = pLimit(3);
  const batchPromises = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    batchPromises.push(
      concurrencyLimit(async () => {
        try {
          await delay();
          const batchResults = await client.multicall({
            contracts: batch.map(call => ({
              address: call.address,
              abi: call.abi,
              functionName: call.functionName,
              args: call.args || [],
            })),
            allowFailure: true,
          });

          const batchResult = batchResults.map((result, index) => ({
            status: result.status === 'success' ? 'success' : 'failure',
            result: result.status === 'success' ? result.result : null,
            error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
          }));
          return batchResult;
        } catch (error) {
          logger.error('utils', `Batch multicall failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
          return batch.map(() => ({
            status: 'failure',
            result: null,
            error: error.message,
          }));
        }
      })
    );
  }

  const batchResults = (await Promise.all(batchPromises)).flat();
  results.push(...batchResults);
  return results;
}

async function getOwnersForContract(contractAddress, abi, options = {}) {
  let owners = [];
  let pageKey = options.pageKey || null;
  const maxPages = options.maxPages || 10; // Safety limit to prevent infinite loops
  let pageCount = 0;

  logger.debug('utils', `Fetching owners for contract: ${contractAddress} with options: ${JSON.stringify(options)}`, 'eth', 'general');

  do {
    try {
      const response = await alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: options.withTokenBalances || false,
        pageKey,
      });

      logger.debug('utils', `Raw Alchemy response: ownersExists=${!!response.owners}, isArray=${Array.isArray(response.owners)}, ownersLength=${response.owners?.length || 0}, pageKey=${response.pageKey || null}, responseKeys=${Object.keys(response)}, sampleOwners=${JSON.stringify(response.owners?.slice(0, 2) || [])}`, 'eth', 'general');

      if (!response.owners || !Array.isArray(response.owners)) {
        logger.error('utils', `Invalid Alchemy response for ${contractAddress}: ${JSON.stringify(response)}`, {}, 'eth', 'general');
        throw new Error('Invalid owners response from Alchemy API');
      }

      for (const owner of response.owners) {
        const tokenBalances = owner.tokenBalances || [];
        logger.debug('utils', `Processing owner: ${owner.ownerAddress}, tokenBalancesCount=${tokenBalances.length}`, 'eth', 'general');

        if (tokenBalances.length > 0) {
          const validBalances = tokenBalances.filter(
            tb => tb.tokenId && Number(tb.balance) > 0
          );
          if (validBalances.length > 0) {
            owners.push({
              ownerAddress: owner.ownerAddress.toLowerCase(),
              tokenBalances: validBalances.map(tb => ({
                tokenId: Number(tb.tokenId),
                balance: Number(tb.balance),
              })),
            });
          }
        }
      }

      pageKey = response.pageKey || null;
      pageCount++;
      logger.debug('utils', `Fetched page ${pageCount}, owners: ${owners.length}, pageKey: ${pageKey}`, 'eth', 'general');

      if (pageCount >= maxPages) {
        logger.warn('utils', `Reached max pages (${maxPages}) for owner fetching`, 'eth', 'general');
        break;
      }
    } catch (error) {
      logger.error('utils', `Failed to fetch owners for ${contractAddress}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      throw error;
    }
  } while (pageKey);

  logger.debug('utils', `Processed owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, 'eth', 'general');
  logger.info('utils', `Fetched ${owners.length} owners for contract: ${contractAddress}`, 'eth', 'general');
  return owners;
}

async function setCache(key, value, ttl, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    const success = cache.set(cacheKey, value);
    logger.info('utils', `Set in-memory cache: ${cacheKey}, success: ${success}, holders: ${value.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          await redis.set(cacheKey, JSON.stringify(value));
          logger.info('utils', `Persisted ${cacheKey} to Redis, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to persist ${cacheKey} to Redis: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      } else {
        const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
        logger.info('utils', `Writing to cache file: ${cacheFile}`, 'eth', prefix.toLowerCase());
        await ensureCacheDir();
        try {
          await fs.writeFile(cacheFile, JSON.stringify(value));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Persisted ${cacheKey} to ${cacheFile}, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to write cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
          throw error;
        }
      }
    }
    return success;
  } catch (error) {
    logger.error('utils', `Failed to set cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return false;
  }
}

async function getCache(key, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    let data = cache.get(cacheKey);
    if (data !== undefined) {
      logger.debug('utils', `Cache hit: ${cacheKey}, holders: ${data.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());
      return data;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          const redisData = await redis.get(cacheKey);
          if (redisData) {
            const parsed = typeof redisData === 'string' ? JSON.parse(redisData) : redisData;
            if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
              const success = cache.set(cacheKey, parsed);
              logger.info('utils', `Loaded ${cacheKey} from Redis, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
              return parsed;
            } else {
              logger.warn('utils', `Invalid data in Redis for ${cacheKey}`, 'eth', prefix.toLowerCase());
            }
          }
        } catch (error) {
          logger.error('utils', `Failed to load cache from Redis for ${cacheKey}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      }

      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        const parsed = JSON.parse(fileData);
        if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
          const success = cache.set(cacheKey, parsed);
          logger.info('utils', `Loaded ${cacheKey} from ${cacheFile}, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
          return parsed;
        } else {
          logger.warn('utils', `Invalid data in ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      } catch (error) {
        if (error.code !== 'ENOENT') {
          logger.error('utils', `Failed to load cache from ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        } else {
          logger.debug('utils', `No cache file at ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      }
    }

    logger.info('utils', `Cache miss: ${cacheKey}`, 'eth', prefix.toLowerCase());
    return null;
  } catch (error) {
    logger.error('utils', `Failed to get cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function saveCacheState(collection, state, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    await ensureCacheDir();
    await fs.writeFile(cacheFile, JSON.stringify(state));
    await fs.chmod(cacheFile, 0o644);
    logger.debug('utils', `Saved cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
  } catch (error) {
    logger.error('utils', `Failed to save cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
  }
}

async function loadCacheState(collection, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    const data = await fs.readFile(cacheFile, 'utf8');
    const parsed = JSON.parse(data);
    logger.debug('utils', `Loaded cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
    return parsed;
  } catch (error) {
    if (error.code === 'ENOENT') {
      logger.debug('utils', `No cache state found for ${prefix}`, 'eth', prefix.toLowerCase());
      return null;
    }
    logger.error('utils', `Failed to load cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function getTransactionReceipt(transactionHash) {
  try {
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    logger.debug('utils', `Fetched transaction receipt for ${transactionHash}`, 'eth', 'general');
    return receipt;
  } catch (error) {
    logger.error('utils', `Failed to fetch transaction receipt for ${transactionHash}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return null;
  }
}

async function log(scope, message, chain = 'eth', collection = 'general') {
  await logger.info(scope, message, chain, collection);
}

export { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract, getTransactionReceipt, log, initializeCache };-e 
---
File: ./app/api/debug/route.js
import { NextResponse } from 'next/server';
import { logger } from '@/lib/logger';

console.log('[Debug Route] Importing logger');
logger.info('debug', 'Debug route module loaded').catch(console.error);

export async function GET() {
  await logger.info('debug', 'Debug endpoint called');
  return NextResponse.json({
    message: 'Debug endpoint triggered',
    debug: process.env.DEBUG,
    nodeEnv: process.env.NODE_ENV,
  });
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global resets */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #111827; /* Gray-900 */
  color: #ffffff; /* White text */
  min-height: 100vh;
}

/* Animation for fade-in */
.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Highlight row for tables */
.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.
const config = {
  plugins: ["tailwindcss"],
};
export default config;
-e 
---
File: ./test-alchemy.js
import { Alchemy } from 'alchemy-sdk';
import dotenv from 'dotenv';
dotenv.config();

const alchemy = new Alchemy({
  apiKey: process.env.ALCHEMY_API_KEY,
  network: 'eth-mainnet',
});

async function testOwners(contractAddress, contractName) {
  try {
    console.log(`Testing ${contractName} at ${contractAddress}`);
    const response = await alchemy.nft.getOwnersForContract(contractAddress, {
      withTokenBalances: true,
    });
    console.log(`[${contractName}] Owners exists: ${!!response.owners}, Is array: ${Array.isArray(response.owners)}, Length: ${response.owners?.length || 0}`);
    if (!response.owners || !Array.isArray(response.owners)) {
      console.log(`[${contractName}] Response keys: ${Object.keys(response || {})}`);
    }
  } catch (error) {
    console.log(`[${contractName}] Error: ${error.message}`);
  }
}

async function runTests() {
  const contracts = [
    { name: 'Stax', address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1' },
    { name: 'element369', address: '0x024D64E2F65747d8bB02dFb852702D588A062575' },
    { name: 'element280', address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    { name: 'ascendant', address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f' },
  ];
  for (const { name, address } of contracts) {
    await testOwners(address, name);
    console.log('---');
  }
}

runTests();-e 
---
File: ./next.config.mjs
// File: next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  serverExternalPackages: ['viem', 'alchemy-sdk'],
  webpack: (config) => {
    config.resolve.fallback = { fs: false, path: false };
    return config;
  },
};

export default nextConfig;-e 
---
File: ./config.js
// config.js
import element280MainAbi from './abi/element280.json' assert { type: 'json' };
import element280VaultAbi from './abi/element280Vault.json' assert { type: 'json' };
import element369MainAbi from './abi/element369.json' assert { type: 'json' };
import element369VaultAbi from './abi/element369Vault.json' assert { type: 'json' };
import staxMainAbi from './abi/staxNFT.json' assert { type: 'json' };
import staxVaultAbi from './abi/staxVault.json' assert { type: 'json' };
import ascendantMainAbi from './abi/ascendantNFT.json' assert { type: 'json' };
// E280 ABI placeholder (not deployed)
const e280MainAbi = [];

const config = {
  // Supported blockchain networks
  supportedChains: ['ETH', 'BASE'],

  // ABIs for all collections
  abis: {
    element280: {
      main: element280MainAbi,
      vault: element280VaultAbi,
    },
    element369: {
      main: element369MainAbi,
      vault: element369VaultAbi,
    },
    stax: {
      main: staxMainAbi,
      vault: staxVaultAbi,
    },
    ascendant: {
      main: ascendantMainAbi,
      vault: [], // No vault ABI provided for Ascendant
    },
    e280: {
      main: e280MainAbi,
      vault: [],
    },
  },

  // NFT contract configurations
  nftContracts: {
    element280: {
      name: 'Element 280',
      symbol: 'ELMNT',
      chain: 'ETH',
      address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
      vaultAddress: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
      deploymentBlock: '20945304',
      tiers: {
        1: { name: 'Common', multiplier: 10, allocation: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 12, allocation: '100000000000000000000000000' },
        3: { name: 'Rare', multiplier: 100, allocation: '1000000000000000000000000000' },
        4: { name: 'Rare Amped', multiplier: 120, allocation: '1000000000000000000000000000' },
        5: { name: 'Legendary', multiplier: 1000, allocation: '10000000000000000000000000000' },
        6: { name: 'Legendary Amped', multiplier: 1200, allocation: '10000000000000000000000000000' },
      },
      description:
        'Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.',
      expectedTotalSupply: 8107,
      expectedBurned: 8776,
      maxTokensPerOwnerQuery: 100,
    },
    element369: {
      name: 'Element 369',
      symbol: 'E369',
      chain: 'ETH',
      address: '0x024D64E2F65747d8bB02dFb852702D588A062575',
      vaultAddress: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',
      deploymentBlock: '21224418',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        3: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
      },
      description:
        'Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.',
    },
    stax: {
      name: 'Stax',
      symbol: 'STAX',
      chain: 'ETH',
      address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
      vaultAddress: '0x5D27813C32dD705404d1A78c9444dAb523331717',
      deploymentBlock: '21452667',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 1.2, price: '100000000000000000000000000', amplifier: '10000000000000000000000000' },
        3: { name: 'Common Super', multiplier: 1.4, price: '100000000000000000000000000', amplifier: '20000000000000000000000000' },
        4: { name: 'Common LFG', multiplier: 2, price: '100000000000000000000000000', amplifier: '50000000000000000000000000' },
        5: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        6: { name: 'Rare Amped', multiplier: 12, price: '1000000000000000000000000000', amplifier: '100000000000000000000000000' },
        7: { name: 'Rare Super', multiplier: 14, price: '1000000000000000000000000000', amplifier: '200000000000000000000000000' },
        8: { name: 'Rare LFG', multiplier: 20, price: '1000000000000000000000000000', amplifier: '500000000000000000000000000' },
        9: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
        10: { name: 'Legendary Amped', multiplier: 120, price: '10000000000000000000000000000', amplifier: '1000000000000000000000000000' },
        11: { name: 'Legendary Super', multiplier: 140, price: '10000000000000000000000000000', amplifier: '2000000000000000000000000000' },
        12: { name: 'Legendary LFG', multiplier: 200, price: '10000000000000000000000000000', amplifier: '5000000000000000000000000000' },
      },
      description:
        'Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.',
    },
    ascendant: {
      name: 'Ascendant',
      symbol: 'ASCNFT',
      chain: 'ETH',
      address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f',
      deploymentBlock: '21112535',
      tiers: {
        1: { name: 'Tier 1', price: '7812500000000000000000', multiplier: 1.01 },
        2: { name: 'Tier 2', price: '15625000000000000000000', multiplier: 1.02 },
        3: { name: 'Tier 3', price: '31250000000000000000000', multiplier: 1.03 },
        4: { name: 'Tier 4', price: '62500000000000000000000', multiplier: 1.04 },
        5: { name: 'Tier 5', price: '125000000000000000000000', multiplier: 1.05 },
        6: { name: 'Tier 6', price: '250000000000000000000000', multiplier: 1.06 },
        7: { name: 'Tier 7', price: '500000000000000000000000', multiplier: 1.07 },
        8: { name: 'Tier 8', price: '1000000000000000000000000', multiplier: 1.08 },
      },
      description:
        'Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.',
    },
    e280: {
      name: 'E280',
      symbol: 'E280',
      chain: 'BASE',
      address: null,
      deploymentBlock: null,
      tiers: {},
      description: 'E280 NFTs on BASE chain. Contract not yet deployed.',
      disabled: true,
    },
  },

  // Contract addresses
  contractAddresses: {
    element280: { chain: 'ETH', address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    element369: { chain: 'ETH', address: '0x024D64E2F65747d8bB02dFb852702D588A062575' },
    stax: { chain: 'ETH', address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1' },
    ascendant: { chain: 'ETH', address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f' },
    e280: { chain: 'BASE', address: null },
  },

  // Vault addresses
  vaultAddresses: {
    element280: { chain: 'ETH', address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97' },
    element369: { chain: 'ETH', address: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5' },
    stax: { chain: 'ETH', address: '0x5D27813C32dD705404d1A78c9444dAb523331717' },
    e280: { chain: 'BASE', address: null },
  },

  // Deployment blocks
  deploymentBlocks: {
    element280: { chain: 'ETH', block: '20945304' },
    element369: { chain: 'ETH', block: '21224418' },
    stax: { chain: 'ETH', block: '21452667' },
    ascendant: { chain: 'ETH', block: '21112535' },
    e280: { chain: 'BASE', block: null },
  },

  // Contract tiers
  contractTiers: {
    element280: {
      1: { name: 'Common', multiplier: 10 },
      2: { name: 'Common Amped', multiplier: 12 },
      3: { name: 'Rare', multiplier: 100 },
      4: { name: 'Rare Amped', multiplier: 120 },
      5: { name: 'Legendary', multiplier: 1000 },
      6: { name: 'Legendary Amped', multiplier: 1200 },
    },
    element369: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Rare', multiplier: 10 },
      3: { name: 'Legendary', multiplier: 100 },
      tierOrder: [
        { tierId: '3', name: 'Legendary' },
        { tierId: '2', name: 'Rare' },
        { tierId: '1', name: 'Common' },
      ],
    },
    stax: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Common Amped', multiplier: 1.2 },
      3: { name: 'Common Super', multiplier: 1.4 },
      4: { name: 'Common LFG', multiplier: 2 },
      5: { name: 'Rare', multiplier: 10 },
      6: { name: 'Rare Amped', multiplier: 12 },
      7: { name: 'Rare Super', multiplier: 14 },
      8: { name: 'Rare LFG', multiplier: 20 },
      9: { name: 'Legendary', multiplier: 100 },
      10: { name: 'Legendary Amped', multiplier: 120 },
      11: { name: 'Legendary Super', multiplier: 140 },
      12: { name: 'Legendary LFG', multiplier: 200 },
    },
    ascendant: {
      1: { name: 'Tier 1', multiplier: 1.01 },
      2: { name: 'Tier 2', multiplier: 1.02 },
      3: { name: 'Tier 3', multiplier: 1.03 },
      4: { name: 'Tier 4', multiplier: 1.04 },
      5: { name: 'Tier 5', multiplier: 1.05 },
      6: { name: 'Tier 6', multiplier: 1.06 },
      7: { name: 'Tier 7', multiplier: 1.07 },
      8: { name: 'Tier 8', multiplier: 1.08 },
    },
    e280: {},
  },

  // Contract details
  contractDetails: {
    element280: {
      name: 'Element 280',
      chain: 'ETH',
      pageSize: 100,
      apiEndpoint: '/api/holders/Element280',
      rewardToken: 'ELMNT',
    },
    element369: {
      name: 'Element 369',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Element369',
      rewardToken: 'INFERNO/FLUX/E280',
    },
    stax: {
      name: 'Stax',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Stax',
      rewardToken: 'X28',
    },
    ascendant: {
      name: 'Ascendant',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Ascendant',
      rewardToken: 'DRAGONX',
    },
    e280: {
      name: 'E280',
      chain: 'BASE',
      pageSize: 1000,
      apiEndpoint: '/api/holders/E280',
      rewardToken: 'E280',
      disabled: true,
    },
  },

  // Utility function to get contract details by name
  getContractDetails: (contractName) => {
    return config.nftContracts[contractName] || null;
  },

  alchemy: {
    apiKey: process.env.ALCHEMY_API_KEY || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
    network: 'eth-mainnet',
    batchSize: 50, // Increased for larger batches
    batchDelayMs: 500, // Reduced for speed
    retryMaxDelayMs: 10000, // Reduced to fail faster
    maxRetries: 2, // Reduced to minimize retry overhead
    timeoutMs: 30000,
  },
  
  // Cache settings
  cache: {
    redis: {
      disableElement280: process.env.DISABLE_ELEMENT280_REDIS === 'true',
      disableElement369: process.env.DISABLE_ELEMENT369_REDIS === 'true',
      disableStax: process.env.DISABLE_STAX_REDIS === 'true',
      disableAscendant: process.env.DISABLE_ASCENDANT_REDIS === 'true',
      disableE280: process.env.DISABLE_E280_REDIS === 'true' || true,
    },
    nodeCache: {
      stdTTL: 3600,
      checkperiod: 120,
    },
  },

  // Debug settings
  debug: {
    enabled: process.env.DEBUG === 'true',
    logLevel: 'debug',
  },

  // Fallback data (optional, for testing)
  fallbackData: {
    element280: process.env.USE_FALLBACK_DATA === 'true' ? element280NftStatus : null,
  },
};

export default config;-e 
---
File: ./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
-e 
---
File: ./README.md
Please find below my Nextjs project TitanXUtils.  This part is concentrating on 4 NFT colections and analysing their data.

Element369, Stax and Ascendant are complete.

I am still trying to perfect the Element280 NFT collection.
All 4 of these are on Ethereum.
I also have a placeholder for future collection E280; this will be deployed on BASE

I have a few components that are important for this analysis.
It shoud be noted that any code changes and enhancements/testing scripts should not risk breaking the work we've already done for  Element369, Stax and Ascendant 


These 3 are the wallets that I own:
0x15702443110894B26911B913b17ea4931F803B02
0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
0x9D641961a31B3eED46e664fA631aAD3021323862

wallet: 0x15702443110894B26911B913b17ea4931F803B02
this output should be the following:
Element 280, live nfts count 29, 5 amped legendary, 1 legendary, 6 rare amped and 17 amp common: 
Minted 2  
Tiers minted  [0,0,0,0,0,2]
Transferred in  28
Transferred out  1
Burned 0

wallet: 0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
this output should be the following:
Element 280, live nfts count 0
Minted 22 
Tiers minted  [[0,17,0,3,0,2]
Transferred in 6
Transferred out 27
Burned 1

wallet: 0x9D641961a31B3eED46e664fA631aAD3021323862
this output should be the following:
Element 280, live nfts count 0
Minted 0
Tiers minted   [0,0,0,0,0,0]
Transferred in 2
Transferred out 2
Burned 0

The current claimable reward Element280 tokens for wallet 0x15702443110894B26911B913b17ea4931F803B02 is currently 1,301,036,482 and my current % of rewards is 1.199%

This is because it is only valid for wallets that currently own at least bone element280 NFT to have a current claimable amount.  This information can be used with the Element280Vault contract and abi to calculate the Claimable value for a wallet.  

The project code and data sources that I think we need for our further analysis is below.



.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI

project includes below

{
  "name": "titanx-utility",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@covalenthq/client-sdk": "^2.2.5",
    "@tanstack/react-query": "^5.72.1",
    "@wagmi/connectors": "^5.7.11",
    "alchemy-sdk": "^3.5.6",
    "chart.js": "^4.4.9",
    "dotenv": "^16.5.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.3",
    "minimist": "^1.2.8",
    "next": "14.2.15",
    "node-fetch": "^3.3.2",
    "p-limit": "^6.2.0",
    "pino": "^9.6.0",
    "pino-pretty": "^13.0.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-virtualized": "^9.22.6",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.1.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.15",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^3.4.17"
  }


===========next

Thank you for the additional requirements. To summarize, the solution must:
Be specific to Element 280, ensuring no impact on other NFT collections.

Address potential database staleness by querying the blockchain for the latest data while using the element280.db database for wallet-specific data and complex aggregates.

Update the element280.db database with any new data obtained from the blockchain to keep it as up-to-date as possible.

Resolve the SQLITE_ERROR: table element280_summary has no column named totalRewardPool issue for the NFT->ETH->Element280 page.

Ensure the solution is quick, easy, and verifies the three wallets’ data from wallets.json.

We’ll implement a hybrid approach that:
Fetches real-time data (totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, tierDistribution) from the Element 280 NFT and vault contracts using a single multicall and Alchemy’s getOwnersForContract.

Queries the database (element280.db) for wallet-specific data (element280_wallets) and burnedDistribution, as computing historical burn data on-chain is complex.

Updates the element280_summary table with fresh blockchain data to keep it up-to-date.

Ensures all changes are isolated to Element 280-specific code (/api/holders/Element280, public/data/element280.db, and optionally trackElement280NFTs.js).

This approach resolves the SQLITE_ERROR, ensures real-time accuracy, keeps the database updated, and remains specific to Element 280.
Key Considerations
Element 280 Specificity:
Modify only /api/holders/Element280 (or equivalent, e.g., app/api/holders/Element280/route.js or pages/api/holders/Element280.js).

Use public/data/element280.db, isolated from other collections’ databases.

Reference only Element 280’s CONTRACT_ADDRESS (NFT) and VAULT_CONTRACT_ADDRESS (vault).

Avoid shared utilities or ABIs used by other collections.

Handling Database Staleness:
Fetch totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, and tierDistribution from the blockchain for real-time data.

Query element280_wallets for wallet data and element280_summary for burnedDistribution (historical data).

Update element280_summary with new blockchain data to keep it current.

Database Updates:
Add totalRewardPool to element280_summary schema to store blockchain-fetched data.

Update totalWallets, tierDistribution, and other fields in element280_summary with blockchain data.

Ensure element280_wallets updates are handled by trackElement280NFTs.js (existing script).

Solution Goals:
Resolve SQLITE_ERROR by adding totalRewardPool to the database and fetching it on-chain.

Ensure real-time data for critical metrics.

Maintain performance by leveraging the database for wallet data.

Keep changes minimal and Element 280-specific.

Implementation
Step 1: Update the Database Schema
Since the SQLITE_ERROR indicates element280_summary lacks a totalRewardPool column, we’ll add it to the schema. This requires updating trackElement280NFTs.js to include totalRewardPool and ensure the database is ready for updates from the API handler.
Update initDb in trackElement280NFTs.js:


its not just the summary table that needs to be updated with the latet data.  All the tables in the batabase need to be aswell.  These tables can be seen in the file scripts/trackElement280NFTs.jsspecifically the tables are described by the creation code in this file:


      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);```



===
old
cat components/NFTPage.js  components/NFTPageWrapper.js components/NFTSummary.js components/HolderTable/Ascendant.js components/HolderTable/Element369.js components/HolderTable/Element280.js components/HolderTable/E280.js components/HolderTable/Stax.js components/SearchResultsModal.js config.js app/store.js  app/page.js app/layout.js app/nft/page.js app/nft/\[chain\]/\[contract\]/page.js   > ClientStuff.txt
===

========================
Summary for README
========================
Current State: The application fetches and displays NFT holder data for collections (Element369, Element280, Stax, Ascendant, E280) using Alchemy and viem, with server-side caching (NodeCache) and client-side caching (useNFTStore). Element280’s cache population is slow (fetching_supply), causing delays.


Logging: Ensure DEBUG=false outputs only [ERROR] and [VALIDATION] logs, using pino-pretty in debug for readability.( this doesn't work in prod)
Enhance Caching: Use independent caches per collection, polling /progress endpoints to wait for server-side cache completion.
Improve Loading: Display loading states (<LoadingIndicator>) until each collection’s cache is ready, ensuring smooth switching between collections.
Support All Collections: Implement consistent /progress endpoints for Element369, Stax, Ascendant, and E280, Element280

Goal:
data is fetched for NFT collections when the button for that collection is clicked.  the cache should be checked first to make sure the data is available in the cache. The cache needs to contain all the data for that NFT collection ( wallets with live NFTs, their owned tiers, etc) and should either be written to file( node-cache) for quick access or Redit Upstash(controlled by env vars).  the cache needs to persist across server restarts.  If its not then the browser should give an animated loading message and then load the data when its fully available and only then render the page.  THe user can switch between NFT colections smoothly and each time its individual memory cache should be queried for complete data and only render once complete. Each NFT colection has its own memoey cache managed my node-cache (written to file) or Redis Upstash depending on whether an env variable is true or false.  I want to ensure the caching is correct before moving to redis upstash.
when a user switches to a different nft collection that data fetch should start. if the user switches back to the original nft collection the data fetch should continue from where it left off.
if a user uses the search functionality then this requires that all the data caches are completed before returning results.  The results should be one row for each NFT collection with its corresponding data and displayed on top of each other in a modal dialog.  The data for each collection is usually different.
If data is in the cache the system should load this but if there any more potential data on the block chain this should be checked first before displaying the data in the holder table. The cache should always be updated with the latest data from the blockchain when a user uses the Browser.  The cache should hold the lastBlock processed info)

Frontend Validation:
Verify HolderTable components (components/HolderTable/Element280.js, HolderTable/Element369.js, etc.) display data correctly (e.g., multiplierSum, shares, rewards).
i need help debugging the code to ensure this happens.
this project uses the free vercel tier and alchemy
Centralized configuration in config.js with ES Modules.
Moved ABIs to config.js for consistency.
Optimized Alchemy settings (batchSize: 10, batchDelayMs: 1000).
Caching Implementation
All collections (Element280, Element369, Stax, Ascendant) support Redis caching (via Upstash) and in-memory/file caching (node-cache) with toggles (DISABLE_*_REDIS in .env.local).

Testing:
Run the following commands to verify API endpoints:

curl -X POST http://localhost:3000/api/holders/Element280"
curl "http://localhost:3000/api/holders/Element280/progress"
curl "http://localhost:3000/api/holders/Element280"
curl "http://localhost:3000/api/holders/Stax"
curl "http://localhost:3000/api/holders/Element369"
curl "http://localhost:3000/api/holders/Ascendant"


*Data**:
  - Total Minted: 16,883 NFTs. ( this will never changed and shoud be hardcoded)
  - Total Live: 8,107 NFTs.  ( this is the current niumber as of a few days ago.  maybe less the next time we check. can only go down to 0)
  - Total Burned: 8,776 NFTs (via `Transfer` events to `0x0000...0000`). ( this is the current number as of a few days ago.  maybe more the next time we check. can only go up to a max of Total Minted)
  - Total Holders: 920 wallets ( as of now)


cat app/api/holders/Ascendant/route.js app/api/holders/Ascendant/progress/route.js \
app/api/holders/E280/route.js \
app/api/holders/E280/progress/route.js \
app/api/holders/Element369/route.js \
app/api/holders/Element369/progress/route.js \
app/store.js config.js app/api/utils.js > ./routes1.txt

cat app/api/holders/Ascendant/route.js app/api/holders/Ascendant/progress/route.js \
app/api/holders/E280/route.js \
app/api/holders/E280/progress/route.js \
app/api/holders/Element369/route.js \
app/api/holders/Element369/progress/route.js \
app/store.js config.js app/api/utils.js > ./routes1.txt

cat app/api/holders/Element280/route.js \
app/api/holders/Element280/progress/route.js \
app/api/holders/Element280/validate-burned/route.js \
app/api/holders/Stax/route.js \
app/store.js config.js app/api/utils.js \
app/api/holders/Stax/progress/route.js  lib/* > ./routes2.txt

cat app/api/holders/\[contract\]/route.js \
app/api/holders/\[contract\]/progress/route.js \
app/api/holders/Element280/validate-burned/route.js \
app/api/debug/route.js app/api/init/* \
app/store.js config.js app/api/utils.js lib/* > ./routes3.txt

cat components/*.js  components/*.jsx components/HolderTable/*.js config.js app/store.js app/page.js app/layout.js app/nft/layout.js app/nft/page.js app/nft/\[chain\]/\[contract\]/page.js   > ./ClientStuff.txt

cat package.json next.config.mjs jsconfig.json tailwind.config.js .env.local .env.development.local lib/*  app/store.js config.js app/api/utils.js > ./envs.txt

clear; cat envs.txt
clear; cat envs.txt  ./routes1.txt 
clear; cat envs.txt ./routes2.txt

clear; cat envs.txt ./routes3.txt 
clear; cat ClientStuff.txt

clear;npm run build

time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/Stax;

time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/element369;

time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/element280;

time curl -X POST http://localhost:3000/api/holders/ascendant;
time curl -X POST http://localhost:3000/api/holders/ascendant;
time curl -X POST http://localhost:3000/api/holders/ascendant;

time curl -X POST http://localhost:3000/api/holders/e280;


time curl -X POST http://localhost:3000/api/holders/Stax;
time curl -X POST http://localhost:3000/api/holders/element369;
time curl -X POST http://localhost:3000/api/holders/e280;
time curl -X POST http://localhost:3000/api/holders/element280;
time curl -X POST http://localhost:3000/api/holders/ascendant;

curl http://localhost:3000/api/holders/Stax/progress
curl http://localhost:3000/api/holders/element369/progress
curl http://localhost:3000/api/holders/e280/progress
curl http://localhost:3000/api/holders/element280/progress
curl http://localhost:3000/api/holders/ascendant/progress


route file basic structure

import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits } from 'viem';
import pLimit from 'p-limit';
import config from '@/config.js';
import { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract } from '@/app/api/utils';
import { HoldersResponseSchema } from '@/lib/schemas';

const limit = pLimit(5);

// Helper functions
async function getCacheState(contractKey) { ... }
async function saveCacheStateContract(contractKey, cacheState) { ... }
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) { ... }
async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState) { ... }
async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) { ... }

// GET handler
export async function GET(request, { params }) { ... }

// POST handler
export async function POST(request, { params }) { ... }-e 
---
File: ./test-logger.js
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const logDir = path.join(__dirname, '../logs');

async function testLogger() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log('Created log directory:', logDir);

    const logFile = path.join(logDir, `test-${new Date().toISOString().split('T')[0]}.log`);
    await fs.appendFile(logFile, 'Test log entry\n');
    console.log('Wrote to log file:', logFile);

    await fs.chmod(logFile, 0o644);
    console.log('Set file permissions for:', logFile);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

testLogger();-e 
---
File: ./not-found.js
// File: app/not-found.js

import Link from 'next/link';

export default function NotFound() {
  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 flex flex-col items-center justify-center p-6">
      <h1 className="text-4xl font-bold mb-4">Page Not Found</h1>
      <p className="text-lg mb-6">Sorry, the page you&apos;re looking for doesn&apos;t exist.</p>
      <Link href="/nft" className="btn btn-primary">
        Return to NFT Collections
      </Link>
    </div>
  );
}-e 
---
File: ./components/NFTLayout.js
// File: components/NFTLayout.js

'use client';

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import dynamic from 'next/dynamic';
import config from '@/config.js';
import { useNFTStore } from '@/app/store';

// Dynamically import SearchResultsModal
const SearchResultsModal = dynamic(() => import('@/components/SearchResultsModal'), { ssr: false });

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isClient, setIsClient] = useState(false);

  const { getCache, setCache } = useNFTStore();

  useEffect(() => {
    setIsClient(true);
  }, []);

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'stax' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendant' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(config.contractDetails).map((key) => ({
    name: config.contractDetails[key].name,
    apiKey: key,
    href:
      key === 'e280'
        ? null
        : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${config.contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (apiKey, apiEndpoint, pageSize) => {
    console.log(`[NFTLayout] Fetching data for ${apiKey} from ${apiEndpoint}`);
    try {
      if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
        console.log(`[NFTLayout] ${apiKey} is disabled`);
        return { error: `${apiKey} is not available` };
      }

      let endpoint = apiEndpoint;
      if (!endpoint || !endpoint.startsWith('http')) {
        const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
        endpoint = `${baseUrl}${apiEndpoint}`;
        console.log(`[NFTLayout] Adjusted endpoint: ${endpoint}`);
      }

      let allHolders = [];
      let totalTokens = 0;
      let totalShares = 0;
      let summary = {};
      let page = 0;
      let totalPages = Infinity;

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries || 3;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
            console.log(`[NFTLayout] Attempt ${attempts + 1} fetching ${url}`);
            const res = await fetch(url, {
              cache: 'force-cache',
              signal: AbortSignal.timeout(config.alchemy.timeoutMs || 30000),
            });
            if (!res.ok) {
              const errorText = await res.text();
              throw new Error(`Failed to fetch ${url}: ${res.status} ${errorText}`);
            }

            const json = await res.json();
            if (json.error) {
              console.log(`[NFTLayout] API error for ${apiKey}: ${json.error}`);
              return { error: json.error };
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              throw new Error(`Invalid holders data for ${url}`);
            }

            allHolders = allHolders.concat(json.holders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            summary = json.summary || summary;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            console.log(`[NFTLayout] Fetched page ${page} for ${apiKey}: ${json.holders.length} holders`);
          } catch (err) {
            attempts++;
            console.error(`[NFTLayout] Fetch attempt ${attempts} failed for ${apiKey}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page}: ${err.message}`);
            }
            await new Promise((resolve) => setTimeout(resolve, (config.alchemy.batchDelayMs || 1000) * attempts));
          }
        }
      }

      const data = {
        holders: allHolders,
        totalTokens,
        totalShares,
        summary,
      };
      console.log(`[NFTLayout] Setting cache for ${apiKey}: ${allHolders.length} holders`);
      setCache(apiKey, data);
      return data;
    } catch (error) {
      console.error(`[NFTLayout] Error fetching ${apiKey}: ${error.message}`);
      return { error: error.message };
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();

      for (const { apiKey } of allNFTs) {
        if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
          searchResults[apiKey] = { error: `${apiKey} is not available` };
          console.log(`[NFTLayout] Skipping disabled contract ${apiKey}`);
          continue;
        }

        let data = getCache(apiKey);
        console.log(`[NFTLayout] Cache check for ${apiKey}: ${data ? 'hit' : 'miss'}`);
        if (!data) {
          console.log(`[NFTLayout] Cache miss for ${apiKey}, fetching data`);
          const contractConfig = config.contractDetails[apiKey] || {};
          data = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);
        }

        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else {
          const holder = data.holders.find(
            (h) => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress
          );
          searchResults[apiKey] = holder
            ? {
                ...holder,
                totalShares: apiKey === 'ascendant' ? data.totalShares : undefined,
                totalTokens: data.totalTokens,
                rewardToken: config.contractDetails[apiKey]?.rewardToken,
              }
            : { error: 'No holdings found for this address' };
          console.log(`[NFTLayout] ${apiKey} search result:`, searchResults[apiKey]);
        }
      }

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err.message, err.stack);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    console.log('[NFTLayout] Chain selected:', chainId);
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    console.log('[NFTLayout] E280 button clicked, selectedChain:', selectedChain);
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  const handleCollectionClick = (name, href) => {
    console.log(`[NFTLayout] Collection button clicked: ${name}, href: ${href}`);
    setShowE280Message(false);
  };

  if (!isClient) {
    return (
      <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
        <h1 className="title mb-8">TitanX NFT Protocols</h1>
        <p>Loading...</p>
      </div>
    );
  }

  return (
    <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
      <h1 className="title mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="search-input"
            disabled={searchLoading}
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`btn btn-primary ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-error mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`btn btn-secondary ${
              selectedChain === chain.id ? 'bg-blue-500 text-gray-100' : ''
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => handleCollectionClick(nft.name, nft.href)}
                className="btn btn-secondary w-full"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) =>
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => handleCollectionClick(nft.name, nft.href)}
                  className="btn btn-secondary w-full"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="btn btn-secondary flex-1 w-full"
              >
                {nft.name}
              </motion.button>
            )
          )}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-gray-100">
          <p className="text-body">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl mt-6">{children}</div>
    </div>
  );
}-e 
---
File: ./components/NFTSummary.js
// File: components/NFTSummary.js

'use client';

import { useState, useEffect } from 'react';
import config from '@/config';

export default function NFTSummary({ collectionsData }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return <div>Loading...</div>;
  }

  return (
    <div className="space-y-section w-full max-w-6xl">
      {collectionsData.map(({ apiKey, data }) => (
        <div key={apiKey} className="card">
          <h2 className="subtitle">{config.contractDetails[apiKey]?.name || apiKey}</h2>
          {data.error ? (
            <p className="text-error">{data.error}</p>
          ) : (
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Tokens:</strong> {data.totalTokens?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Holders:</strong> {data.holders?.length || 0}
                </p>
              </div>
              {data.totalLockedAscendant > 0 && (
                <p>
                  <strong>Total Locked Ascendant:</strong>{' '}
                  {data.totalLockedAscendant?.toLocaleString() || 'N/A'}
                </p>
              )}
              {data.pendingRewards > 0 && (
                <p>
                  <strong>Pending Rewards:</strong>{' '}
                  {data.pendingRewards?.toLocaleString() || 'N/A'}
                </p>
              )}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}-e 
---
File: ./components/LoadingIndicator.js
import { memo } from 'react';

function LoadingIndicator({ status, progress }) {
  return (
    <div className="flex flex-col items-center justify-center p-6 bg-gray-800 rounded-lg">
      <svg className="animate-spin h-8 w-8 text-blue-500" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z" />
      </svg>
      <p className="mt-4 text-gray-200">{status}</p>
      {progress && (
        <div className="mt-2 w-64 bg-gray-700 rounded-full h-2.5">
          <div
            className="bg-blue-600 h-2.5 rounded-full"
            style={{ width: `${progress.progressPercentage}%` }}
          />
        </div>
      )}
    </div>
  );
}

export default memo(LoadingIndicator);-e 
---
File: ./components/NFTPage.js
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from '@/components/LoadingIndicator';
import config from '@/config.js';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { useNFTStore } from '@/app/store';
import { barChartOptions } from '@/lib/chartOptions';

// Dynamically import chart component
const Bar = dynamic(() => import('react-chartjs-2').then(mod => mod.Bar), { ssr: false });

// Default timeout for fetches
const DEFAULT_TIMEOUT_MS = 30000; // 30 seconds

// Retry utility
async function retry(fn, attempts = config.alchemy.maxRetries, delay = (retryCount) => Math.min(config.alchemy.batchDelayMs * 2 ** retryCount, config.alchemy.retryMaxDelayMs)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      console.error(`[NFTPage] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = config.contractAddresses.element280.address;
  const vaultAddress = config.vaultAddresses.element280.address;
  console.log(`[NFTPage] [INFO] Fetching contract data for Element280: contract=${contractAddress}, vault=${vaultAddress}`);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }
  if (!config.alchemy.apiKey) {
    throw new Error('Alchemy API key not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`, { timeout: Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS }),
  });

  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'totalSupply' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: config.abis.element280.vault, functionName: 'totalRewardPool' },
        ],
      })
    );
    console.log(`[NFTPage] [DEBUG] multicall results: ${JSON.stringify(results, (k, v) => (typeof v === 'bigint' ? v.toString() : v), 2)}`);
    const [totalSupply, tierCounts, multiplierPool, totalRewardPool] = results;
    if (totalSupply.status === 'failure') {
      throw new Error(`totalSupply call failed: ${totalSupply.error}`);
    }
    if (tierCounts.status === 'failure' || !tierCounts.result) {
      console.warn(`[NFTPage] [WARN] getTotalNftsPerTiers failed or returned no data: ${tierCounts.error || 'empty result'}`);
    }
    if (multiplierPool.status === 'failure' || !multiplierPool.result) {
      console.warn(`[NFTPage] [WARN] multiplierPool failed or returned no data: ${multiplierPool.error || 'empty result'}`);
    }
    if (totalRewardPool.status === 'failure') {
      throw new Error(`totalRewardPool call failed: ${totalRewardPool.error}`);
    }

    let burnedDistribution = [0, 0, 0, 0, 0, 0];
    let totalBurned = 0;
    try {
      const res = await fetch('/api/holders/Element280/validate-burned', { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
      if (res.ok) {
        const reader = res.body.getReader();
        let events = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line);
          for (const line of lines) {
            const data = JSON.parse(line);
            if (data.event) {
              const tier = data.event.tier;
              if (tier >= 1 && tier <= 6) {
                burnedDistribution[tier - 1]++;
              }
            }
            if (data.complete) {
              events = data.result.events;
              totalBurned = data.result.burnedCount;
            }
          }
        }
        console.log(`[NFTPage] [DEBUG] Burned distribution: ${burnedDistribution}, total events: ${events.length}, totalBurned: ${totalBurned}`);
      } else {
        console.error(`[NFTPage] [ERROR] Failed to fetch burned distribution: ${res.status}`);
      }
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Burned distribution fetch error: ${err.message}, stack: ${err.stack}`);
    }

    return {
      totalMinted: Number(totalSupply.result) + totalBurned,
      totalBurned,
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.status === 'success' && tierCounts.result ? tierCounts.result.map(Number) : [0, 0, 0, 0, 0, 0],
      multiplierPool: multiplierPool.status === 'success' && multiplierPool.result ? Number(multiplierPool.result) : 0,
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution,
    };
  } catch (error) {
    console.error(`[NFTPage] [ERROR] fetchContractData failed: ${error.message}, stack: ${error.stack}`);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  console.log(`[NFTPage] [INFO] Received props: chain=${chain}, contract=${contract}`);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [isInvalidContract, setIsInvalidContract] = useState(false);
  const [isClient, setIsClient] = useState(false);

  // Call useNFTStore unconditionally
  const { getCache, setCache } = useNFTStore();
  // Use useMemo to stabilize effectiveGetCache and effectiveSetCache
  const effectiveGetCache = useMemo(() => (isClient ? getCache : () => null), [isClient, getCache]);
  const effectiveSetCache = useMemo(() => (isClient ? setCache : () => {}), [isClient, setCache]);

  useEffect(() => {
    setIsClient(true);
  }, []);

  const contractId = contract ? contract.toLowerCase() : null;
  console.log(`[NFTPage] [INFO] Derived contractId: ${contractId}`);

  const contractConfig = config.contractDetails[contractId] || {};
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  const fetchData = useCallback(async () => {
    if (!apiEndpoint) {
      console.error(`[NFTPage] [ERROR] Invalid contract configuration for ${contractId}`);
      setError('Invalid contract configuration');
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      let progressData = { isPopulating: false, phase: 'Idle', progressPercentage: 0, totalOwners: 0 };
      if (isElement280) {
        try {
          console.log(`[NFTPage] [INFO] Fetching progress from ${apiEndpoint}/progress`);
          const res = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
          if (!res.ok) {
            console.error(`[NFTPage] [ERROR] Progress fetch failed: ${res.status}`);
          } else {
            progressData = await res.json();
            if (progressData.totalOwners === 0 && progressData.phase === 'Idle') {
              console.log(`[NFTPage] [INFO] Stale progress, triggering cache refresh`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              const retryRes = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
              if (retryRes.ok) progressData = await retryRes.json();
            }
          }
        } catch (err) {
          console.error(`[NFTPage] [ERROR] Progress fetch error: ${err.message}, stack: ${err.stack}`);
        }
        setProgress(progressData);
      }

      const cacheKey = `contract_data_${contractId}`;
      const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
      if (cachedData && cachedData.totalMinted > 0) {
        console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      let contractData;
      if (isElement280) {
        contractData = await fetchContractData();
      } else {
        contractData = {
          totalMinted: 0,
          totalBurned: 0,
          totalLive: 0,
          tierDistribution: [0, 0, 0, 0, 0, 0],
          multiplierPool: 0,
          totalRewardPool: 0,
          burnedDistribution: [0, 0, 0, 0, 0, 0],
        };
        console.log(`[NFTPage] [INFO] Using placeholder data for non-Element280 contract: ${contractId}`);
      }

      if (isClient) {
        effectiveSetCache(cacheKey, contractData);
      }
      setData(contractData);
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isElement280, isClient, effectiveGetCache, effectiveSetCache, name]);

  const fetchAllHolders = useCallback(async () => {
    const cacheKey = `holders_${contractId}`;
    const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
    if (cachedData) {
      console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}, holders: ${cachedData.holders.length}`);
      setData(prev => ({ ...prev, holders: cachedData.holders, summary: cachedData.summary }));
      setLoading(false);
      return;
    }
    console.log(`[NFTPage] [INFO] Cache miss for ${cacheKey}, fetching holders`);

    try {
      console.log(`[NFTPage] [INFO] Starting holders fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || config.contractDetails[contractId]?.pageSize;

      let progressData = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) }).then(res => res.json()).catch(() => ({}));
      if (progressData.phase === 'Idle' || progressData.totalOwners === 0) {
        console.log(`[NFTPage] [INFO] Cache is Idle or empty, triggering POST`);
        await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
      }

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            console.log(`[NFTPage] [INFO] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[NFTPage] [ERROR] Fetch failed for ${url}: ${res.status} - ${errorText}`);
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            console.log(`[NFTPage] [DEBUG] API response for ${url}: holders=${json.holders?.length}, totalTokens=${json.totalTokens}`);
            if (json.error) {
              console.error(`[NFTPage] [ERROR] API error for ${url}: ${json.error}`);
              throw new Error(json.error);
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              console.error(`[NFTPage] [ERROR] Invalid holders data for ${url}: ${JSON.stringify(json, null, 2)}`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              throw new Error(`Invalid holders data: retrying after POST`);
            }
            const newHolders = json.holders;
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            totalClaimableRewards = json.totalClaimableRewards || totalClaimableRewards;
            totalInfernoRewards = json.totalInfernoRewards || totalInfernoRewards;
            totalFluxRewards = json.totalFluxRewards || totalFluxRewards;
            totalE280Rewards = json.totalE280Rewards || totalE280Rewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            if (!newHolders.length && json.totalPages === 0) {
              console.log(`[NFTPage] [INFO] Empty holders with zero pages, accepting as valid`);
              break;
            }
          } catch (err) {
            attempts++;
            console.error(`[NFTPage] [ERROR] Attempt ${attempts}/${maxAttempts} failed for page ${page}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page} after ${maxAttempts} attempts: ${err.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs * attempts));
          }
        }
      }

      const holdersData = {
        holders: allHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      console.log(`[NFTPage] [INFO] Fetched ${allHolders.length} holders for ${contractId}`);
      if (isClient) {
        effectiveSetCache(cacheKey, holdersData);
      }
      setData(prev => ({ ...prev, ...holdersData }));
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Holders fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isClient, effectiveGetCache, effectiveSetCache, name, pageSize]);

  useEffect(() => {
    if (!contractId || !config.contractDetails[contractId]) {
      console.error(`[NFTPage] [ERROR] Invalid or missing contract: chain=${chain}, contract=${contract}`);
      setIsInvalidContract(true);
      setLoading(false);
    } else if (disabled) {
      console.log(`[NFTPage] [INFO] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    } else {
      setIsInvalidContract(false);
      fetchData();
      fetchAllHolders();
    }
  }, [contractId, chain, contract, disabled, name, fetchData, fetchAllHolders]);

  if (!isClient) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{name || 'Unknown Contract'} Holders</h1>
        <p>Loading...</p>
      </div>
    );
  }

  const HolderTable = holderTableComponents[contractId] || null;

  const chartData = data && isElement280 ? {
    labels: ['Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Tier 5', 'Tier 6'],
    datasets: [
      {
        label: 'Live NFTs',
        data: data.tierDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(96, 165, 250, 0.6)', // text-blue-400
      },
      {
        label: 'Burned NFTs',
        data: data.burnedDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(248, 113, 113, 0.6)', // text-red-400
      },
    ],
  } : null;

  if (isInvalidContract) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">Invalid Contract</h1>
        <p className="text-error text-lg">
          The contract "{contractId || 'none specified'}" is not supported.
        </p>
      </motion.div>
    );
  }

  if (!HolderTable) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-error text-lg">
          Error: Holder table component for {contractId} not found.
        </p>
      </motion.div>
    );
  }

  // Define props for each HolderTable component
  const holderTableProps = {
    e280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    ascendant: { holders: data?.holders || [], loading, totalShares: data?.totalShares || 0, totalTokens: data?.totalTokens || 0, rewardToken },
    element280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    element369: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    stax: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
  };

  return (
    <div className="container page-content">
      <motion.h1
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="title mb-6"
      >
        {name || 'Unknown Contract'} Holders
      </motion.h1>

      <AnimatePresence>
        {loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="card text-center-section"
          >
            <LoadingIndicator
              status={`Loading ${name} data... ${
                isElement280 ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''
              }`}
              progress={progress}
            />
          </motion.div>
        )}
      </AnimatePresence>

      {error && (
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
          className="text-error text-lg mb-6 text-center"
        >
          {error}
        </motion.p>
      )}

      {!loading && !error && data && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="space-y-section"
        >
          <div className="card">
            <h2 className="subtitle mb-4">Contract Summary</h2>
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Minted:</strong> {data.totalMinted?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Live:</strong> {data.totalLive?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Burned:</strong> {data.totalBurned?.toLocaleString() || 'N/A'}
                </p>
              </div>
              <div>
                <p>
                  <strong>Multiplier Pool:</strong>{' '}
                  {data.multiplierPool?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Reward Pool:</strong>{' '}
                  {data.totalRewardPool?.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  }) || 'N/A'}{' '}
                  {rewardToken}
                </p>
                <p>
                  <strong>Total Holders:</strong>{' '}
                  {progress.totalOwners?.toLocaleString() || 'N/A'}
                </p>
              </div>
            </div>
            {isElement280 && (
              <div className="mt-6">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowChart(!showChart)}
                  className="btn btn-primary"
                >
                  {showChart ? 'Hide Tier Distribution' : 'Show Tier Distribution'}
                </motion.button>
                <AnimatePresence>
                  {showChart && chartData && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      transition={{ duration: 0.3 }}
                      className="chart-container mt-6"
                    >
                      <Bar data={chartData} options={barChartOptions} />
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            )}
          </div>

          <div className="card">
            <h2 className="subtitle mb-4">Holders</h2>
            <HolderTable {...holderTableProps[contractId]} />
          </div>
        </motion.div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import config from '@/config.js';

// Loading components
const Element280Loading = () => <div className="text-body">Loading Element280 data...</div>;
Element280Loading.displayName = 'Element280Loading';

const Element369Loading = () => <div className="text-body">Loading Element369 data...</div>;
Element369Loading.displayName = 'Element369Loading';

const StaxNFTLoading = () => <div className="text-body">Loading Stax data...</div>;
StaxNFTLoading.displayName = 'StaxNFTLoading';

const AscendantNFTLoading = () => <div className="text-body">Loading Ascendant data...</div>;
AscendantNFTLoading.displayName = 'AscendantNFTLoading';

const E280Loading = () => <div className="text-body">Loading E280 data...</div>;
E280Loading.displayName = 'E280Loading';

// Fallback components
const Element280Fallback = () => <div className="text-error">Error loading data for Element280</div>;
Element280Fallback.displayName = 'Element280ErrorFallback';

const Element369Fallback = () => <div className="text-error">Error loading data for Element369</div>;
Element369Fallback.displayName = 'Element369ErrorFallback';

const StaxNFTFallback = () => <div className="text-error">Error loading data for Stax</div>;
StaxNFTFallback.displayName = 'StaxNFTErrorFallback';

const AscendantNFTFallback = () => <div className="text-error">Error loading data for Ascendant</div>;
AscendantNFTFallback.displayName = 'AscendantNFTErrorFallback';

const E280Fallback = () => <div className="text-error">Error loading data for E280</div>;
E280Fallback.displayName = 'E280ErrorFallback';

const holderTableComponents = {
  element280: dynamic(
    () => import('./HolderTable/Element280').catch((err) => {
      console.error('Failed to load Element280 HolderTable:', err);
      return { default: Element280Fallback };
    }),
    { ssr: false, loading: Element280Loading }
  ),
  element369: dynamic(
    () => import('./HolderTable/Element369').catch((err) => {
      console.error('Failed to load Element369 HolderTable:', err);
      return { default: Element369Fallback };
    }),
    { ssr: false, loading: Element369Loading }
  ),
  stax: dynamic(
    () => import('./HolderTable/Stax').catch((err) => {
      console.error('Failed to load Stax HolderTable:', err);
      return { default: StaxNFTFallback };
    }),
    { ssr: false, loading: StaxNFTLoading }
  ),
  ascendantNFT: dynamic(
    () => import('./HolderTable/Ascendant').catch((err) => {
      console.error('Failed to load Ascendant HolderTable:', err);
      return { default: AscendantNFTFallback };
    }),
    { ssr: false, loading: AscendantNFTLoading }
  ),
  e280: dynamic(
    () => import('./HolderTable/E280').catch((err) => {
      console.error('Failed to load E280 HolderTable:', err);
      return { default: E280Fallback };
    }),
    { ssr: false, loading: E280Loading }
  ),
};

Object.keys(holderTableComponents).forEach((key) => {
  holderTableComponents[key].displayName = `${key}HolderTable`;
});

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  const collections = [
    { apiKey: 'element280', name: 'Element280' },
    { apiKey: 'element369', name: 'Element369' },
    { apiKey: 'stax', name: 'Stax' },
    { apiKey: 'ascendantNFT', name: 'Ascendant' },
    { apiKey: 'e280', name: 'E280' },
  ];

  return (
    <div className="modal-overlay" onClick={handleBackgroundClick}>
      <motion.div
        className="card w-full max-w-4xl max-h-[90vh] overflow-y-auto border-gray-700"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="subtitle">
            NFT Ownership for {searchAddress.slice(0, 6)}...{searchAddress.slice(-4)}
          </h2>
          <button onClick={closeModal} className="text-gray-300 hover:text-gray-100 text-2xl">
            ×
          </button>
        </div>

        <div className="space-y-section">
          {collections.map(({ apiKey, name }) => {
            const data = searchResult[apiKey];
            const HolderTable = holderTableComponents[apiKey] || (() => <div>Holder table not found for {apiKey}</div>);
            return (
              <div key={apiKey} className="border-b border-gray-700 pb-4">
                <h3 className="subtitle mb-2">{name}</h3>
                {data === null ? (
                  <p className="text-body">No NFTs owned in this collection.</p>
                ) : data?.error ? (
                  <p className="text-error">Error: {data.error}</p>
                ) : data?.message ? (
                  <p className="text-body">{data.message}</p>
                ) : (
                  <HolderTable
                    holders={[data]}
                    contract={apiKey}
                    loading={false}
                    totalTokens={data.totalTokens || 0}
                    totalShares={data.totalShares}
                    rewardToken={data.rewardToken || config.contractDetails[apiKey]?.rewardToken}
                  />
                )}
              </div>
            );
          })}
        </div>
      </motion.div>
    </div>
  );
}-e 
---
File: ./components/NFTPageWrapper.js
// File: components/NFTPageWrapper.js

'use client';

import { useState, useEffect } from 'react';
import HolderTable from './HolderTable';

export default function NFTPageWrapper({ chain, contract, data, rewardToken }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return (
      <div>
        <p>Loading...</p>
      </div>
    );
  }

  if (!data || data.error) {
    return (
      <div>
        <p className="text-error">
          {data?.error || 'Failed to load collection data'}
        </p>
      </div>
    );
  }

  return (
    <HolderTable
      chain={chain}
      contract={contract}
      holders={data.holders}
      totalTokens={data.totalTokens}
      totalShares={data.totalShares}
      rewardToken={rewardToken}
      totalBurned={data.totalBurned}
    />
  );
}-e 
---
File: ./components/NFTLayoutWrapper.js
// File: components/NFTLayoutWrapper.js

'use client';

import dynamic from 'next/dynamic';

// Dynamically import NFTLayout
const NFTLayout = dynamic(() => import('@/components/NFTLayout'), { ssr: false });

export default function NFTLayoutWrapper({ children }) {
  return <NFTLayout>{children}</NFTLayout>;
}-e 
---
File: ./components/Navbar.jsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { CurrencyDollarIcon } from '@heroicons/react/24/solid';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);
  const pathname = usePathname();

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10, scale: 0.95 },
    visible: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.2 } },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0, transition: { duration: 0.2 } },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining', icon: CurrencyDollarIcon },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [{ name: 'E280', href: '/nft/BASE/E280' }],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="nav bg-gray-800 text-white">
      <div className="nav-container">
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="nav-logo"
        >
          <Link href="/" className="nav-link">
            TitanXUtils
          </Link>
        </motion.div>

        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative group"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Link
                href={item.href}
                className={`nav-link flex items-center space-x-1 ${
                  pathname === item.href ? 'text-orange-500' : 'text-gray-300 hover:text-orange-500'
                }`}
              >
                {item.icon && <item.icon className="h-5 w-5" />}
                <span>{item.name}</span>
              </Link>
              {item.subItems && (
                <motion.div
                  className="nav-dropdown opacity-0 group-hover:opacity-100 group-hover:mt-3 transition-all duration-200 pointer-events-none group-hover:pointer-events-auto bg-gray-700 text-white"
                  variants={dropdownVariants}
                  initial="hidden"
                  animate="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="nav-dropdown-item font-semibold">{subItem.name}</div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <Link
                              key={nestedItem.name}
                              href={nestedItem.href}
                              className="nav-dropdown-item hover:text-orange-500"
                            >
                              {nestedItem.name}
                            </Link>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
          {/* Removed theme toggle button */}
        </div>

        <button
          className="md:hidden p-2 focus:outline-none text-gray-300 hover:text-white"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2 px-4"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="nav-dropdown-item"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer text-gray-300 hover:text-orange-500"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      <span>{item.name}</span>
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                          transition={{ duration: 0.2 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2 text-gray-300 font-semibold">
                              {subItem.name}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <Link
                                    key={nestedItem.name}
                                    href={nestedItem.href}
                                    className="nav-dropdown-item hover:text-orange-500"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    {nestedItem.name}
                                  </Link>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : (
                  <Link
                    href={item.href}
                    className={`block flex items-center space-x-1 ${
                      pathname === item.href ? 'text-orange-500' : 'text-gray-300 hover:text-orange-500'
                    }`}
                    onClick={() => setIsOpen(false)}
                  >
                    {item.icon && <item.icon className="h-5 w-5" />}
                    <span>{item.name}</span>
                  </Link>
                )}
              </motion.div>
            ))}
            {/* Removed theme toggle button */}
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./components/HolderTable/E280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const e280TierOrder = [
    { tierId: '1', name: 'Common' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '6', name: 'Legendary Amped' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {e280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {e280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.e280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for E280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {e280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {e280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/index.js
// components/HolderTable/index.js
'use client';

import Element280 from './Element280';
import Element369 from './Element369';
import Stax from './Stax';
import Ascendant from './Ascendant';
import E280 from './E280';

const HolderTable = ({ chain, contract, holders, totalTokens, totalShares, rewardToken, totalBurned }) => {
  const components = {
    element280: Element280,
    element369: Element369,
    stax: Stax,
    ascendant: Ascendant,
    e280: E280,
  };

  const TableComponent = components[contract];
  if (!TableComponent) {
    return <div>Invalid contract: {contract}</div>;
  }

  return (
    <TableComponent
      chain={chain}
      holders={holders}
      totalTokens={totalTokens}
      totalShares={totalShares}
      rewardToken={rewardToken}
      totalBurned={totalBurned}
    />
  );
};

export default HolderTable;-e 
---
File: ./components/HolderTable/Ascendant.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Ascendant] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) ||
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) ||
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) ||
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 8) {
        console.warn('[Ascendant] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 8');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
          <p><strong>Total Shares:</strong> {totalShares?.toLocaleString() || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="table-cell">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Stax.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const staxTierOrder = [
    { tierId: '12', name: 'Legendary LFG', index: 11 },
    { tierId: '11', name: 'Legendary Super', index: 10 },
    { tierId: '10', name: 'Legendary Amped', index: 9 },
    { tierId: '9', name: 'Legendary', index: 8 },
    { tierId: '8', name: 'Rare LFG', index: 7 },
    { tierId: '7', name: 'Rare Super', index: 6 },
    { tierId: '6', name: 'Rare Amped', index: 5 },
    { tierId: '5', name: 'Rare', index: 4 },
    { tierId: '4', name: 'Common LFG', index: 3 },
    { tierId: '3', name: 'Common Super', index: 2 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0x15702443110894B26911B913b17ea4931F803B02';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Stax] Holder Data for Wallet:', targetHolder);
      console.log('[Stax] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Stax] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = staxTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && Number(targetHolder.tiers[Number(tier.tierId) - 1]) || 0);
        return { tier: tier.name, count };
      });
      console.log('[Stax] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Stax] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      const multipliers = {
        '12': 200, '11': 140, '10': 120, '9': 100, '8': 20, '7': 14, '6': 12, '5': 10,
        '4': 2, '3': 1.4, '2': 1.2, '1': 1
      };
      const expectedMultiplierSum = tierCounts.reduce((sum, { count }, idx) => {
        const tierId = staxTierOrder[idx].tierId;
        return sum + count * multipliers[tierId];
      }, 0);
      console.log('[Stax] Multiplier Sum:', {
        actual: targetHolder.multiplierSum,
        expected: expectedMultiplierSum
      });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 12) {
        console.warn('[Stax] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 12');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Stax] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
      if (targetHolder.multiplierSum !== expectedMultiplierSum) {
        console.warn('[Stax] Warning: Multiplier sum mismatch for wallet', targetWallet, {
          actual: targetHolder.multiplierSum,
          expected: expectedMultiplierSum
        });
      }
    } else {
      console.warn('[Stax] Warning: Wallet not found in holders:', targetWallet);
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {staxTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {staxTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.stax;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Stax.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {staxTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.multiplierSum === 'number' ? holder.multiplierSum.toFixed(2) : '-'}
              </td>
              {staxTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? Number(holder.tiers[Number(tier.tierId) - 1]) || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element369.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

const element369TierOrder = config.contractTiers.element369.tierOrder || [
  { tierId: '3', name: 'Legendary' },
  { tierId: '2', name: 'Rare' },
  { tierId: '1', name: 'Common' },
];

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">E280 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element369TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element369TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element369;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element369.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Flux Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">E280 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element369TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="reward-cell">
                {(holder.infernoRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.fluxRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.e280Rewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {(holder.percentage || 0).toFixed(2)}%
              </td>
              <td className="table-cell">
                {(holder.multiplierSum || 0).toFixed(2)}
              </td>
              {element369TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? holder.tiers[Number(tier.tierId) - 1] || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const element280TierOrder = [
    { tierId: '6', name: 'Legendary Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '1', name: 'Common' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {element280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts*.sqlite
*.db
output.txt
scripts/backups/
.env*.local

cache_*.json
burned_events_*.json-e 
---
File: ./testcontract.js
// testContract.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import staxMainAbi from './abi/staxNFT.json' with { type: 'json' };
import pLimit from 'p-limit';

const limit = pLimit(5); // Limit concurrent requests to 5
const client = createPublicClient({
  chain: mainnet,
  transport: http('https://eth-mainnet.g.alchemy.com/v2/rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI', { timeout: 60000 }),
});

async function retry(fn, retries = 3, delayMs = 1000) {
  let lastError;
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      console.error(`Retry ${i + 1}/${retries} failed for ${fn.name || 'fn'}: ${error.message}`);
      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }
  throw lastError;
}

async function test() {
  try {
    // Fetch totalSupply
    const totalSupply = await retry(async () => {
      const result = await client.readContract({
        address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
        abi: staxMainAbi,
        functionName: 'totalSupply',
      });
      console.log('Total Supply:', result);
      return result;
    });
    
    // Fetch totalBurned
    const burnedCount = await retry(async () => {
      const result = await client.readContract({
        address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
        abi: staxMainAbi,
        functionName: 'totalBurned',
      });
      console.log('Burned Count:', result);
      return result;
    });

    // Fetch tiers for all token IDs
    console.log('Fetching tiers for all tokens...');
    const tokenIds = Array.from({ length: Number(totalSupply) }, (_, i) => i); // tokenId 0 to totalSupply-1
    const tierPromises = tokenIds.map(tokenId =>
      limit(() =>
        retry(async () => {
          try {
            const tier = await client.readContract({
              address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
              abi: staxMainAbi,
              functionName: 'getNftTier',
              args: [tokenId],
            });
            return { tokenId, tier: Number(tier) };
          } catch (error) {
            // Handle non-existent tokens
            if (error.message.includes('OwnerQueryForNonexistentToken')) {
              return { tokenId, tier: null, error: 'Non-existent token' };
            }
            throw error;
          }
        })
      )
    );

    const tiers = await Promise.all(tierPromises);
    
    // Log results
    console.log('\nTier Results:');
    tiers.forEach(({ tokenId, tier, error }) => {
      if (error) {
        console.log(`Token ${tokenId}: ${error}`);
      } else {
        console.log(`Token ${tokenId}: Tier ${tier}`);
      }
    });

    // Summarize tiers
    const tierSummary = tiers.reduce((acc, { tier }) => {
      if (tier !== null) {
        acc[tier] = (acc[tier] || 0) + 1;
      }
      return acc;
    }, {});
    console.log('\nTier Summary:');
    Object.entries(tierSummary).forEach(([tier, count]) => {
      console.log(`Tier ${tier}: ${count} tokens`);
    });

    // Log invalid tiers
    const invalidTiers = tiers.filter(({ tier }) => tier !== null && (tier < 1 || tier > 12));
    if (invalidTiers.length > 0) {
      console.log('\nInvalid Tiers:');
      invalidTiers.forEach(({ tokenId, tier }) => {
        console.log(`Token ${tokenId}: Tier ${tier}`);
      });
    }

  } catch (error) {
    console.error('Error:', error);
  }
}

test();-e 
---
File: ./lib/logger.js
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

// Use process.cwd() to reference the project root
const logDir = path.join(process.cwd(), 'logs');

console.log(chalk.cyan('[Logger] Initializing logger...'));
console.log(chalk.cyan('[Logger] process.env.DEBUG:'), process.env.DEBUG);
console.log(chalk.cyan('[Logger] process.env.NODE_ENV:'), process.env.NODE_ENV);
console.log(chalk.cyan('[Logger] Log directory:'), logDir);

const isDebug = process.env.DEBUG === 'true';
console.log(chalk.cyan('[Logger] isDebug:'), isDebug);

async function ensureLogDir() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log(chalk.cyan('[Logger] Created or verified log directory:'), logDir);
  } catch (error) {
    console.error(chalk.red('[Logger] Failed to create log directory:'), error.message);
  }
}

ensureLogDir().catch(error => {
  console.error(chalk.red('[Logger] ensureLogDir error:'), error.message);
});

export const logger = {
  info: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [INFO] ${message}`;
    console.log(chalk.green(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote INFO log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write INFO log:'), error.message);
      }
    }
  },
  error: async (scope, message, details = {}, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [ERROR] ${message} ${JSON.stringify(details)}`;
    console.error(chalk.red(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote ERROR log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write ERROR log:'), error.message);
      }
    }
  },
  debug: async (scope, message, chain = 'eth', collection = 'general') => {
    if (!isDebug) return;
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [DEBUG] ${message}`;
    console.log(chalk.blue(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
      console.log(chalk.cyan('[Logger] Wrote DEBUG log to:'), logFile);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write DEBUG log:'), error.message);
    }
  },
};

try {
  logger.info('startup', 'Logger module loaded').catch(error => {
    console.error(chalk.red('[Logger] Startup log error:'), error.message);
  });
} catch (error) {
  console.error(chalk.red('[Logger] Immediate log error:'), error.message);
}-e 
---
File: ./lib/serverInit.js
// File: lib/serverInit.js
import { logger } from '@/lib/logger';
import { initializeCache } from '@/app/api/utils';
import chalk from 'chalk';

console.log(chalk.cyan('[ServerInit] Initializing server...'));

try {
  logger.info('serverInit', 'Server initialization started');
  await initializeCache();
} catch (error) {
  logger.error('serverInit', `Initialize cache error: ${error.message}`, { stack: error.stack });
  console.error(chalk.red('[ServerInit] Initialization error:'), error.message);
}

export const serverInit = true;-e 
---
File: ./lib/chartOptions.js
export const barChartOptions = {
    responsive: true,
    plugins: {
      legend: { position: 'top', labels: { color: '#e5e7eb' } }, // Gray-200
      title: {
        display: true,
        text: 'NFT Tier Distribution',
        color: '#e5e7eb',
        font: { size: 16, weight: 'bold' },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: 'Number of NFTs', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' }, // Gray-300
      },
      x: {
        title: { display: true, text: 'Tiers', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' },
      },
    },
  };-e 
---
File: ./lib/schemas.js
// File: lib/schemas.js
import { z } from 'zod';

export const HoldersResponseSchema = z.object({
  holders: z.array(z.object({
    wallet: z.string(),
    total: z.number().optional(),
    tiers: z.array(z.number()).optional(),
    shares: z.number().optional(),
  })),
  totalTokens: z.number().optional(),
  totalShares: z.number().optional(),
  totalBurned: z.number().optional(),
  summary: z.object({}).optional(),
  totalPages: z.number().optional(),
});-e 
---
File: ./lib/useNFTData.js
// lib/useNFTData.js
'use client';
import { useQuery } from '@tanstack/react-query';
import { useNFTStore } from '@/app/store';
import config from '@/config';
import { HoldersResponseSchema } from '@/lib/schemas';

async function fetchNFTData(apiKey, apiEndpoint, pageSize, page = 0) {
  if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
    return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Contract not deployed' };
  }

  const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;
  const progressUrl = `${endpoint}/progress`;

  const progressRes = await fetch(progressUrl, { cache: 'no-store' });
  if (!progressRes.ok) throw new Error(`Progress fetch failed: ${progressRes.status}`);
  const progress = await progressRes.json();

  if (progress.isPopulating || progress.phase !== 'Completed') {
    throw new Error('Cache is populating');
  }

  let allHolders = [];
  let totalTokens = 0;
  let totalShares = 0;
  let totalBurned = 0;
  let summary = {};
  let totalPages = Infinity;

  while (page < totalPages) {
    const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error(`API request failed: ${res.status}`);
    const json = await res.json();

    if (json.message === 'Cache is populating' || json.isCachePopulating) {
      throw new Error('Cache is populating');
    }

    const validation = HoldersResponseSchema.safeParse(json);
    if (!validation.success) {
      throw new Error(`Invalid holders schema: ${JSON.stringify(validation.error.errors)}`);
    }

    allHolders = allHolders.concat(json.holders);
    totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
    totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
    totalBurned = json.totalBurned || totalBurned;
    summary = json.summary || summary;
    totalPages = json.totalPages || 1;
    page++;
  }

  return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
}

export function useNFTData(apiKey, pageSize) {
  const { getCache, setCache } = useNFTStore();

  return useQuery({
    queryKey: ['nft', apiKey],
    queryFn: async () => {
      const cachedData = getCache(apiKey);
      if (cachedData) return cachedData;

      const data = await fetchNFTData(apiKey, config.contractDetails[apiKey].apiEndpoint, pageSize);
      setCache(apiKey, data);
      return data;
    },
    retry: config.alchemy.maxRetries,
    retryDelay: attempt => config.alchemy.batchDelayMs * (attempt + 1),
    staleTime: 30 * 60 * 1000, // 30 minutes
    refetchInterval: progress => (progress?.isPopulating ? 2000 : false),
    onError: error => console.error(`[useNFTData] [ERROR] ${apiKey}: ${error.message}`),
  });
}-e 
---
File: ./.env.development.local
# File: .env.local
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
UPSTASH_REDIS_REST_URL=https://splendid-sunbird-26504.upstash.io
UPSTASH_REDIS_REST_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_URL=https://splendid-sunbird-26504.upstash.io
KV_REST_API_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
KV_REST_API_READ_ONLY_TOKEN=AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg
KV_URL=rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379
PERSIST_CACHE=true
DEBUG=true
LOG_LEVEL=info
USE_FALLBACK_DATA=false
ESLINT_NO_DEV_ERRORS=true
USE_ALCHEMY_FOR_OWNERS=true
NEXT_NO_WORKER_THREADS=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:3000
DISABLE_ELEMENT280_REDIS=true
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true-e 
---
File: ./postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};