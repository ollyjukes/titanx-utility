-e 
---
File: ./types/eslint-config-next.d.ts
declare module 'eslint-config-next';
-e 
---
File: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,jsx,ts,tsx,mdx}',
    './components/**/*.{js,jsx,ts,tsx,mdx}',
    './pages/**/*.{js,jsx,ts,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
  darkMode: 'class', // Enable dark mode with 'class' strategy
};-e 
---
File: ./.env.local
# Created by Vercel CLI
KV_REST_API_READ_ONLY_TOKEN="AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg"
KV_REST_API_TOKEN="AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA"
KV_REST_API_URL="https://splendid-sunbird-26504.upstash.io"
KV_URL="rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379"
NEXT_PUBLIC_ALCHEMY_API_KEY="rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI"
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID="1dd2a69d54ac94fdefad918243183710"
REDIS_URL="rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379"
UPSTASH_REDIS_REST_TOKEN="AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA"
UPSTASH_REDIS_REST_URL="https://splendid-sunbird-26504.upstash.io"
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF

# Redis on/off switches
DISABLE_ELEMENT280_REDIS=true
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true

DEBUG=true
USE_FALLBACK_DATA=false-e 
---
File: ./app/layout.js
import './global.css';
import Navbar from '@/components/Navbar';
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'TitanXUtils',
  description: 'NFT tracking and management platform for TitanX ecosystem',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={inter.className}>
        <Navbar />
        <main className="flex-grow container page-content">{children}</main>
        <footer className="footer">
          <p>© {new Date().getFullYear()} TitanXUtils. All rights reserved.</p>
        </footer>
      </body>
    </html>
  );
}-e 
---
File: ./app/page.js
// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-gray-300">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}-e 
---
File: ./app/nft/layout.js
// app/nft/layout.js
'use client';

import { useState, useRef, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import NFTSummary from '@/components/NFTSummary';
import config from '@/config.js';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [collectionsData, setCollectionsData] = useState([]);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(config.contractDetails).map((key) => ({
    name: config.contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${config.contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = useCallback(async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    const cachedData = getCache(contractKey);
    if (cachedData && contractKey !== 'ascendantNFT') {
      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
      return cachedData;
    }
    console.log(`[NFTLayout] ${contractKey === 'ascendantNFT' ? 'Bypassing cache for ascendantNFT' : 'Cache miss for ' + contractKey}`);
  
    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }
  
    const { apiEndpoint } = config.contractDetails[contractKey];
    try {
      console.log(`[NFTLayout] Fetching ${contractKey} from ${apiEndpoint}`);
      const res = await fetch(`${apiEndpoint}?page=0&pageSize=1000`, {
        signal: AbortSignal.timeout(60000),
      });
      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[NFTLayout] Fetch failed for ${contractKey}: ${res.status} - ${errorText}`);
        throw new Error(`Fetch failed for ${contractKey}: ${res.status} - ${errorText}`);
      }
      const json = await res.json();
      console.log(`[NFTLayout] Fetched data for ${contractKey}: ${json.holders?.length || 0} holders`);
  
      const result = {
        ...json,
        summary: {
          totalLive: json.summary?.totalLive || json.totalTokens || 0,
          totalBurned: json.summary?.totalBurned || 0,
          totalRewardPool: json.summary?.totalRewardPool || 0,
        },
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${result.holders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}, stack: ${err.stack}`);
      const errorResult = { holders: [], totalTokens: 0, summary: { totalBurned: 0 }, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  }, [getCache, setCache]);

  useEffect(() => {
    const fetchAllCollections = async () => {
      console.log('[NFTLayout] Fetching all collection data for summary');
      const fetchPromises = allNFTs.map((nft) =>
        fetchCollectionData(nft.apiKey)
          .then((data) => ({ apiKey: nft.apiKey, data }))
          .catch((err) => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}, stack: ${err.stack}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, summary: { totalBurned: 0 }, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      setCollectionsData(results);
      console.log('[NFTLayout] All collections fetched for summary:', results);
    };
  
    if (!hasRun.current) {
      fetchAllCollections();
      hasRun.current = true;
    }
  }, [allNFTs, fetchCollectionData]);

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map((nft) =>
        fetchCollectionData(nft.apiKey)
          .then((data) => ({ apiKey: nft.apiKey, data }))
          .catch((err) => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}, stack: ${err.stack}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, summary: { totalBurned: 0 }, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find((h) => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err.message, err.stack);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
      <h1 className="text-4xl font-bold text-white mb-8">TitanX NFT Protocols</h1>

      {collectionsData.length > 0 && <NFTSummary collectionsData={collectionsData} />}

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`px-4 py-2 bg-orange-500 text-white rounded-md font-semibold hover:bg-orange-600 transition-colors ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`px-6 py-2 rounded-md font-semibold transition-colors ${
              selectedChain === chain.id
                ? 'bg-orange-500 text-white'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) =>
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="flex-1 w-full px-6 py-3 bg-gray-700 text-gray-300 rounded-md font-semibold hover:bg-orange-500 hover:text-white transition-colors"
              >
                {nft.name}
              </motion.button>
            )
          )}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <button
        onClick={() => useNFTStore.getState().clearCache()}
        className="mt-6 px-4 py-2 bg-red-500 text-white rounded-md font-semibold hover:bg-red-600"
      >
        Clear Client Cache
      </button>
      <div className="w-full max-w-6xl mt-6">{children}</div>
    </div>
  );
}-e 
---
File: ./app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="min-h-screen bg-gray-900 text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">NFT Collections</h1>
      <p className="text-lg text-gray-300">Select a collection from the menu above to view details.</p>
    </div>
  );
}-e 
---
File: ./app/nft/[chain]/[contract]/page.js
//'use client';

import { notFound } from 'next/navigation';
import { motion } from 'framer-motion';
import NFTPage from '@/components/NFTPage';
import config from '@/config';

export default function Page({ params }) {
  const { chain, contract } = params;
  console.log('[Page] Received params:', params);

  const supportedContracts = Object.keys(config.contractDetails).map((key) => key.toLowerCase());
  if (!config.supportedChains.includes(chain) || !supportedContracts.includes(contract.toLowerCase())) {
    notFound();
  }

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="container page-content"
    >
      <NFTPage chain={chain} contract={contract} />
    </motion.div>
  );
}

export async function generateStaticParams() {
  return Object.entries(config.contractDetails).map(([contractId, details]) => ({
    chain: details.chain,
    contract: contractId.charAt(0).toUpperCase() + contractId.slice(1),
  }));
}

export const revalidate = 60;-e 
---
File: ./app/global.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base Styles */
html {
  @apply scroll-smooth;
}

body {
  @apply min-h-screen flex flex-col bg-gray-100 text-gray-900 antialiased;
}

.dark body {
  @apply bg-gray-900 text-gray-100;
}

/* Component Classes */
@layer components {
  /* Layout */
  .container {
    @apply mx-auto max-w-7xl px-4 sm:px-6 lg:px-8;
  }

  .page-content {
    @apply py-8;
  }

  /* Cards */
  .card {
    @apply rounded-lg shadow-lg p-6 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700;
  }

  /* Buttons */
  .btn {
    @apply inline-flex items-center px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500;
    /* Orange theme: @apply inline-flex items-center px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500; */
  }

  .btn-primary {
    @apply bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600;
    /* Orange theme: @apply bg-orange-600 text-white hover:bg-orange-700 dark:bg-orange-500 dark:hover:bg-orange-600; */
  }

  .btn-secondary {
    @apply bg-gray-200 text-gray-900 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600;
  }

  /* Typography */
  .title {
    @apply text-3xl font-bold tracking-tight text-gray-900 dark:text-gray-100;
  }

  .subtitle {
    @apply text-2xl font-semibold text-gray-900 dark:text-gray-100;
  }

  .text-body {
    @apply text-sm sm:text-base text-gray-600 dark:text-gray-300;
  }

  .text-error {
    @apply text-red-500 dark:text-red-400;
  }

  /* Tables */
  .table-container {
    @apply overflow-x-auto w-full rounded-lg shadow-lg animate-fade-in;
  }

  .table {
    @apply w-full table-auto md:table-fixed bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100;
  }

  .table-head {
    @apply bg-gradient-to-r from-blue-600 to-blue-800 text-sm md:text-base text-white;
    /* Orange theme: @apply bg-gradient-to-r from-orange-600 to-orange-800 text-sm md:text-base text-white; */
  }

  .table-body {
    @apply text-xs md:text-sm text-gray-600 dark:text-gray-300;
  }

  .table-row {
    @apply transition-colors border-b border-gray-200 dark:border-gray-700;
  }

  .table-row-even {
    @apply bg-white dark:bg-gray-800;
  }

  .table-row-odd {
    @apply bg-gray-50 dark:bg-gray-900;
  }

  .table-row:hover {
    @apply bg-blue-900/30 shadow-sm;
    /* Orange theme: @apply bg-orange-900/30 shadow-sm; */
  }

  .table-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold;
  }

  .table-link {
    @apply text-blue-500 dark:text-blue-400 hover:text-blue-600 dark:hover:text-blue-300 hover:underline break-all;
    /* Orange theme: @apply text-orange-500 dark:text-orange-400 hover:text-orange-600 dark:hover:text-orange-300 hover:underline break-all; */
  }

  .table-pulse {
    @apply animate-pulse;
  }

  .table-pulse-placeholder {
    @apply h-4 bg-gray-300 dark:bg-gray-600 rounded w-3/4;
  }

  /* Reward Columns (for Element369.js) */
  .reward-cell {
    @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold text-blue-600 dark:text-blue-400;
    /* Orange theme: @apply py-2 px-2 md:py-4 md:px-6 text-left font-semibold text-orange-600 dark:text-orange-400; */
  }

  /* Chart Container */
  .chart-container {
    @apply bg-gray-800 p-4 rounded-lg;
  }

  /* Loading Indicator */
  .loading-container {
    @apply flex flex-col items-center justify-center gap-3 w-full flex-1;
  }

  .spinner {
    @apply h-6 w-6 sm:h-8 sm:w-8 text-blue-500 dark:text-blue-400;
    /* Orange theme: @apply h-6 w-6 sm:h-8 sm:w-8 text-orange-500 dark:text-orange-400; */
  }

  .progress-bar {
    @apply w-64 bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mt-2;
  }

  .progress-fill {
    @apply bg-blue-600 dark:bg-blue-400 h-2.5 rounded-full;
    /* Orange theme: @apply bg-orange-600 dark:bg-orange-400 h-2.5 rounded-full; */
  }

  /* Navbar */
  .nav {
    @apply bg-gray-900 text-gray-100 sticky top-0 z-50 shadow-lg;
  }

  .nav-container {
    @apply container py-4 flex justify-between items-center;
  }

  .nav-logo {
    @apply text-2xl font-bold;
  }

  .nav-link {
    @apply text-gray-300 hover:text-blue-400 transition-colors duration-200;
    /* Orange theme: @apply text-gray-300 hover:text-orange-400 transition-colors duration-200; */
  }

  .nav-dropdown {
    @apply absolute left-0 mt-2 w-56 bg-gray-800 rounded-lg shadow-xl;
  }

  .nav-dropdown-item {
    @apply block px-4 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md transition-colors;
  }

  .nav-toggle {
    @apply p-2 rounded-full bg-gray-700 text-gray-100 hover:bg-gray-600 transition-colors;
  }

  /* Footer */
  .footer {
    @apply bg-gray-800 py-4 text-center text-gray-400;
  }

  /* Animations */
  .animate-fade-in {
    animation: fade-in 0.3s ease-out;
  }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Utility Classes */
@layer utilities {
  .grid-responsive {
    @apply grid grid-cols-1 sm:grid-cols-2 gap-4;
  }

  .space-y-section {
    @apply space-y-6;
  }

  .text-center-section {
    @apply text-center py-12;
  }
}-e 
---
File: ./app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));

export const useThemeStore = create((set) => ({
  isDarkMode: true, // Default to dark mode
  toggleTheme: () =>
    set((state) => {
      const isDarkMode = !state.isDarkMode;
      if (typeof window !== 'undefined') {
        document.documentElement.classList.toggle('dark', isDarkMode);
      }
      return { isDarkMode };
    }),
}));-e 
---
File: ./app/about/page.js
// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          May add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}-e 
---
File: ./app/mining/page.js
// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/api/holders/Stax/route.js
import { NextResponse } from 'next/server';
import config from '@/config.js';
import { client, alchemy, log, batchMulticall, getCache, setCache } from '../../utils.js'; // Removed CACHE_TTL
import NodeCache from 'node-cache';

// Use config.cache.nodeCache.stdTTL instead of CACHE_TTL
const CACHE_TTL = config.cache.nodeCache.stdTTL;

// Redis toggle
const DISABLE_REDIS = process.env.DISABLE_STAX_REDIS === 'true';

// In-memory cache when Redis is disabled
const inMemoryCache = new NodeCache({ stdTTL: CACHE_TTL });

const contractAddress = config.contractAddresses.stax.address;
const vaultAddress = config.vaultAddresses.stax.address;
const tiersConfig = config.contractTiers.stax;
const defaultPageSize = config.contractDetails.stax.pageSize || 1000;

async function retryAlchemy(fn, attempts = config.alchemy.maxRetries, delayMs = config.alchemy.batchDelayMs) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      log(`[Stax] Alchemy retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
}

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || defaultPageSize);
  const wallet = searchParams.get('wallet')?.toLowerCase();

  log(`[Stax] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress || !tiersConfig) {
      log(`[Stax] Config error: contractAddress=${contractAddress}, vaultAddress=${vaultAddress}, tiersConfig=${JSON.stringify(tiersConfig)}`);
      throw new Error('Stax contract or vault address missing');
    }

    const cacheKey = `stax_holders_${page}_${pageSize}_${wallet || 'all'}`;
    let cachedData;
    if (!wallet) {
      try {
        if (DISABLE_REDIS) {
          cachedData = inMemoryCache.get(cacheKey);
        } else {
          cachedData = await getCache(cacheKey);
        }
        if (cachedData) {
          log(`[Stax] Returning cached data for ${cacheKey} (Redis=${!DISABLE_REDIS})`);
          return NextResponse.json(cachedData);
        }
      } catch (cacheError) {
        log(`[Stax] Cache read error: ${cacheError.message}`);
      }
    }
    log(`[Stax] Cache miss for ${cacheKey}`);

    // Clear cache for wallet-specific queries
    if (wallet) {
      try {
        if (DISABLE_REDIS) {
          inMemoryCache.del(cacheKey);
        } else {
          await setCache(cacheKey, null);
        }
        log(`[Stax] Cleared cache for ${cacheKey}`);
      } catch (cacheError) {
        log(`[Stax] Cache clear error: ${cacheError.message}`);
      }
    }

    // Fetch totalBurned
    let totalBurned = 0;
    try {
      const burnedResult = await client.readContract({
        address: contractAddress,
        abi: config.abis.stax.main,
        functionName: 'totalBurned',
      });
      totalBurned = Number(burnedResult || 0);
      log(`[Stax] Fetched totalBurned: ${totalBurned}`);
    } catch (error) {
      log(`[Stax] Error fetching totalBurned: ${error.message}`);
      totalBurned = 0;
    }

    // Fetch owners
    const ownersResponse = await retryAlchemy(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        block: 'latest',
        withTokenBalances: true,
      })
    );
    log(`[Stax] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddresses = [
      '0x0000000000000000000000000000000000000000',
      '0x000000000000000000000000000000000000dead',
    ];
    const filteredOwners = wallet
      ? ownersResponse.owners.filter(
          owner => owner.ownerAddress.toLowerCase() === wallet && !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
        )
      : ownersResponse.owners.filter(
          owner => !burnAddresses.includes(owner.ownerAddress.toLowerCase()) && owner.tokenBalances.length > 0
        );
    log(`[Stax] Live owners after filter: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const walletAddr = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, walletAddr);
        totalTokens++;
      });
      ownerTokens.set(walletAddr, tokenIds);
    });
    log(`[Stax] Total tokens: ${totalTokens}`);

    // Paginate
    let paginatedTokenIds = Array.from(tokenOwnerMap.keys());
    if (!wallet) {
      const start = page * pageSize;
      const end = Math.min(start + pageSize, paginatedTokenIds.length);
      paginatedTokenIds = paginatedTokenIds.slice(start, end);
    }
    log(`[Stax] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: config.abis.stax.main,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    const failedTiers = tierResults.filter(r => r.status === 'failure');
    if (failedTiers.length) {
      log(`[Stax] Failed tier calls: ${failedTiers.map(r => r.error).join(', ')}`);
    }
    log(`[Stax] Tiers fetched for ${tierResults.length} tokens`);

    // Log tier results
    tierResults.forEach((result, i) => {
      const tokenId = paginatedTokenIds[i];
      if (result?.status === 'success') {
        log(`[Stax] Token ${tokenId}: Tier ${result.result}`);
      } else {
        log(`[Stax] Tier fetch failed for token ${tokenId}: ${result?.error || 'Unknown'}`);
      }
    });

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number));
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const walletAddr = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && walletAddr) {
          if (!holdersMap.has(walletAddr)) {
            holdersMap.set(walletAddr, {
              wallet: walletAddr,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier).fill(0),
              claimableRewards: 0,
            });
          }
          const holder = holdersMap.get(walletAddr);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier - 1] += 1;
        } else {
          log(`[Stax] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Stax] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch rewards
    let holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: config.abis.stax.vault,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet],
      };
    });

    const totalRewardPoolCall = {
      address: vaultAddress,
      abi: config.abis.stax.vault,
      functionName: 'totalRewardPool',
      args: [],
    };

    log(`[Stax] Fetching rewards for ${holders.length} holders`);
    const [rewardResults, totalRewardPoolResult] = await Promise.all([
      rewardCalls.length ? batchMulticall(rewardCalls) : [],
      batchMulticall([totalRewardPoolCall]),
    ]);

    const failedRewards = rewardResults.filter(r => r.status === 'failure');
    if (failedRewards.length) {
      log(`[Stax] Failed reward calls: ${failedRewards.map(r => r.error).join(', ')}`);
    }

    const totalRewardPool = totalRewardPoolResult[0]?.status === 'success'
      ? Number(totalRewardPoolResult[0].result) / 1e18
      : 0;

    holders.forEach((holder, i) => {
      if (rewardResults[i]?.status === 'success' && rewardResults[i].result) {
        const [, totalPayout] = rewardResults[i].result;
        holder.claimableRewards = Number(totalPayout) / 1e18;
        log(
          `[Stax] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Claimable=${holder.claimableRewards.toFixed(4)}, ` +
          `Tokens=${ownerTokens.get(holder.wallet).length}`
        );
      } else {
        holder.claimableRewards = 0;
        log(`[Stax] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardResults[i]?.error || 'Unknown'}`);
      }
      holder.percentage = totalRewardPool ? (holder.claimableRewards / totalRewardPool) * 100 : 0;
      holder.rank = 0;
      holder.displayMultiplierSum = holder.multiplierSum / 10; // Adjust for Stax display
    });

    // Calculate ranks
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
    });

    const response = {
      holders,
      totalTokens,
      summary: {
        totalLive: totalTokens,
        totalBurned,
        totalRewardPool,
      },
      page,
      pageSize,
      totalPages: wallet ? 1 : Math.ceil(totalTokens / pageSize),
    };

    try {
      if (DISABLE_REDIS) {
        inMemoryCache.set(cacheKey, response);
      } else {
        await setCache(cacheKey, response);
      }
      log(`[Stax] Cached response: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
    } catch (cacheError) {
      log(`[Stax] Cache write error: ${cacheError.message}`);
    }

    log(`[Stax] Success: ${holders.length} holders, totalBurned=${totalBurned}, totalRewardPool=${totalRewardPool}`);
    return NextResponse.json(response);
  } catch (error) {
    log(`[Stax] Error: ${error.message}`);
    console.error('[Stax] Error stack:', error.stack);
    let status = 500;
    let message = 'Failed to fetch Stax data';
    if (error.message.includes('Rate limit')) {
      status = 429;
      message = 'Alchemy rate limit exceeded';
    }
    return NextResponse.json({ error: message, details: error.message }, { status });
  }
}-e 
---
File: ./app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';
import NodeCache from 'node-cache';

// Redis toggle
const DISABLE_REDIS = process.env.DISABLE_E280_REDIS === 'true';

// In-memory cache (for future use when contract is deployed)
const inMemoryCache = new NodeCache({ stdTTL: 3600 });

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '1000');
  const wallet = searchParams.get('wallet')?.toLowerCase();

  log(`[E280] GET Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}, Redis=${!DISABLE_REDIS}`);

  // Placeholder for future cache check when contract is deployed
  /*
  const cacheKey = `e280_holders_${page}_${pageSize}_${wallet || 'all'}`;
  let cachedData;
  try {
    if (DISABLE_REDIS) {
      cachedData = inMemoryCache.get(cacheKey);
    } else {
      cachedData = await getCache(cacheKey);
    }
    if (cachedData) {
      log(`[E280] Cache hit: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
      return NextResponse.json(cachedData);
    }
    log(`[E280] Cache miss: ${cacheKey}`);
  } catch (cacheError) {
    log(`[E280] Cache read error: ${cacheError.message}`);
  }
  */

  log('[E280] GET: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}

export async function POST(request) {
  log(`[E280] POST Request: Redis=${!DISABLE_REDIS}`);
  log('[E280] POST: Contract not yet deployed');
  return NextResponse.json({ error: 'E280 contract not yet deployed' }, { status: 400 });
}-e 
---
File: ./app/api/holders/Element280/route.js
// app/api/holders/Element280/route.js


import { NextResponse } from 'next/server';
import { log, saveCacheState, getCache, setCache, loadCacheState, batchMulticall } from '../../utils.js';
import config from '@/config';
import { alchemy, client } from '../../utils.js';
import pLimit from 'p-limit';
import { parseAbiItem } from 'viem';
import NodeCache from 'node-cache';
import fs from 'fs/promises';

// Use config.cache.nodeCache.stdTTL instead of CACHE_TTL
const CACHE_TTL = config.cache.nodeCache.stdTTL;
const CACHE_STATE_KEY = 'element280_cache_state';
const HOLDERS_CACHE_KEY = 'element280_holders_map';
const TOKEN_CACHE_KEY = 'element280_token_cache';
const BURNED_EVENTS_CACHE_KEY = 'element280_burned_events';
const DISABLE_REDIS = process.env.DISABLE_ELEMENT280_REDIS === 'true';

// Initialize node-cache
const cache = new NodeCache({ stdTTL: CACHE_TTL });
cache.setMaxListeners(20);

// Initialize storage for a contract
function initStorage(contractAddress) {
  const cacheKey = `storage_${contractAddress}`;
  let storage = cache.get(cacheKey);
  if (!storage) {
    storage = {
      holdersMap: null,
      cacheState: {
        isCachePopulating: false,
        holdersMapCache: null,
        totalOwners: 0,
        progressState: { step: 'idle', processedNfts: 0, totalNfts: 0 },
        debugId: 'state-' + Math.random().toString(36).slice(2),
      },
      burnedEventsCache: null,
    };
    cache.set(cacheKey, storage);
    cache.removeAllListeners('set');
    log(`[element280] [INIT] Initialized node-cache for ${contractAddress}, debugId=${storage.cacheState.debugId}`);
  }
  return storage;
}

// Cache state
export async function getCacheState(contractAddress) {
  const storage = initStorage(contractAddress);
  if (DISABLE_REDIS) {
    let state = storage.cacheState;
    if (!state || state.totalOwners === 0) {
      const persistedState = await loadCacheState(`state_${contractAddress}`);
      if (persistedState) {
        storage.cacheState = persistedState;
        state = persistedState;
        log(`[element280] [DEBUG] Loaded persisted state from file for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      } else {
        log(`[element280] [DEBUG] No persisted state found for ${contractAddress}, using default: ${JSON.stringify(state, null, 2)}`);
      }
    }
    log(`[element280] [DEBUG] getCacheState: contract=${contractAddress}, totalOwners=${state.totalOwners}, step=${state.progressState.step}, isCachePopulating=${state.isCachePopulating}, debugId=${state.debugId}`);
    return state;
  }
  try {
    const state = await getCache(`${CACHE_STATE_KEY}_${contractAddress}`);
    log(`[element280] [DEBUG] getCacheState (Redis): contract=${contractAddress}, state=${JSON.stringify(state)}`);
    return state || {
      isCachePopulating: false,
      holdersMapCache: null,
      totalOwners: 0,
      progressState: { step: 'idle', processedNfts: 0, totalNfts: 0 },
    };
  } catch (error) {
    log(`[element280] [ERROR] Error fetching cache state for ${contractAddress}: ${error.message}, stack: ${error.stack}`);
    return {
      isCachePopulating: false,
      holdersMapCache: null,
      totalOwners: 0,
      progressState: { step: 'error', processedNfts: 0, totalNfts: 0 },
    };
  }
}

// Serialize BigInt
function serializeBigInt(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) => (typeof value === 'bigint' ? value.toString() : value))
  );
}

// Retry utility
async function retry(fn, attempts = config.alchemy.maxRetries, delay = (retryCount) => Math.min(config.alchemy.batchDelayMs * 2 ** retryCount, config.alchemy.retryMaxDelayMs)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      log(`[element280] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) {
        log(`[element280] [ERROR] Retry failed after ${attempts} attempts: ${error.message}, stack: ${error.stack}`);
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Count burned NFTs from Transfer events
async function getBurnedCountFromEvents(contractAddress, errorLog) {
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const storage = initStorage(contractAddress);
  let cachedBurned = null;

  if (DISABLE_REDIS) {
    if (storage.burnedEventsCache) {
      cachedBurned = storage.burnedEventsCache;
      log(`[element280] [DEBUG] Using in-memory burned events cache for ${contractAddress}: ${cachedBurned.count} burned NFTs`);
    }
  } else {
    try {
      cachedBurned = await getCache(`${BURNED_EVENTS_CACHE_KEY}_${contractAddress}`);
      if (cachedBurned) {
        log(`[element280] [DEBUG] Using Redis burned events cache for ${contractAddress}: ${cachedBurned.count} burned NFTs`);
      }
    } catch (cacheError) {
      log(`[element280] [ERROR] Cache read error for burned events: ${cacheError.message}`);
    }
  }

  if (cachedBurned) {
    return cachedBurned.count;
  }

  log(`[element280] [STAGE] Fetching burned NFT count from Transfer events for ${contractAddress}`);
  let burnedCount = 0;
  const endBlock = await retry(() => client.getBlockNumber());
  const limit = pLimit(2);
  const ranges = [];
  for (let fromBlock = BigInt(config.deploymentBlocks.element280.block); fromBlock <= endBlock; fromBlock += BigInt(config.nftContracts.element280.maxTokensPerOwnerQuery)) {
    const toBlock = BigInt(Math.min(Number(fromBlock) + config.nftContracts.element280.maxTokensPerOwnerQuery - 1, Number(endBlock)));
    ranges.push({ fromBlock, toBlock });
  }

  try {
    await Promise.all(
      ranges.map(({ fromBlock, toBlock }, index) =>
        limit(async () => {
          try {
            log(`[element280] [PROGRESS] Processing blocks ${fromBlock}-${toBlock} for ${contractAddress} (${index + 1}/${ranges.length})`);
            const logs = await retry(() =>
              client.getLogs({
                address: contractAddress,
                event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
                fromBlock,
                toBlock,
              })
            );
            const burns = logs.filter(log => log.args.to.toLowerCase() === burnAddress);
            burnedCount += burns.length;
          } catch (error) {
            log(`[element280] [ERROR] Failed to fetch Transfer events for blocks ${fromBlock}-${toBlock}: ${error.message}`);
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned_events', error: error.message });
          }
        })
      )
    );
    log(`[element280] [STAGE] Found ${burnedCount} burned NFTs from Transfer events for ${contractAddress}`);

    const cacheData = { count: burnedCount, timestamp: Date.now() };
    if (DISABLE_REDIS) {
      storage.burnedEventsCache = cacheData;
      cache.set(`storage_${contractAddress}`, storage);
      await saveCacheState(`burned_${contractAddress}`, cacheData);
    } else {
      await setCache(`${BURNED_EVENTS_CACHE_KEY}_${contractAddress}`, cacheData, CACHE_TTL);
    }

    return burnedCount;
  } catch (error) {
    log(`[element280] [ERROR] Failed to fetch burned events for ${contractAddress}: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned_events', error: error.message });
    throw error;
  }
}

// Fetch total supply and burned count
async function getTotalSupply(contractAddress, errorLog) {
  const cacheKey = `element280_total_supply_${contractAddress}`;
  if (!DISABLE_REDIS) {
    try {
      const cached = await getCache(cacheKey);
      if (cached) {
        return { totalSupply: cached.totalSupply, totalBurned: cached.totalBurned };
      }
    } catch (cacheError) {
      log(`[element280] [ERROR] Cache read error for total supply: ${cacheError.message}, stack: ${cacheError.stack}`);
    }
  }

  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'totalSupply' },
        ],
      })
    );
    const totalSupply = results[0].status === 'success' ? Number(results[0].result) : 0;
    if (isNaN(totalSupply)) {
      const errorMsg = `Invalid totalSupply=${totalSupply}`;
      log(`[element280] [ERROR] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: errorMsg });
      throw new Error(errorMsg);
    }

    const totalBurned = await getBurnedCountFromEvents(contractAddress, errorLog);
    if (totalBurned < 0) {
      const errorMsg = `Invalid totalBurned=${totalBurned} from events`;
      log(`[element280] [ERROR] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_burned', error: errorMsg });
      throw new Error(errorMsg);
    }

    if (totalSupply + totalBurned > config.nftContracts.element280.expectedTotalSupply + config.nftContracts.element280.expectedBurned) {
      const errorMsg = `Invalid data: totalSupply (${totalSupply}) + totalBurned (${totalBurned}) exceeds totalMinted (${config.nftContracts.element280.expectedTotalSupply + config.nftContracts.element280.expectedBurned})`;
      log(`[element280] [ERROR] ${errorMsg}`);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_supply', error: errorMsg });
      throw new Error(errorMsg);
    }

    const expectedBurned = config.nftContracts.element280.expectedBurned;
    if (Math.abs(totalBurned - expectedBurned) > 100) {
      log(`[element280] [WARN] Event-based totalBurned=${totalBurned} deviates from expected=${expectedBurned}.`);
    }

    if (!DISABLE_REDIS) await setCache(cacheKey, { totalSupply, totalBurned }, CACHE_TTL);
    return { totalSupply, totalBurned };
  } catch (error) {
    log(`[element280] [ERROR] Failed to fetch total supply for ${contractAddress}: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_total_supply', error: error.message });
    throw error;
  }
}

// Fetch NFT ownership
async function fetchAllNftOwnership(contractAddress, errorLog, timings) {
  const ownershipByToken = new Map();
  const ownershipByWallet = new Map();
  const burnAddress = '0x0000000000000000000000000000000000000000';
  const failedTokens = new Set();

  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    const errorMsg = `Invalid contract address: ${contractAddress}`;
    log(`[element280] [ERROR] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_contract', error: errorMsg });
    throw new Error(errorMsg);
  }

  const tokenIdStart = Date.now();
  let pageKey = null;
  let tokenIds = [];
  try {
    do {
      const response = await retry(() =>
        alchemy.nft.getNftsForContract(contractAddress, { pageKey })
      );
      if (!response.nfts || !Array.isArray(response.nfts)) {
        const errorMsg = `Invalid NFT response: nfts array missing`;
        log(`[element280] [ERROR] ${errorMsg}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
        throw new Error(errorMsg);
      }
      response.nfts.forEach(nft => {
        const tokenId = nft.tokenId || nft.id || nft.token_id;
        if (tokenId) tokenIds.push(tokenId);
      });
      pageKey = response.pageKey;
    } while (pageKey);
    timings.tokenIdFetch = Date.now() - tokenIdStart;
  } catch (error) {
    log(`[element280] [ERROR] Alchemy error fetching NFTs for ${contractAddress}: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: error.message });
    throw error;
  }

  if (tokenIds.length === 0) {
    const errorMsg = `No token IDs found for contract ${contractAddress}`;
    log(`[element280] [ERROR] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_token_ids', error: errorMsg });
    throw new Error(errorMsg);
  }

  const ownerFetchStart = Date.now();
  const ownerCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: config.abis.element280.main,
    functionName: 'ownerOf',
    args: [BigInt(tokenId)],
  }));
  const limit = pLimit(config.alchemy.batchSize);
  const chunkSize = config.nftContracts.element280.maxTokensPerOwnerQuery;
  const ownerResults = [];
  for (let i = 0; i < ownerCalls.length; i += chunkSize) {
    const chunk = ownerCalls.slice(i, i + chunkSize);
    const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
    ownerResults.push(...results);
  }
  timings.ownerFetch = Date.now() - ownerFetchStart;

  const ownerProcessStart = Date.now();
  let invalidTokens = 0;
  let nonExistentTokens = 0;
  tokenIds.forEach((tokenId, index) => {
    const result = ownerResults[index];
    if (result.status === 'success') {
      const owner = result.result.toLowerCase();
      if (owner && owner !== burnAddress) {
        ownershipByToken.set(tokenId, owner);
        const walletTokens = ownershipByWallet.get(owner) || [];
        walletTokens.push(tokenId);
        ownershipByWallet.set(owner, walletTokens);
      } else {
        invalidTokens++;
      }
    } else {
      if (result.error?.message.includes('0xdf2d9b42')) {
        nonExistentTokens++;
        failedTokens.add(tokenId);
      } else {
        log(`[element280] [ERROR] Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}`);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owners', error: `Failed to fetch owner for token ${tokenId}: ${result.error || 'unknown error'}` });
        failedTokens.add(tokenId);
      }
    }
  });
  timings.ownerProcess = Date.now() - ownerProcessStart;

  if (failedTokens.size > 0) {
    log(`[element280] [WARN] Failed to fetch owners for ${failedTokens.size} tokens: ${[...failedTokens].join(', ')}`);
  }

  const { totalSupply, totalBurned } = await getTotalSupply(contractAddress, errorLog);
  if (ownershipByToken.size > totalSupply) {
    const errorMsg = `Found ${ownershipByToken.size} live NFTs, more than totalSupply ${totalSupply}`;
    log(`[element280] [ERROR] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    throw new Error(errorMsg);
  }
  if (ownershipByToken.size === 0 && totalSupply > 0) {
    const errorMsg = `No valid NFTs with owners found for contract ${contractAddress}, expected up to ${totalSupply}`;
    log(`[element280] [ERROR] ${errorMsg}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'validate_ownership', error: errorMsg });
    throw new Error(errorMsg);
  }

  return { ownershipByToken, ownershipByWallet, totalSupply, totalBurned };
}

// Populate holders cache
async function populateHoldersMapCache(contractAddress, tiers) {
  log(`[element280] [STAGE] Starting populateHoldersMapCache for contract: ${contractAddress}`);
  const storage = initStorage(contractAddress);
  let state = await getCacheState(contractAddress);
  if (state.isCachePopulating) {
    log(`[element280] [ERROR] Cache population already in progress for ${contractAddress}`);
    return;
  }

  state.isCachePopulating = true;
  state.progressState = { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 };
  if (DISABLE_REDIS) {
    storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
    cache.set(`storage_${contractAddress}`, storage);
    log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
    await saveCacheState(`state_${contractAddress}`, storage.cacheState);
  } else {
    await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
  }
  log(`[element280] [STAGE] Initialized state for ${contractAddress}, isCachePopulating: ${state.isCachePopulating}`);

  const timings = {
    totalSupply: 0,
    tokenIdFetch: 0,
    ownerFetch: 0,
    ownerProcess: 0,
    holderInit: 0,
    tierFetch: 0,
    rewardFetch: 0,
    metricsCalc: 0,
    total: 0,
  };
  const errorLog = [];
  const totalStart = Date.now();

  try {
    const supplyStart = Date.now();
    log(`[element280] [DEBUG] Fetching total supply and ownership for ${contractAddress}`);
    const { ownershipByToken, ownershipByWallet, totalSupply, totalBurned } = await fetchAllNftOwnership(contractAddress, errorLog, timings);
    timings.totalSupply = Date.now() - supplyStart;
    state.progressState = { step: 'fetching_ownership', processedNfts: 0, totalNfts: totalSupply };
    if (DISABLE_REDIS) {
      storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
      cache.set(`storage_${contractAddress}`, storage);
      log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      await saveCacheState(`state_${contractAddress}`, storage.cacheState);
    } else {
      await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
    }
    log(`[element280] [STAGE] Ownership fetched for ${contractAddress}: ${ownershipByToken.size} NFTs, ${ownershipByWallet.size} wallets, totalSupply=${totalSupply}, totalBurned=${totalBurned}, duration: ${timings.totalSupply + timings.tokenIdFetch + timings.ownerFetch + timings.ownerProcess}ms`);

    const holderInitStart = Date.now();
    log(`[element280] [DEBUG] Initializing holders for ${contractAddress}`);
    const holdersMap = new Map();
    ownershipByWallet.forEach((tokenIds, wallet) => {
      const holder = {
        wallet,
        total: tokenIds.length,
        totalLive: tokenIds.length,
        multiplierSum: 0,
        displayMultiplierSum: 0,
        tiers: Array(6).fill(0),
        tokenIds: tokenIds.map(id => BigInt(id)),
        claimableRewards: 0,
        percentage: 0,
        rank: 0,
      };
      holdersMap.set(wallet, holder);
      if (!DISABLE_REDIS) setCache(`${TOKEN_CACHE_KEY}_${contractAddress}-${wallet}-nfts`, tokenIds.map(id => ({ tokenId: id, tier: 0 })), CACHE_TTL);
    });
    timings.holderInit = Date.now() - holderInitStart;
    log(`[element280] [STAGE] Holders initialized for ${contractAddress}: ${holdersMap.size} holders, duration: ${timings.holderInit}ms`);
    state.totalOwners = holdersMap.size;
    state.progressState = { step: 'fetching_tiers', processedNfts: ownershipByToken.size, totalNfts: totalSupply };
    if (DISABLE_REDIS) {
      storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
      cache.set(`storage_${contractAddress}`, storage);
      log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      await saveCacheState(`state_${contractAddress}`, storage.cacheState);
    } else {
      await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
    }

    const tierFetchStart = Date.now();
    log(`[element280] [DEBUG] Fetching tiers for ${contractAddress}`);
    const allTokenIds = Array.from(ownershipByToken.keys()).map(id => BigInt(id));
    const tierCalls = allTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: config.abis.element280.main,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    if (tierCalls.length > 0) {
      const limit = pLimit(config.alchemy.batchSize);
      const chunkSize = config.nftContracts.element280.maxTokensPerOwnerQuery;
      const tierResults = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        log(`[element280] [DEBUG] Processing tier batch ${i}-${i + chunkSize - 1} of ${tierCalls.length}`);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        tierResults.push(...results);
        state.progressState = {
          step: 'fetching_tiers',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalSupply,
        };
        if (DISABLE_REDIS) {
          storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
          cache.set(`storage_${contractAddress}`, storage);
          log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
          await saveCacheState(`state_${contractAddress}`, storage.cacheState);
        } else {
          await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
        }
      }
      tierResults.forEach((result, index) => {
        const tokenId = allTokenIds[index].toString();
        if (result.status === 'success') {
          const tier = Number(result.result);
          if (tier >= 1 && tier <= 6) {
            const owner = ownershipByToken.get(tokenId);
            const holder = holdersMap.get(owner);
            if (holder) {
              holder.tiers[tier - 1]++;
              if (!DISABLE_REDIS) setCache(`${TOKEN_CACHE_KEY}_${contractAddress}-${tokenId}-tier`, tier, CACHE_TTL);
            }
          }
        } else {
          log(`[element280] [ERROR] Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`);
        }
      });
    }
    timings.tierFetch = Date.now() - tierFetchStart;
    log(`[element280] [STAGE] Tiers fetched for ${contractAddress}: ${allTokenIds.length} tokens processed, duration: ${timings.tierFetch}ms`);
    state.progressState = { step: 'fetching_rewards', processedNfts: ownershipByToken.size, totalNfts: totalSupply };
    if (DISABLE_REDIS) {
      storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
      cache.set(`storage_${contractAddress}`, storage);
      log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      await saveCacheState(`state_${contractAddress}`, storage.cacheState);
    } else {
      await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
    }

    const rewardFetchStart = Date.now();
    log(`[element280] [DEBUG] Fetching rewards for ${contractAddress}`);
    const rewardCalls = [];
    ownershipByWallet.forEach((tokenIds, wallet) => {
      tokenIds.forEach(tokenId => {
        rewardCalls.push({
          address: config.vaultAddresses.element280.address,
          abi: config.abis.element280.vault,
          functionName: 'getRewards',
          args: [[BigInt(tokenId)], wallet],
        });
      });
    });
    if (rewardCalls.length > 0) {
      const limit = pLimit(config.alchemy.batchSize);
      const chunkSize = config.nftContracts.element280.maxTokensPerOwnerQuery;
      const rewardResults = [];
      for (let i = 0; i < rewardCalls.length; i += chunkSize) {
        const chunk = rewardCalls.slice(i, i + chunkSize);
        log(`[element280] [DEBUG] Processing reward batch ${i}-${i + chunkSize - 1} of ${rewardCalls.length}`);
        const results = await limit(() => retry(() => client.multicall({ contracts: chunk })));
        rewardResults.push(...results);
        state.progressState = {
          step: 'fetching_rewards',
          processedNfts: Math.min(ownershipByToken.size, i + chunkSize),
          totalNfts: totalSupply,
        };
        if (DISABLE_REDIS) {
          storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
          cache.set(`storage_${contractAddress}`, storage);
          log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
          await saveCacheState(`state_${contractAddress}`, storage.cacheState);
        } else {
          await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
        }
      }
      let resultIndex = 0;
      ownershipByWallet.forEach((tokenIds, wallet) => {
        let totalRewards = 0n;
        tokenIds.forEach(() => {
          const result = rewardResults[resultIndex++];
          if (result.status === 'success') {
            const rewardValue = BigInt(result.result[1] || 0);
            totalRewards += rewardValue;
          }
        });
        const holder = holdersMap.get(wallet);
        if (holder) {
          holder.claimableRewards = Number(totalRewards) / 1e18;
          if (isNaN(holder.claimableRewards)) {
            holder.claimableRewards = 0;
          }
          if (!DISABLE_REDIS) setCache(`${TOKEN_CACHE_KEY}_element280-${wallet}-reward`, holder.claimableRewards, CACHE_TTL);
        }
      });
    }
    timings.rewardFetch = Date.now() - rewardFetchStart;
    log(`[element280] [STAGE] Rewards fetched for ${contractAddress}: ${rewardCalls.length} NFTs processed, duration: ${timings.rewardFetch}ms`);
    state.progressState = { step: 'calculating_metrics', processedNfts: ownershipByToken.size, totalNfts: totalSupply };
    if (DISABLE_REDIS) {
      storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
      cache.set(`storage_${contractAddress}`, storage);
      log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      await saveCacheState(`state_${contractAddress}`, storage.cacheState);
    } else {
      await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
    }

    const metricsStart = Date.now();
    log(`[element280] [DEBUG] Calculating metrics for ${contractAddress}`);
    const multipliers = Object.values(config.contractTiers.element280).map(t => t.multiplier);
    const totalMultiplierSum = Array.from(holdersMap.values()).reduce((sum, holder) => {
      holder.multiplierSum = holder.tiers.reduce(
        (sum, count, index) => sum + count * (multipliers[index] || 0),
        0
      );
      holder.displayMultiplierSum = holder.multiplierSum / 10;
      return sum + holder.multiplierSum;
    }, 0);
    const holders = Array.from(holdersMap.values());
    holders.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    });
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holders.forEach((holder, index) => {
      holder.rank = index + 1;
      holdersMap.set(holder.wallet, holder);
    });
    if (!DISABLE_REDIS) await setCache(`${HOLDERS_CACHE_KEY}_${contractAddress}`, Array.from(holdersMap.entries()), CACHE_TTL);
    if (DISABLE_REDIS) {
      storage.holdersMap = holdersMap;
      cache.set(`storage_${contractAddress}`, storage);
      // Save holdersMap to file
      await saveCacheState(`holders_${contractAddress}`, Array.from(holdersMap.entries()));
      log(`[element280] [DEBUG] Saved holdersMap to file for ${contractAddress}: ${holdersMap.size} holders`);
    }
    timings.metricsCalc = Date.now() - metricsStart;
    log(`[element280] [STAGE] Metrics calculated for ${contractAddress}: ${holders.length} holders, duration: ${timings.metricsCalc}ms`);

    timings.total = Date.now() - totalStart;
    const summary = {
      totalDurationMs: timings.total,
      phases: {
        fetchTotalSupply: { durationMs: timings.totalSupply },
        fetchTokenIds: { durationMs: timings.tokenIdFetch },
        fetchOwners: { durationMs: timings.ownerFetch },
        processOwners: { durationMs: timings.ownerProcess },
        initializeHolders: { durationMs: timings.holderInit },
        fetchTiers: { durationMs: timings.tierFetch },
        fetchRewards: { durationMs: timings.rewardFetch },
        calculateMetrics: { durationMs: timings.metricsCalc },
      },
      nftsProcessed: ownershipByToken.size,
      walletsProcessed: ownershipByWallet.size,
      errors: errorLog,
    };
    log(`[element280] [STAGE] Cache population completed for ${contractAddress}: ${summary.nftsProcessed} NFTs, ${summary.walletsProcessed} wallets, ${summary.totalDurationMs}ms`);
    state.progressState = { step: 'completed', processedNfts: ownershipByToken.size, totalNfts: totalSupply };
  } catch (error) {
    log(`[element280] [ERROR] Failed to populate holdersMapCache for ${contractAddress}: ${error.message}, stack: ${error.stack}`);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'populate_cache', error: error.message });
    state.holdersMapCache = null;
    state.progressState = { step: 'error', processedNfts: 0, totalNfts: 0 };
  } finally {
    state.isCachePopulating = false;
    state.totalOwners = storage.holdersMap ? storage.holdersMap.size : 0;
    if (DISABLE_REDIS) {
      storage.cacheState = { ...state, debugId: storage.cacheState.debugId };
      cache.set(`storage_${contractAddress}`, storage);
      log(`[element280] [DEBUG] Saving cache state for ${contractAddress}: ${JSON.stringify(state, null, 2)}`);
      await saveCacheState(`state_${contractAddress}`, storage.cacheState);
    } else {
      await setCache(`${CACHE_STATE_KEY}_${contractAddress}`, state);
    }
    log(`[element280] [STAGE] Finalized for ${contractAddress}: isCachePopulating=false, totalOwners=${state.totalOwners}, debugId=${state.debugId}`);
  }
}

// Fetch holder data
async function getHolderData(contractAddress, wallet, tiers) {
  const cacheKey = `element280_holder_${contractAddress}-${wallet.toLowerCase()}`;
  const storage = initStorage(contractAddress);
  if (!DISABLE_REDIS) {
    try {
      const cached = await getCache(cacheKey);
      if (cached) {
        return cached;
      }
    } catch (cacheError) {
      log(`[element280] [ERROR] Cache read error for holder: ${cacheError.message}, stack: ${cacheError.stack}`);
    }
  }

  let state = await getCacheState(contractAddress);
  while (state.isCachePopulating) {
    await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
    state = await getCacheState(contractAddress);
  }

  let holdersMap;
  if (!DISABLE_REDIS) {
    try {
      const holdersEntries = await getCache(`${HOLDERS_CACHE_KEY}_${contractAddress}`);
      holdersMap = holdersEntries ? new Map(holdersEntries) : new Map();
    } catch (cacheError) {
      log(`[element280] [ERROR] Cache read error for holders map: ${cacheError.message}, stack: ${cacheError.stack}`);
      holdersMap = new Map();
    }
  } else {
    holdersMap = storage.holdersMap || new Map();
  }

  const walletLower = wallet.toLowerCase();
  if (holdersMap.has(walletLower)) {
    const holder = holdersMap.get(walletLower);
    if (!DISABLE_REDIS) await setCache(cacheKey, serializeBigInt(holder), CACHE_TTL);
    return serializeBigInt(holder);
  }

  const holder = {
    wallet: walletLower,
    total: 0,
    totalLive: 0,
    multiplierSum: 0,
    displayMultiplierSum: 0,
    tiers: Array(6).fill(0),
    tokenIds: [],
    claimableRewards: 0,
    percentage: 0,
    rank: 0,
  };

  const tokenIdsResponse = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.element280.main,
      functionName: 'tokenIdsOf',
      args: [walletLower],
    })
  );
  const tokenIds = tokenIdsResponse.map(id => id.toString());
  const nfts = tokenIds.map(tokenId => ({ tokenId, tier: 0 }));
  holder.total = nfts.length;
  holder.totalLive = nfts.length;
  if (!DISABLE_REDIS) await setCache(`${TOKEN_CACHE_KEY}_${contractAddress}-${walletLower}-nfts`, nfts, CACHE_TTL);

  if (nfts.length === 0) {
    return null;
  }

  const bigIntTokenIds = nfts.map(nft => BigInt(nft.tokenId));
  const calls = [];
  bigIntTokenIds.forEach(tokenId => {
    calls.push({
      address: contractAddress,
      abi: config.abis.element280.main,
      functionName: 'getNftTier',
      args: [tokenId],
    });
    calls.push({
      address: config.vaultAddresses.element280.address,
      abi: config.abis.element280.vault,
      functionName: 'getRewards',
      args: [[tokenId], walletLower],
    });
  });

  const results = await retry(() => client.multicall({ contracts: calls }));
  const finalTokenIds = [];
  let totalRewards = 0n;
  nfts.forEach((nft, index) => {
    const tierResult = results[index * 2];
    const rewardResult = results[index * 2 + 1];
    if (tierResult.status === 'success') {
      const tier = Number(tierResult.result);
      if (tier >= 1 && tier <= 6) {
        holder.tiers[tier - 1]++;
        finalTokenIds.push(BigInt(nft.tokenId));
        if (!DISABLE_REDIS) setCache(`${TOKEN_CACHE_KEY}_${contractAddress}-${nft.tokenId}-tier`, tier, CACHE_TTL);
      }
    }
    if (rewardResult.status === 'success') {
      const rewardValue = BigInt(rewardResult.result[1] || 0);
      totalRewards += rewardValue;
    }
  });

  holder.tokenIds = finalTokenIds;
  holder.total = finalTokenIds.length;
  holder.totalLive = finalTokenIds.length;
  holder.claimableRewards = Number(totalRewards) / 1e18;
  if (isNaN(holder.claimableRewards)) {
    holder.claimableRewards = 0;
  }
  if (!DISABLE_REDIS) await setCache(`${TOKEN_CACHE_KEY}_element280-${walletLower}-reward`, holder.claimableRewards, CACHE_TTL);

  const multipliers = Object.values(tiers).map(t => t.multiplier);
  holder.multiplierSum = holder.tiers.reduce(
    (sum, count, index) => sum + count * (multipliers[index] || 0),
    0
  );
  holder.displayMultiplierSum = holder.multiplierSum / 10;

  if (!DISABLE_REDIS) await setCache(cacheKey, serializeBigInt(holder), CACHE_TTL);
  return serializeBigInt(holder);
}

// Fetch all holders
async function getAllHolders(contractAddress, page = 0, pageSize = 100) {
  log(`[element280] [DEBUG] getAllHolders: contract=${contractAddress}, page=${page}, pageSize=${pageSize}`);
  const storage = initStorage(contractAddress);
  let state = await getCacheState(contractAddress);
  log(`[element280] [DEBUG] Cache state: totalOwners=${state.totalOwners}, step=${state.progressState.step}, isCachePopulating=${state.isCachePopulating}`);

  // Reload holdersMap if completed but empty
  if (state.progressState.step === 'completed' && (!storage.holdersMap || storage.holdersMap.size === 0)) {
    log(`[element280] [DEBUG] Completed state but empty holdersMap, reloading cache`);
    const persistedHolders = await loadCacheState(`holders_${contractAddress}`);
    if (persistedHolders) {
      storage.holdersMap = new Map(persistedHolders);
      log(`[element280] [DEBUG] Reloaded holdersMap size: ${storage.holdersMap.size}`);
    } else {
      log(`[element280] [DEBUG] No persisted holdersMap found, triggering population`);
      await populateHoldersMapCache(contractAddress, config.contractTiers.element280).catch(err => {
        log(`[element280] [ERROR] Cache population failed: ${err.message}, stack: ${err.stack}`);
      });
      state = await getCacheState(contractAddress);
    }
  }

  while (state.isCachePopulating) {
    log(`[element280] [DEBUG] Waiting for cache population to complete`);
    await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
    state = await getCacheState(contractAddress);
  }

  let holdersMap;
  if (!DISABLE_REDIS) {
    try {
      const holdersEntries = await getCache(`${HOLDERS_CACHE_KEY}_${contractAddress}`);
      holdersMap = holdersEntries ? new Map(holdersEntries) : new Map();
      log(`[element280] [DEBUG] Redis holdersMap size: ${holdersMap.size}`);
    } catch (cacheError) {
      log(`[element280] [ERROR] Cache read error for holders map: ${cacheError.message}, stack: ${cacheError.stack}`);
      holdersMap = new Map();
    }
  } else {
    holdersMap = storage.holdersMap || new Map();
    log(`[element280] [DEBUG] node-cache holdersMap size: ${holdersMap.size}`);
  }

  // Trigger population if cache is empty and not completed
  if (holdersMap.size === 0 && state.progressState.step !== 'completed') {
    log(`[element280] [DEBUG] Empty holdersMap and cache not completed, triggering population`);
    await populateHoldersMapCache(contractAddress, config.contractTiers.element280).catch(err => {
      log(`[element280] [ERROR] Cache population failed: ${err.message}, stack: ${err.stack}`);
    });
    state = await getCacheState(contractAddress);
    holdersMap = storage.holdersMap || new Map();
    log(`[element280] [DEBUG] Post-population holdersMap size: ${holdersMap.size}`);
  }

  let tierDistribution = [0, 0, 0, 0, 0, 0];
  let multiplierPool = 0;
  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'multiplierPool' },
        ],
      })
    );
    log(`[element280] [DEBUG] multicall results for tiers and multiplier: ${JSON.stringify(results, (k, v) => (typeof v === 'bigint' ? v.toString() : v), 2)}`);
    if (results[0].status === 'success' && results[0].result) {
      tierDistribution = results[0].result.map(Number);
      log(`[element280] [DEBUG] Fetched tierDistribution: ${tierDistribution}`);
    } else {
      log(`[element280] [WARN] getTotalNftsPerTiers returned no data, using default: ${tierDistribution}`);
    }
    if (results[1].status === 'success' && results[1].result) {
      multiplierPool = Number(results[1].result);
      log(`[element280] [DEBUG] Fetched multiplierPool: ${multiplierPool}`);
    } else {
      log(`[element280] [WARN] multiplierPool returned no data, using default: ${multiplierPool}`);
    }
  } catch (error) {
    log(`[element280] [ERROR] Failed to fetch tierDistribution or multiplierPool: ${error.message}, stack: ${error.stack}`);
    const allTokenIds = Array.from(holdersMap.values()).flatMap(h => h.tokenIds);
    if (allTokenIds.length > 0) {
      try {
        const tierCalls = allTokenIds.map(tokenId => ({
          address: contractAddress,
          abi: config.abis.element280.main,
          functionName: 'getNftTier',
          args: [tokenId],
        }));
        const tierResults = await batchMulticall(tierCalls, config.alchemy.batchSize);
        tierResults.forEach(result => {
          if (result.status === 'success') {
            const tier = Number(result.result);
            if (tier >= 1 && tier <= 6) {
              tierDistribution[tier - 1]++;
            }
          }
        });
        const multipliers = Object.values(config.contractTiers.element280).map(t => t.multiplier);
        multiplierPool = tierDistribution.reduce(
          (sum, count, index) => sum + count * (multipliers[index] || 0),
          0
        );
        log(`[element280] [DEBUG] Computed tierDistribution: ${tierDistribution}`);
        log(`[element280] [DEBUG] Computed multiplierPool: ${multiplierPool}`);
        cache.set(`element280_tier_distribution_${contractAddress}`, { tierDistribution, multiplierPool }, CACHE_TTL);
      } catch (computeError) {
        log(`[element280] [ERROR] Failed to compute tierDistribution: ${computeError.message}, stack: ${computeError.stack}`);
      }
    }
  }

  const totalTokens = Array.from(holdersMap.values()).reduce((sum, h) => sum + h.totalLive, 0);
  const holders = Array.from(holdersMap.values());
  const totalPages = Math.ceil(holders.length / pageSize);
  const startIndex = page * pageSize;
  const paginatedHolders = holders.slice(startIndex, startIndex + pageSize);
  const response = {
    holders: serializeBigInt(paginatedHolders),
    totalPages,
    totalTokens,
    totalShares: multiplierPool,
    totalClaimableRewards: paginatedHolders.reduce((sum, h) => sum + h.claimableRewards, 0),
    summary: {
      totalLive: totalTokens,
      totalBurned: await getBurnedCountFromEvents(contractAddress, []),
      totalMinted: config.nftContracts.element280.expectedTotalSupply + config.nftContracts.element280.expectedBurned,
      tierDistribution,
      multiplierPool,
      totalRewardPool: 0,
    },
  };
  log(`[element280] [DEBUG] getAllHolders response: holdersCount=${paginatedHolders.length}, totalPages=${totalPages}, totalTokens=${totalTokens}`);
  return response;
}

// API handlers
export async function GET(request) {
  const address = config.contractAddresses.element280.address;
  if (!address) {
    log(`[element280] [ERROR] Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || config.contractDetails.element280.pageSize, 10);
  const wallet = searchParams.get('wallet');

  try {
    if (wallet) {
      const holder = await getHolderData(address, wallet, config.contractTiers.element280);
      if (!holder) {
        return NextResponse.json({ message: 'No holder data found for wallet' }, { status: 404 });
      }
      return NextResponse.json(serializeBigInt(holder));
    }

    const data = await getAllHolders(address, page, pageSize);
    return NextResponse.json(data);
  } catch (error) {
    log(`[element280] [ERROR] GET error: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

export async function POST() {
  const address = config.contractAddresses.element280.address;
  if (!address) {
    log(`[element280] [ERROR] Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    populateHoldersMapCache(address, config.contractTiers.element280).catch((error) => {
      log(`[element280] [ERROR] Async cache population failed: ${error.message}, stack: ${error.stack}`);
    });
    return NextResponse.json({ message: 'Cache population started' });
  } catch (error) {
    log(`[element280] [ERROR] POST error: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element280/validate-burned/route.js
// app/api/holders/Element280/validate-burned/route.js
import { NextResponse } from 'next/server';
import config from '@/config.js';
import { client, log, batchMulticall, saveCacheState, loadCacheState } from '../../../utils.js';
import pLimit from 'p-limit';
import { parseAbiItem } from 'viem';
import NodeCache from 'node-cache';
import fs from 'fs/promises';

// Force-dynamic: This route is dynamic and should not be cached by Next.js
export const dynamic = 'force-dynamic';

// Constants
const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
const RECENT_BLOCK_CHECK = 10000; // Check last 10,000 blocks for new burns
const EVENT_CACHE_TTL = config.cache.nodeCache.stdTTL;
const BURNED_EVENTS_CACHE_KEY = 'element280_burned_events_detailed';
const METADATA_CACHE_KEY = 'element280_burned_metadata';
const DISABLE_REDIS = process.env.DISABLE_ELEMENT280_REDIS === 'true';

// Initialize node-cache
const cache = new NodeCache({ stdTTL: EVENT_CACHE_TTL });
cache.setMaxListeners(20); // Increase limit

// Initialize storage
function initStorage(contractAddress) {
  const cacheKey = `burned_storage_${contractAddress}`;
  let storage = cache.get(cacheKey);
  if (!storage) {
    storage = { burnedEventsDetailedCache: null, lastBurnBlock: Number(config.deploymentBlocks.element280.block) };
    cache.set(cacheKey, storage);
    cache.removeAllListeners('set'); // Clean up
    log(`[element280] [INIT] Initialized node-cache for burned events: ${contractAddress}`);
  }
  return storage;
}

// Load metadata (last burn block)
async function loadMetadata(contractAddress) {
  const metadata = await loadCacheState(`burned_metadata_${contractAddress}`);
  return metadata ? metadata.lastBurnBlock : Number(config.deploymentBlocks.element280.block);
}

// Save metadata
async function saveMetadata(contractAddress, lastBurnBlock) {
  await saveCacheState(`burned_metadata_${contractAddress}`, { lastBurnBlock });
}

// Retry utility
async function retry(fn, attempts = config.alchemy.maxRetries, delay = (retryCount) => Math.min(config.alchemy.batchDelayMs * 2 ** retryCount, config.alchemy.retryMaxDelayMs)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      log(`[element280] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) {
        log(`[element280] [ERROR] Retry failed after ${attempts} attempts: ${error.message}, stack: ${error.stack}`);
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Update last burn block by checking recent blocks
async function updateLastBurnBlock(contractAddress, currentLastBurnBlock, endBlock) {
  const fromBlock = Math.max(currentLastBurnBlock + 1, Number(config.deploymentBlocks.element280.block));
  const toBlock = Math.min(fromBlock + RECENT_BLOCK_CHECK, Number(endBlock));
  if (fromBlock > toBlock) return currentLastBurnBlock;

  log(`[element280] [DEBUG] Checking recent blocks ${fromBlock}-${toBlock} for new burns`);
  const logs = await retry(() =>
    client.getLogs({
      address: contractAddress,
      event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
      fromBlock: BigInt(fromBlock),
      toBlock: BigInt(toBlock),
    })
  );
  const burnLogs = logs.filter(log => log.args.to.toLowerCase() === BURN_ADDRESS);
  if (burnLogs.length > 0) {
    const latestBurnBlock = Math.max(...burnLogs.map(log => Number(log.blockNumber)));
    log(`[element280] [DEBUG] Found new burns, updating lastBurnBlock to ${latestBurnBlock}`);
    return latestBurnBlock;
  }
  return currentLastBurnBlock;
}

// Validate burned events
async function validateBurnedEvents(contractAddress) {
  const storage = initStorage(contractAddress);
  if (DISABLE_REDIS) {
    if (storage.burnedEventsDetailedCache) {
      log(`[element280] [DEBUG] Cache hit for burned events: ${storage.burnedEventsDetailedCache.burnedCount} events`);
      return storage.burnedEventsDetailedCache;
    }
    const persistedCache = await loadCacheState(`burned_${contractAddress}`);
    if (persistedCache) {
      storage.burnedEventsDetailedCache = persistedCache;
      log(`[element280] [DEBUG] Loaded persisted burned events: ${persistedCache.burnedCount} events`);
      return persistedCache;
    }
  }

  log(`[element280] [STAGE] Fetching burned events for ${contractAddress}`);
  const burnedEvents = [];
  let burnedCount = 0;
  const endBlock = await retry(() => client.getBlockNumber());
  let lastBurnBlock = await loadMetadata(contractAddress);
  lastBurnBlock = await updateLastBurnBlock(contractAddress, lastBurnBlock, endBlock);
  const ranges = [];
  for (let fromBlock = Number(config.deploymentBlocks.element280.block); fromBlock <= lastBurnBlock; fromBlock += config.nftContracts.element280.maxTokensPerOwnerQuery) {
    const toBlock = Math.min(fromBlock + config.nftContracts.element280.maxTokensPerOwnerQuery - 1, lastBurnBlock);
    ranges.push({ fromBlock, toBlock });
  }

  const limit = pLimit(2); // Reduced concurrency
  for (const [index, { fromBlock, toBlock }] of ranges.entries()) {
    try {
      log(`[element280] [PROGRESS] Processing blocks ${fromBlock}-${toBlock} for ${contractAddress} (${index + 1}/${ranges.length})`);
      const logs = await retry(() =>
        client.getLogs({
          address: contractAddress,
          event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
          fromBlock: BigInt(fromBlock),
          toBlock: BigInt(toBlock),
        })
      );
      const burnLogs = logs.filter(log => log.args.to.toLowerCase() === BURN_ADDRESS);
      if (burnLogs.length === 0) continue;

      const tokenIds = burnLogs.map(log => log.args.tokenId);
      const tierCalls = tokenIds.map(tokenId => ({
        address: contractAddress,
        abi: config.abis.element280.main,
        functionName: 'getNftTier',
        args: [tokenId],
      }));
      const tierResults = await batchMulticall(tierCalls, config.alchemy.batchSize);
      const block = await retry(() => client.getBlock({ blockNumber: burnLogs[0]?.blockNumber }));

      burnLogs.forEach((log, i) => {
        const tier = tierResults[i].status === 'success' ? Number(tierResults[i].result) : 0;
        burnedEvents.push({
          tokenId: log.args.tokenId.toString(),
          tier,
          from: log.args.from.toLowerCase(),
          transactionHash: log.transactionHash.toLowerCase(),
          blockNumber: Number(log.blockNumber),
          blockTimestamp: Number(block.timestamp),
        });
        burnedCount++;
      });
    } catch (error) {
      log(`[element280] [ERROR] Failed to process blocks ${fromBlock}-${toBlock}: ${error.message}, stack: ${error.stack}`);
    }
  }

  const result = { burnedCount, events: burnedEvents, timestamp: Date.now() };
  if (DISABLE_REDIS) {
    storage.burnedEventsDetailedCache = result;
    storage.lastBurnBlock = lastBurnBlock;
    cache.set(`burned_storage_${contractAddress}`, storage);
    await saveCacheState(`burned_${contractAddress}`, result);
    await saveMetadata(contractAddress, lastBurnBlock);
  }
  log(`[element280] [STAGE] Completed burned events fetch: ${burnedCount} events, lastBurnBlock=${lastBurnBlock}`);
  return result;
}

// Stream burned events
export async function GET() {
  const address = config.contractAddresses.element280.address;
  if (!address) {
    log(`[element280] [ERROR] Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  return new Response(
    new ReadableStream({
      async start(controller) {
        try {
          const storage = initStorage(address);
          if (DISABLE_REDIS && storage.burnedEventsDetailedCache) {
            controller.enqueue(JSON.stringify({
              complete: true,
              result: storage.burnedEventsDetailedCache,
            }) + '\n');
            controller.close();
            return;
          }

          const burnedEvents = [];
          let burnedCount = 0;
          const endBlock = await retry(() => client.getBlockNumber());
          let lastBurnBlock = await loadMetadata(address);
          lastBurnBlock = await updateLastBurnBlock(address, lastBurnBlock, endBlock);
          const ranges = [];
          for (let fromBlock = Number(config.deploymentBlocks.element280.block); fromBlock <= lastBurnBlock; fromBlock += config.nftContracts.element280.maxTokensPerOwnerQuery) {
            const toBlock = Math.min(fromBlock + config.nftContracts.element280.maxTokensPerOwnerQuery - 1, lastBurnBlock);
            ranges.push({ fromBlock, toBlock });
          }

          const limit = pLimit(2);
          for (const [index, { fromBlock, toBlock }] of ranges.entries()) {
            log(`[element280] [PROGRESS] Processing blocks ${fromBlock}-${toBlock} for ${address} (${index + 1}/${ranges.length})`);
            const logs = await retry(() =>
              client.getLogs({
                address,
                event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
                fromBlock: BigInt(fromBlock),
                toBlock: BigInt(toBlock),
              })
            );
            const burnLogs = logs.filter(log => log.args.to.toLowerCase() === BURN_ADDRESS);
            if (burnLogs.length === 0) continue;

            const tokenIds = burnLogs.map(log => log.args.tokenId);
            const tierCalls = tokenIds.map(tokenId => ({
              address,
              abi: config.abis.element280.main,
              functionName: 'getNftTier',
              args: [tokenId],
            }));
            const tierResults = await batchMulticall(tierCalls, config.alchemy.batchSize);
            const block = await retry(() => client.getBlock({ blockNumber: burnLogs[0]?.blockNumber }));

            burnLogs.forEach((log, i) => {
              const tier = tierResults[i].status === 'success' ? Number(tierResults[i].result) : 0;
              const event = {
                tokenId: log.args.tokenId.toString(),
                tier,
                from: log.args.from.toLowerCase(),
                transactionHash: log.transactionHash.toLowerCase(),
                blockNumber: Number(log.blockNumber),
                blockTimestamp: Number(block.timestamp),
              };
              burnedEvents.push(event);
              burnedCount++;
              controller.enqueue(JSON.stringify({ event, progress: { index: index + 1, total: ranges.length } }) + '\n');
            });
          }

          const result = { burnedCount, events: burnedEvents, timestamp: Date.now() };
          if (DISABLE_REDIS) {
            storage.burnedEventsDetailedCache = result;
            storage.lastBurnBlock = lastBurnBlock;
            cache.set(`burned_storage_${address}`, storage);
            await saveCacheState(`burned_${address}`, result);
            await saveMetadata(address, lastBurnBlock);
          }
          controller.enqueue(JSON.stringify({ complete: true, result }) + '\n');
          controller.close();
        } catch (error) {
          log(`[element280] [ERROR] Streaming error: ${error.message}, stack: ${error.stack}`);
          controller.enqueue(JSON.stringify({ error: `Server error: ${error.message}` }) + '\n');
          controller.close();
        }
      },
    }),
    { headers: { 'Content-Type': 'text/event-stream' } }
  );
}-e 
---
File: ./app/api/holders/Element280/progress/route.js
import { NextResponse } from 'next/server';
import { log } from '@/app/api/utils';
import { getCacheState } from '@/app/api/holders/Element280/route';
import config from '@/config'; // Use @/ alias for root config.js

export async function GET() {
  const address = config.contractAddresses.element280.address; // Updated to use config
  if (!address) {
    log(`[element280] [ERROR] Element280 contract address not found`);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    const state = await getCacheState(address);
    if (!state || !state.progressState) {
      log(`[element280] [ERROR] Invalid cache state for ${address}`);
      return NextResponse.json({ error: 'Cache state not initialized' }, { status: 500 });
    }
    const progressPercentage = state.progressState.totalNfts > 0
      ? ((state.progressState.processedNfts / state.progressState.totalNfts) * 100).toFixed(1)
      : '0.0';

    return NextResponse.json({
      isPopulating: state.isCachePopulating,
      totalLiveHolders: state.totalOwners,
      totalOwners: state.totalOwners,
      phase: state.progressState.step.charAt(0).toUpperCase() + state.progressState.step.slice(1),
      progressPercentage,
    });
  } catch (error) {
    log(`[element280] [ERROR] Progress endpoint error: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Element369/route.js
import { NextResponse } from 'next/server';
import config from '@/config.js';
import { client, alchemy, getCache, setCache, log, batchMulticall } from '@/app/api/utils.js';
import NodeCache from 'node-cache';

// Redis toggle
const DISABLE_REDIS = process.env.DISABLE_ELEMENT369_REDIS === 'true';

// In-memory cache when Redis is disabled
const inMemoryCache = new NodeCache({ stdTTL: config.cache.nodeCache.stdTTL }); // Fixed: config.cache.ttl -> config.cache.nodeCache.stdTTL

const contractAddress = config.contractAddresses.element369.address;
const vaultAddress = config.vaultAddresses.element369.address;
const tiersConfig = config.contractTiers.element369;
const defaultPageSize = config.contractDetails.element369.pageSize;

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || defaultPageSize);
  const wallet = searchParams.get('wallet')?.toLowerCase();

  log(`[Element369] Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}`);

  try {
    if (!contractAddress || !vaultAddress || !tiersConfig) {
      log(`[Element369] Config error: contractAddress=${contractAddress}, vaultAddress=${vaultAddress}`);
      throw new Error('Element369 contract or vault address missing');
    }

    const cacheKey = `element369_holders_${page}_${pageSize}_${wallet || 'all'}`;
    let cachedData;
    try {
      if (DISABLE_REDIS) {
        cachedData = inMemoryCache.get(cacheKey);
      } else {
        cachedData = await getCache(cacheKey);
      }
      if (cachedData) {
        log(`[Element369] Cache hit: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
        return NextResponse.json(cachedData);
      }
      log(`[Element369] Cache miss: ${cacheKey}`);
    } catch (cacheError) {
      log(`[Element369] Cache read error: ${cacheError.message}`);
    }

    // Fetch owners
    const ownersResponse = await alchemy.nft.getOwnersForContract(contractAddress, {
      block: 'latest',
      withTokenBalances: true,
    });
    log(`[Element369] Owners fetched: ${ownersResponse.owners.length}`);

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const filteredOwners = wallet
      ? ownersResponse.owners.filter(owner => owner.ownerAddress.toLowerCase() === wallet && owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0)
      : ownersResponse.owners.filter(owner => owner.ownerAddress.toLowerCase() !== burnAddress && owner.tokenBalances.length > 0);
    log(`[Element369] Live owners: ${filteredOwners.length}`);

    // Build token-to-owner map
    const tokenOwnerMap = new Map();
    const ownerTokens = new Map();
    let totalTokens = 0;
    filteredOwners.forEach(owner => {
      const walletAddr = owner.ownerAddress.toLowerCase();
      const tokenIds = owner.tokenBalances.map(tb => BigInt(tb.tokenId));
      tokenIds.forEach(tokenId => {
        tokenOwnerMap.set(tokenId, walletAddr);
        totalTokens++;
      });
      ownerTokens.set(walletAddr, tokenIds);
    });
    log(`[Element369] Total tokens: ${totalTokens}`);

    // Paginate
    const allTokenIds = Array.from(tokenOwnerMap.keys());
    const start = page * pageSize;
    const end = Math.min(start + pageSize, allTokenIds.length);
    const paginatedTokenIds = allTokenIds.slice(start, end);
    log(`[Element369] Paginated tokens: ${paginatedTokenIds.length}`);

    // Fetch tiers
    const tierCalls = paginatedTokenIds.map(tokenId => ({
      address: contractAddress,
      abi: config.abis.element369.main,
      functionName: 'getNftTier',
      args: [tokenId],
    }));
    const tierResults = await batchMulticall(tierCalls);
    log(`[Element369] Tiers fetched for ${tierResults.length} tokens`);

    // Build holders
    const maxTier = Math.max(...Object.keys(tiersConfig).map(Number)); // maxTier = 3
    const holdersMap = new Map();

    tierResults.forEach((result, i) => {
      if (result?.status === 'success') {
        const tokenId = paginatedTokenIds[i];
        const walletAddr = tokenOwnerMap.get(tokenId);
        const tier = Number(result.result);

        if (tier >= 1 && tier <= maxTier && walletAddr) {
          if (!holdersMap.has(walletAddr)) {
            holdersMap.set(walletAddr, {
              wallet: walletAddr,
              total: 0,
              multiplierSum: 0,
              tiers: Array(maxTier).fill(0), // [Common, Rare, Legendary]
              infernoRewards: 0,
              fluxRewards: 0,
              e280Rewards: 0,
            });
          }
          const holder = holdersMap.get(walletAddr);
          holder.total += 1;
          holder.multiplierSum += tiersConfig[tier]?.multiplier || 0;
          holder.tiers[tier - 1] += 1; // Zero-based: tiers[0] = Common
        } else {
          log(`[Element369] Invalid tier ${tier} for token ${tokenId}`);
        }
      } else {
        log(`[Element369] Tier fetch failed for token ${paginatedTokenIds[i]}: ${result?.error || 'Unknown'}`);
      }
    });

    // Fetch current cycle for debugging
    let currentCycle = 0;
    try {
      currentCycle = await client.readContract({
        address: vaultAddress,
        abi: config.abis.element369.vault,
        functionName: 'getCurrentE369Cycle',
      });
      log(`[Element369] Current cycle: ${currentCycle}`);
    } catch (error) {
      log(`[Element369] Error fetching cycle: ${error.message}`);
    }

    // Fetch rewards
    let holders = Array.from(holdersMap.values());
    const rewardCalls = holders.map(holder => {
      const tokenIds = ownerTokens.get(holder.wallet) || [];
      return {
        address: vaultAddress,
        abi: config.abis.element369.vault,
        functionName: 'getRewards',
        args: [tokenIds, holder.wallet, false], // isBacking: false for claimable rewards
      };
    });

    log(`[Element369] Fetching rewards for ${holders.length} holders`);
    const rewardsResults = await batchMulticall(rewardCalls);

    holders.forEach((holder, i) => {
      if (rewardsResults[i]?.status === 'success' && rewardsResults[i].result) {
        const [availability, burned, infernoPool, fluxPool, e280Pool] = rewardsResults[i].result;
        holder.infernoRewards = Number(infernoPool) / 1e18;
        holder.fluxRewards = Number(fluxPool) / 1e18;
        holder.e280Rewards = Number(e280Pool) / 1e18;
        log(
          `[Element369] Rewards for ${holder.wallet.slice(0, 6)}...: ` +
          `Inferno=${holder.infernoRewards.toFixed(4)}, ` +
          `Flux=${holder.fluxRewards.toFixed(4)}, ` +
          `E280=${holder.e280Rewards.toFixed(4)}, ` +
          `Tokens=${availability.length}, Burned=${burned.filter(b => b).length}, ` +
          `Availability=${availability.join(',')}`
        );
        if (holder.infernoRewards === 0 && holder.fluxRewards === 0 && holder.e280Rewards === 0) {
          log(`[Element369] Zero rewards for ${holder.wallet}: Tokens=${ownerTokens.get(holder.wallet).join(',')}`);
        }
      } else {
        holder.infernoRewards = 0;
        holder.fluxRewards = 0;
        holder.e280Rewards = 0;
        log(`[Element369] Reward fetch failed for ${holder.wallet.slice(0, 6)}...: ${rewardsResults[i]?.error || 'Unknown'}`);
      }
      holder.displayMultiplierSum = holder.multiplierSum;
      holder.percentage = 0;
      holder.rank = 0;
    });

    // Calculate percentages and ranks
    const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
    holders.forEach((holder, index) => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.rank = index + 1;
      holder.displayMultiplierSum = holder.multiplierSum;
    });

    // Sort holders
    holders.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);

    const response = {
      holders,
      totalTokens,
      page,
      pageSize,
      totalPages: wallet ? 1 : Math.ceil(totalTokens / pageSize),
    };

    try {
      if (DISABLE_REDIS) {
        inMemoryCache.set(cacheKey, response);
      } else {
        await setCache(cacheKey, response);
      }
      log(`[Element369] Cached response: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
    } catch (cacheError) {
      log(`[Element369] Cache write error: ${cacheError.message}`);
    }

    log(`[Element369] Success: ${holders.length} holders`);
    return NextResponse.json(response);
  } catch (error) {
    log(`[Element369] Error: ${error.message}`);
    console.error('[Element369] Error stack:', error.stack);
    return NextResponse.json({ error: 'Failed to fetch Element369 data', details: error.message }, { status: 500 });
  }
}-e 
---
File: ./app/api/holders/Ascendant/route.js
import { NextResponse } from 'next/server';
import config from '@/config.js';
import { alchemy, client, log, batchMulticall, getCache, setCache } from '@/app/api/utils.js';
import { formatUnits, getAddress } from 'viem';
import { v4 as uuidv4 } from 'uuid';
import NodeCache from 'node-cache';

// Redis toggle
const DISABLE_REDIS = process.env.DISABLE_ASCENDANT_REDIS === 'true';

// In-memory cache when Redis is disabled
const inMemoryCache = new NodeCache({ stdTTL: config.cache.nodeCache.stdTTL }); // Fixed: config.cache.ttl -> config.cache.nodeCache.stdTTL

// Utility to serialize BigInt values
function safeSerialize(obj) {
  return JSON.parse(
    JSON.stringify(obj, (key, value) => (typeof value === 'bigint' ? value.toString() : value))
  );
}

// Retry utility
async function retry(
  fn,
  attempts = config.alchemy.maxRetries,
  delay = (retryCount, error) =>
    error?.details?.code === 429 ? config.alchemy.batchDelayMs * 2 ** retryCount : config.alchemy.batchDelayMs
) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      log(`[Ascendant] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delay(i, error)));
    }
  }
}

// Fetch data for all holders with pagination
async function getAllHolders(page = 0, pageSize = config.contractDetails.ascendant.pageSize, requestId = '') {
  const contractAddress = config.contractAddresses.ascendant.address;
  const tiers = config.contractTiers.ascendant;
  const cacheKey = `ascendant_holders_${contractAddress}-${page}-${pageSize}`;

  try {
    let cached;
    if (DISABLE_REDIS) {
      cached = inMemoryCache.get(cacheKey);
    } else {
      cached = await getCache(cacheKey);
    }
    if (cached) {
      log(`[Ascendant] Cache hit: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
      return cached;
    }
    log(`[Ascendant] Cache miss: ${cacheKey}`);
  } catch (cacheError) {
    log(`[Ascendant] Cache read error: ${cacheError.message}`);
  }

  if (!contractAddress || !tiers) {
    log(`[Ascendant] Config error: contractAddress=${contractAddress}, tiers=${JSON.stringify(tiers)}`);
    throw new Error('Missing contract address or tiers');
  }

  let owners = [];
  let pageKey = null;
  do {
    const response = await retry(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        block: 'latest',
        withTokenBalances: true,
        pageKey,
      })
    );
    owners = owners.concat(response.owners);
    pageKey = response.pageKey;
  } while (pageKey);

  const burnAddress = '0x0000000000000000000000000000000000000000';
  const filteredOwners = owners.filter(
    owner =>
      owner?.ownerAddress &&
      owner.ownerAddress.toLowerCase() !== burnAddress &&
      owner.tokenBalances?.length > 0
  );

  const tokenOwnerMap = new Map();
  let totalTokens = 0;
  filteredOwners.forEach(owner => {
    if (!owner.ownerAddress) return;
    let wallet;
    try {
      wallet = getAddress(owner.ownerAddress);
    } catch (e) {
      log(`[Ascendant] Invalid wallet address: ${owner.ownerAddress}`);
      return;
    }
    owner.tokenBalances.forEach(tb => {
      if (!tb.tokenId) return;
      const tokenId = Number(tb.tokenId);
      tokenOwnerMap.set(tokenId, wallet);
      totalTokens++;
    });
  });

  const allTokenIds = Array.from(tokenOwnerMap.keys());
  const start = page * pageSize;
  const end = Math.min(start + pageSize, allTokenIds.length);
  const paginatedTokenIds = allTokenIds.slice(start, end);

  if (paginatedTokenIds.length === 0) {
    const result = {
      holders: [],
      totalTokens,
      totalLockedAscendant: 0,
      totalShares: 0,
      toDistributeDay8: 0,
      toDistributeDay28: 0,
      toDistributeDay90: 0,
      pendingRewards: 0,
      page,
      pageSize,
      totalPages: Math.ceil(totalTokens / pageSize),
    };
    try {
      if (DISABLE_REDIS) {
        inMemoryCache.set(cacheKey, result);
      } else {
        await setCache(cacheKey, result);
      }
      log(`[Ascendant] Cached response: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
    } catch (cacheError) {
      log(`[Ascendant] Cache write error: ${cacheError.message}`);
    }
    return result;
  }

  const tierCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: config.abis.ascendant.main,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = paginatedTokenIds.map(tokenId => ({
    address: contractAddress,
    abi: config.abis.ascendant.main,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));

  const [tierResults, recordResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls, config.alchemy.batchSize)),
    retry(() => batchMulticall(recordCalls, config.alchemy.batchSize)),
  ]);

  const failedTiers = tierResults.filter(r => r.status === 'failure');
  if (failedTiers.length) {
    log(`[Ascendant] Failed tier calls: ${failedTiers.map(r => r.error).join(', ')}`);
  }
  const failedRecords = recordResults.filter(r => r.status === 'failure');
  if (failedRecords.length) {
    log(`[Ascendant] Failed record calls: ${failedRecords.map(r => r.error).join(', ')}`);
  }

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const holdersMap = new Map();
  let totalLockedAscendant = 0;

  const walletTokenIds = new Map();
  paginatedTokenIds.forEach(tokenId => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!walletTokenIds.has(wallet)) {
      walletTokenIds.set(wallet, []);
    }
    walletTokenIds.get(wallet).push(tokenId);
  });

  const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
    address: contractAddress,
    abi: config.abis.ascendant.main,
    functionName: 'batchClaimableAmount',
    args: [tokenIds.map(id => BigInt(id))],
  }));

  const claimableResults = await retry(() => batchMulticall(claimableCalls, config.alchemy.batchSize));
  const failedClaimables = claimableResults.filter(r => r.status === 'failure');
  if (failedClaimables.length) {
    log(`[Ascendant] Failed claimable calls: ${failedClaimables.map(r => r.error).join(', ')}`);
  }

  paginatedTokenIds.forEach((tokenId, i) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) return;
    if (!holdersMap.has(wallet)) {
      holdersMap.set(wallet, {
        wallet,
        total: 0,
        multiplierSum: 0,
        tiers: Array(maxTier + 1).fill(0),
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: 0,
        pendingDay28: 0,
        pendingDay90: 0,
        claimableRewards: 0,
      });
    }
    const holder = holdersMap.get(wallet);

    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      } else {
        log(`[Ascendant] Unexpected tier result format for token ${tokenId}: ${JSON.stringify(tierResult.result)}`);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      holder.tiers[tier] += 1;
      holder.total += 1;
      holder.multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const shares = parseFloat(formatUnits(sharesRaw, 18));
      const lockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      holder.shares += shares;
      holder.lockedAscendant += lockedAscendant;
      totalLockedAscendant += lockedAscendant;
    }
  });

  let claimableIndex = 0;
  for (const [wallet, tokenIds] of walletTokenIds.entries()) {
    const holder = holdersMap.get(wallet);
    if (!holder) {
      claimableIndex++;
      continue;
    }
    if (claimableResults[claimableIndex]?.status === 'success') {
      const claimableRaw = claimableResults[claimableIndex].result || '0';
      holder.claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
    }
    claimableIndex++;
  }

  const holders = Array.from(holdersMap.values());
  const totalMultiplierSum = holders.reduce((sum, h) => sum + h.multiplierSum, 0);
  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  holders.forEach(holder => {
    holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
    holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
    holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
    holder.rank = 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holders.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
  holders.forEach((holder, index) => (holder.rank = index + 1));

  const result = {
    holders,
    totalTokens,
    totalLockedAscendant,
    totalShares,
    toDistributeDay8,
    toDistributeDay28,
    toDistributeDay90,
    pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    page,
    pageSize,
    totalPages: Math.ceil(totalTokens / pageSize),
  };

  try {
    if (DISABLE_REDIS) {
      inMemoryCache.set(cacheKey, result);
    } else {
      await setCache(cacheKey, result);
    }
    log(`[Ascendant] Cached response: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
  } catch (cacheError) {
    log(`[Ascendant] Cache write error: ${cacheError.message}`);
  }

  return result;
}

// Fetch data for a specific wallet
async function getHolderData(wallet, requestId = '') {
  const contractAddress = config.contractAddresses.ascendant.address;
  const tiers = config.contractTiers.ascendant;
  const cacheKey = `ascendant_holder_${contractAddress}-${wallet.toLowerCase()}`;

  try {
    let cached;
    if (DISABLE_REDIS) {
      cached = inMemoryCache.get(cacheKey);
    } else {
      cached = await getCache(cacheKey);
    }
    if (cached) {
      log(`[Ascendant] Cache hit: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
      return cached;
    }
    log(`[Ascendant] Cache miss: ${cacheKey}`);
  } catch (cacheError) {
    log(`[Ascendant] Cache read error: ${cacheError.message}`);
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) {
    throw new Error('Invalid wallet address');
  }

  const checksummedWallet = getAddress(wallet);

  const nfts = await retry(() =>
    alchemy.nft.getNftsForOwner(checksummedWallet, { contractAddresses: [contractAddress] })
  );

  if (nfts.totalCount === 0) return null;

  const tokenIds = nfts.ownedNfts
    .filter(nft => nft.contract.address.toLowerCase() === contractAddress.toLowerCase())
    .map(nft => Number(nft.tokenId));

  if (tokenIds.length === 0) return null;

  const tierCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: config.abis.ascendant.main,
    functionName: 'getNFTAttribute',
    args: [BigInt(tokenId)],
  }));
  const recordCalls = tokenIds.map(tokenId => ({
    address: contractAddress,
    abi: config.abis.ascendant.main,
    functionName: 'userRecords',
    args: [BigInt(tokenId)],
  }));
  const claimableCall = [
    {
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'batchClaimableAmount',
      args: [tokenIds.map(id => BigInt(id))],
    },
  ];

  const [tierResults, recordResults, claimableResults] = await Promise.all([
    retry(() => batchMulticall(tierCalls, config.alchemy.batchSize)),
    retry(() => batchMulticall(recordCalls, config.alchemy.batchSize)),
    retry(() => batchMulticall(claimableCall, config.alchemy.batchSize)),
  ]);

  let claimableRewards = 0;
  if (claimableResults[0]?.status === 'success') {
    const claimableRaw = claimableResults[0].result || '0';
    claimableRewards = parseFloat(formatUnits(claimableRaw, 18));
  }

  const maxTier = Math.max(...Object.keys(tiers).map(Number));
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;
  let shares = 0;
  let lockedAscendant = 0;

  tokenIds.forEach((tokenId, i) => {
    const tierResult = tierResults[i];
    let tier;
    if (tierResult?.status === 'success') {
      if (Array.isArray(tierResult.result) && tierResult.result.length >= 2) {
        tier = Number(tierResult.result[1]);
      } else if (typeof tierResult.result === 'object' && tierResult.result.tier !== undefined) {
        tier = Number(tierResult.result.tier);
      } else {
        log(`[Ascendant] Unexpected tier result format for token ${tokenId}: ${JSON.stringify(tierResult.result)}`);
      }
    }
    if (tier >= 1 && tier <= maxTier) {
      tiersArray[tier] += 1;
      total += 1;
      multiplierSum += tiers[tier]?.multiplier || 0;
    }

    const recordResult = recordResults[i];
    if (recordResult?.status === 'success' && Array.isArray(recordResult.result)) {
      const sharesRaw = recordResult.result[0] || '0';
      const lockedAscendantRaw = recordResult.result[1] || '0';
      const tokenShares = parseFloat(formatUnits(sharesRaw, 18));
      const tokenLockedAscendant = parseFloat(formatUnits(lockedAscendantRaw, 18));
      shares += tokenShares;
      lockedAscendant += tokenLockedAscendant;
    }
  });

  const totalSharesRaw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'totalShares',
    })
  );
  const totalShares = parseFloat(formatUnits(totalSharesRaw.toString(), 18));

  const toDistributeDay8Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [0],
    })
  );
  const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw.toString(), 18));

  const toDistributeDay28Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [1],
    })
  );
  const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw.toString(), 18));

  const toDistributeDay90Raw = await retry(() =>
    client.readContract({
      address: contractAddress,
      abi: config.abis.ascendant.main,
      functionName: 'toDistribute',
      args: [2],
    })
  );
  const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw.toString(), 18));

  const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
  const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
  const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

  const totalMultiplierSum = multiplierSum || 1;
  const percentage = (multiplierSum / totalMultiplierSum) * 100;
  const rank = 1;

  const result = {
    wallet: checksummedWallet,
    rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum,
    percentage,
    tiers: tiersArray,
    shares,
    lockedAscendant,
    pendingDay8: shares * pendingRewardPerShareDay8,
    pendingDay28: shares * pendingRewardPerShareDay28,
    pendingDay90: shares * pendingRewardPerShareDay90,
    claimableRewards,
  };

  try {
    if (DISABLE_REDIS) {
      inMemoryCache.set(cacheKey, result);
    } else {
      await setCache(cacheKey, result);
    }
    log(`[Ascendant] Cached response: ${cacheKey} (Redis=${!DISABLE_REDIS})`);
  } catch (cacheError) {
    log(`[Ascendant] Cache write error: ${cacheError.message}`);
  }

  return result;
}

// API endpoint handler
export async function GET(request) {
  const requestId = uuidv4();
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || config.contractDetails.ascendant.pageSize, 10);

  log(`[Ascendant] GET Request: page=${page}, pageSize=${pageSize}, wallet=${wallet}, Redis=${!DISABLE_REDIS}`);

  try {
    if (wallet) {
      const holderData = await getHolderData(wallet, requestId);
      const response = { holders: holderData ? [holderData] : [] };
      log(`[Ascendant] GET /api/holders/Ascendant?wallet=${wallet} completed`);
      return NextResponse.json(safeSerialize(response));
    }

    const result = await getAllHolders(page, pageSize, requestId);
    log(`[Ascendant] GET /api/holders/Ascendant?page=${page}&pageSize=${pageSize} completed`);
    return NextResponse.json(safeSerialize(result));
  } catch (error) {
    log(`[${requestId}] [Ascendant] Error: ${error.message}`);
    console.error(`[${requestId}] [Ascendant] Error stack:`, error.stack);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}-e 
---
File: ./app/api/utils.js
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';
import { Redis } from '@upstash/redis';
import NodeCache from 'node-cache';
import pino from 'pino';
import { promises as fs } from 'fs';
import config from '@/config.js';

const ALCHEMY_API_KEY = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;

export const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`, {
    timeout: 60000, // Default timeout (60 seconds)
  }),
});

export const alchemy = new Alchemy({
  apiKey: ALCHEMY_API_KEY,
  network: config.alchemy.network || Network.ETH_MAINNET,
});

export const logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true, translateTime: 'SYS:standard' },
  },
});

export function log(message) {
  logger.info(message);
}

const cache = new NodeCache({
  stdTTL: config.cache.nodeCache.stdTTL,
  checkperiod: config.cache.nodeCache.checkperiod,
});

const redis = config.cache.redis.disableElement280
  ? null
  : new Redis({
      url: process.env.REDIS_URL || config.redis.url,
      token: process.env.REDIS_TOKEN || config.redis.token,
    });

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

export async function batchMulticall(calls, batchSize = config.alchemy.batchSize) {
  const batches = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    batches.push(calls.slice(i, i + batchSize));
  }
  const results = [];
  for (const batch of batches) {
    try {
      const batchResults = await client.multicall({ contracts: batch });
      results.push(...batchResults);
      await delay(config.alchemy.batchDelayMs);
    } catch (error) {
      log(`[utils] [ERROR] batchMulticall failed: ${error.message}`);
      if (options.retryCount < config.alchemy.maxRetries) {
        await delay(config.alchemy.retryMaxDelayMs / config.alchemy.maxRetries);
        return batchMulticall(calls, { ...options, retryCount: (options.retryCount || 0) + 1 });
      }
      throw error;
    }
  }
  return results;
}

export async function getCache(key) {
  let data = cache.get(key);
  if (!data && !config.cache.redis.disableElement280) {
    try {
      data = await redis?.get(key);
      data = data ? JSON.parse(data) : null;
    } catch (error) {
      log(`[utils] [ERROR] Redis get failed for key ${key}: ${error.message}`);
    }
  }
  if (config.debug.enabled) {
    log(`[utils] [DEBUG] Cache get for ${key}: ${data ? 'hit' : 'miss'}`);
  }
  return data;
}

export async function setCache(key, value) {
  cache.set(key, value);
  if (!config.cache.redis.disableElement280) {
    try {
      await redis?.set(key, JSON.stringify(value), 'EX', config.cache.nodeCache.stdTTL); // Fixed: config.cache.ttl -> config.cache.nodeCache.stdTTL
    } catch (error) {
      log(`[utils] [ERROR] Redis set failed for key ${key}: ${error.message}`);
    }
  }
  if (config.debug.enabled) {
    log(`[utils] [DEBUG] Cache set for ${key}`);
  }
}

export async function loadCacheState(contractAddress) {
  const cacheKey = `state_${contractAddress}`;
  let state = cache.get(cacheKey);
  if (!state && !config.cache.redis.disableElement280) {
    state = await redis?.get(cacheKey);
    state = state ? JSON.parse(state) : null;
  }
  if (!state) {
    try {
      state = JSON.parse(await fs.readFile(`./cache_state_${contractAddress}.json`, 'utf8'));
    } catch (error) {
      state = {
        isCachePopulating: false,
        holdersMapCache: null,
        totalOwners: 0,
        progressState: { step: 'fetching_supply', processedNfts: 0, totalNfts: 0 },
      };
    }
  }
  if (config.debug.enabled) {
    log(`[utils] [DEBUG] Loaded cache state for ${cacheKey}: ${JSON.stringify(state)}`);
  }
  return state;
}

export async function saveCacheState(contractAddress, state) {
  const cacheKey = `state_${contractAddress}`;
  cache.set(cacheKey, state);
  if (!config.cache.redis.disableElement280) {
    try {
      await redis?.set(cacheKey, JSON.stringify(state));
    } catch (error) {
      log(`[utils] [ERROR] Redis set failed for key ${cacheKey}: ${error.message}`);
    }
  }
  try {
    await fs.writeFile(`./cache_state_${contractAddress}.json`, JSON.stringify(state, null, 2));
  } catch (error) {
    log(`[utils] [ERROR] Failed to write cache state to file: ${error.message}`);
  }
  if (config.debug.enabled) {
    log(`[utils] [DEBUG] Saved cache state for ${cacheKey}`);
  }
}-e 
---
File: ./app/layout.css
/* app/layout.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global resets */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #111827; /* Gray-900 */
  color: #ffffff; /* White text */
  min-height: 100vh;
}

/* Animation for fade-in */
.animate-fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Highlight row for tables */
.highlight-row-bold {
  background-color: #fef08a; /* Bold yellow */
  font-weight: 600;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: background-color 0.3s ease;
}-e 
---
File: ./app/auctions/page.js
// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./app/ClientProvider.js
// app/ClientProvider.js
'use client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 60 * 1000, // 30 minutes
      cacheTime: 60 * 60 * 1000, // 1 hour
    },
  },
});

export default function ClientProvider({ children }) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}-e 
---
File: ./postcss.config.mjs
// This file is used to configure PostCSS, a tool for transforming CSS with JavaScript.
const config = {
  plugins: ["tailwindcss"],
};
export default config;
-e 
---
File: ./next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
-e 
---
File: ./config.js
// config.js
import element280NftStatus from './element280_nft_status.json' assert { type: 'json' };
import element280MainAbi from './abi/element280.json' assert { type: 'json' };
import element280VaultAbi from './abi/element280Vault.json' assert { type: 'json' };
import element369MainAbi from './abi/element369.json' assert { type: 'json' };
import element369VaultAbi from './abi/element369Vault.json' assert { type: 'json' };
import staxMainAbi from './abi/staxNFT.json' assert { type: 'json' };
import staxVaultAbi from './abi/staxVault.json' assert { type: 'json' };
import ascendantMainAbi from './abi/ascendantNFT.json' assert { type: 'json' };
// E280 ABI placeholder (not deployed)
const e280MainAbi = [];

const config = {
  // Supported blockchain networks
  supportedChains: ['ETH', 'BASE'],

  // ABIs for all collections
  abis: {
    element280: {
      main: element280MainAbi,
      vault: element280VaultAbi,
    },
    element369: {
      main: element369MainAbi,
      vault: element369VaultAbi,
    },
    stax: {
      main: staxMainAbi,
      vault: staxVaultAbi,
    },
    ascendant: {
      main: ascendantMainAbi,
      vault: [], // No vault ABI provided for Ascendant
    },
    e280: {
      main: e280MainAbi,
      vault: [],
    },
  },

  // NFT contract configurations
  nftContracts: {
    element280: {
      name: 'Element 280',
      symbol: 'ELMNT',
      chain: 'ETH',
      address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
      vaultAddress: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
      deploymentBlock: '20945304',
      tiers: {
        1: { name: 'Common', multiplier: 10, allocation: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 12, allocation: '100000000000000000000000000' },
        3: { name: 'Rare', multiplier: 100, allocation: '1000000000000000000000000000' },
        4: { name: 'Rare Amped', multiplier: 120, allocation: '1000000000000000000000000000' },
        5: { name: 'Legendary', multiplier: 1000, allocation: '10000000000000000000000000000' },
        6: { name: 'Legendary Amped', multiplier: 1200, allocation: '10000000000000000000000000000' },
      },
      description:
        'Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.',
      expectedTotalSupply: 8107,
      expectedBurned: 8776,
      maxTokensPerOwnerQuery: 100,
    },
    element369: {
      name: 'Element 369',
      symbol: 'E369',
      chain: 'ETH',
      address: '0x024D64E2F65747d8bB02dFb852702D588A062575',
      vaultAddress: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5',
      deploymentBlock: '21224418',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        3: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
      },
      description:
        'Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.',
    },
    stax: {
      name: 'Stax',
      symbol: 'STAX',
      chain: 'ETH',
      address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
      vaultAddress: '0x5D27813C32dD705404d1A78c9444dAb523331717',
      deploymentBlock: '21452667',
      tiers: {
        1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
        2: { name: 'Common Amped', multiplier: 1.2, price: '100000000000000000000000000', amplifier: '10000000000000000000000000' },
        3: { name: 'Common Super', multiplier: 1.4, price: '100000000000000000000000000', amplifier: '20000000000000000000000000' },
        4: { name: 'Common LFG', multiplier: 2, price: '100000000000000000000000000', amplifier: '50000000000000000000000000' },
        5: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
        6: { name: 'Rare Amped', multiplier: 12, price: '1000000000000000000000000000', amplifier: '100000000000000000000000000' },
        7: { name: 'Rare Super', multiplier: 14, price: '1000000000000000000000000000', amplifier: '200000000000000000000000000' },
        8: { name: 'Rare LFG', multiplier: 20, price: '1000000000000000000000000000', amplifier: '500000000000000000000000000' },
        9: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
        10: { name: 'Legendary Amped', multiplier: 120, price: '10000000000000000000000000000', amplifier: '1000000000000000000000000000' },
        11: { name: 'Legendary Super', multiplier: 140, price: '10000000000000000000000000000', amplifier: '2000000000000000000000000000' },
        12: { name: 'Legendary LFG', multiplier: 200, price: '10000000000000000000000000000', amplifier: '5000000000000000000000000000' },
      },
      description:
        'Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.',
    },
    ascendant: {
      name: 'Ascendant',
      symbol: 'ASCNFT',
      chain: 'ETH',
      address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f',
      deploymentBlock: '21112535',
      tiers: {
        1: { name: 'Tier 1', price: '7812500000000000000000', multiplier: 1.01 },
        2: { name: 'Tier 2', price: '15625000000000000000000', multiplier: 1.02 },
        3: { name: 'Tier 3', price: '31250000000000000000000', multiplier: 1.03 },
        4: { name: 'Tier 4', price: '62500000000000000000000', multiplier: 1.04 },
        5: { name: 'Tier 5', price: '125000000000000000000000', multiplier: 1.05 },
        6: { name: 'Tier 6', price: '250000000000000000000000', multiplier: 1.06 },
        7: { name: 'Tier 7', price: '500000000000000000000000', multiplier: 1.07 },
        8: { name: 'Tier 8', price: '1000000000000000000000000', multiplier: 1.08 },
      },
      description:
        'Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.',
    },
    e280: {
      name: 'E280',
      symbol: 'E280',
      chain: 'BASE',
      address: null,
      deploymentBlock: null,
      tiers: {},
      description: 'E280 NFTs on BASE chain. Contract not yet deployed.',
      disabled: true,
    },
  },

  // Contract addresses
  contractAddresses: {
    element280: { chain: 'ETH', address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    element369: { chain: 'ETH', address: '0x024D64E2F65747d8bB02dFb852702D588A062575' },
    stax: { chain: 'ETH', address: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1' },
    ascendant: { chain: 'ETH', address: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f' },
    e280: { chain: 'BASE', address: null },
  },

  // Vault addresses
  vaultAddresses: {
    element280: { chain: 'ETH', address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97' },
    element369: { chain: 'ETH', address: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5' },
    stax: { chain: 'ETH', address: '0x5D27813C32dD705404d1A78c9444dAb523331717' },
    e280: { chain: 'BASE', address: null },
  },

  // Deployment blocks
  deploymentBlocks: {
    element280: { chain: 'ETH', block: '20945304' },
    element369: { chain: 'ETH', block: '21224418' },
    stax: { chain: 'ETH', block: '21452667' },
    ascendant: { chain: 'ETH', block: '21112535' },
    e280: { chain: 'BASE', block: null },
  },

  // Contract tiers
  contractTiers: {
    element280: {
      1: { name: 'Common', multiplier: 10 },
      2: { name: 'Common Amped', multiplier: 12 },
      3: { name: 'Rare', multiplier: 100 },
      4: { name: 'Rare Amped', multiplier: 120 },
      5: { name: 'Legendary', multiplier: 1000 },
      6: { name: 'Legendary Amped', multiplier: 1200 },
    },
    element369: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Rare', multiplier: 10 },
      3: { name: 'Legendary', multiplier: 100 },
      tierOrder: [
        { tierId: '3', name: 'Legendary' },
        { tierId: '2', name: 'Rare' },
        { tierId: '1', name: 'Common' },
      ],
    },
    stax: {
      1: { name: 'Common', multiplier: 1 },
      2: { name: 'Common Amped', multiplier: 1.2 },
      3: { name: 'Common Super', multiplier: 1.4 },
      4: { name: 'Common LFG', multiplier: 2 },
      5: { name: 'Rare', multiplier: 10 },
      6: { name: 'Rare Amped', multiplier: 12 },
      7: { name: 'Rare Super', multiplier: 14 },
      8: { name: 'Rare LFG', multiplier: 20 },
      9: { name: 'Legendary', multiplier: 100 },
      10: { name: 'Legendary Amped', multiplier: 120 },
      11: { name: 'Legendary Super', multiplier: 140 },
      12: { name: 'Legendary LFG', multiplier: 200 },
    },
    ascendant: {
      1: { name: 'Tier 1', multiplier: 1.01 },
      2: { name: 'Tier 2', multiplier: 1.02 },
      3: { name: 'Tier 3', multiplier: 1.03 },
      4: { name: 'Tier 4', multiplier: 1.04 },
      5: { name: 'Tier 5', multiplier: 1.05 },
      6: { name: 'Tier 6', multiplier: 1.06 },
      7: { name: 'Tier 7', multiplier: 1.07 },
      8: { name: 'Tier 8', multiplier: 1.08 },
    },
    e280: {},
  },

  // Contract details
  contractDetails: {
    element280: {
      name: 'Element 280',
      chain: 'ETH',
      pageSize: 100,
      apiEndpoint: '/api/holders/Element280',
      rewardToken: 'ELMNT',
    },
    element369: {
      name: 'Element 369',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Element369',
      rewardToken: 'INFERNO/FLUX/E280',
    },
    stax: {
      name: 'Stax',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Stax',
      rewardToken: 'X28',
    },
    ascendant: {
      name: 'Ascendant',
      chain: 'ETH',
      pageSize: 1000,
      apiEndpoint: '/api/holders/Ascendant',
      rewardToken: 'DRAGONX',
    },
    e280: {
      name: 'E280',
      chain: 'BASE',
      pageSize: 1000,
      apiEndpoint: '/api/holders/E280',
      rewardToken: 'E280',
      disabled: true,
    },
  },

  // Utility function to get contract details by name
  getContractDetails: (contractName) => {
    return config.nftContracts[contractName] || null;
  },

  // Alchemy settings (optimized for free tier)
  alchemy: {
    network: 'eth-mainnet',
    batchSize: 10,
    batchDelayMs: 1000,
    retryMaxDelayMs: 30000,
    maxRetries: 3,
  },

  // Cache settings
  cache: {
    redis: {
      disableElement280: process.env.DISABLE_ELEMENT280_REDIS === 'true',
      disableElement369: process.env.DISABLE_ELEMENT369_REDIS === 'true',
      disableStax: process.env.DISABLE_STAX_REDIS === 'true',
      disableAscendant: process.env.DISABLE_ASCENDANT_REDIS === 'true',
      disableE280: process.env.DISABLE_E280_REDIS === 'true' || true,
    },
    nodeCache: {
      stdTTL: 3600,
      checkperiod: 120,
    },
  },

  // Debug settings
  debug: {
    enabled: process.env.DEBUG === 'true',
    logLevel: 'debug',
  },

  // Fallback data (optional, for testing)
  fallbackData: {
    element280: process.env.USE_FALLBACK_DATA === 'true' ? element280NftStatus : null,
  },
};

export default config;-e 
---
File: ./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
-e 
---
File: ./README.md
Please find below my Nextjs project TitanXUtils.  This part is concentrating on 4 NFT colections and analysing their data.

Element369, Stax and Ascendant are complete.

I am still trying to perfect the Element280 NFT collection.
All 4 of these are on Ethereum.
I also have a placeholder for future collection E280; this will be deployed on BASE

I have a few components that are important for this analysis.
It shoud be noted that any code changes and enhancements/testing scripts should not risk breaking the work we've already done for  Element369, Stax and Ascendant 


Please let me know if you need me to share the contents of any source file to help your analysis.


  We've just finished the population of a database for Element280 NFTs data.
  We used the scripts // scripts/trackElement280NFTs.js

The below is definite states for the following 3 wallets so that we can test and check output.
We have run through  the tests and the database seems to match up so we good to move forward.

These 3 are the wallets that I own:
0x15702443110894B26911B913b17ea4931F803B02
0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
0x9D641961a31B3eED46e664fA631aAD3021323862

wallet: 0x15702443110894B26911B913b17ea4931F803B02
this output should be the following:
Element 280, live nfts count 29, 5 amped legendary, 1 legendary, 6 rare amped and 17 amp common: 
Minted 2  
Tiers minted  [0,0,0,0,0,2]
Transferred in  28
Transferred out  1
Burned 0

wallet: 0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA
this output should be the following:
Element 280, live nfts count 0
Minted 22 
Tiers minted  [[0,17,0,3,0,2]
Transferred in 6
Transferred out 27
Burned 1

wallet: 0x9D641961a31B3eED46e664fA631aAD3021323862
this output should be the following:
Element 280, live nfts count 0
Minted 0
Tiers minted   [0,0,0,0,0,0]
Transferred in 2
Transferred out 2
Burned 0

The current claimable reward Element280 tokens for wallet 0x15702443110894B26911B913b17ea4931F803B02 is currently 1,301,036,482 and my current % of rewards is 1.199%

This is because it is only valid for wallets that currently own at least bone element280 NFT to have a current claimable amount.  This information can be used with the Element280Vault contract and abi to calculate the Claimable value for a wallet.  

The project code and data sources that I think we need for our further analysis is below.

public/data/element280_nft_status.json
public/data/element280.db

components/HolderTable.js
components/NFTPage.js
components/Navbar.jsx
components/SearchResultsModal.js

app/holders/Element280/route.js
app/holders/utils.js

nft/ETH/page.js
nft/ETH/layout.js
nft/ETH/Element280/page.js

app/nft-contracts.js  - contains all the contracts - should not be changed
app/page.js
app/layout.js

.env.local
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI

project includes below

{
  "name": "titanx-utility",
  "version": "0.1.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@covalenthq/client-sdk": "^2.2.5",
    "@tanstack/react-query": "^5.72.1",
    "@wagmi/connectors": "^5.7.11",
    "alchemy-sdk": "^3.5.6",
    "chart.js": "^4.4.9",
    "dotenv": "^16.5.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.3",
    "minimist": "^1.2.8",
    "next": "14.2.15",
    "node-fetch": "^3.3.2",
    "p-limit": "^6.2.0",
    "pino": "^9.6.0",
    "pino-pretty": "^13.0.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-virtualized": "^9.22.6",
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "uuid": "^11.1.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.15",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "tailwindcss": "^3.4.17"
  }
}

===========next

Thank you for the additional requirements. To summarize, the solution must:
Be specific to Element 280, ensuring no impact on other NFT collections.

Address potential database staleness by querying the blockchain for the latest data while using the element280.db database for wallet-specific data and complex aggregates.

Update the element280.db database with any new data obtained from the blockchain to keep it as up-to-date as possible.

Resolve the SQLITE_ERROR: table element280_summary has no column named totalRewardPool issue for the NFT->ETH->Element280 page.

Ensure the solution is quick, easy, and verifies the three wallets’ data from wallets.json.

We’ll implement a hybrid approach that:
Fetches real-time data (totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, tierDistribution) from the Element 280 NFT and vault contracts using a single multicall and Alchemy’s getOwnersForContract.

Queries the database (element280.db) for wallet-specific data (element280_wallets) and burnedDistribution, as computing historical burn data on-chain is complex.

Updates the element280_summary table with fresh blockchain data to keep it up-to-date.

Ensures all changes are isolated to Element 280-specific code (/api/holders/Element280, public/data/element280.db, and optionally trackElement280NFTs.js).

This approach resolves the SQLITE_ERROR, ensures real-time accuracy, keeps the database updated, and remains specific to Element 280.
Key Considerations
Element 280 Specificity:
Modify only /api/holders/Element280 (or equivalent, e.g., app/api/holders/Element280/route.js or pages/api/holders/Element280.js).

Use public/data/element280.db, isolated from other collections’ databases.

Reference only Element 280’s CONTRACT_ADDRESS (NFT) and VAULT_CONTRACT_ADDRESS (vault).

Avoid shared utilities or ABIs used by other collections.

Handling Database Staleness:
Fetch totalRewardPool, multiplierPool, totalSupply, totalBurned, totalMinted, totalLive, lastBlock, totalWallets, and tierDistribution from the blockchain for real-time data.

Query element280_wallets for wallet data and element280_summary for burnedDistribution (historical data).

Update element280_summary with new blockchain data to keep it current.

Database Updates:
Add totalRewardPool to element280_summary schema to store blockchain-fetched data.

Update totalWallets, tierDistribution, and other fields in element280_summary with blockchain data.

Ensure element280_wallets updates are handled by trackElement280NFTs.js (existing script).

Solution Goals:
Resolve SQLITE_ERROR by adding totalRewardPool to the database and fetching it on-chain.

Ensure real-time data for critical metrics.

Maintain performance by leveraging the database for wallet data.

Keep changes minimal and Element 280-specific.

Implementation
Step 1: Update the Database Schema
Since the SQLITE_ERROR indicates element280_summary lacks a totalRewardPool column, we’ll add it to the schema. This requires updating trackElement280NFTs.js to include totalRewardPool and ensure the database is ready for updates from the API handler.
Update initDb in trackElement280NFTs.js:


its not just the summary table that needs to be updated with the latet data.  All the tables in the batabase need to be aswell.  These tables can be seen in the file scripts/trackElement280NFTs.jsspecifically the tables are described by the creation code in this file:


      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);```



  Element 369: show Unique Wallets, Active NFTs, Inferno , Flux and Element 280 Rewards
Element 280: show unique wallets, NUmber live NFTs, number burned NFTs,  keep the live NFTs distribution list
Stax:  Unique wallets, NUm live NFTs, NUmber of burned NFts, the live NFTs distribution list if available
Ascendant:  Unique wallets, Active NFTs, Total Ascendant Locked, Total Claimable rewards, Total Pending REwards


=======================

Step 3: Summary of Progress
What We’ve Done:
Initial Analysis:
Identified 500 errors for /nft, /api/holders/Element280, /api/holders/Stax, and /api/holders/Ascendant.

Confirmed the use of Zustand for client-side caching (useNFTStore) and the goal of using Redis for server-side caching.

Analyzed app/nft-contracts.js for contract configurations:
Element280: 0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9, vault: 0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97.

Stax: 0x74270Ca3a274B4dbf26be319A55188690CACE6E1, vault: 0x5D27813C32dD705404d1A78c9444dAb523331717.

Ascendant: 0x9da95c32c5869c84ba2c020b5e87329ec0adc97f, no vault.

Element369: Not fully shared but assumed similar.

API Route Fixes:
Element369: Updated app/api/holders/Element369/route.js to use Redis (getCache, setCache), added retry logic, and improved error handling (not shared by you, assumed similar to Stax).

Stax: Updated app/api/holders/Stax/route.js to use Redis, added retry logic for Alchemy calls, and fixed potential contract call issues.

Element280: Updated app/api/holders/Element280/route.js to replace in-memory cache, holdersMapCache, and tokenCache with Redis. Fixed progress/route.js to work with Redis-based getCacheState.

Ascendant: Updated app/api/holders/Ascendant/route.js to use Redis, fixed burn address typo, and improved retry logic.

Client-Side Fixes:
NFTPage.js: Updated components/NFTPage.js to:
Increase fetch timeout to 120 seconds.

Make /progress fetch non-critical.

Add detailed error logging for fetchContractData and fetchAllHolders.

Include a cache clear button.

NFTLayout.js: Updated app/nft/layout.js to:
Increase fetch timeout to 60 seconds.

Remove ascendantNFT cache bypass.

Add detailed error logging.

Include a cache clear button.

NFTOverview.js: Updated app/nft/page.js to improve styling and messaging.

Caching:
Server-Side: All API routes (Element369, Stax, Element280, Ascendant) now use Redis for caching, replacing in-memory or LRUCache implementations.

Client-Side: NFTPage.js and NFTLayout.js use Zustand for caching, with a button to clear the cache.

Remaining Issues:
Element280 500 Error: May be caused by app/api/holders/Element280/route cache db.js if it’s the active route using LRUCache.

NFT Page 500 Error: Likely due to API failures; requires app/nft/[chain]/[contract]/page.js to confirm how NFTPage.js is rendered.

Missing Files: Need app/api/holders/Element280/route cache db.js and app/nft/[chain]/[contract]/page.js.

Current Status:
API Routes: Updated to use Redis, with improved retry logic and error handling. 500 errors should be reduced, but Element280 needs confirmation on route cache db.js.

NFT Page: Updated NFTPage.js and NFTLayout.js to handle errors better and use Zustand caching. The /nft 500 error persists due to missing dynamic route handler.

Testing Needed: Verify API endpoints and dynamic routes (e.g., /nft/ETH/Element280).

===do you need to see this file?  not sure if its related.  Also could you summarise what we're trying to achive at the moment and the files we're analysing to achieve this? I just need it to add to my readme file so that I cansend you a summary the next time I have to refresh Grok

=================
Summary for README
Objective: Fix the /api/holders/Element280/progress endpoint, which incorrectly returns "totalWallets": 0, "totalOwners": 0, and "phase": "Idle" after the POST /api/holders/Element280 endpoint successfully populates the in-memory cache with 920 holders (totalOwners: 920, step: completed). Ensure the /progress endpoint reflects the correct state (totalWallets: 920, totalOwners: 920, phase: "Completed") while maintaining functionality of POST and GET endpoints and zero Redis usage with DISABLE_ELEMENT280_REDIS=true.
Problem: The /progress endpoint does not access the updated inMemoryCacheState from route.js. The current /progress/route.js uses holdersMapCache?.length (always 0 because holdersMapCache is null in DISABLE_REDIS mode) and sets phase: "Idle" when isCachePopulating: false, ignoring progressState.step (e.g., completed). The getCacheState function in route.js may also be returning an outdated state due to module scoping or incorrect implementation.
Files Analyzed:
/app/api/holders/Element280/route.js:
Handles POST and GET for /api/holders/Element280.

Defines inMemoryHoldersMap and inMemoryCacheState for DISABLE_REDIS mode.

Exports getCacheState to share state with /progress.

Contains populateHoldersMapCache, which correctly updates inMemoryCacheState with totalOwners: 920 and step: completed.

Issue: getCacheState may not return the updated inMemoryCacheState to /progress.

Fix: Ensure getCacheState returns inMemoryCacheState directly in DISABLE_REDIS mode.

/app/api/holders/Element280/progress/route.js:
Handles GET /api/holders/Element280/progress.

Uses getCacheState to fetch state and return isPopulating, totalWallets, totalOwners, phase, and progressPercentage.

Issue: Uses holdersMapCache?.length (always 0) and sets phase: "Idle" incorrectly.

Fix: Use totalOwners for totalWallets and set phase based on progressState.step (e.g., "Completed").

/app/api/utils.js:
Defines log, getCache, setCache, alchemy, client, and ABIs.

Used by route.js for logging and Redis (bypassed with DISABLE_REDIS=true).

Status: No changes needed, as it correctly supports in-memory mode and logging.

Current Status:
POST /api/holders/Element280: Works, returns {"message":"Cache preload completed","totalHolders":920}.

GET /api/holders/Element280?page=0&pageSize=100: Works, returns totalHolders: 920 with 100 holders.

/progress: Fails, returns {"isPopulating":false,"totalWallets":0,"totalOwners":0,"phase":"Idle","progressPercentage":"0.0"} instead of totalWallets: 920, totalOwners: 920, phase: "Completed".

Redis usage: Zero (confirmed by no [UpstashRedis] logs with DISABLE_REDIS=true).

Fixes Applied:
Updated /progress/route.js to use totalOwners for totalWallets and set phase based on progressState.step.

Updated /route.js to ensure getCacheState returns inMemoryCacheState directly in DISABLE_REDIS mode.

Verified utils.js supports in-memory mode (no Redis calls).

Next Steps:
Apply the fixed /progress/route.js and /route.js (provided in previous response).

Test POST, GET, and /progress endpoints.

Share test outputs, logs ([STAGE] and [PROD_DEBUG] Handling /progress), and Upstash Console request count.

Confirm /progress returns totalWallets: 920, totalOwners: 920, phase: "Completed" after POST.

==============

Summary of Objective
Goal: Fix the /api/holders/Element280/progress endpoint to return the correct state (totalWallets: 920, totalOwners: 920, phase: "Completed") after POST /api/holders/Element280 populates the in-memory cache with 920 holders. Ensure POST and GET endpoints remain functional and Redis usage is zero (DISABLE_ELEMENT280_REDIS=true).
Current Status:
POST /api/holders/Element280: Works, returns {"message":"Cache preload completed","totalHolders":920}.

GET /api/holders/Element280?page=0&pageSize=100: Works, returns totalHolders: 920 with 100 holders.

GET /api/holders/Element280/progress: Fails, returns {"isPopulating":false,"totalWallets":0,"totalOwners":0,"phase":"Idle","progressPercentage":"0.0"} instead of totalWallets: 920, totalOwners: 920, phase: "Completed".

Redis Usage: Zero, confirmed by no [UpstashRedis] logs and DISABLE_ELEMENT280_REDIS=true.

Issue: The /progress endpoint uses an outdated /progress/route.js that:
Calculates totalWallets with holdersMapCache?.length (always 0 because holdersMapCache is null in DISABLE_REDIS mode).

Sets phase: "Idle" when isCachePopulating: false, ignoring progressState.step (e.g., completed).

Fails to reflect the updated inMemoryCacheState (totalOwners: 920, step: completed) set by populateHoldersMapCache.

Files Involved:
/app/api/holders/Element280/route.js:
Handles POST and GET, manages inMemoryHoldersMap and inMemoryCacheState.

Exports getCacheState for /progress.

Status: Correct, matches the fixed version. No changes needed.

/app/api/holders/Element280/progress/route.js:
Handles /progress, returns cache state.

Issue: Uses old version with incorrect totalWallets and phase logic.

Fix: Update to use totalOwners for totalWallets and set phase from progressState.step.

/app/api/utils.js:
Provides log, getCache, setCache, alchemy, client.

Status: Correct, supports in-memory mode. No changes needed.

.env.local:
Confirms DISABLE_ELEMENT280_REDIS=true.

Status

====================

# Element280 NFT Holders API

## Project Overview

The **Element280 NFT Holders API** is a Next.js-based backend service designed to provide real-time data about NFT holders for the `Element280` collection on Ethereum. It fetches and caches ownership, supply, and burn data for NFTs, serving endpoints for holder lists, progress tracking, and burn event validation. The API is built to handle high query volumes efficiently using in-memory caching, with plans to support multiple NFT collections.

### Key Features
- **Holders Data (`GET /api/holders/Element280`)**: Returns paginated lists of holders with wallet addresses, NFT counts, tiers, rewards, and rankings.
- **Cache Preload (`POST /api/holders/Element280`)**: Populates an in-memory cache with holder data for fast subsequent queries.
- **Progress Tracking (`GET /api/holders/Element280/progress`)**: Reports cache population status, total holders, and progress percentage.
- **Burn Validation (`GET /api/holders/Element280/validate-burned`)**: Lists burned NFTs (transferred to `0x0000...0000`) with token IDs, tiers, and transaction details.
- **In-Memory Caching**: Uses a custom `inMemoryStorage` singleton to cache data, with Redis support disabled (`DISABLE_ELEMENT280_REDIS=true`). - 
Would like to add more variables similar -  THIS NEEDS TO BE IMPLEMENTED SIMILAR TO THE ABOVE
`DISABLE_ELEMENT369_REDIS=true`
`DISABLE_STAX_REDIS=true`
`DISABLE_ASCENDANT_REDIS=true`
`DISABLE_E280_REDIS=true`

- **Blockchain Integration**: Queries Ethereum via Alchemy SDK and Viem for contract calls (`totalSupply` , `ownerOf`, `getNftTier`, `getRewards`) and event logs (`Transfer`).
please note totalSupply is badly named in the API.  THis actually means totalLiveSupply

### Current Status
- **Codebase**: The API is implemented in Next.js 14.2.28, with primary logic in:
  - `/app/api/holders/Element280/route.js`: Handles GET/POST for holders data and cache population.
  - `/app/api/holders/Element280/progress/route.js`: Reports cache progress.
  - `/app/api/holders/Element280/validate-burned/route.js`: Validates burned NFTs.
  - Supporting utilities in `/app/api/utils.js` and contract ABIs in `/app/nft-contracts.js`.

- **Data**:
  - Total Minted: 16,883 NFTs. ( this will never changed and shoud be hardcoded)
  - Total Live: 8,107 NFTs.  ( this is the current niumber as of now.  maybe less the next time we check. can only go down to 0)
  - Total Burned: 8,776 NFTs (via `Transfer` events to `0x0000...0000`). ( this is the current number as of now.  maybe more the next time we check. can only go up to a max of Total Minted)
  - Total Holders: 920 wallets ( as of now)
- **Dependencies**: `viem`, `alchemy-sdk`, `p-limit`, Next.js.
- **Environment**: `DISABLE_ELEMENT280_REDIS=true`, `NEXT_PUBLIC_ALCHEMY_API_KEY` set in `.env.local`.

### Current Issues
1. **Progress Endpoint Failure**:
   - `/progress` returns `totalLiveHolders: 0`, `totalOwners: 0`, `phase: "Idle"`, despite POST reporting 920 holders. ( this needs to be debugged for the current state)
   - Likely cause: `inMemoryStorage.inMemoryCacheState` is resetting due to server restarts (Next.js dev mode hot reload) or logic errors. - now been implemented with node-cache.  The idea is to get all cacjhing working first with this.  Then have the option to use Redis ( via env vars) or use the serverless env Vercel and Upstash.  ( this cache swicthing has been done for Element280,  we still need to do this for all other nft collections)
2. **Slow `/validate-burned` Endpoint**:
   - Hangs or takes too long due to fetching ~8,776 `Transfer` events and calling `getNftTier` for each.
   - No progress feedback, making debugging difficult. lets keep on checking the performance;  we use the vercel free teir and Upstash free tier.
3. **Shared In-Memory Cache**:
   - `inMemoryStorage` is a global singleton, risking overwrites if multiple NFT collections are supported.  can't remember if this is still the case but each memory cache should use its own in memory storage ( or node-cache  file now I think)
4. **Tier Distribution Failure**:
   - `tierDistribution` and `multiplierPool` return `[0,0,0,0,0,0]` and `0`, indicating failed contract calls (`getTotalNftsPerTiers`, `multiplierPool`).

### Intentions
- **Fix Progress Endpoint**: Ensure caching persists `totalOwners: 920` and `phase: "Completed"` after POST.
- **Optimize `/validate-burned`**: Cache results, add progress logging, and batch `getNftTier` calls.
- **Isolate Cache per Collection**: Modify `inMemoryStorage` to use a map keyed by contract address to support multiple collections without conflicts. Done already ?  maybe
- **Improve Caching**: Replace `inMemoryStorage` with `node-cache` for robustness, TTL support, and eviction policies. - DONE
- **Fix Tier Distribution**: Debug and resolve failed `getTotalNftsPerTiers` and `multiplierPool` calls.
- **Enhance Reliability**: Add error handling, retries, and logging for all blockchain interactions.

### Plan Going Forward
1. **Immediate Fixes** (Next 1-2 days):
   - Update `route.js` to log `inMemoryCacheState` changes and detect resets.
   - Test in production mode (`npm run build && npm run start`) to avoid dev mode hot reloads.
   - Optimize `/validate-burned` with caching and progress logs.
   - Debug `tierDistribution` and `multiplierPool` failures using contract call logs.
2. **Cache Isolation** (Next 3-5 days): - doing now
   - Modify `inMemoryStorage` to use `inMemoryStorage[contractAddress]` for collection-specific data.
   - Test with a second NFT collection to ensure no overwrites.
3. **Switch to `node-cache`** (Next 5-7 days): switched already
   - Integrate `node-cache` for in-memory caching with TTL and eviction.
   - Update all cache operations (`getCacheState`, `inMemoryHoldersMap`, `burnedEventsCache`) to use `node-cache`.
   - Benchmark performance and memory usage.
4. **Long-Term Improvements** (Next 2-4 weeks):
   - Add streaming responses for `/validate-burned` to handle large datasets.
   - Implement Redis fallback for high-traffic scenarios.
   - Add unit tests for cache isolation and blockchain queries.
   - Document API endpoints and caching strategy in Swagger/OpenAPI.

### How to Test
```bash
# Clear cache
rm -rf .next

# Start server
npm run dev

# Test endpoints
curl -X POST http://localhost:3000/api/holders/Element280
curl -v "http://localhost:3000/api/holders/Element280?page=0&pageSize=100"
curl http://localhost:3000/api/holders/Element280/progress
curl http://localhost:3000/api/holders/Element280/validate-burned

# Monitor logs
tail -f server.log

================

README.md Summary for TitanX Utility
Project Overview
TitanX Utility is a Next.js-based web application designed to provide a user-friendly interface for interacting with Ethereum-based NFT collections, specifically Element280, Element369, Stax, Ascendant, and E280. The project integrates with blockchain data via Alchemy, Viem, and Upstash Redis to fetch and display real-time information about NFT holders, token attributes, rewards, and burned tokens. The frontend, accessible at routes like /nft/ETH/Element280, presents this data in tabular formats, while the backend API (/api/holders/*) handles on-chain queries and caching for performance. The application supports both Ethereum (ETH) and Base (BASE) chains, with features for auctions, mining, and NFT analytics.
Goals
The primary goals of TitanX Utility are:
Real-Time NFT Analytics: Provide accurate, up-to-date information on NFT ownership, tiers, shares, and rewards for collections like Element280 (burned token tracking), Element369 (Inferno/Flux/E280 rewards), Stax (vault rewards), and Ascendant (time-based rewards: Day 8/28/90).

Scalable Backend: Implement robust API endpoints (/api/holders/*, /api/holders/Element280/progress, /api/holders/Element280/validate-burned) with caching (Redis or in-memory via node-cache) to handle high query volumes and Alchemy rate limits.

User-Friendly Frontend: Deliver a responsive UI with dynamic routes (/nft/[chain]/[contract]) for exploring NFT data, supporting pagination and wallet-specific queries.

Reliability and Optimization: Ensure the application is stable, with minimal errors, optimized bundle sizes, and efficient blockchain interactions.

Extensibility: Support future collections (e.g., E280 when deployed) and additional features like auctions and mining analytics.

Current Status (as of April 25, 2025)
The TitanX Utility project has reached a stable state with all major issues resolved, and the application is fully buildable and deployable. Key milestones and updates include:
Successful Build: The latest build (npm run build) completed without errors, generating static pages for /nft/ETH/Element280, /nft/ETH/Element369, /nft/ETH/Stax, /nft/ETH/Ascendant, and /nft/BASE/E280. All API routes (/api/holders/*) are server-rendered and functional.

Resolved Issues:
Fixed failedFacts Error: Corrected a typo in app/api/holders/Element280/route.js (failedFacts to failedTokens), resolving cache population issues.

Fixed MaxListenersExceededWarning: Added debounced saveCacheState in app/api/utils.js and cleaned up listeners in Element280/route.js and validate-burned/route.js.

Fixed /progress Endpoint: Added state validation in app/api/holders/Element280/progress/route.js to prevent crashes.

Fixed a.holders is undefined: Updated components/NFTPage.js with error handling and default holders array.

Fixed Duplicate saveCacheState: Removed duplicate definition in app/api/utils.js, using the debounced version.

Fixed loadCacheState and ABI Imports: Added loadCacheState to app/api/utils.js and corrected element369Abi/element369VaultAbi imports in app/api/holders/Element369/route.js to use @/abi/.

Reduced Log Noise: Updated app/api/utils.js to make log conditional (DEBUG=true or NODE_ENV=development) and silenced SIGINT handler during builds.

Caching Implementation:
All collections (Element280, Element369, Stax, Ascendant) support Redis caching (via Upstash) and in-memory caching (node-cache) with toggles (DISABLE_*_REDIS in .env.local).

E280 is disabled, returning { error: "E280 contract not yet deployed" }, but includes caching placeholders for future activation.

Frontend Routes:
Dynamic routes (/nft/[chain]/[contract]) render correctly for Element280, Element369, Stax, and Ascendant.

E280 displays a disabled message as expected.

Additional pages (/auctions, /mining, /about) are static and functional.

Backend Functionality:
/api/holders/Element280: Fetches holders, burned tokens, and progress state (~8107 tokens, ~8776 burned).

/api/holders/Element369: Returns holders with infernoRewards, fluxRewards, and e280Rewards.

/api/holders/Stax: Provides holders, totalBurned, and totalRewardPool.

/api/holders/Ascendant: Delivers holders with shares, lockedAscendant, and pendingDay8/28/90 rewards.

/api/holders/Element280/validate-burned: Validates burned tokens with optimized concurrency.

/api/holders/Element280/progress: Tracks cache population progress.

Optimizations:
Batch multicall size set to 50 in app/api/utils.js to balance Alchemy rate limits.

Conditional logging reduces build and runtime noise.

ABI imports centralized in app/api/utils.js for consistency, with potential for lazy-loading if bundle size (143 kB for /nft/[chain]/[contract]) becomes an issue.

Environment Configuration:
.env.local includes NEXT_PUBLIC_ALCHEMY_API_KEY, REDIS_URL, DEBUG, and DISABLE_*_REDIS toggles for all collections.

Dependencies:
Installed: lodash, node-cache, uuid, @upstash/redis, viem, alchemy-sdk.

Next Steps:
Testing: Run curls.sh to verify API endpoints and share test.log to confirm expected outputs (e.g., holder data, rewards, burned counts). Test frontend routes (/nft/ETH/*) for rendering issues.

Frontend Validation: Ensure HolderTable components (HolderTable/Element280.js, HolderTable/Element369.js, etc.) display data correctly (e.g., multiplierSum, shares, rewards). Report any console errors.

Performance Optimization: Consider moving ABIs to route-specific files or lazy-loading to reduce bundle size (currently 143 kB for /nft/[chain]/[contract]). Adjust batchMulticall batch size if Alchemy rate limits persist.

E280 Deployment: Prepare for E280 contract deployment by updating app/api/holders/E280/route.js with contract address and ABI.

Monitoring: Enable DEBUG=true in .env.local for detailed logs during testing, then disable for production to minimize noise.

Documentation: Update README.md with setup instructions, API usage, and environment variable details.

Known Considerations:
The /nft/[chain]/[contract] route has a large bundle size (143 kB) due to ABI imports and blockchain dependencies. Optimization may be needed for faster load times.

Alchemy rate limits could affect API performance during high traffic. Monitor batchMulticall errors and adjust batch size if needed.

Ensure app/abi/*.json files (element369.json, staxNFT.json, etc.) are versioned and match on-chain contracts.

The TitanX Utility project is now stable, with all critical bugs fixed and a clear path for further testing and optimization. The application is ready for deployment pending final API and frontend validation.


==============

Summary of Testing Progress
Project Context:
Goal: Populate caches for Element280, Element369, Stax, Ascendant, E280 and display complete data in the frontend without partial data.

Initial Issue: Synchronous POST handler caused ~153-second delays and Idle state due to Alchemy rate limits or errors. 

Fixes Applied:
Asynchronous POST handler (~0.118 seconds).

Enhanced populateHoldersMapCache with debug logging.

Updated retry (30-second max delay) and batchMulticall (batchSize = 25).

Current State:
Backend: Element280 cache populates successfully (totalOwners: 920, phase: "Completed").

Frontend: Fails with a.holders is undefined for all collections.

Other Collections: Likely have the same frontend issue; backend status unclear without /progress outputs.

Milestones:
Resolved Synchronous Blocking: POST handler is asynchronous, and cache population completes.

Confirmed Cache Population: Cache file and /progress show Element280 is ready.

Identified Frontend Issue: a.holders is undefined prevents data display across all collections.

Pending: Debug the GET handler, frontend parsing, and verify other collections.


////////////////////////////////  New Summary

Updated README.md Summary for TitanX Utility
Project Overview
TitanX Utility is a Next.js-based web application designed to provide a user-friendly interface for interacting with Ethereum-based NFT collections, specifically Element280, Element369, Stax, Ascendant, and E280. The project integrates with blockchain data via Alchemy, Viem, and Upstash Redis to fetch and display real-time information about NFT holders, token attributes, rewards, and burned tokens. The frontend, accessible at routes like /nft/ETH/Element280, presents this data in tabular formats, while the backend API (/api/holders/*) handles on-chain queries and caching for performance. The application supports both Ethereum (ETH) and Base (BASE) chains, with features for auctions, mining, and NFT analytics.
Goals
The primary goals of TitanX Utility are:
Real-Time NFT Analytics: Provide accurate, up-to-date information on NFT ownership, tiers, shares, and rewards for collections like Element280 (burned token tracking), Element369 (Inferno/Flux/E280 rewards), Stax (vault rewards), and Ascendant (time-based rewards: Day 8/28/90).

Scalable Backend: Implement robust API endpoints (/api/holders/*, /api/holders/Element280/progress, /api/holders/Element280/validate-burned) with caching (Redis or in-memory via node-cache) to handle high query volumes and Alchemy rate limits.

User-Friendly Frontend: Deliver a responsive UI with dynamic routes (/nft/[chain]/[contract]) for exploring NFT data, supporting pagination and wallet-specific queries.

Reliability and Optimization: Ensure the application is stable, with minimal errors, optimized bundle sizes, and efficient blockchain interactions within Alchemy’s free tier limits.

Extensibility: Support future collections (e.g., E280 when deployed) and additional features like auctions and mining analytics.

Current Status (as of April 25, 2025)
The TitanX Utility project is in a stable state, with ongoing updates to centralize configuration and eliminate hardcoded values. Key milestones and updates include:
Configuration Centralization
Centralized config.js: Replaced app/nft-contracts.js with config.js, using ES Modules (import/export) to consolidate all configuration parameters, including:
Contract addresses, vault addresses, deployment blocks, and tiers for Element280, Element369, Stax, Ascendant, and E280.

ABI imports for all collections (element280.json, element280Vault.json, element369.json, element369Vault.json, staxNFT.json, staxVault.json, ascendantNFT.json) moved to config.js.

Alchemy settings (batchSize: 10, batchDelayMs: 1000, maxRetries: 3) optimized for the free tier.

Cache settings (Redis and node-cache) and debug toggles.

Files Updated:
app/api/utils.js: Converted to ES Modules, uses config.js for Alchemy and cache settings.

app/api/holders/Stax/route.js: Updated to use config.js for contract details, tiers, and ABIs (config.abis.stax.main, config.abis.stax.vault).

Files Pending Update (from find command):  THIS IS NOW DONE, so we can move on
app/api/holders/Element280/route.js

app/api/holders/Element280/validate-burned/route.js

app/api/holders/Ascendant/route.js

components/loadElement280NFTsDB.js

components/NFTPage.js

components/HolderTable/E280.js

components/HolderTable/Ascendant.js

components/HolderTable/Stax.js

components/HolderTable/Element369.js

components/HolderTable/Element280.js

Removed: app/nft-contracts.js deleted after updating imports to config.js.

Resolved Issues
Fixed a.holders is undefined: Updated components/NFTPage.js with error handling and default holders array to prevent frontend crashes.

Fixed Synchronous Blocking: Asynchronous POST handler in app/api/holders/Element280/route.js reduced delays from ~153 seconds to ~0.118 seconds.

Fixed Cache Population: Element280 cache population completes (totalOwners: ~920, phase: "Completed") with enhanced populateHoldersMapCache and debug logging.

Fixed failedFacts Error: Corrected typo (failedFacts to failedTokens) in app/api/holders/Element280/route.js.

Fixed MaxListenersExceededWarning: Added debounced saveCacheState in app/api/utils.js and cleaned up listeners in Element280/route.js and validate-burned/route.js.

Fixed /progress Endpoint: Added state validation in app/api/holders/Element280/progress/route.js to prevent crashes.

Fixed Duplicate saveCacheState: Removed duplicate definition in app/api/utils.js.

Reduced Log Noise: Conditional logging in app/api/utils.js (enabled only when DEBUG=true or NODE_ENV=development).

Caching Implementation
All collections (Element280, Element369, Stax, Ascendant) support Redis caching (via Upstash) and in-memory caching (node-cache) with toggles (DISABLE_*_REDIS in .env.local).

E280 is disabled, returning { error: "E280 contract not yet deployed" }, with caching placeholders for future activation.

Cache population for Element280 is optimized with batchSize: 10 and batchDelayMs: 1000 to stay within Alchemy’s free tier limits.

Frontend Routes
Dynamic routes (/nft/[chain]/[contract]) render correctly for Element280, Element369, Stax, and Ascendant when data is available.

E280 displays a disabled message as expected.

Additional pages (/auctions, /mining, /about) are static and functional.

Backend Functionality
/api/holders/Element280: Fetches holders, burned tokens, and progress state (~8107 tokens, ~8776 burned).

/api/holders/Element369: Returns holders with infernoRewards, fluxRewards, and e280Rewards.

/api/holders/Stax: Provides holders, totalBurned, and totalRewardPool.

/api/holders/Ascendant: Delivers holders with shares, lockedAscendant, and pendingDay8/28/90 rewards.

/api/holders/Element280/validate-burned: Validates burned tokens with optimized concurrency.

/api/holders/Element280/progress: Tracks cache population progress.

Optimizations
Alchemy batch size set to 10 in config.js to balance rate limits.

Conditional logging reduces build and runtime noise.

ABIs centralized in config.js for consistency, reducing redundancy in source files.

Environment Configuration
.env.local includes:
NEXT_PUBLIC_ALCHEMY_API_KEY

REDIS_URL, REDIS_TOKEN

DEBUG (set to true for testing)

DISABLE_*_REDIS toggles for each collection

USE_FALLBACK_DATA for Element280 fallback data

Dependencies
Installed: lodash, node-cache, uuid, @upstash/redis, viem, alchemy-sdk.

Next Steps
Update Remaining Files:
Continue updating the pending files listed above to use config.js with ES Modules, replacing references to app/nft-contracts.js and hardcoded values (e.g., contract addresses, batchSize, delay).

Test each updated file to ensure functionality (e.g., cache population, frontend rendering).

Testing:
Run the following commands to verify API endpoints:

curl -X POST http://localhost:3000/api/holders/Element280
curl http://localhost:3000/api/holders/Element280/progress
curl http://localhost:3000/api/holders/Element280
curl http://localhost:3000/api/holders/Stax
curl http://localhost:3000/api/holders/Element369
curl http://localhost:3000/api/holders/Ascendant

Save outputs to test.log and inspect for expected data (e.g., holder counts, rewards, burned tokens).

Test frontend routes (/nft/ETH/Element280, /nft/ETH/Stax, etc.) in a browser, checking for rendering issues or console errors.

Enable DEBUG=true in .env.local for detailed logs, then disable for production.

Frontend Validation:
Verify HolderTable components (HolderTable/Element280.js, HolderTable/Element369.js, etc.) display data correctly (e.g., multiplierSum, shares, rewards).

Ensure no a.holders is undefined errors in the browser console.

Performance Optimization:
Monitor Alchemy rate limit errors (e.g., 429 Too Many Requests) in server.log. Adjust config.alchemy.batchSize (e.g., to 5) or batchDelayMs (e.g., to 2000) if needed.

Evaluate bundle size for /nft/[chain]/[contract] (currently 143 kB). Consider lazy-loading ABIs in config.js if size becomes an issue.

E280 Deployment:
Prepare app/api/holders/E280/route.js for activation by updating config.js with E280’s contract address and ABI once deployed.

Documentation:
Update README.md with:
Setup instructions (e.g., .env.local configuration, dependency installation).

API usage examples (e.g., curl commands).

Environment variable descriptions.

Testing and deployment guidelines.

Known Considerations
Bundle Size: The /nft/[chain]/[contract] route has a bundle size of 143 kB due to ABI imports and blockchain dependencies. Lazy-loading ABIs or moving them to route-specific files may improve load times.

Alchemy Rate Limits: High traffic may trigger rate limits. Monitor batchMulticall errors and adjust config.alchemy settings if necessary.

ABI Consistency: Ensure ABI files in abi/ (element369.json, staxNFT.json, etc.) match on-chain contracts and are versioned in git.

Ascendant Vault: No vault ABI was provided for Ascendant. Confirm if one exists and update config.js if needed.

Scripts Directory: Files in scripts/ (e.g., trackElement280NFTs.js) were excluded from updates but may need similar changes (config.js, ES Modules) if used in production.

Summary of Testing Progress
Project Context:
Goal: Populate caches for Element280, Element369, Stax, Ascendant, and E280, and display complete data in the frontend without partial data or errors.

Initial Issues:
Synchronous POST handler caused ~153-second delays.

a.holders is undefined prevented frontend rendering.

Hardcoded values and app/nft-contracts.js caused maintenance issues.

Fixes Applied:
Asynchronous POST handler (~0.118 seconds).

Enhanced populateHoldersMapCache with debug logging.

Centralized configuration in config.js with ES Modules.

Updated app/api/utils.js and app/api/holders/Stax/route.js to use config.js.

Moved ABIs to config.js for consistency.

Optimized Alchemy settings (batchSize: 10, batchDelayMs: 1000).

Current State:
Backend: Element280 cache populates successfully (totalOwners: ~920, phase: "Completed"). Stax, Element369, and Ascendant likely functional but pending verification.

Frontend: a.holders is undefined resolved in components/NFTPage.js, but rendering needs validation post-file updates.

Configuration: config.js centralizes all settings and ABIs; app/nft-contracts.js removed.

Pending: Update and test remaining files (app/api/holders/Element280/route.js, etc.) to ensure full functionality.

Milestones:
Resolved synchronous blocking and cache population issues.

Centralized configuration and ABI imports.

Identified and started updating files with hardcoded values.

Pending: Complete file updates, verify other collections, and validate frontend.

The TitanX Utility project is on track for full stability, with configuration centralized and critical bugs resolved. The focus is on updating the remaining files, testing API endpoints, and validating frontend rendering.
Notes
Checkpoint: This summary captures the current state (updated config.js, app/api/utils.js, app/api/holders/Stax/route.js). If a crash or disconnection occurs, share this summary, and we can resume updating the next file.

Testing: After updating all files, run the test commands provided to verify functionality. Share test.log or server.log if issues arise.

ABI Files: The config.js assumes ABI files are in ../abi/. If the path differs, adjust the imports or share the correct path.

Scripts: The scripts/ directory was excluded, but files like trackElement280NFTs.js may need updates later. Let me know if you want to address these.

CURRENT status:  trying to get the project to build: I'd linke to add the mining link to the hiome page much like auctions and NFTs are. I also want to remove alchemy-sdk ( as it includes a very troublesome solana library that I want to remove) and use viem possibly instead. 

ollyjukes@MacBookPro titanx-utility % npm run build 

> titanx-utility@0.1.0 build
> next build

   ▲ Next.js 15.3.1
   - Environments: .env.local

   Creating an optimized production build ...

> Build error occurred
[Error: Page "/nft/[chain]/[contract]/page" cannot use both "use client" and export function "generateStaticParams()".] {
  type: 'Error'
}-e 
---
File: ./components/loadElement280NFTsDB.js
// components/loadElement280NFTsDB.js

// Global error handlers
process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
  process.exit(1);
});
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

import { createPublicClient, http, parseAbiItem } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import path from 'path';
import pLimit from 'p-limit';
import { execSync } from 'child_process';
import pino from 'pino';
import { fileURLToPath } from 'url';
import minimist from 'minimist';
import config from '@/config.js';
import { Semaphore } from 'async-mutex';

// Initialize environment
dotenv.config({ path: path.join(process.cwd(), '.env.local') });

// Parse command-line arguments
const args = minimist(process.argv.slice(2), {
  alias: { h: 'help', v: 'verbose', q: 'quiet' },
  boolean: ['verbose', 'quiet'],
});
const FORCE_REFRESH = args.refresh || (args.wallets ? true : false);
const FULL_MODE = args.full || !args.wallets;
const CUSTOM_WALLETS = args.wallets ? args.wallets.split(',').map(addr => addr.trim().toLowerCase()) : [];
const SHOW_HELP = args.help || false;
const SHOW_SUMMARY = args.summary || false;
const VERBOSE_MODE = args.verbose || true;
const QUIET_MODE = args.quiet || false;

// Validate logging options
if (VERBOSE_MODE && QUIET_MODE) {
  console.error('Error: Cannot use both --verbose (-v) and --quiet (-q) together');
  process.exit(1);
}

// Logger setup
const logLevel = VERBOSE_MODE ? 'debug' : QUIET_MODE ? 'error' : 'info';
const logger = pino({
  level: logLevel,
  transport: {
    target: 'pino-pretty',
    options: { colorize: true, translateTime: 'SYS:standard' },
  },
});

// Semaphore for database transaction serialization
const dbSemaphore = new Semaphore(1);

// Constants
const CONTRACT_ADDRESS = config.contractAddresses.element280;
const VAULT_CONTRACT_ADDRESS = config.vaultAddresses.element280;
const DEPLOYMENT_BLOCK = Number(config.deploymentBlocks.element280);
const CACHE_FILE = path.join(process.cwd(), 'public', 'data', 'element280_nft_status.json');
const DB_FILE = path.join(process.cwd(), 'public', 'data', 'element280.db');
const CHECKPOINT_FILE = path.join(process.cwd(), 'public', 'data', 'element280_checkpoint.json');
const FAILED_TOKENS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_tokens.json');
const SKIPPED_TOKENS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_tokens.json');
const SKIPPED_TOKENS_DETAILED_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_tokens_detailed.json');
const FAILED_INSERTS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_inserts.json');
const FAILED_BLOCKS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_failed_blocks.json');
const SKIPPED_WALLETS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_skipped_wallets.json');
const COLLECTED_WALLETS_FILE = path.join(process.cwd(), 'public', 'data', 'element280_collected_wallets.json');
const BACKUP_DIR = path.join(process.cwd(), 'scripts', 'backups');
const MAX_BLOCK_RANGE = config.element280.maxBlockRange || 5000;
const MAX_CONCURRENT_BLOCKS = config.element280.maxConcurrentBlocks || 3;
const MAX_CONCURRENT_WALLETS = config.element280.maxConcurrentWallets || 1;
const MAX_MULTICALL_BATCH = config.element280.maxMulticallBatch || 50;
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const ELMNT_DECIMALS = config.element280.decimals || 18;
const BLOCK_STEP = config.element280.blockStep || 1000;
const DEBUG_WALLETS = config.element280.debugWallets || [
  '0x15702443110894b26911b913b17ea4931f803b02',
  '0xf98f0ee190d9f2e6531e226933f1e47a2890cbda',
  '0x9d641961a31b3eed46e664fa631aad3021323862',
];
const DEBUG_TOKEN_IDS = config.element280.debugTokenIds || [16028, 630, 631, 632];

// Verify environment
const ALCHEMY_API_KEY = config.alchemy.apiKey;
if (!ALCHEMY_API_KEY) {
  logger.error('ALCHEMY_API_KEY not defined in config');
  process.exit(1);
}

// Contract ABIs
const element280Abi = config.abis.element280.main;
const element280VaultAbi = config.abis.element280.vault;

// Clients
const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`, { timeout: config.element280.rpcTimeout || 60000 }),
});
const alchemy = new Alchemy({ apiKey: ALCHEMY_API_KEY, network: Network.ETH_MAINNET });

// Utility Functions
async function retry(fn, attempts = config.element280.retryAttempts || 5, delay = retryCount => Math.min(1000 * 2 ** retryCount, config.element280.maxRetryDelay || 10000)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === attempts - 1) {
        logger.error(`Failed after ${attempts} attempts: ${error.message}`);
        throw error;
      }
      logger.warn(`Retry ${i + 1}/${attempts}: ${error.message}`);
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

async function executeDbTransaction(db, fn) {
  const [value, release] = await dbSemaphore.acquire();
  try {
    await db.run('BEGIN TRANSACTION');
    const result = await fn();
    await db.run('COMMIT');
    return result;
  } catch (error) {
    await db.run('ROLLBACK');
    logger.error(`Transaction failed: ${error.message}`);
    throw error;
  } finally {
    release();
  }
}

async function clearDatabase() {
  logger.debug('Clearing database');
  const backupFile = path.join(BACKUP_DIR, `element280_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.sql`);
  await fs.mkdir(BACKUP_DIR, { recursive: true });
  try {
    execSync(`sqlite3 ${DB_FILE} .dump > ${backupFile}`);
    logger.info(`Backup created: ${backupFile}`);
  } catch (error) {
    logger.warn(`Backup failed: ${error.message}`);
  }
  const db = await open({ filename: DB_FILE, driver: sqlite3.Database });
  await db.exec('DROP TABLE IF EXISTS element280_summary; DROP TABLE IF EXISTS element280_transfers; DROP TABLE IF EXISTS element280_wallets;');
  await db.close();
}

async function initDb() {
  const db = await open({
    filename: DB_FILE,
    driver: sqlite3.Database,
  });
  await db.configure('busyTimeout', config.element280.dbBusyTimeout || 60000);
  await db.run('PRAGMA journal_mode = WAL;');
  await db.exec(`
    CREATE TABLE IF NOT EXISTS element280_summary (
      id INTEGER PRIMARY KEY,
      totalMinted INTEGER,
      totalBurned INTEGER,
      totalLive INTEGER,
      totalWallets INTEGER,
      tierDistribution TEXT,
      burnedDistribution TEXT,
      multiplierPool INTEGER,
      totalRewardPool INTEGER,
      lastBlock INTEGER
    );
    CREATE TABLE IF NOT EXISTS element280_transfers (
      tokenId TEXT,
      fromAddr TEXT,
      toAddr TEXT,
      tier INTEGER,
      blockNumber INTEGER,
      transactionHash TEXT,
      blockTimestamp INTEGER,
      eventType TEXT,
      multiplierPool INTEGER,
      totalSupply INTEGER,
      totalBurned INTEGER,
      ownerAddr TEXT,
      PRIMARY KEY (tokenId, transactionHash, eventType)
    );
    CREATE TABLE IF NOT EXISTS element280_wallets (
      address TEXT PRIMARY KEY,
      totalLive INTEGER,
      totalBurned INTEGER,
      totalBought INTEGER,
      totalSold INTEGER,
      minted INTEGER,
      tiersLive TEXT,
      tiersBurned TEXT,
      tiersMinted TEXT,
      tiersTransferredIn TEXT,
      tiersTransferredOut TEXT,
      nfts TEXT,
      multiplierSum INTEGER,
      displayMultiplierSum REAL,
      claimableRewards REAL
    );
    CREATE INDEX IF NOT EXISTS idx_transfers_addresses ON element280_transfers(fromAddr, toAddr);
    CREATE INDEX IF NOT EXISTS idx_transfers_tokenId ON element280_transfers(tokenId);
    CREATE INDEX IF NOT EXISTS idx_transfers_eventType ON element280_transfers(eventType);
    CREATE INDEX IF NOT EXISTS idx_transfers_blockNumber ON element280_transfers(blockNumber);
  `);
  logger.info('Database initialized');
  return db;
}

async function migrateDb(db) {
  try {
    await db.exec(`
      ALTER TABLE element280_summary ADD COLUMN totalRewardPool INTEGER DEFAULT 0;
      ALTER TABLE element280_wallets ADD COLUMN claimableRewards REAL DEFAULT 0;
      ALTER TABLE element280_wallets ADD COLUMN tiersMinted TEXT DEFAULT '[0,0,0,0,0,0]';
      ALTER TABLE element280_wallets ADD COLUMN tiersTransferredIn TEXT DEFAULT '[0,0,0,0,0,0]';
      ALTER TABLE element280_wallets ADD COLUMN tiersTransferredOut TEXT DEFAULT '[0,0,0,0,0,0]';
    `);
    logger.info('Database migrated');
  } catch (error) {
    if (!error.message.includes('duplicate column name')) {
      logger.error(`Migration failed: ${error.message}`);
      throw error;
    }
  }
}

async function loadCheckpoint() {
  try {
    const data = await fs.readFile(CHECKPOINT_FILE, 'utf8');
    const checkpoint = JSON.parse(data);
    logger.info(`Loaded checkpoint: lastBlock=${checkpoint.lastBlock}`);
    return checkpoint;
  } catch {
    logger.info(`No checkpoint file found, starting from deployment block ${DEPLOYMENT_BLOCK - 1}`);
    return { lastBlock: DEPLOYMENT_BLOCK - 1 };
  }
}

async function saveCheckpoint(lastBlock) {
  await fs.writeFile(CHECKPOINT_FILE, JSON.stringify({ lastBlock }));
  logger.info(`Checkpoint saved: lastBlock=${lastBlock}`);
}

async function loadFailedTokens() {
  try {
    return new Set(JSON.parse(await fs.readFile(FAILED_TOKENS_FILE, 'utf8')));
  } catch {
    return new Set();
  }
}

async function saveFailedTokens(failedTokenIds) {
  await fs.writeFile(FAILED_TOKENS_FILE, JSON.stringify([...failedTokenIds]));
  logger.info('Saved failed tokens');
}

async function loadSkippedTokens() {
  try {
    return new Set(JSON.parse(await fs.readFile(SKIPPED_TOKENS_FILE, 'utf8')));
  } catch {
    return new Set();
  }
}

async function saveSkippedTokens(skippedTokenIds, skippedDetails = []) {
  await fs.writeFile(SKIPPED_TOKENS_FILE, JSON.stringify([...skippedTokenIds]));
  await fs.appendFile(SKIPPED_TOKENS_DETAILED_FILE, JSON.stringify(skippedDetails, null, 2) + '\n');
  logger.info('Saved skipped tokens');
}

async function createScriptBackup() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupFile = path.join(BACKUP_DIR, `trackElement280NFTs_${timestamp}.js`);
  await fs.mkdir(BACKUP_DIR, { recursive: true });
  await fs.copyFile(fileURLToPath(import.meta.url), backupFile);
  logger.info(`Script backup created: ${backupFile}`);
}

async function batchMulticall(contracts) {
  const results = [];
  for (let i = 0; i < contracts.length; i += MAX_MULTICALL_BATCH) {
    const batch = contracts.slice(i, i + MAX_MULTICALL_BATCH);
    results.push(...(await retry(() => client.multicall({ contracts: batch }))));
  }
  return results;
}

async function validateTokenOwnership(owner, tokenId, blockNumber) {
  try {
    const currentOwner = await retry(() =>
      client.readContract({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'ownerOf',
        args: [BigInt(tokenId)],
        blockNumber: BigInt(blockNumber),
      })
    );
    return currentOwner && currentOwner.toLowerCase() === owner.toLowerCase();
  } catch (error) {
    logger.warn(`Token ${tokenId} validation failed: ${error.message}`);
    return false;
  }
}

async function fetchContractData() {
  try {
    const [totalSupply, totalBurned, tierCounts, multiplierPool, totalRewardPool] = await retry(() =>
      client.multicall({
        contracts: [
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalSupply' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalBurned' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'getTotalNftsPerTiers' },
          { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'multiplierPool' },
          { address: VAULT_CONTRACT_ADDRESS, abi: element280VaultAbi, functionName: 'totalRewardPool' },
        ],
      })
    );
    return {
      totalMinted: Number(totalSupply.result) + Number(totalBurned.result),
      totalBurned: Number(totalBurned.result),
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.result.map(Number),
      multiplierPool: Number(multiplierPool.result),
      totalRewardPool: Number(totalRewardPool.result),
    };
  } catch (error) {
    logger.error(`Failed to fetch contract data: ${error.message}`);
    throw error;
  }
}

async function fetchAndStoreEvents(db, startBlock, endBlock, skippedTokenIds, skippedDetails) {
  const burnedDistribution = [0, 0, 0, 0, 0, 0];
  const limit = pLimit(MAX_CONCURRENT_BLOCKS);
  const ranges = [];
  for (let fromBlock = startBlock; fromBlock <= endBlock; fromBlock += MAX_BLOCK_RANGE) {
    const toBlock = Math.min(fromBlock + MAX_BLOCK_RANGE - 1, endBlock);
    ranges.push({ fromBlock, toBlock });
  }

  const failedBlocks = [];
  await Promise.all(
    ranges.map(({ fromBlock, toBlock }) =>
      limit(async () => {
        try {
          const logs = await retry(() =>
            client.getLogs({
              address: CONTRACT_ADDRESS,
              event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
              fromBlock: BigInt(fromBlock),
              toBlock: BigInt(toBlock),
            })
          );

          const uniqueBlocks = [...new Set(logs.map(log => Number(log.blockNumber)))];
          const blockTimestamps = new Map();
          await Promise.all(
            uniqueBlocks.map(blockNumber =>
              retry(() =>
                client.getBlock({ blockNumber: BigInt(blockNumber) }).then(block =>
                  blockTimestamps.set(blockNumber, Number(block.timestamp))
                )
              )
            )
          );

          for (const log of logs) {
            const { from, to, tokenId } = log.args;
            const tokenIdNum = tokenId.toString();
            const blockNumber = Number(log.blockNumber);
            const transactionHash = log.transactionHash.toLowerCase();
            let tier = 0;
            let eventType = 'transfer';
            let ownerAddr = '';

            if (from.toLowerCase() === ZERO_ADDRESS.toLowerCase()) {
              eventType = 'mint';
            } else if (to.toLowerCase() === ZERO_ADDRESS.toLowerCase()) {
              eventType = 'burn';
            }

            try {
              tier = Number(
                await retry(() =>
                  client.readContract({
                    address: CONTRACT_ADDRESS,
                    abi: element280Abi,
                    functionName: 'getNftTier',
                    args: [tokenId],
                    blockNumber: BigInt(blockNumber),
                  })
                )
              );
            } catch (error) {
              logger.warn(`Skipping token ${tokenIdNum} at block ${blockNumber}: Failed to fetch tier (${error.message})`);
              skippedTokenIds.add(tokenIdNum);
              skippedDetails.push({ tokenId: tokenIdNum, blockNumber, reason: `Failed to fetch tier: ${error.message}` });
              continue;
            }

            try {
              ownerAddr = await retry(() =>
                client.readContract({
                  address: CONTRACT_ADDRESS,
                  abi: element280Abi,
                  functionName: 'ownerOf',
                  args: [tokenId],
                  blockNumber: BigInt(blockNumber),
                })
              );
            } catch (error) {
              logger.warn(`Token ${tokenIdNum} owner fetch failed: ${error.message}`);
            }

            const [multiplierPool, totalSupply, totalBurned] = await retry(() =>
              client.multicall({
                contracts: [
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'multiplierPool', blockNumber: BigInt(blockNumber) },
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalSupply', blockNumber: BigInt(blockNumber) },
                  { address: CONTRACT_ADDRESS, abi: element280Abi, functionName: 'totalBurned', blockNumber: BigInt(blockNumber) },
                ],
              })
            );

            try {
              await executeDbTransaction(db, async () => {
                await db.run(
                  `INSERT OR REPLACE INTO element280_transfers (
                    tokenId, fromAddr, toAddr, tier, blockNumber, transactionHash,
                    blockTimestamp, eventType, multiplierPool, totalSupply, totalBurned, ownerAddr
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                  [
                    tokenIdNum,
                    from.toLowerCase(),
                    to.toLowerCase(),
                    tier,
                    blockNumber,
                    transactionHash,
                    blockTimestamps.get(blockNumber) || 0,
                    eventType,
                    multiplierPool.status === 'success' ? Number(multiplierPool.result) : 0,
                    totalSupply.status === 'success' ? Number(totalSupply.result) : 0,
                    totalBurned.status === 'success' ? Number(totalBurned.result) : 0,
                    ownerAddr.toLowerCase(),
                  ]
                );
              });
            } catch (error) {
              logger.error(`Failed to insert transfer for token ${tokenIdNum}: ${error.message}`);
              await fs.appendFile(FAILED_INSERTS_FILE, JSON.stringify({ tokenId: tokenIdNum, error: error.message }) + '\n');
            }

            if (eventType === 'burn' && tier >= 1 && tier <= 6) {
              burnedDistribution[tier - 1]++;
            }
          }
        } catch (error) {
          logger.error(`Failed to process block range ${fromBlock}-${toBlock}: ${error.message}`);
          failedBlocks.push({ fromBlock, toBlock, error: error.message });
        }
      })
    )
  );

  if (failedBlocks.length > 0) {
    await fs.writeFile(FAILED_BLOCKS_FILE, JSON.stringify(failedBlocks, null, 2));
  }

  return burnedDistribution;
}

async function processWallet(owner, db, failedTokenIds, skippedTokenIds, skippedDetails) {
  if (owner.toLowerCase() === ZERO_ADDRESS.toLowerCase()) return null;

  logger.info(`Processing wallet ${owner}`);
  if (DEBUG_WALLETS.includes(owner.toLowerCase())) {
    logger.debug(`Processing debug wallet ${owner}`);
  }

  const wallet = {
    wallet: owner.toLowerCase(),
    totalLive: 0,
    totalBurned: 0,
    totalBought: 0,
    totalSold: 0,
    minted: 0,
    tiersLive: [0, 0, 0, 0, 0, 0],
    tiersBurned: [0, 0, 0, 0, 0, 0],
    tiersMinted: [0, 0, 0, 0, 0, 0],
    tiersTransferredIn: [0, 0, 0, 0, 0, 0],
    tiersTransferredOut: [0, 0, 0, 0, 0, 0],
    nfts: [],
    multiplierSum: 0,
    displayMultiplierSum: 0,
    claimableRewards: 0,
  };

  // Fetch current balance
  try {
    const balance = await retry(() =>
      client.readContract({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'balanceOf',
        args: [owner],
      })
    );
    wallet.totalLive = Number(balance);
  } catch (error) {
    logger.warn(`Failed to get balance for ${owner}: ${error.message}`);
    wallet.totalLive = 0;
  }

  // Fetch owned NFTs
  let nfts = [];
  if (wallet.totalLive > 0) {
    try {
      const nftsResponse = await retry(() =>
        alchemy.nft.getNftsForOwner(owner, {
          contractAddresses: [CONTRACT_ADDRESS],
        })
      );
      nfts = nftsResponse.ownedNfts.map(nft => ({
        tokenId: nft.tokenId,
        status: 'live',
        tier: 0,
        tierName: '',
      }));

      const tokenIds = nfts.map(nft => BigInt(nft.tokenId));
      const tierCalls = tokenIds.map(tokenId => ({
        address: CONTRACT_ADDRESS,
        abi: element280Abi,
        functionName: 'getNftTier',
        args: [tokenId],
      }));

      const tierResults = await retry(() => client.multicall({ contracts: tierCalls }));
      const validTokenIds = [];
      nfts.forEach((nft, index) => {
        if (tierResults[index].status === 'success') {
          const tier = Number(tierResults[index].result);
          if (tier >= 1 && tier <= 6) {
            nft.tier = tier;
            nft.tierName = config.contractTiers.element280[tier].name;
            wallet.tiersLive[tier - 1]++;
            validTokenIds.push(BigInt(nft.tokenId));
          }
        }
      });

      wallet.nfts = nfts;

      // Calculate multiplier sum
      const multipliers = Object.values(config.contractTiers.element280).map(t => t.multiplier);
      wallet.multiplierSum = nfts.reduce((sum, nft) => sum + (nft.tier > 0 ? multipliers[nft.tier - 1] : 0), 0);
      wallet.displayMultiplierSum = wallet.multiplierSum / 100;

      // Calculate claimable rewards
      if (validTokenIds.length > 0) {
        try {
          const rewards = await retry(
            () =>
              client.readContract({
                address: CONTRACT_ADDRESS,
                abi: element280Abi,
                functionName: 'getClaimableRewardsForTokens',
                args: [validTokenIds],
              }),
            2,
            1000,
            true
          );
          wallet.claimableRewards = Number(rewards) / 1e18;
        } catch (error) {
          logger.warn(`Rewards query failed for ${owner}: ${error.message}`);
          wallet.claimableRewards = 0;
        }
      }
    } catch (error) {
      logger.warn(`Failed to process NFTs for ${owner}: ${error.message}`);
    }
  }

  // Process transfers to calculate minted, bought, sold, burned
  try {
    const transfers = await db.all(
      `SELECT tokenId, transactionHash, blockNumber, eventType, tier, fromAddr, toAddr
       FROM element280_transfers
       WHERE lower(fromAddr) = ? OR lower(toAddr) = ?
       ORDER BY blockNumber ASC`,
      [owner.toLowerCase(), owner.toLowerCase()]
    );
    logger.debug(`Fetched ${transfers.length} transfers for ${owner}`);
    if (transfers.length === 0) {
      logger.warn(`No transfers found for ${owner}`);
    } else {
      logger.trace(`Transfers for ${owner}: ${JSON.stringify(transfers, null, 2)}`);
    }

    for (const log of transfers) {
      const { fromAddr, toAddr, tokenId, tier, eventType } = log;
      if (tier < 1 || tier > 6) continue;

      if (eventType === 'mint') {
        wallet.minted += 1;
        wallet.tiersMinted[tier - 1]++;
      } else if (eventType === 'burn') {
        wallet.totalBurned += 1;
        wallet.tiersBurned[tier - 1]++;
      } else if (eventType === 'transfer') {
        if (fromAddr.toLowerCase() === owner.toLowerCase()) {
          wallet.totalSold += 1;
          wallet.tiersTransferredOut[tier - 1]++;
        }
        if (toAddr.toLowerCase() === owner.toLowerCase()) {
          wallet.totalBought += 1;
          wallet.tiersTransferredIn[tier - 1]++;
        }
      }
    }
  } catch (error) {
    logger.error(`Failed to fetch transfers for ${owner}: ${error.message}`);
  }

  return wallet;
}

async function trackElement280NFTs() {
  if (SHOW_HELP) {
    console.log(`
      Usage: node scripts/trackElement280NFTs.js [options]
      Options:
        --help, -h          Show this help message
        --verbose, -v       Enable verbose logging
        --quiet, -q         Enable quiet mode (errors only)
        --full              Run full sync from deployment block
        --refresh           Force refresh of wallet data
        --summary           Show summary only
        --wallets=addr1,addr2 Process specific wallets (comma-separated)
    `);
    process.exit(0);
  }

  const result = {
    summary: {
      totalMinted: 0,
      totalBurned: 0,
      totalLive: 0,
      totalWallets: 0,
      tierDistribution: [0, 0, 0, 0, 0, 0],
      burnedDistribution: [0, 0, 0, 0, 0, 0],
      multiplierPool: 0,
      totalRewardPool: 0,
    },
    wallets: [],
    burnedNfts: [],
  };

  const failedTokenIds = await loadFailedTokens();
  const skippedTokenIds = await loadSkippedTokens();
  const skippedDetails = [];

  let db;
  try {
    if (FULL_MODE) {
      await clearDatabase();
    }
    await createScriptBackup();
    db = await initDb();
    await migrateDb(db);

    const checkpoint = await loadCheckpoint();
    const contractData = await fetchContractData();
    Object.assign(result.summary, contractData);

    const endBlock = Number(await client.getBlockNumber());
    result.summary.burnedDistribution = await fetchAndStoreEvents(db, DEPLOYMENT_BLOCK, endBlock, skippedTokenIds, skippedDetails);
    await db.run('UPDATE element280_summary SET lastBlock = ? WHERE id = 1', endBlock);

    const wallets = new Map();
    let owners = [];

    // Fetch current owners using Alchemy
    if (CUSTOM_WALLETS.length === 0) {
      logger.info('Fetching owners with NFTs');
      try {
        const ownersResponse = await retry(() => alchemy.nft.getOwnersForContract(CONTRACT_ADDRESS));
        owners = ownersResponse.owners
          .filter(owner => owner.toLowerCase() !== ZERO_ADDRESS.toLowerCase())
          .map(owner => owner.toLowerCase());
        logger.info(`Found ${owners.length} owners`);
      } catch (error) {
        logger.error(`Failed to fetch owners: ${error.message}`);
      }
    } else {
      owners = CUSTOM_WALLETS;
      logger.info(`Processing custom wallets: ${CUSTOM_WALLETS.join(', ')}`);
    }

    // Initialize wallets from owners and transfers
    for (const owner of owners) {
      wallets.set(owner.toLowerCase(), {
        wallet: owner.toLowerCase(),
        totalLive: 0,
        totalBurned: 0,
        totalBought: 0,
        totalSold: 0,
        minted: 0,
        tiersLive: [0, 0, 0, 0, 0, 0],
        tiersBurned: [0, 0, 0, 0, 0, 0],
        tiersMinted: [0, 0, 0, 0, 0, 0],
        tiersTransferredIn: [0, 0, 0, 0, 0, 0],
        tiersTransferredOut: [0, 0, 0, 0, 0, 0],
        nfts: [],
        multiplierSum: 0,
        displayMultiplierSum: 0,
        claimableRewards: 0,
      });
    }

    // Add wallets from transfers
    const transferWallets = await db.all(`
      SELECT DISTINCT address
      FROM (
        SELECT lower(fromAddr) AS address FROM element280_transfers WHERE fromAddr != ?
        UNION
        SELECT lower(toAddr) AS address FROM element280_transfers WHERE toAddr != ?
      )`,
      [ZERO_ADDRESS.toLowerCase(), ZERO_ADDRESS.toLowerCase()]
    );
    for (const { address } of transferWallets) {
      if (!wallets.has(address.toLowerCase())) {
        wallets.set(address.toLowerCase(), {
          wallet: address.toLowerCase(),
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }
    }

    logger.info(`Collected ${wallets.size} unique wallets`);
    await fs.writeFile(COLLECTED_WALLETS_FILE, JSON.stringify([...wallets.keys()], null, 2));

    // Verify debug wallets
    DEBUG_WALLETS.forEach(wallet => {
      if (!wallets.has(wallet.toLowerCase())) {
        logger.warn(`Debug wallet ${wallet} not found in wallets Map`);
      } else {
        logger.info(`Debug wallet ${wallet} included in wallets Map`);
      }
    });

    // Process wallets
    const walletLimit = pLimit(MAX_CONCURRENT_WALLETS);
    const walletResults = [];
    let walletCount = 0;
    for (const walletAddr of wallets.keys()) {
      logger.debug(`Processing wallet ${walletAddr}`);
      const wallet = await walletLimit(() => processWallet(walletAddr, db, failedTokenIds, skippedTokenIds, skippedDetails));
      if (wallet) {
        walletResults.push(wallet);
        await retry(
          async () => {
            await executeDbTransaction(db, async () => {
              await db.run(
                `INSERT OR REPLACE INTO element280_wallets (
                  address, totalLive, totalBurned, totalBought, totalSold, minted,
                  tiersLive, tiersBurned, tiersMinted, tiersTransferredIn, tiersTransferredOut,
                  nfts, multiplierSum, displayMultiplierSum, claimableRewards
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                  wallet.wallet.toLowerCase(),
                  wallet.totalLive,
                  wallet.totalBurned,
                  wallet.totalBought,
                  wallet.totalSold,
                  wallet.minted,
                  JSON.stringify(wallet.tiersLive),
                  JSON.stringify(wallet.tiersBurned),
                  JSON.stringify(wallet.tiersMinted),
                  JSON.stringify(wallet.tiersTransferredIn),
                  JSON.stringify(wallet.tiersTransferredOut),
                  JSON.stringify(wallet.nfts),
                  wallet.multiplierSum,
                  wallet.displayMultiplierSum,
                  wallet.claimableRewards,
                ]
              );
            });
            logger.debug(`Inserted/updated wallet ${walletAddr}`);
          },
          3,
          1000
        );
        walletCount++;
        logger.info(`Processed ${walletCount}/${wallets.size} wallets: ${walletAddr}`);
      } else {
        logger.warn(`No wallet data returned for ${walletAddr}`);
        await fs.appendFile(
          SKIPPED_WALLETS_FILE,
          JSON.stringify({ wallet: walletAddr, timestamp: new Date().toISOString() }) + '\n'
        );
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Process transfers in memory for historical stats
    const logs = await db.all('SELECT * FROM element280_transfers ORDER BY blockNumber ASC');
    for (const log of logs) {
      const from = log.fromAddr.toLowerCase();
      const to = log.toAddr.toLowerCase();
      const tokenIdNum = log.tokenId;
      const tier = log.tier;
      const eventType = log.eventType;

      if (from !== ZERO_ADDRESS.toLowerCase() && !wallets.has(from)) {
        wallets.set(from, {
          wallet: from,
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }
      if (to !== ZERO_ADDRESS.toLowerCase() && !wallets.has(to)) {
        wallets.set(to, {
          wallet: to,
          totalLive: 0,
          totalBurned: 0,
          totalBought: 0,
          totalSold: 0,
          minted: 0,
          tiersLive: [0, 0, 0, 0, 0, 0],
          tiersBurned: [0, 0, 0, 0, 0, 0],
          tiersMinted: [0, 0, 0, 0, 0, 0],
          tiersTransferredIn: [0, 0, 0, 0, 0, 0],
          tiersTransferredOut: [0, 0, 0, 0, 0, 0],
          nfts: [],
          multiplierSum: 0,
          displayMultiplierSum: 0,
          claimableRewards: 0,
        });
      }

      if (eventType === 'mint' && tier >= 1 && tier <= 6) {
        const wallet = wallets.get(to);
        wallet.minted += 1;
        wallet.totalBought += 1;
        wallet.tiersMinted[tier - 1]++;
      } else if (eventType === 'burn' && tier >= 1 && tier <= 6) {
        const wallet = wallets.get(from);
        wallet.totalBurned += 1;
        wallet.totalSold += 1;
        wallet.tiersBurned[tier - 1]++;
        result.burnedNfts.push({
          tokenId: tokenIdNum,
          tier,
          tierName: config.contractTiers.element280[tier].name,
          burnerWallet: from,
          transactionHash: log.transactionHash,
          blockTimestamp: log.blockTimestamp,
          ownerAddr: log.ownerAddr,
        });
      } else if (eventType === 'transfer' && tier >= 1 && tier <= 6) {
        const fromWallet = wallets.get(from);
        const toWallet = wallets.get(to);
        fromWallet.totalSold += 1;
        toWallet.totalBought += 1;
        fromWallet.tiersTransferredOut[tier - 1]++;
        toWallet.tiersTransferredIn[tier - 1]++;
      }
    }

    // Finalize wallet data
    result.wallets = Array.from(wallets.values())
      .filter(w => w.totalLive > 0 || w.totalBurned > 0 || w.totalBought > 0 || w.totalSold > 0 || w.minted > 0)
      .map((w, index) => ({
        ...w,
        rank: index + 1,
        percentage: result.summary.multiplierPool > 0 ? (w.multiplierSum / result.summary.multiplierPool) * 100 : 0,
      }));
    result.summary.totalWallets = result.wallets.length;

    // Update summary
    await executeDbTransaction(db, async () => {
      await db.run(
        `INSERT OR REPLACE INTO element280_summary (
          id, totalMinted, totalBurned, totalLive, totalWallets,
          tierDistribution, burnedDistribution, multiplierPool, totalRewardPool, lastBlock
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          1,
          result.summary.totalMinted,
          result.summary.totalBurned,
          result.summary.totalLive,
          result.summary.totalWallets,
          JSON.stringify(result.summary.tierDistribution),
          JSON.stringify(result.summary.burnedDistribution),
          result.summary.multiplierPool,
          result.summary.totalRewardPool,
          endBlock,
        ]
      );
    });

    // Save failed and skipped tokens
    await saveFailedTokens(failedTokenIds);
    await saveSkippedTokens(skippedTokenIds, skippedDetails);

    // Save output
    await fs.writeFile(CACHE_FILE, JSON.stringify(result, null, 2));
    await saveCheckpoint(endBlock);

    logger.info(`Completed: Processed ${result.wallets.length} wallets, ${result.burnedNfts.length} burned NFTs`);
    logger.info(`Summary: totalMinted=${result.summary.totalMinted}, totalLive=${result.summary.totalLive}, totalBurned=${result.summary.totalBurned}, totalWallets=${result.summary.totalWallets}`);
  } catch (error) {
    logger.error(`Error: ${error.message}`);
    throw error;
  } finally {
    if (db) await db.close();
  }

  return result;
}

trackElement280NFTs().catch(error => {
  logger.error('Script failed:', error);
  process.exit(1);
});-e 
---
File: ./components/NFTSummary.js
// components/NFTSummary.js
'use client';
import { motion } from 'framer-motion';

const NFTSummary = ({ collectionsData }) => {
  return (
    <div className="w-full max-w-6xl mt-6 mb-4">
      <h2 className="text-lg font-semibold text-white mb-3 text-center">NFT Collections</h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
        {collectionsData.map(({ apiKey, data }) => {
          const isE280 = apiKey === 'e280';
          if (isE280) {
            return (
              <div
                key={apiKey}
                className="bg-gray-800 rounded-md p-3 text-gray-300"
              >
                <h3 className="text-sm font-semibold text-orange-500 mb-1">E280 (Base)</h3>
                <p className="text-xs">Not deployed yet</p>
              </div>
            );
          }

          const {
            holders = [],
            totalTokens = 0,
            summary = {},
            totalLockedAscendant = 0,
            toDistributeDay8 = 0,
            toDistributeDay28 = 0,
            toDistributeDay90 = 0,
            pendingRewards = 0,
            error,
          } = data;

          const uniqueWallets = holders.length;
          const liveNFTs = apiKey === 'element280' ? summary.totalLive || totalTokens : totalTokens;
          const burnedNFTs = summary.totalBurned || 0;
          const totalRewardPool = summary.totalRewardPool || 0;
          const infernoRewards = holders.reduce((sum, h) => sum + (h.infernoRewards || 0), 0);
          const fluxRewards = holders.reduce((sum, h) => sum + (h.fluxRewards || 0), 0);
          const e280Rewards = holders.reduce((sum, h) => sum + (h.e280Rewards || 0), 0);
          const claimableRewards = toDistributeDay8 + toDistributeDay28 + toDistributeDay90;

          const collectionName = {
            element280: 'Element 280',
            element369: 'Element 369',
            staxNFT: 'Stax',
            ascendantNFT: 'Ascendant',
          }[apiKey] || apiKey;

          if (error) {
            return (
              <div
                key={apiKey}
                className="bg-gray-800 rounded-md p-3 text-gray-300"
              >
                <h3 className="text-sm font-semibold text-orange-500 mb-1">{collectionName}</h3>
                <p className="text-xs">Error: {error}</p>
              </div>
            );
          }

          return (
            <motion.div
              key={apiKey}
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.2 }}
              className="bg-gray-800 rounded-md p-3 text-gray-300 hover:shadow-md transition-shadow"
            >
              <h3 className="text-sm font-semibold text-orange-500 mb-1">{collectionName}</h3>
              <div className="space-y-1 text-xs">
                <p>
                  <span className="font-medium">Wallets:</span> {uniqueWallets.toLocaleString()}
                </p>
                <p>
                  <span className="font-medium">Live NFTs:</span> {liveNFTs.toLocaleString()}
                </p>
                {['element280', 'staxNFT'].includes(apiKey) && (
                  <p>
                    <span className="font-medium">Burned:</span> {burnedNFTs.toLocaleString()}
                  </p>
                )}
                {apiKey === 'element280' && (
                  <p>
                    <span className="font-medium">Rewards:</span>{' '}
                    {totalRewardPool.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ELMNT
                  </p>
                )}
                {apiKey === 'element369' && (
                  <>
                    <p>
                      <span className="font-medium">Inferno:</span>{' '}
                      {infernoRewards.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ETH
                    </p>
                    <p>
                      <span className="font-medium">Flux:</span>{' '}
                      {fluxRewards.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ETH
                    </p>
                    <p>
                      <span className="font-medium">E280:</span>{' '}
                      {e280Rewards.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} ETH
                    </p>
                  </>
                )}
                {apiKey === 'staxNFT' && (
                  <p>
                    <span className="font-medium">Rewards:</span>{' '}
                    {holders.reduce((sum, h) => sum + (h.claimableRewards || 0), 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} X28
                  </p>
                )}
                {apiKey === 'ascendantNFT' && (
                  <>
                    <p>
                      <span className="font-medium">Locked:</span>{' '}
                      {totalLockedAscendant.toLocaleString()}
                    </p>
                    <p>
                      <span className="font-medium">Claimable:</span>{' '}
                      {claimableRewards.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} DRAGONX
                    </p>
                    <p>
                      <span className="font-medium">Pending:</span>{' '}
                      {pendingRewards.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} DRAGONX
                    </p>
                  </>
                )}
              </div>
            </motion.div>
          );
        })}
      </div>
    </div>
  );
};

export default NFTSummary;-e 
---
File: ./components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status, progress }) {
  const percentage = progress?.totalOwners > 0 ? (progress.totalWallets / progress.totalOwners) * 100 : 0;

  return (
    <div className="loading-container">
      <motion.svg
        className="spinner"
        animate={{ scale: [1, 1.2, 1], rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'easeInOut' }}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </motion.svg>
      <p className="text-body">{status}</p>
      {progress?.totalOwners > 0 && (
        <div className="progress-bar">
          <div className="progress-fill" style={{ width: `${percentage}%` }}></div>
        </div>
      )}
    </div>
  );
}-e 
---
File: ./components/NFTPage.js
'use client';

import { useState, useEffect, useCallback } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from './LoadingIndicator';
import config from '@/config.js';
import { Bar } from 'react-chartjs-2';
import Chart from 'chart.js/auto';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { useNFTStore } from '@/app/store';
import { barChartOptions } from '@/lib/chartOptions';

// Retry utility
async function retry(fn, attempts = config.alchemy.maxRetries, delay = (retryCount) => Math.min(config.alchemy.batchDelayMs * 2 ** retryCount, config.alchemy.retryMaxDelayMs)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      console.error(`[NFTPage] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = config.contractAddresses.element280.address;
  const vaultAddress = config.vaultAddresses.element280.address;
  console.log(`[NFTPage] [INFO] Fetching contract data for Element280: contract=${contractAddress}, vault=${vaultAddress}`);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }
  if (!config.alchemy.apiKey) {
    throw new Error('Alchemy API key not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`, { timeout: config.alchemy.timeoutMs }),
  });

  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'totalSupply' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: config.abis.element280.vault, functionName: 'totalRewardPool' },
        ],
      })
    );
    console.log(`[NFTPage] [DEBUG] multicall results: ${JSON.stringify(results, (k, v) => (typeof v === 'bigint' ? v.toString() : v), 2)}`);
    const [totalSupply, tierCounts, multiplierPool, totalRewardPool] = results;
    if (totalSupply.status === 'failure') {
      throw new Error(`totalSupply call failed: ${totalSupply.error}`);
    }
    if (tierCounts.status === 'failure' || !tierCounts.result) {
      console.warn(`[NFTPage] [WARN] getTotalNftsPerTiers failed or returned no data: ${tierCounts.error || 'empty result'}`);
    }
    if (multiplierPool.status === 'failure' || !multiplierPool.result) {
      console.warn(`[NFTPage] [WARN] multiplierPool failed or returned no data: ${multiplierPool.error || 'empty result'}`);
    }
    if (totalRewardPool.status === 'failure') {
      throw new Error(`totalRewardPool call failed: ${totalRewardPool.error}`);
    }

    let burnedDistribution = [0, 0, 0, 0, 0, 0];
    let totalBurned = 0;
    try {
      const res = await fetch('/api/holders/Element280/validate-burned', { cache: 'no-store' });
      if (res.ok) {
        const reader = res.body.getReader();
        let events = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line);
          for (const line of lines) {
            const data = JSON.parse(line);
            if (data.event) {
              const tier = data.event.tier;
              if (tier >= 1 && tier <= 6) {
                burnedDistribution[tier - 1]++;
              }
            }
            if (data.complete) {
              events = data.result.events;
              totalBurned = data.result.burnedCount;
            }
          }
        }
        console.log(`[NFTPage] [DEBUG] Burned distribution: ${burnedDistribution}, total events: ${events.length}, totalBurned: ${totalBurned}`);
      } else {
        console.error(`[NFTPage] [ERROR] Failed to fetch burned distribution: ${res.status}`);
      }
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Burned distribution fetch error: ${err.message}, stack: ${err.stack}`);
    }

    return {
      totalMinted: Number(totalSupply.result) + totalBurned,
      totalBurned,
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.status === 'success' && tierCounts.result ? tierCounts.result.map(Number) : [0, 0, 0, 0, 0, 0],
      multiplierPool: multiplierPool.status === 'success' && multiplierPool.result ? Number(multiplierPool.result) : 0,
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution,
    };
  } catch (error) {
    console.error(`[NFTPage] [ERROR] fetchContractData failed: ${error.message}, stack: ${error.stack}`);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  console.log(`[NFTPage] [INFO] Received props: chain=${chain}, contract=${contract}`);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [isInvalidContract, setIsInvalidContract] = useState(false);

  const { getCache, setCache } = useNFTStore();

  const contractId = contract ? contract.toLowerCase() : null;
  console.log(`[NFTPage] [INFO] Derived contractId: ${contractId}`);

  const contractConfig = config.contractDetails[contractId] || {};
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  const fetchData = useCallback(async () => {
    if (!apiEndpoint) {
      console.error(`[NFTPage] [ERROR] Invalid contract configuration for ${contractId}`);
      setError('Invalid contract configuration');
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      let progressData = { isPopulating: false, phase: 'Idle', progressPercentage: 0, totalOwners: 0 };
      if (isElement280) {
        try {
          console.log(`[NFTPage] [INFO] Fetching progress from ${apiEndpoint}/progress`);
          const res = await fetch(`${apiEndpoint}/progress`, { cache: 'no-store', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
          if (!res.ok) {
            console.error(`[NFTPage] [ERROR] Progress fetch failed: ${res.status}`);
          } else {
            progressData = await res.json();
            if (progressData.totalOwners === 0 && progressData.phase === 'Idle') {
              console.log(`[NFTPage] [INFO] Stale progress, triggering cache refresh`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'no-store' });
              const retryRes = await fetch(`${apiEndpoint}/progress`, { cache: 'no-store', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
              if (retryRes.ok) progressData = await retryRes.json();
            }
          }
        } catch (err) {
          console.error(`[NFTPage] [ERROR] Progress fetch error: ${err.message}, stack: ${err.stack}`);
        }
        setProgress(progressData);
      }

      const cacheKey = `contract_data_${contractId}`;
      const cachedData = getCache(cacheKey);
      if (cachedData && cachedData.totalMinted > 0) {
        console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      let contractData;
      if (isElement280) {
        contractData = await fetchContractData();
      } else {
        contractData = {
          totalMinted: 0,
          totalBurned: 0,
          totalLive: 0,
          tierDistribution: [0, 0, 0, 0, 0, 0],
          multiplierPool: 0,
          totalRewardPool: 0,
          burnedDistribution: [0, 0, 0, 0, 0, 0],
        };
        console.log(`[NFTPage] [INFO] Using placeholder data for non-Element280 contract: ${contractId}`);
      }

      setCache(cacheKey, contractData);
      setData(contractData);
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isElement280, getCache, setCache, name]);

  const fetchAllHolders = useCallback(async () => {
    const cacheKey = `holders_${contractId}`;
    const cachedData = getCache(cacheKey);
    if (cachedData) {
      console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}, holders: ${cachedData.holders.length}`);
      setData(prev => ({ ...prev, holders: cachedData.holders, summary: cachedData.summary }));
      setLoading(false);
      return;
    }
    console.log(`[NFTPage] [INFO] Cache miss for ${cacheKey}, fetching holders`);

    try {
      console.log(`[NFTPage] [INFO] Starting holders fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || config.contractDetails[contractId]?.pageSize;

      let progressData = await fetch(`${apiEndpoint}/progress`, { cache: 'no-store' }).then(res => res.json()).catch(() => ({}));
      if (progressData.phase === 'Idle' || progressData.totalOwners === 0) {
        console.log(`[NFTPage] [INFO] Cache is Idle or empty, triggering POST`);
        await fetch(apiEndpoint, { method: 'POST', cache: 'no-store' });
      }

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            console.log(`[NFTPage] [INFO] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[NFTPage] [ERROR] Fetch failed for ${url}: ${res.status} - ${errorText}`);
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            console.log(`[NFTPage] [DEBUG] API response for ${url}: ${JSON.stringify(json, null, 2)}`);
            if (json.error) {
              console.error(`[NFTPage] [ERROR] API error for ${url}: ${json.error}`);
              throw new Error(json.error);
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              console.error(`[NFTPage] [ERROR] Invalid holders data for ${url}: ${JSON.stringify(json, null, 2)}`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'no-store' });
              throw new Error(`Invalid holders data: retrying after POST`);
            }
            const newHolders = json.holders;
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            totalClaimableRewards = json.totalClaimableRewards || totalClaimableRewards;
            totalInfernoRewards = json.totalInfernoRewards || totalInfernoRewards;
            totalFluxRewards = json.totalFluxRewards || totalFluxRewards;
            totalE280Rewards = json.totalE280Rewards || totalE280Rewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            if (!newHolders.length && json.totalPages === 0) {
              console.log(`[NFTPage] [] Empty holders with zero pages, accepting as valid`);
              break;
            }
          } catch (err) {
            attempts++;
            console.error(`[NFTPage] [ERROR] Attempt ${attempts}/${maxAttempts} failed for page ${page}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page} after ${maxAttempts} attempts: ${err.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs * attempts));
          }
        }
      }

      const holdersData = {
        holders: allHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      console.log(`[NFTPage] [INFO] Fetched ${allHolders.length} holders for ${contractId}`);
      setCache(cacheKey, holdersData);
      setData(prev => ({ ...prev, ...holdersData }));
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Holders fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, getCache, setCache, name, pageSize]);

  useEffect(() => {
    if (!contractId || !config.contractDetails[contractId]) {
      console.error(`[NFTPage] [ERROR] Invalid or missing contract: chain=${chain}, contract=${contract}`);
      setIsInvalidContract(true);
      setLoading(false);
    } else if (disabled) {
      console.log(`[NFTPage] [INFO] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    } else {
      setIsInvalidContract(false);
      fetchData();
      fetchAllHolders();
    }
  }, [contractId, chain, contract, disabled, name, fetchData, fetchAllHolders]);

  const HolderTable = holderTableComponents[contractId] || null;

  const chartData = data && isElement280 ? {
    labels: ['Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Tier 5', 'Tier 6'],
    datasets: [
      {
        label: 'Live NFTs',
        data: data.tierDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(59, 130, 246, 0.6)', // Blue-500
        /* Orange theme: backgroundColor: 'rgba(249, 115, 22, 0.6)', // Orange-500 */
      },
      {
        label: 'Burned NFTs',
        data: data.burnedDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(239, 68, 68, 0.6)', // Red-500
      },
    ],
  } : null;

  if (isInvalidContract) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">Invalid Contract</h1>
        <p className="text-error text-lg">
          The contract "{contractId || 'none specified'}" is not supported.
        </p>
      </motion.div>
    );
  }

  if (!HolderTable) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-error text-lg">
          Error: Holder table component for {contractId} not found.
        </p>
      </motion.div>
    );
  }

  // Define props for each HolderTable component
  const holderTableProps = {
    e280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    ascendant: { holders: data?.holders || [], loading, totalShares: data?.totalShares || 0, totalTokens: data?.totalTokens || 0, rewardToken },
    element280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    element369: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    stax: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
  };

  return (
    <div className="container page-content">
      <motion.h1
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="title mb-6"
      >
        {name || 'Unknown Contract'} Holders
      </motion.h1>

      <AnimatePresence>
        {loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="card text-center-section"
          >
            <LoadingIndicator
              status={`Loading ${name} data... ${
                isElement280 ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''
              }`}
              progress={progress}
            />
          </motion.div>
        )}
      </AnimatePresence>

      {error && (
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
          className="text-error text-lg mb-6 text-center"
        >
          {error}
        </motion.p>
      )}

      {!loading && !error && data && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="space-y-section"
        >
          <div className="card">
            <h2 className="subtitle mb-4">Contract Summary</h2>
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Minted:</strong> {data.totalMinted?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Live:</strong> {data.totalLive?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Burned:</strong> {data.totalBurned?.toLocaleString() || 'N/A'}
                </p>
              </div>
              <div>
                <p>
                  <strong>Multiplier Pool:</strong>{' '}
                  {data.multiplierPool?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Reward Pool:</strong>{' '}
                  {data.totalRewardPool?.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  }) || 'N/A'}{' '}
                  {rewardToken}
                </p>
                <p>
                  <strong>Total Holders:</strong>{' '}
                  {progress.totalOwners?.toLocaleString() || 'N/A'}
                </p>
              </div>
            </div>
            {isElement280 && (
              <div className="mt-6">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowChart(!showChart)}
                  className="btn btn-primary"
                >
                  {showChart ? 'Hide Tier Distribution' : 'Show Tier Distribution'}
                </motion.button>
                <AnimatePresence>
                  {showChart && chartData && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      transition={{ duration: 0.3 }}
                      className="chart-container mt-6"
                    >
                      <Bar data={chartData} options={barChartOptions} />
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            )}
          </div>

          <div className="card">
            <h2 className="subtitle mb-4">Holders</h2>
            <HolderTable {...holderTableProps[contractId]} />
          </div>
        </motion.div>
      )}
    </div>
  );
}-e 
---
File: ./components/SearchResultsModal.js
// components/SearchResultsModal.js
'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import config from '@/config.js';

// Loading components
const Element280Loading = () => <div className="text-gray-400">Loading Element280 holder table...</div>;
Element280Loading.displayName = 'Element280Loading';

const Element369Loading = () => <div className="text-gray-400">Loading Element369 holder table...</div>;
Element369Loading.displayName = 'Element369Loading';

const StaxNFTLoading = () => <div className="text-gray-400">Loading Stax holder table...</div>;
StaxNFTLoading.displayName = 'StaxNFTLoading';

const AscendantNFTLoading = () => <div className="text-gray-400">Loading Ascendant holder table...</div>;
AscendantNFTLoading.displayName = 'AscendantNFTLoading';

const E280Loading = () => <div className="text-gray-400">Loading E280 holder table...</div>;
E280Loading.displayName = 'E280Loading';

// Fallback components
const Element280Fallback = () => <div>Error loading holder table for Element280</div>;
Element280Fallback.displayName = 'Element280ErrorFallback';

const Element369Fallback = () => <div>Error loading holder table for Element369</div>;
Element369Fallback.displayName = 'Element369ErrorFallback';

const StaxNFTFallback = () => <div>Error loading holder table for Stax</div>;
StaxNFTFallback.displayName = 'StaxNFTErrorFallback';

const AscendantNFTFallback = () => <div>Error loading holder table for Ascendant</div>;
AscendantNFTFallback.displayName = 'AscendantNFTErrorFallback';

const E280Fallback = () => <div>Error loading holder table for E280</div>;
E280Fallback.displayName = 'E280ErrorFallback';

// Define holder table components for each contract
const holderTableComponents = {
  element280: dynamic(
    () =>
      import('./HolderTable/Element280').catch(err => {
        console.error('Failed to load Element280 HolderTable:', err);
        return { default: Element280Fallback };
      }),
    {
      ssr: false,
      loading: Element280Loading,
    }
  ),
  element369: dynamic(
    () =>
      import('./HolderTable/Element369').catch(err => {
        console.error('Failed to load Element369 HolderTable:', err);
        return { default: Element369Fallback };
      }),
    {
      ssr: false,
      loading: Element369Loading,
    }
  ),
  staxNFT: dynamic(
    () =>
      import('./HolderTable/Stax').catch(err => {
        console.error('Failed to load Stax HolderTable:', err);
        return { default: StaxNFTFallback };
      }),
    {
      ssr: false,
      loading: StaxNFTLoading,
    }
  ),
  ascendantNFT: dynamic(
    () =>
      import('./HolderTable/Ascendant').catch(err => {
        console.error('Failed to load Ascendant HolderTable:', err);
        return { default: AscendantNFTFallback };
      }),
    {
      ssr: false,
      loading: AscendantNFTLoading,
    }
  ),
  e280: dynamic(
    () =>
      import('./HolderTable/E280').catch(err => {
        console.error('Failed to load E280 HolderTable:', err);
        return { default: E280Fallback };
      }),
    {
      ssr: false,
      loading: E280Loading,
    }
  ),
};

// Assign displayName to each dynamically imported component
Object.keys(holderTableComponents).forEach(key => {
  const Component = holderTableComponents[key];
  Component.displayName = `${key}HolderTable`;
});

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"
      onClick={handleBackgroundClick}
    >
      <motion.div
        className="bg-gray-800 text-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={e => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Search Results for {searchAddress}</h2>
          <button onClick={closeModal} className="text-gray-400 hover:text-white text-2xl">
            ×
          </button>
        </div>

        {Object.keys(searchResult).length === 0 ? (
          <p className="text-gray-400">No results available.</p>
        ) : (
          Object.entries(searchResult).map(([contract, data]) => {
            const HolderTable = holderTableComponents[contract] || (() => <div>Holder table not found for {contract}</div>);
            return (
              <div key={contract} className="mb-6">
                <h3 className="text-xl font-semibold mb-2">{config.contractDetails[contract]?.name || contract}</h3>
                {data === null ? (
                  <p className="text-gray-400">Wallet not found in this collection.</p>
                ) : data.error ? (
                  <p className="text-red-500">Error: {data.error}</p>
                ) : data.message ? (
                  <p className="text-gray-400">{data.message}</p>
                ) : (
                  <HolderTable
                    holders={[data]}
                    contract={contract}
                    loading={false}
                    totalShares={data.totalShares}
                  />
                )}
              </div>
            );
          })
        )}
      </motion.div>
    </div>
  );
}-e 
---
File: ./components/Navbar.jsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { useThemeStore } from '@/app/store';
import { SunIcon, MoonIcon } from '@heroicons/react/24/solid';

function Navbar() {
  const [isOpen, setIsOpen] = useState(false);
  const [isNFTDropdownOpen, setIsNFTDropdownOpen] = useState(false);
  const { isDarkMode, toggleTheme } = useThemeStore();

  const menuVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: { duration: 0.3, ease: 'easeOut', staggerChildren: 0.1 },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: -10, scale: 0.95 },
    visible: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.2 } },
  };

  const dropdownVariants = {
    hidden: { opacity: 0, height: 0, transition: { duration: 0.2 } },
    visible: { opacity: 1, height: 'auto', transition: { duration: 0.2 } },
  };

  const navItems = [
    { name: 'Home', href: '/' },
    { name: 'Auctions', href: '/auctions' },
    { name: 'Mining', href: '/mining' },
    {
      name: 'NFT',
      href: '/nft',
      subItems: [
        {
          name: 'ETH',
          subItems: [
            { name: 'Element280', href: '/nft/ETH/Element280' },
            { name: 'Element369', href: '/nft/ETH/Element369' },
            { name: 'Stax', href: '/nft/ETH/Stax' },
            { name: 'Ascendant', href: '/nft/ETH/Ascendant' },
          ],
        },
        {
          name: 'BASE',
          subItems: [{ name: 'E280', href: '/nft/BASE/E280' }],
        },
      ],
    },
    { name: 'About', href: '/about' },
  ];

  return (
    <nav className="nav">
      <div className="nav-container">
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
          className="nav-logo"
        >
          <Link href="/" className="nav-link">
            TitanXUtils
          </Link>
        </motion.div>

        <div className="hidden md:flex space-x-6 items-center">
          {navItems.map((item) => (
            <motion.div
              key={item.name}
              className="relative group"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Link href={item.href} className="nav-link">
                {item.name}
              </Link>
              {item.subItems && (
                <motion.div
                  className="nav-dropdown opacity-0 group-hover:opacity-100 group-hover:mt-3 transition-all duration-200 pointer-events-none group-hover:pointer-events-auto"
                  variants={dropdownVariants}
                  initial="hidden"
                  animate="hidden"
                  whileHover="visible"
                >
                  {item.subItems.map((subItem) => (
                    <div key={subItem.name} className="py-1">
                      <div className="nav-dropdown-item font-semibold">{subItem.name}</div>
                      {subItem.subItems && (
                        <div className="pl-4">
                          {subItem.subItems.map((nestedItem) => (
                            <Link
                              key={nestedItem.name}
                              href={nestedItem.href}
                              className="nav-dropdown-item"
                            >
                              {nestedItem.name}
                            </Link>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </motion.div>
              )}
            </motion.div>
          ))}
          <motion.button
            onClick={toggleTheme}
            className="nav-toggle"
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            aria-label="Toggle theme"
          >
            {isDarkMode ? <SunIcon className="h-5 w-5" /> : <MoonIcon className="h-5 w-5" />}
          </motion.button>
        </div>

        <button
          className="md:hidden p-2 focus:outline-none text-gray-300 hover:text-white"
          onClick={() => setIsOpen(!isOpen)}
        >
          <motion.svg
            className="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            animate={{ rotate: isOpen ? 90 : 0 }}
            transition={{ duration: 0.3 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d={isOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
            />
          </motion.svg>
        </button>
      </div>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            variants={menuVariants}
            initial="hidden"
            animate="visible"
            exit="hidden"
            className="md:hidden mt-4 space-y-2 px-4"
          >
            {navItems.map((item) => (
              <motion.div
                key={item.name}
                variants={itemVariants}
                className="nav-dropdown-item"
              >
                {item.subItems ? (
                  <>
                    <div
                      className="flex justify-between items-center cursor-pointer"
                      onClick={() =>
                        item.name === 'NFT' &&
                        setIsNFTDropdownOpen(!isNFTDropdownOpen)
                      }
                    >
                      <span>{item.name}</span>
                      {item.name === 'NFT' && (
                        <motion.svg
                          className="w-4 h-4"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24"
                          animate={{ rotate: isNFTDropdownOpen ? 180 : 0 }}
                          transition={{ duration: 0.2 }}
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            d="M19 9l-7 7-7-7"
                          />
                        </motion.svg>
                      )}
                    </div>
                    {item.name === 'NFT' && isNFTDropdownOpen && (
                      <motion.div
                        variants={dropdownVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                        className="pl-4 space-y-2"
                      >
                        {item.subItems.map((subItem) => (
                          <div key={subItem.name}>
                            <div className="py-2 text-gray-300 font-semibold">
                              {subItem.name}
                            </div>
                            {subItem.subItems && (
                              <div className="pl-4 space-y-2">
                                {subItem.subItems.map((nestedItem) => (
                                  <Link
                                    key={nestedItem.name}
                                    href={nestedItem.href}
                                    className="nav-dropdown-item"
                                    onClick={() => setIsOpen(false)}
                                  >
                                    {nestedItem.name}
                                  </Link>
                                ))}
                              </div>
                            )}
                          </div>
                        ))}
                      </motion.div>
                    )}
                  </>
                ) : (
                  <Link
                    href={item.href}
                    className="block"
                    onClick={() => setIsOpen(false)}
                  >
                    {item.name}
                  </Link>
                )}
              </motion.div>
            ))}
            <motion.button
              onClick={toggleTheme}
              className="w-full text-left nav-dropdown-item"
              variants={itemVariants}
            >
              {isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
            </motion.button>
          </motion.div>
        )}
      </AnimatePresence>
    </nav>
  );
}

export default Navbar;-e 
---
File: ./components/HolderTable/E280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const e280TierOrder = [
    { tierId: '1', name: 'Common' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '6', name: 'Legendary Amped' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {e280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {e280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.e280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for E280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {e280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {e280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Ascendant.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Ascendant] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) ||
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) ||
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) ||
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 8) {
        console.warn('[Ascendant] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 8');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
          <p><strong>Total Shares:</strong> {totalShares?.toLocaleString() || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="table-cell">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Stax.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const staxTierOrder = [
    { tierId: '12', name: 'Legendary LFG', index: 11 },
    { tierId: '11', name: 'Legendary Super', index: 10 },
    { tierId: '10', name: 'Legendary Amped', index: 9 },
    { tierId: '9', name: 'Legendary', index: 8 },
    { tierId: '8', name: 'Rare LFG', index: 7 },
    { tierId: '7', name: 'Rare Super', index: 6 },
    { tierId: '6', name: 'Rare Amped', index: 5 },
    { tierId: '5', name: 'Rare', index: 4 },
    { tierId: '4', name: 'Common LFG', index: 3 },
    { tierId: '3', name: 'Common Super', index: 2 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0x15702443110894B26911B913b17ea4931F803B02';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Stax] Holder Data for Wallet:', targetHolder);
      console.log('[Stax] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Stax] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = staxTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && Number(targetHolder.tiers[Number(tier.tierId) - 1]) || 0);
        return { tier: tier.name, count };
      });
      console.log('[Stax] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Stax] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      const multipliers = {
        '12': 200, '11': 140, '10': 120, '9': 100, '8': 20, '7': 14, '6': 12, '5': 10,
        '4': 2, '3': 1.4, '2': 1.2, '1': 1
      };
      const expectedMultiplierSum = tierCounts.reduce((sum, { count }, idx) => {
        const tierId = staxTierOrder[idx].tierId;
        return sum + count * multipliers[tierId];
      }, 0);
      console.log('[Stax] Multiplier Sum:', {
        actual: targetHolder.multiplierSum,
        expected: expectedMultiplierSum
      });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 12) {
        console.warn('[Stax] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 12');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Stax] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
      if (targetHolder.multiplierSum !== expectedMultiplierSum) {
        console.warn('[Stax] Warning: Multiplier sum mismatch for wallet', targetWallet, {
          actual: targetHolder.multiplierSum,
          expected: expectedMultiplierSum
        });
      }
    } else {
      console.warn('[Stax] Warning: Wallet not found in holders:', targetWallet);
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {staxTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {staxTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.stax;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Stax.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {staxTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.multiplierSum === 'number' ? holder.multiplierSum.toFixed(2) : '-'}
              </td>
              {staxTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? Number(holder.tiers[Number(tier.tierId) - 1]) || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element369.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

const element369TierOrder = config.contractTiers.element369.tierOrder || [
  { tierId: '3', name: 'Legendary' },
  { tierId: '2', name: 'Rare' },
  { tierId: '1', name: 'Common' },
];

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">E280 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element369TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element369TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element369;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element369.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Flux Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">E280 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element369TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="reward-cell">
                {(holder.infernoRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.fluxRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.e280Rewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {(holder.percentage || 0).toFixed(2)}%
              </td>
              <td className="table-cell">
                {(holder.multiplierSum || 0).toFixed(2)}
              </td>
              {element369TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? holder.tiers[Number(tier.tierId) - 1] || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./components/HolderTable/Element280.js
'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const element280TierOrder = [
    { tierId: '6', name: 'Legendary Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '1', name: 'Common' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {element280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);-e 
---
File: ./USDxFunctions.js
// usdxFunctions.js
// Extracted functions from the USDx contract ABI for later use

const usdxFunctions = [
    {
      name: 'DOMAIN_SEPARATOR',
      inputs: [],
      outputs: [{ type: 'bytes32', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'allowance',
      inputs: [
        { type: 'address', name: 'owner' },
        { type: 'address', name: 'spender' },
      ],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'approve',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'backstopPoolAddress',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'balanceOf',
      inputs: [{ type: 'address', name: 'account' }],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'burn',
      inputs: [
        { type: 'address', name: '_account' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'collateralController',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'decimals',
      inputs: [],
      outputs: [{ type: 'uint8', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'decreaseAllowance',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'subtractedValue' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'eip712Domain',
      inputs: [],
      outputs: [
        { type: 'bytes1', name: 'fields' },
        { type: 'string', name: 'name' },
        { type: 'string', name: 'version' },
        { type: 'uint256', name: 'chainId' },
        { type: 'address', name: 'verifyingContract' },
        { type: 'bytes32', name: 'salt' },
        { type: 'uint256[]', name: 'extensions' },
      ],
      stateMutability: 'view',
    },
    {
      name: 'increaseAllowance',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'addedValue' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'mint',
      inputs: [
        { type: 'address', name: '_account' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'name',
      inputs: [],
      outputs: [{ type: 'string', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'nonces',
      inputs: [{ type: 'address', name: 'owner' }],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'permit',
      inputs: [
        { type: 'address', name: 'owner' },
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'value' },
        { type: 'uint256', name: 'deadline' },
        { type: 'uint8', name: 'v' },
        { type: 'bytes32', name: 'r' },
        { type: 'bytes32', name: 's' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'positionControllerAddress',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'returnFromPool',
      inputs: [
        { type: 'address', name: '_poolAddress' },
        { type: 'address', name: '_receiver' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'sendToPool',
      inputs: [
        { type: 'address', name: '_sender' },
        { type: 'address', name: '_poolAddress' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'symbol',
      inputs: [],
      outputs: [{ type: 'string', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'totalSupply',
      inputs: [],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'transfer',
      inputs: [
        { type: 'address', name: 'recipient' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'transferForRedemptionEscrow',
      inputs: [
        { type: 'address', name: '_sender' },
        { type: 'address', name: '_positionManager' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'transferFrom',
      inputs: [
        { type: 'address', name: 'sender' },
        { type: 'address', name: 'recipient' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
  ];
  
  export default usdxFunctions;-e 
---
File: ./.gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build
/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log

# env files (can opt-in for committing if needed)
.env*
.env

# vercel
.vercel

# typescript (optional if no TS)
*.tsbuildinfo
next-env.d.ts*.sqlite
*.db
output.txt
scripts/backups/
.env*.local

cache_*.json
burned_events_*.json-e 
---
File: ./lib/chartOptions.js
export const barChartOptions = {
    responsive: true,
    plugins: {
      legend: { position: 'top', labels: { color: '#e5e7eb' } }, // Gray-200
      title: {
        display: true,
        text: 'NFT Tier Distribution',
        color: '#e5e7eb',
        font: { size: 16, weight: 'bold' },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: 'Number of NFTs', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' }, // Gray-300
      },
      x: {
        title: { display: true, text: 'Tiers', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' },
      },
    },
  };-e 
---
File: ./.env.development.local
# Created by Vercel CLI
KV_REST_API_READ_ONLY_TOKEN="AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg"
KV_REST_API_TOKEN="AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA"
KV_REST_API_URL="https://splendid-sunbird-26504.upstash.io"
KV_URL="rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379"
NEXT_PUBLIC_ALCHEMY_API_KEY="rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI"
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID="1dd2a69d54ac94fdefad918243183710"
REDIS_URL="rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379"
UPSTASH_REDIS_REST_TOKEN="AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA"
UPSTASH_REDIS_REST_URL="https://splendid-sunbird-26504.upstash.io"
-e 
---
File: ./postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};-e 
---
File: ./eslint.config.mjs
// eslint.config.mjs
import eslint from '@eslint/js';
import nextPlugin from 'eslint-config-next';

export default [
  eslint.configs.recommended,
  {
    files: ['**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx'],
    plugins: {
      next: nextPlugin,
    },
    rules: {
      ...nextPlugin.rules,
      'react/display-name': 'off',
      'no-unused-vars': 'warn',
      'react/prop-types': 'off',
    },
  },
];-e 
---
File: ./ORXFunctions.js
// tokenFunctions.js
// Extracted functions from the token contract ABI for later use

const tokenFunctions = [
    {
      name: 'BASE_SUPPLY',
      inputs: [],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'DOMAIN_SEPARATOR',
      inputs: [],
      outputs: [{ type: 'bytes32', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'SUPPLY_CAP',
      inputs: [],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'allowance',
      inputs: [
        { type: 'address', name: 'owner' },
        { type: 'address', name: 'spender' },
      ],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'approve',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'attachMinter',
      inputs: [{ type: 'address', name: '_minterAddress' }],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'balanceOf',
      inputs: [{ type: 'address', name: 'account' }],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'burn',
      inputs: [{ type: 'uint256', name: 'amount' }],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'decimals',
      inputs: [],
      outputs: [{ type: 'uint8', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'decreaseAllowance',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'subtractedValue' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'eip712Domain',
      inputs: [],
      outputs: [
        { type: 'bytes1', name: 'fields' },
        { type: 'string', name: 'name' },
        { type: 'string', name: 'version' },
        { type: 'uint256', name: 'chainId' },
        { type: 'address', name: 'verifyingContract' },
        { type: 'bytes32', name: 'salt' },
        { type: 'uint256[]', name: 'extensions' },
      ],
      stateMutability: 'view',
    },
    {
      name: 'increaseAllowance',
      inputs: [
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'addedValue' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'mint',
      inputs: [
        { type: 'address', name: 'account' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'minterAddress',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'minterSupply',
      inputs: [],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'pure',
    },
    {
      name: 'name',
      inputs: [],
      outputs: [{ type: 'string', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'nonces',
      inputs: [{ type: 'address', name: 'owner' }],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'orxStakingAddress',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'owner',
      inputs: [],
      outputs: [{ type: 'address', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'permit',
      inputs: [
        { type: 'address', name: 'owner' },
        { type: 'address', name: 'spender' },
        { type: 'uint256', name: 'value' },
        { type: 'uint256', name: 'deadline' },
        { type: 'uint8', name: 'v' },
        { type: 'bytes32', name: 'r' },
        { type: 'bytes32', name: 's' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'renounceOwnership',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'sendToFeeStaking',
      inputs: [
        { type: 'address', name: '_sender' },
        { type: 'uint256', name: '_amount' },
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
    {
      name: 'symbol',
      inputs: [],
      outputs: [{ type: 'string', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'totalSupply',
      inputs: [],
      outputs: [{ type: 'uint256', name: '' }],
      stateMutability: 'view',
    },
    {
      name: 'transfer',
      inputs: [
        { type: 'address', name: 'recipient' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'transferFrom',
      inputs: [
        { type: 'address', name: 'sender' },
        { type: 'address', name: 'recipient' },
        { type: 'uint256', name: 'amount' },
      ],
      outputs: [{ type: 'bool', name: '' }],
      stateMutability: 'nonpayable',
    },
    {
      name: 'transferOwnership',
      inputs: [{ type: 'address', name: 'newOwner' }],
      outputs: [],
      stateMutability: 'nonpayable',
    },
  ];
  
  export default tokenFunctions;