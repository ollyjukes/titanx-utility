================= Includes the following files under ./app =================
./app/about/page.js
./app/api/holders/Element280/validate-burned/route.js
./app/api/holders/[contract]/progress/route.js
./app/api/holders/[contract]/route.js
./app/api/utils.js
./app/auctions/page.js
./app/layout.js
./app/lib/chartOptions.js
./app/lib/fetchCollectionData.js
./app/lib/logger.js
./app/lib/schemas.js
./app/lib/serverInit.js
./app/lib/useNFTData.js
./app/mining/page.js
./app/nft/[chain]/[contract]/page.js
./app/nft/layout.js
./app/nft/page.js
./app/page.js
./app/store.js
./client/components/HolderTable/Ascendant.js
./client/components/HolderTable/E280.js
./client/components/HolderTable/Element280.js
./client/components/HolderTable/Element369.js
./client/components/HolderTable/Stax.js
./client/components/HolderTable/index.js
./client/components/LoadingIndicator.js
./client/components/NFTLayout.js
./client/components/NFTLayoutWrapper.js
./client/components/NFTPage.js
./client/components/NFTPageWrapper.js
./client/components/NFTSummary.js
./client/components/SearchResultsModal.js


================= Contents of above files =================


----- ./app/about/page.js -----

// app/about/page.js
export default function AboutPage() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-6">
      <div className="max-w-2xl text-center">
        <h1 className="text-4xl font-bold mb-6 text-orange-500">About TitanXUtils</h1>
        <p className="text-lg text-gray-300 leading-relaxed">
        TitanXUtils is a platform co-developed by{' '}
          <span className="font-semibold text-blue-400">@JukesTheGreat</span> and{' '}
          <span className="font-semibold text-blue-400">@KetoNatural1970</span>. Designed to empower
          users with quick access to the TitanX Mining, auction and minting protocols. Included is insightful NFT yield bearing stats data, this tool reflects a commitment to precision, innovation,
          and community-driven development.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          Its purpose is to serve as a centralized hub for accessing critical TitanX information,
          streamlining the experience for both existing and new users. With numerous protocols to
          navigate, NFTUtils simplifies the process by providing immediate, essential updates in
          one convenient location.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          This is a continuos development project, and we are always looking for ways to improve the user experience. If you have any suggestions or feedback, please feel free to reach out to us on Twitter.
        </p>
        <p className="text-lg text-gray-300 leading-relaxed mt-4">
          May add sections on our lending and farms protocols.  to be continued...
        </p>
      </div>
    </div>
  );
}
----- ./app/api/holders/Element280/validate-burned/route.js -----

// app/api/holders/Element280/validate-burned/route.js
import { NextResponse } from 'next/server';
import config from '@/contracts/config';
import { getTransactionReceipt, log, client, getCache, setCache } from '@/app/api/utils.js';
import { parseAbiItem } from 'viem';

export async function POST(request) {
  if (process.env.DEBUG === 'true') {
    log(`[Element280-Validate-Burned] [DEBUG] Processing POST request for validate-burned`);
  }

  try {
    const { transactionHash } = await request.json();
    if (!transactionHash || typeof transactionHash !== 'string' || !transactionHash.match(/^0x[a-fA-F0-9]{64}$/)) {
      log(`[Element280-Validate-Burned] [VALIDATION] Invalid transaction hash: ${transactionHash || 'undefined'}`);
      return NextResponse.json({ error: 'Invalid transaction hash' }, { status: 400 });
    }

    const contractAddress = config.contractAddresses?.element280?.address;
    if (!contractAddress) {
      log(`[Element280-Validate-Burned] [VALIDATION] Element280 contract address not configured in config.js`);
      return NextResponse.json({ error: 'Contract address not configured' }, { status: 500 });
    }

    const cacheKey = `element280_burn_validation_${transactionHash}`;
    const cachedResult = await getCache(cacheKey, 'element280');
    if (cachedResult) {
      if (process.env.DEBUG === 'true') {
        log(`[Element280-Validate-Burned] [DEBUG] Cache hit for burn validation: ${transactionHash}`);
      }
      return NextResponse.json(cachedResult);
    }

    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Fetching transaction receipt for hash: ${transactionHash}`);
    }
    const receipt = await getTransactionReceipt(transactionHash);
    if (!receipt) {
      log(`[Element280-Validate-Burned] [VALIDATION] Transaction receipt not found for hash: ${transactionHash}`);
      return NextResponse.json({ error: 'Transaction not found' }, { status: 404 });
    }

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const transferEvent = parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)');
    const burnedTokenIds = [];

    for (const logEntry of receipt.logs) {
      if (
        logEntry.address.toLowerCase() === contractAddress.toLowerCase() &&
        logEntry.topics[0] === transferEvent.topics[0]
      ) {
        try {
          const decodedLog = client.decodeEventLog({
            abi: [transferEvent],
            data: logEntry.data,
            topics: logEntry.topics,
          });
          if (decodedLog.args.to.toLowerCase() === burnAddress) {
            burnedTokenIds.push(decodedLog.args.tokenId.toString());
          }
        } catch (_decodeError) {
          log(`[Element280-Validate-Burned] [ERROR] Failed to decode log entry for transaction ${transactionHash}: ${_decodeError.message}`);
        }
      }
    }

    if (burnedTokenIds.length === 0) {
      log(`[Element280-Validate-Burned] [VALIDATION] No burn events found in transaction: ${transactionHash}`);
      return NextResponse.json({ error: 'No burn events found in transaction' }, { status: 400 });
    }

    const result = {
      transactionHash,
      burnedTokenIds,
      blockNumber: receipt.blockNumber.toString(),
    };

    await setCache(cacheKey, result, config.cache.nodeCache.stdTTL, 'element280');
    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Found ${burnedTokenIds.length} burned tokens in transaction: ${transactionHash}`);
    }
    return NextResponse.json(result);
  } catch (error) {
    log(`[Element280-Validate-Burned] [ERROR] Error processing transaction: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: 'Failed to validate transaction', details: error.message }, { status: 500 });
  }
}
----- ./app/api/holders/[contract]/progress/route.js -----

import { NextResponse } from 'next/server';
import { logger, loadCacheState } from '@/app/api/utils';
import config from '@/contracts/config';

async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
    globalMetrics: {}, // Added
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.progressState = {
        step: savedState.progressState?.step ?? 'idle',
        processedNfts: savedState.progressState?.processedNfts ?? 0,
        totalNfts: savedState.progressState?.totalNfts ?? 0,
        processedTiers: savedState.progressState?.processedTiers ?? 0,
        totalTiers: savedState.progressState?.totalTiers ?? 0,
        error: savedState.progressState?.error ?? null,
        errorLog: savedState.progressState?.errorLog ?? [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
      cacheState.globalMetrics = savedState.globalMetrics ?? {};
    }
  } catch (error) {
    logger.error(contractKey, `Failed to load cache state: ${error.message}`, { stack: error.stack });
    cacheState.progressState.error = `Failed to load cache state: ${error.message}`;
    cacheState.progressState.errorLog.push({
      timestamp: new Date().toISOString(),
      phase: 'load_cache_state',
      error: error.message,
    });
  }
  return cacheState;
}

export async function GET(_request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();

  if (!config.contractDetails[contractKey]) {
    logger.error(contractKey, `Invalid contract: ${contractKey}`);
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  try {
    const state = await getCacheState(contractKey);
    console.log(`Progress state for ${contractKey}:`, JSON.stringify(state, null, 2)); // Debug log
    if (!state || !state.progressState) {
      logger.error(contractKey, 'Invalid cache state');
      return NextResponse.json({ error: 'Cache state not initialized' }, { status: 500 });
    }

    let progressPercentage = '0.0';
    if (state.progressState.error) {
      progressPercentage = '0.0';
    } else if (state.progressState.step === 'completed') {
      progressPercentage = '100.0';
    } else if (state.progressState.totalNfts > 0) {
      if (state.progressState.step === 'fetching_owners') {
        const ownerProgress = (state.progressState.processedNfts / state.progressState.totalNfts) * 50;
        progressPercentage = Math.min(ownerProgress, 50).toFixed(1);
      } else if (state.progressState.step === 'fetching_tiers') {
        const tierProgress = (state.progressState.processedTiers / state.progressState.totalTiers) * 50;
        progressPercentage = Math.min(50 + tierProgress, 100).toFixed(1);
      }
    }

    return NextResponse.json({
      isPopulating: state.isPopulating,
      totalLiveHolders: state.totalOwners,
      totalOwners: state.totalOwners,
      phase: state.progressState.step.charAt(0).toUpperCase() + state.progressState.step.slice(1),
      progressPercentage,
      lastProcessedBlock: state.lastProcessedBlock,
      error: state.progressState.error || null,
      errorLog: (state.progressState.errorLog || []).slice(-50), // Limit to last 50 errors
      globalMetrics: state.globalMetrics, // Added
    });
  } catch (error) {
    logger.error(contractKey, `Progress endpoint error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to fetch ${contractKey} cache state`, details: error.message }, { status: 500 });
  }
}
----- ./app/api/holders/[contract]/route.js -----

// ./app/api/holders/[contract]/route.js
import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits, getAddress } from 'viem';
import pLimit from 'p-limit';
import config from '@/contracts/config.js';
import { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract, validateContract } from '@/app/api/utils';
import { HoldersResponseSchema } from '@/app/lib/schemas';

const limit = pLimit(5);

// Utility to sanitize BigInt values
function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') return obj.toString();
  if (Array.isArray(obj)) return obj.map(item => sanitizeBigInt(item));
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}

// Get cache state for a contract
async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    totalLiveHolders: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
    globalMetrics: {},
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      Object.assign(cacheState, {
        isPopulating: savedState.isPopulating ?? false,
        totalOwners: savedState.totalOwners ?? 0,
        totalLiveHolders: savedState.totalLiveHolders ?? 0,
        progressState: {
          step: savedState.progressState?.step ?? 'idle',
          processedNfts: savedState.progressState?.processedNfts ?? 0,
          totalNfts: savedState.progressState?.totalNfts ?? 0,
          processedTiers: savedState.progressState?.processedTiers ?? 0,
          totalTiers: savedState.progressState?.totalTiers ?? 0,
          error: savedState.progressState?.error ?? null,
          errorLog: savedState.progressState?.errorLog ?? [],
        },
        lastUpdated: savedState.lastUpdated ?? null,
        lastProcessedBlock: savedState.lastProcessedBlock ?? null,
        globalMetrics: savedState.globalMetrics ?? {},
      });
      if (!config.debug.suppressDebug) {
        logger.debug('utils', `Loaded cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`, 'eth', contractKey);
      }
    }
  } catch (error) {
    logger.error('utils', `Failed to load cache state: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
  }
  return cacheState;
}

// Save cache state for a contract
async function saveCacheStateContract(contractKey, cacheState) {
  try {
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Saved cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`, 'eth', contractKey);
    }
  } catch (error) {
    logger.error('utils', `Failed to save cache state: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
  }
}

// Fetch new Transfer events (burns and transfers)
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) {
  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const cacheKey = `${contractKey.toLowerCase()}_events_${contractAddress}_${fromBlock}`;
  let cachedEvents = await getCache(cacheKey, contractKey.toLowerCase());

  if (cachedEvents) {
    logger.info('utils', `Events cache hit: ${cacheKey}, count: ${cachedEvents.burnedTokenIds.length + (cachedEvents.transferTokenIds?.length || 0)}`, 'eth', contractKey);
    return cachedEvents;
  }

  let burnedTokenIds = [];
  let transferTokenIds = [];
  let endBlock;
  try {
    endBlock = await client.getBlockNumber();
  } catch (error) {
    logger.error('utils', `Failed to fetch block number: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (fromBlock >= endBlock) {
    logger.info('utils', `No new blocks: fromBlock ${fromBlock} >= endBlock ${endBlock}`, 'eth', contractKey);
    return { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock) };
  }

  try {
    const logs = await client.getLogs({
      address: contractAddress,
      event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
      fromBlock: BigInt(fromBlock),
      toBlock: endBlock,
    });
    burnedTokenIds = logs
      .filter(log => log.args.to.toLowerCase() === burnAddress.toLowerCase())
      .map(log => Number(log.args.tokenId));
    transferTokenIds = logs
      .filter(log => log.args.to.toLowerCase() !== burnAddress.toLowerCase())
      .map(log => ({ tokenId: Number(log.args.tokenId), from: log.args.from.toLowerCase(), to: log.args.to.toLowerCase() }));
    const cacheData = { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock), timestamp: Date.now() };
    await setCache(cacheKey, cacheData, config.cache.nodeCache.stdTTL, contractKey.toLowerCase());
    logger.info('utils', `Cached events: ${cacheKey}, burns: ${burnedTokenIds.length}, transfers: ${transferTokenIds.length}`, 'eth', contractKey);
    return cacheData;
  } catch (error) {
    logger.error('utils', `Failed to fetch events: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_events', error: error.message });
    throw error;
  }
}

// Utility function to safely serialize objects with BigInt
function safeStringify(obj) {
  return JSON.stringify(obj, (key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  );
}

async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState, forceUpdate = false) {
  if (!contractAddress) throw new Error('Contract address missing');
  if (!abi) throw new Error(`${contractKey} ABI missing`);

  contractKey = contractKey.toLowerCase();
  if (!config.debug.suppressDebug) {
    logger.debug('utils', `Starting getHoldersMap: contractKey=${contractKey}, forceUpdate=${forceUpdate}`, 'eth', contractKey);
  }

  const requiredFunctions = contractKey === 'ascendant'
    ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute', 'batchClaimableAmount']
    : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
  const missingFunctions = requiredFunctions.filter(fn => !abi.some(item => item.name === fn && item.type === 'function'));
  if (missingFunctions.length > 0) throw new Error(`Missing ABI functions: ${missingFunctions.join(', ')}`);

  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  let holdersMap = new Map();
  let totalBurned = cacheState.totalBurned || 0;
  let errorLog = cacheState.progressState.errorLog || [];
  let totalLockedAscendant = 0;
  let totalShares = 0;
  let toDistributeDay8 = 0;
  let toDistributeDay28 = 0;
  let toDistributeDay90 = 0;
  let totalTokens = 0;
  let tokenOwnerMap = new Map();

  const contractTiers = config.nftContracts[contractKey]?.tiers || {};
  const maxTier = Math.max(...Object.keys(contractTiers).map(Number), 0);
  let rarityDistribution = contractKey === 'ascendant' ? Array(3).fill(0) : [];
  let tierDistribution = Array(maxTier + 1).fill(0); // 0 to maxTier inclusive

  cacheState.progressState.step = 'checking_cache';
  cacheState.progressState.progressPercentage = '0%';
  await saveCacheStateContract(contractKey, cacheState);

  let currentBlock;
  try {
    currentBlock = await client.getBlockNumber();
    cacheState.progressState.lastProcessedBlock = Number(currentBlock); // Save immediately
    cacheState.progressState.lastUpdated = Date.now();
    await saveCacheStateContract(contractKey, cacheState);
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Fetched current block: ${currentBlock}, saved to cacheState`, 'eth', contractKey);
    }
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    logger.error('utils', `Failed to fetch block number: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    throw error;
  }

  // Check cache validity
  const blockThreshold = contractKey === 'element280' ? (config.cache.blockThreshold || 7200) : (config.cache.blockThreshold || 100); // ~24 hours for element280
  const cacheValid = !forceUpdate &&
    cacheState.lastProcessedBlock &&
    cacheState.progressState.step === 'completed' &&
    !cacheState.isPopulating &&
    (Number(currentBlock) - cacheState.lastProcessedBlock < blockThreshold);

  if (!config.debug.suppressDebug) {
    logger.debug('utils', `Cache validity check: cacheValid=${cacheValid}, forceUpdate=${forceUpdate}, lastProcessedBlock=${cacheState.lastProcessedBlock}, step=${cacheState.progressState.step}, isPopulating=${cacheState.isPopulating}, blockDiff=${Number(currentBlock) - cacheState.lastProcessedBlock}, blockThreshold=${blockThreshold}`, 'eth', contractKey);
  }

  let cachedTokenTiers = new Map();
  if (cacheValid && contractKey === 'element280') {
    try {
      const cachedHolders = await getCache(`${contractKey}_holders`, contractKey);
      if (cachedHolders?.holders && Array.isArray(cachedHolders.holders)) {
        holdersMap = new Map(cachedHolders.holders.map(h => [h.wallet, h]));
        totalBurned = cachedHolders.totalBurned || totalBurned;
        totalTokens = cacheState.progressState.totalNfts || 0;
        holdersMap.forEach(holder => {
          holder.tokenIds.forEach(tokenId => tokenOwnerMap.set(Number(tokenId), holder.wallet));
        });
        // Load cached tiers for element280
        const cachedTiers = await getCache(`${contractKey}_tiers`, contractKey) || {};
        Object.entries(cachedTiers).forEach(([tokenId, tierData]) => {
          if (tierData && typeof tierData.tier === 'number') {
            cachedTokenTiers.set(Number(tokenId), tierData);
          }
        });
        if (!config.debug.suppressDebug) {
          logger.debug('utils', `Cache hit: holders=${holdersMap.size}, tiers=${cachedTokenTiers.size}, lastBlock=${cacheState.lastProcessedBlock}`, 'eth', contractKey);
        }
        // Fetch new Transfer events
        const fromBlock = BigInt(cacheState.lastProcessedBlock);
        const { burnedTokenIds, transferTokenIds, lastBlock } = await getNewEvents(contractKey, contractAddress, fromBlock, errorLog);
        if (!config.debug.suppressDebug) {
          logger.debug('utils', `New events: burns=${burnedTokenIds.length}, transfers=${transferTokenIds.length}, fromBlock=${fromBlock}, toBlock=${lastBlock}`, 'eth', contractKey);
        }
        // Process burns
        const updatedTokenIds = new Set();
        burnedTokenIds.forEach(tokenId => {
          const wallet = tokenOwnerMap.get(tokenId);
          if (wallet) {
            const holder = holdersMap.get(wallet);
            if (holder) {
              holder.tokenIds = holder.tokenIds.filter(id => id !== tokenId);
              holder.total -= 1;
              const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
              holder.tiers[tier] -= 1;
              holder.multiplierSum -= contractTiers[tier + 1]?.multiplier || (tier + 1);
              if (holder.total === 0) holdersMap.delete(wallet);
              tokenOwnerMap.delete(tokenId);
              cachedTokenTiers.delete(tokenId);
              totalTokens -= 1;
              totalBurned += 1;
              tierDistribution[tier] -= 1;
            }
          }
        });
        // Process transfers
        transferTokenIds.forEach(({ tokenId, from, to }) => {
          updatedTokenIds.add(tokenId);
          const oldHolder = holdersMap.get(from);
          if (oldHolder) {
            oldHolder.tokenIds = oldHolder.tokenIds.filter(id => id !== tokenId);
            oldHolder.total -= 1;
            const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
            oldHolder.tiers[tier] -= 1;
            oldHolder.multiplierSum -= contractTiers[tier + 1]?.multiplier || (tier + 1);
            if (oldHolder.total === 0) holdersMap.delete(from);
          }
          let newHolder = holdersMap.get(to) || {
            wallet: to,
            tokenIds: [],
            tiers: Array(maxTier + 1).fill(0),
            total: 0,
            multiplierSum: 0,
            claimableRewards: 0,
          };
          newHolder.tokenIds.push(tokenId);
          newHolder.total += 1;
          const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
          newHolder.tiers[tier] += 1;
          newHolder.multiplierSum += contractTiers[tier + 1]?.multiplier || (tier + 1);
          holdersMap.set(to, newHolder);
          tokenOwnerMap.set(tokenId, to);
        });
        // Fetch tiers for tokens without cached tiers
        const missingTierTokenIds = Array.from(updatedTokenIds).filter(tokenId => !cachedTokenTiers.has(tokenId));
        if (missingTierTokenIds.length > 0) {
          cacheState.progressState.step = 'fetching_updated_tiers';
          cacheState.progressState.processedTiers = 0;
          cacheState.progressState.totalTiers = missingTierTokenIds.length;
          cacheState.progressState.progressPercentage = '50%';
          await saveCacheStateContract(contractKey, cacheState);
          const tierCalls = missingTierTokenIds.map(tokenId => ({
            address: contractAddress,
            abi,
            functionName: 'getNftTier',
            args: [BigInt(tokenId)]
          }));
          const tierResults = [];
          const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
          for (let i = 0; i < tierCalls.length; i += chunkSize) {
            const chunk = tierCalls.slice(i, i + chunkSize);
            const results = await retry(
              () => batchMulticall(chunk, config.alchemy.batchSize),
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            tierResults.push(...results);
            cacheState.progressState.processedTiers = Math.min(i + chunkSize, tierCalls.length);
            cacheState.progressState.progressPercentage = `${Math.round(50 + (i / tierCalls.length) * 20)}%`;
            await saveCacheStateContract(contractKey, cacheState);
            if (!config.debug.suppressDebug) {
              logger.debug('utils', `Processed updated tiers for ${cacheState.progressState.processedTiers}/${tierCalls.length} tokens`, 'eth', contractKey);
            }
          }
          tierResults.forEach((result, i) => {
            const tokenId = missingTierTokenIds[i];
            if (result.status === 'success') {
              const tier = Number(result.result) || 0;
              cachedTokenTiers.set(tokenId, { tier, timestamp: Date.now() });
            } else {
              errorLog.push({
                timestamp: new Date().toISOString(),
                phase: 'fetch_updated_tier',
                tokenId,
                error: result.error || 'unknown error'
              });
            }
          });
          // Update holders with new tiers
          missingTierTokenIds.forEach(tokenId => {
            const wallet = tokenOwnerMap.get(tokenId);
            if (wallet) {
              const holder = holdersMap.get(wallet);
              if (holder) {
                const oldTierIndex = holder.tokenIds.indexOf(tokenId);
                if (oldTierIndex >= 0) {
                  const oldTier = holder.tiers.findIndex((count, i) => count > 0 && i !== oldTierIndex);
                  if (oldTier >= 0) {
                    holder.tiers[oldTier] -= 1;
                    holder.multiplierSum -= contractTiers[oldTier + 1]?.multiplier || (oldTier + 1);
                    tierDistribution[oldTier] -= 1;
                  }
                }
                const newTier = cachedTokenTiers.get(tokenId)?.tier || 0;
                holder.tiers[newTier] += 1;
                holder.multiplierSum += contractTiers[newTier + 1]?.multiplier || (newTier + 1);
                tierDistribution[newTier] += 1;
              }
            }
          });
          await setCache(`${contractKey}_tiers`, Object.fromEntries(cachedTokenTiers), config.cache.nodeCache.stdTTL || 86400, contractKey); // 24 hours TTL
        }
        cacheState.progressState.totalNfts = totalTokens;
        cacheState.progressState.totalTiers = totalTokens;
        cacheState.progressState.totalLiveHolders = totalTokens;
        cacheState.globalMetrics = {
          totalMinted: totalTokens + totalBurned,
          totalLive: totalTokens,
          totalBurned,
          tierDistribution,
        };
        cacheState.progressState.isPopulating = false;
        cacheState.progressState.step = 'completed';
        cacheState.progressState.processedNfts = totalTokens;
        cacheState.progressState.processedTiers = missingTierTokenIds.length;
        cacheState.progressState.progressPercentage = '100%';
        cacheState.progressState.lastProcessedBlock = Number(currentBlock);
        cacheState.progressState.lastUpdated = Date.now();
        await saveCacheStateContract(contractKey, cacheState);
        const holderList = Array.from(holdersMap.values());
        holderList.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
        holderList.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = (holder.total / totalTokens * 100) || 0;
          holder.displayMultiplierSum = holder.multiplierSum;
        });
        await setCache(`${contractKey}_holders`, { holders: holderList, totalBurned, timestamp: Date.now() }, 0, contractKey);
        logger.info('utils', `Updated cached holders for ${contractKey}, lastBlock=${cacheState.lastProcessedBlock}, updatedTokens=${missingTierTokenIds.length}`, 'eth', contractKey);
        return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog, rarityDistribution };
      } else {
        logger.warn('utils', `Invalid holders cache data for ${contractKey}`, 'eth', contractKey);
      }
    } catch (error) {
      logger.error('utils', `Failed to load cache for ${contractKey}: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'load_cache', error: error.message });
    }
  } else if (cacheValid) {
    // Original cache logic for non-element280 contracts
    try {
      const cachedHolders = await getCache(`${contractKey}_holders`, contractKey);
      if (cachedHolders?.holders) {
        holdersMap = new Map(cachedHolders.holders.map(h => [h.wallet, h]));
        totalBurned = cachedHolders.totalBurned || totalBurned;
        rarityDistribution = cachedHolders.rarityDistribution || rarityDistribution;
        totalTokens = cacheState.progressState.totalNfts || 0;
        holdersMap.forEach(holder => {
          holder.tokenIds.forEach(tokenId => tokenOwnerMap.set(Number(tokenId), holder.wallet));
        });
        if (contractKey === 'ascendant') {
          totalLockedAscendant = cacheState.globalMetrics.totalLockedAscendant || 0;
          totalShares = cacheState.globalMetrics.totalShares || 0;
          toDistributeDay8 = cacheState.globalMetrics.toDistributeDay8 || 0;
          toDistributeDay28 = cacheState.globalMetrics.toDistributeDay28 || 0;
          toDistributeDay90 = cacheState.globalMetrics.toDistributeDay90 || 0;
        }
        cacheState.progressState.isPopulating = false;
        cacheState.progressState.step = 'cached';
        cacheState.progressState.progressPercentage = '100%';
        await saveCacheStateContract(contractKey, cacheState);
        logger.info('utils', `Using cached holders for ${contractKey}, lastBlock=${cacheState.lastProcessedBlock}`, 'eth', contractKey);
        return { holdersMap, totalBurned, lastBlock: cacheState.lastProcessedBlock, errorLog, rarityDistribution };
      }
    } catch (error) {
      logger.error('utils', `Failed to load cache for ${contractKey}: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    }
  }

  cacheState.progressState.step = 'fetching_supply';
  cacheState.progressState.isPopulating = true;
  cacheState.progressState.progressPercentage = '10%';
  await saveCacheStateContract(contractKey, cacheState);

  const isBurnContract = ['stax', 'element280', 'element369'].includes(contractKey);
  if (contractKey === 'ascendant') {
    try {
      const [totalSharesRaw, toDistributeDay8Raw, toDistributeDay28Raw, toDistributeDay90Raw] = await retry(
        () => Promise.all([
          client.readContract({ address: contractAddress, abi, functionName: 'totalShares' }),
          client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] }),
          client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] }),
          client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] })
        ]),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      totalShares = parseFloat(formatUnits(totalSharesRaw, 18));
      toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));
      toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));
      toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));
      if (!config.debug.suppressDebug) {
        logger.debug('utils', `Ascendant metrics: totalShares=${totalShares}, toDistributeDay8=${toDistributeDay8}`, 'eth', contractKey);
      }
    } catch (error) {
      logger.error('utils', `Failed to fetch ascendant metrics: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_ascendant_metrics', error: error.message });
      throw error;
    }
  } else {
    try {
      const [totalSupply, burnedCount] = await retry(
        () => Promise.all([
          client.readContract({ address: contractAddress, abi, functionName: 'totalSupply' }),
          client.readContract({ address: contractAddress, abi, functionName: 'totalBurned' }).catch(() => 0)
        ]),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      totalTokens = Number(totalSupply);
      totalBurned = Number(burnedCount);
      if (!config.debug.suppressDebug) {
        logger.debug('utils', `Total tokens: ${totalTokens}, totalBurned: ${totalBurned}`, 'eth', contractKey);
      }
    } catch (error) {
      logger.error('utils', `Supply fetch error: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_supply', error: error.message });
      throw error;
    }
  }

  cacheState.progressState.step = 'fetching_holders';
  cacheState.progressState.progressPercentage = '20%';
  await saveCacheStateContract(contractKey, cacheState);

  try {
    const owners = await retry(
      () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true, maxPages: 100 }),
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );

    const filteredOwners = owners.filter(
      owner => owner?.ownerAddress && owner.ownerAddress.toLowerCase() !== burnAddress.toLowerCase() && owner.tokenBalances?.length > 0
    );
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Filtered owners: ${filteredOwners.length}`, 'eth', contractKey);
    }

    tokenOwnerMap.clear();
    totalTokens = 0;
    const seenTokenIds = new Set();

    filteredOwners.forEach(owner => {
      if (!owner.ownerAddress) return;
      let wallet;
      try {
        wallet = getAddress(owner.ownerAddress).toLowerCase();
      } catch (e) {
        logger.warn('utils', `Invalid wallet address: ${owner.ownerAddress}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owner', ownerAddress: owner.ownerAddress, error: 'Invalid wallet address' });
        return;
      }
      owner.tokenBalances.forEach(tb => {
        if (!tb.tokenId) return;
        const tokenId = Number(tb.tokenId);
        if (seenTokenIds.has(tokenId)) {
          logger.warn('utils', `Duplicate tokenId ${tokenId} for wallet ${wallet}`, 'eth', contractKey);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_token', tokenId, wallet, error: 'Duplicate tokenId' });
          return;
        }
        seenTokenIds.add(tokenId);
        tokenOwnerMap.set(tokenId, wallet);
        totalTokens++;
      });
    });
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Total tokens (Alchemy): ${totalTokens}, unique tokenIds: ${seenTokenIds.size}`, 'eth', contractKey);
    }
  } catch (error) {
    logger.warn('utils', `Failed to fetch owners via getOwnersForContract: ${error.message}, falling back to Transfer events`, 'eth', contractKey);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_owners_alchemy', error: error.message });

    const fromBlock = BigInt(config.getDeploymentBlocks()[contractKey]?.block || 0);
    const toBlock = currentBlock;
    tokenOwnerMap.clear();
    totalTokens = 0;
    const seenTokenIds = new Set();

    const transferLogs = await retry(
      async () => {
        const logs = await client.getLogs({
          address: contractAddress,
          event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
          fromBlock,
          toBlock,
        });
        return logs;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );

    for (const log of transferLogs) {
      const from = log.args.from.toLowerCase();
      const to = log.args.to.toLowerCase();
      const tokenId = Number(log.args.tokenId);

      if (to === burnAddress.toLowerCase()) {
        totalBurned += 1;
        tokenOwnerMap.delete(tokenId);
        seenTokenIds.delete(tokenId);
        continue;
      }

      if (from === '0x0000000000000000000000000000000000000000') {
        if (!seenTokenIds.has(tokenId)) {
          tokenOwnerMap.set(tokenId, to);
          seenTokenIds.add(tokenId);
          totalTokens++;
        }
      } else {
        tokenOwnerMap.set(tokenId, to);
        seenTokenIds.add(tokenId);
      }
    }
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Total tokens (Transfer events): ${totalTokens}, unique tokenIds: ${seenTokenIds.size}`, 'eth', contractKey);
    }
  }

  cacheState.progressState.totalNfts = totalTokens;
  cacheState.progressState.totalTiers = totalTokens;
  cacheState.progressState.totalLiveHolders = totalTokens;
  cacheState.progressState.progressPercentage = '30%';
  await saveCacheStateContract(contractKey, cacheState);

  if (totalTokens === 0) {
    cacheState.progressState.step = 'completed';
    cacheState.progressState.progressPercentage = '100%';
    cacheState.globalMetrics = {
      ...(contractKey === 'element280' || contractKey === 'stax' || contractKey === 'ascendant' ? { totalMinted: totalTokens + totalBurned } : {}),
      totalLive: totalTokens,
      totalBurned,
      tierDistribution: Array(maxTier + 1).fill(0),
      ...(contractKey === 'ascendant' ? {
        totalLockedAscendant: 0,
        totalShares: 0,
        toDistributeDay8: 0,
        toDistributeDay28: 0,
        toDistributeDay90: 0,
        pendingRewards: 0,
        rarityDistribution: Array(3).fill(0)
      } : {})
    };
    await saveCacheStateContract(contractKey, cacheState);
    await setCache(`${contractKey}_tiers`, {}, config.cache.nodeCache.stdTTL || 86400, contractKey);
    logger.info('utils', `No tokens found, returning empty holdersMap`, 'eth', contractKey);
    return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog, rarityDistribution };
  }

  cacheState.progressState.step = 'fetching_records';
  cacheState.progressState.progressPercentage = '40%';
  await saveCacheStateContract(contractKey, cacheState);

  const tokenIds = Array.from(tokenOwnerMap.keys());
  const recordCalls = contractKey === 'ascendant' ? tokenIds.map(tokenId => ({
    address: contractAddress,
    abi,
    functionName: 'userRecords',
    args: [BigInt(tokenId)]
  })) : [];
  const recordResults = contractKey === 'ascendant' ? [] : tokenIds.map(() => ({ status: 'success', result: [] }));
  if (contractKey === 'ascendant') {
    const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
    for (let i = 0; i < recordCalls.length; i += chunkSize) {
      const chunk = recordCalls.slice(i, i + chunkSize);
      const results = await retry(
        () => batchMulticall(chunk, config.alchemy.batchSize),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      recordResults.push(...results);
      cacheState.progressState.progressPercentage = `${Math.round(40 + (i / recordCalls.length) * 10)}%`;
      await saveCacheStateContract(contractKey, cacheState);
    }
  }

  cacheState.progressState.step = 'fetching_tiers';
  cacheState.progressState.processedTiers = 0;
  cacheState.progressState.progressPercentage = '50%';
  await saveCacheStateContract(contractKey, cacheState);

  // Load cached tiers for element280
  if (contractKey === 'element280') {
    const cachedTiers = await getCache(`${contractKey}_tiers`, contractKey) || {};
    Object.entries(cachedTiers).forEach(([tokenId, tierData]) => {
      if (tierData && typeof tierData.tier === 'number') {
        cachedTokenTiers.set(Number(tokenId), tierData);
      }
    });
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Cached tiers loaded: ${cachedTokenTiers.size}, missing tiers for ${tokenIds.length - cachedTokenTiers.size} tokens`, 'eth', contractKey);
    }
  }

  const missingTierTokenIds = contractKey === 'element280' ? tokenIds.filter(tokenId => !cachedTokenTiers.has(tokenId)) : tokenIds;
  const tierCalls = missingTierTokenIds.map(tokenId => ({
    address: contractAddress,
    abi,
    functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
    args: [BigInt(tokenId)]
  }));

  const tierResults = [];
  const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
  for (let i = 0; i < tierCalls.length; i += chunkSize) {
    const chunk = tierCalls.slice(i, i + chunkSize);
    const results = await retry(
      () => batchMulticall(chunk, config.alchemy.batchSize),
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    tierResults.push(...results);
    cacheState.progressState.processedTiers = Math.min(i + chunkSize, missingTierTokenIds.length);
    cacheState.progressState.progressPercentage = `${Math.round(50 + (i / tierCalls.length) * 20)}%`;
    await saveCacheStateContract(contractKey, cacheState);
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Processed tiers for ${cacheState.progressState.processedTiers}/${missingTierTokenIds.length} tokens`, 'eth', contractKey);
    }
  }

  // Cache new tier results for element280
  if (contractKey === 'element280') {
    tierResults.forEach((result, i) => {
      const tokenId = missingTierTokenIds[i];
      if (result.status === 'success') {
        const tier = Number(result.result) || 0;
        cachedTokenTiers.set(tokenId, { tier, timestamp: Date.now() });
      } else {
        errorLog.push({
          timestamp: new Date().toISOString(),
          phase: 'fetch_tier',
          tokenId,
          error: result.error || 'unknown error'
        });
      }
    });
    await setCache(`${contractKey}_tiers`, Object.fromEntries(cachedTokenTiers), config.cache.nodeCache.stdTTL || 86400, contractKey);
  }

  // Combine cached and new tier results for element280
  const allTierResults = contractKey === 'element280' ? tokenIds.map(tokenId => {
    if (cachedTokenTiers.has(tokenId)) {
      const tierData = cachedTokenTiers.get(tokenId);
      return { status: 'success', result: tierData.tier };
    }
    const index = missingTierTokenIds.indexOf(tokenId);
    return index >= 0 ? tierResults[index] : { status: 'failure', error: 'Missing tier data' };
  }) : tierResults;

  cacheState.progressState.step = 'fetching_rewards';
  cacheState.progressState.progressPercentage = '70%';
  await saveCacheStateContract(contractKey, cacheState);

  const rewardCalls = contractKey === 'ascendant' ? [{
    address: contractAddress,
    abi,
    functionName: 'batchClaimableAmount',
    args: [tokenIds.map(id => BigInt(id))]
  }, {
    address: contractAddress,
    abi,
    functionName: 'toDistribute',
    args: [0]
  }, {
    address: contractAddress,
    abi,
    functionName: 'toDistribute',
    args: [1]
  }, {
    address: contractAddress,
    abi,
    functionName: 'toDistribute',
    args: [2]
  }, {
    address: contractAddress,
    abi,
    functionName: 'totalShares',
    args: []
  }] : [];

  const rewardResults = contractKey === 'ascendant' ? await retry(
    () => batchMulticall(rewardCalls, config.alchemy.batchSize),
    { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
  ) : [];

  if (contractKey === 'ascendant') {
    if (rewardResults[0].status === 'success') {
      const claimable = parseFloat(formatUnits(rewardResults[0].result || 0, 18));
      holdersMap.forEach(holder => {
        holder.claimableRewards = claimable / totalTokens * holder.total;
      });
    }
    toDistributeDay8 = rewardResults[1].status === 'success' ? parseFloat(formatUnits(rewardResults[1].result || 0, 18)) : toDistributeDay8;
    toDistributeDay28 = rewardResults[2].status === 'success' ? parseFloat(formatUnits(rewardResults[2].result || 0, 18)) : toDistributeDay28;
    toDistributeDay90 = rewardResults[3].status === 'success' ? parseFloat(formatUnits(rewardResults[3].result || 0, 18)) : toDistributeDay90;
    totalShares = rewardResults[4].status === 'success' ? parseFloat(formatUnits(rewardResults[4].result || 0, 18)) : totalShares;
  }

  cacheState.progressState.step = 'building_holders';
  cacheState.progressState.progressPercentage = '80%';
  await saveCacheStateContract(contractKey, cacheState);

  tokenIds.forEach((tokenId, i) => {
    const wallet = tokenOwnerMap.get(tokenId);
    if (!wallet) {
      logger.warn('utils', `No owner found for token ${tokenId}`, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_token', tokenId, error: 'No owner found' });
      return;
    }

    let shares = 0;
    let lockedAscendant = 0;
    if (contractKey === 'ascendant') {
      const recordResult = recordResults[i];
      if (recordResult.status === 'success' && Array.isArray(recordResult.result)) {
        shares = parseFloat(formatUnits(recordResult.result[0] || 0, 18));
        lockedAscendant = parseFloat(formatUnits(recordResult.result[1] || 0, 18));
        totalLockedAscendant += lockedAscendant;
      } else {
        logger.error('utils', `Failed to fetch userRecords for token ${tokenId}: ${recordResult.error || 'unknown error'}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_records', tokenId, wallet, error: recordResult.error || 'unknown error' });
        return;
      }
    }

    let tier = 0;
    let rarityNumber = 0;
    let rarity = 0;
    const tierResult = allTierResults[i];
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `Raw tierResult for token ${tokenId}: status=${tierResult.status}, result=${safeStringify(tierResult.result)}`, 'eth', contractKey);
    }

    if (tierResult.status === 'success') {
      if (contractKey === 'ascendant') {
        const result = tierResult.result;
        let parsedResult;
        if (Array.isArray(result) && result.length >= 3) {
          parsedResult = {
            rarityNumber: Number(result[0]) || 0,
            tier: Number(result[1]) || 0,
            rarity: Number(result[2]) || 0
          };
        } else if (typeof result === 'object' && result !== null && 'rarityNumber' in result) {
          parsedResult = {
            rarityNumber: Number(result.rarityNumber) || 0,
            tier: Number(result.tier) || 0,
            rarity: Number(result.rarity) || 0
          };
        } else {
          logger.warn('utils', `Invalid getNFTAttribute result for token ${tokenId}: result=${safeStringify(result)}`, 'eth', contractKey);
          errorLog.push({
            timestamp: new Date().toISOString(),
            phase: 'fetch_tier',
            tokenId,
            wallet,
            error: `Invalid getNFTAttribute result: ${safeStringify(result)}`
          });
          return;
        }
        rarityNumber = parsedResult.rarityNumber;
        tier = parsedResult.tier;
        rarity = parsedResult.rarity;
        if (!config.debug.suppressDebug) {
          logger.debug('utils', `Parsed attributes for token ${tokenId} (ascendant): tier=${tier}, rarityNumber=${rarityNumber}, rarity=${rarity}`, 'eth', contractKey);
        }
      } else {
        tier = typeof tierResult.result === 'bigint' ? Number(tierResult.result) : Number(tierResult.result) || 0;
      }

      if (isNaN(tier) || tier < 0 || tier > maxTier) {
        logger.warn('utils', `Invalid tier for token ${tokenId} in ${contractKey}: tier=${tier}, maxTier=${maxTier}, defaulting to 0`, 'eth', contractKey);
        errorLog.push({
          timestamp: new Date().toISOString(),
          phase: 'fetch_tier',
          tokenId,
          wallet,
          error: `Invalid tier ${tier}`,
          details: { rawResult: safeStringify(tierResult.result), maxTier, parsedTier: tier }
        });
        tier = 0;
      }
    } else {
      logger.error('utils', `Failed to fetch tier for token ${tokenId}: ${tierResult.error || 'unknown error'}`, 'eth', contractKey);
      errorLog.push({
        timestamp: new Date().toISOString(),
        phase: 'fetch_tier',
        tokenId,
        wallet,
        error: tierResult.error || 'unknown error',
        details: { rawResult: safeStringify(tierResult.result) }
      });
      return;
    }

    if (contractKey === 'ascendant' && rarity >= 0 && rarity < rarityDistribution.length) {
      rarityDistribution[rarity] += 1;
    } else if (contractKey === 'ascendant') {
      logger.warn('utils', `Invalid rarity for token ${tokenId}: rarity=${rarity}, maxRarity=${rarityDistribution.length - 1}`, 'eth', contractKey);
      errorLog.push({
        timestamp: new Date().toISOString(),
        phase: 'fetch_rarity',
        tokenId,
        wallet,
        error: `Invalid rarity ${rarity}`
      });
    }

    const holder = holdersMap.get(wallet) || {
      wallet,
      tokenIds: [],
      tiers: Array(maxTier + 1).fill(0),
      total: 0,
      multiplierSum: 0,
      ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
      ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
      ...(contractKey === 'ascendant' ? {
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: toDistributeDay8 / totalTokens * 8 / 100,
        pendingDay28: toDistributeDay28 / totalTokens * 28 / 100,
        pendingDay90: toDistributeDay90 / totalTokens * 90 / 100,
        claimableRewards: 0,
        tokens: []
      } : {})
    };

    if (holder.tokenIds.includes(tokenId)) {
      logger.warn('utils', `Duplicate tokenId ${tokenId} for wallet ${wallet} in holdersMap`, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'build_holders', tokenId, wallet, error: 'Duplicate tokenId in holdersMap' });
      return;
    }

    holder.tokenIds.push(tokenId);
    holder.total += 1;
    holder.tiers[tier] += 1;
    holder.multiplierSum += contractTiers[tier + 1]?.multiplier || (tier + 1);
    if (contractKey === 'ascendant') {
      holder.shares += shares;
      holder.lockedAscendant += lockedAscendant;
      holder.tokens.push({
        tokenId: Number(tokenId),
        tier: tier + 1,
        rawTier: tier,
        rarityNumber,
        rarity
      });
    }
    holdersMap.set(wallet, holder);
    tierDistribution[tier] += 1;
  });

  cacheState.progressState.step = 'finalizing';
  cacheState.progressState.progressPercentage = '90%';
  await saveCacheStateContract(contractKey, cacheState);

  const totalLiveHolders = holdersMap.size;
  cacheState.progressState.totalOwners = totalLiveHolders;
  let holderList = Array.from(holdersMap.values());
  holderList.forEach((holder, index) => {
    holder.rank = index + 1;
    holder.percentage = (holder.total / totalTokens * 100) || 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  holderList.sort((a, b) => {
    if (contractKey === 'ascendant') {
      return b.shares - a.shares || b.total - a.total;
    }
    return b.total - a.total || b.multiplierSum - a.multiplierSum;
  });
  holderList.forEach((holder, index) => {
    holder.rank = index + 1;
  });

  cacheState.globalMetrics = {
    ...(contractKey === 'element280' || contractKey === 'stax' || contractKey === 'ascendant' ? { totalMinted: totalTokens + totalBurned } : {}),
    totalLive: totalTokens,
    totalBurned,
    tierDistribution,
    ...(contractKey === 'ascendant' ? {
      totalLockedAscendant,
      totalShares,
      toDistributeDay8,
      toDistributeDay28,
      toDistributeDay90,
      pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
      rarityDistribution
    } : {})
  };
  cacheState.progressState.isPopulating = false;
  cacheState.progressState.step = 'completed';
  cacheState.progressState.processedNfts = totalTokens;
  cacheState.progressState.processedTiers = missingTierTokenIds.length;
  cacheState.progressState.progressPercentage = '100%';
  cacheState.progressState.lastProcessedBlock = Number(currentBlock);
  cacheState.progressState.lastUpdated = Date.now();
  await saveCacheStateContract(contractKey, cacheState);

  await setCache(`${contractKey}_holders`, { holders: holderList, totalBurned, timestamp: Date.now(), rarityDistribution }, 0, contractKey);
  if (contractKey === 'element280') {
    await setCache(`${contractKey}_tiers`, Object.fromEntries(cachedTokenTiers), config.cache.nodeCache.stdTTL || 86400, contractKey);
  }
  logger.info('utils', `Completed holders map with ${holderList.length} holders, totalBurned=${totalBurned}, cachedTiers=${cachedTokenTiers.size}`, 'eth', contractKey);
  if (!config.debug.suppressDebug) {
    logger.debug('utils', `Tier distribution for ${contractKey}: ${tierDistribution}`, 'eth', contractKey);
    if (contractKey === 'ascendant') {
      logger.debug('utils', `Rarity distribution for ${contractKey}: ${rarityDistribution}`, 'eth', contractKey);
    }
  }

  return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog, rarityDistribution };
}

// Populate holders map cache
async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) {
  try {
    const cacheState = await getCacheState(contractKey.toLowerCase());
    if (!forceUpdate && cacheState.isPopulating) {
      logger.info('utils', `Cache population already in progress for ${contractKey}`, 'eth', contractKey);
      return { status: 'pending', holders: [] };
    }

    cacheState.isPopulating = true;
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);

    const { holdersMap, totalBurned } = await getHoldersMap(
      contractKey,
      contractAddress,
      abi,
      vaultAddress,
      vaultAbi,
      cacheState,
      forceUpdate
    );

    const holderList = [];
    for (const [wallet, data] of holdersMap) {
      holderList.push({
        wallet,
        total: data.total,
        tokenIds: data.tokenIds,
        tiers: data.tiers,
        multiplierSum: data.multiplierSum,
        shares: data.shares || 0,
        lockedAscendant: data.lockedAscendant || 0,
        claimableRewards: data.claimableRewards || 0,
        pendingDay8: data.pendingDay8 || 0,
        pendingDay28: data.pendingDay28 || 0,
        pendingDay90: data.pendingDay90 || 0,
        infernoRewards: data.infernoRewards || 0,
        fluxRewards: data.fluxRewards || 0,
        e280Rewards: data.e280Rewards || 0,
        percentage: data.percentage || 0,
        displayMultiplierSum: data.displayMultiplierSum || data.multiplierSum,
        rank: 0, // Will be set later
        ...(contractKey === 'ascendant' ? { tokens: data.tokens || [] } : {}) // Include tokens for ascendant
      });
    }

    // Sort and set ranks
    holderList.sort((a, b) => (contractKey === 'ascendant' ? b.shares - a.shares : b.multiplierSum - a.multiplierSum) || b.total - a.total);
    holderList.forEach((holder, index) => {
      holder.rank = index + 1;
    });

    const isBurnContract = ['stax', 'element280', 'element369'].includes(contractKey.toLowerCase());
    const cacheTotalBurned = isBurnContract ? totalBurned : 0; // 0 for ascendant
    const cacheData = {
      holders: holderList,
      totalBurned: cacheTotalBurned,
      timestamp: Date.now(),
    };

    // Validate cache data
    if (!Array.isArray(cacheData.holders) || (isBurnContract && typeof cacheData.totalBurned !== 'number')) {
      logger.error('utils', `Invalid cache data for ${contractKey}: ${JSON.stringify(cacheData)}`, 'eth', contractKey);
      throw new Error('Invalid cache data');
    }

    logger.info('utils', `Saving cache for ${contractKey}: totalBurned=${cacheTotalBurned}, holders=${holderList.length}`, 'eth', contractKey);
    await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());

    cacheState.isPopulating = false;
    cacheState.phase = 'Completed';
    cacheState.progressPercentage = '100.0';
    cacheState.totalLiveHolders = holderList.length;
    cacheState.totalOwners = holderList.length;
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);

    logger.info('utils', `Cache populated: ${holderList.length} holders, totalBurned: ${cacheTotalBurned}`, 'eth', contractKey);
    return { status: 'success', holders: holderList };
  } catch (error) {
    logger.error('utils', `Failed to populate holders cache for ${contractKey}: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    cacheState.isPopulating = false;
    cacheState.error = error.message;
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);
    return { status: 'error', holders: [] };
  }
}

// GET handler
export async function GET(request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();

  if (!config.nftContracts[contractKey]) {
    logger.error('utils', `Invalid contract: ${contractKey}`, 'eth', contractKey);
    return NextResponse.json({ error: 'Invalid contract' }, { status: 400 });
  }

  const { contractAddress, abi } = config.nftContracts[contractKey];
  const cacheState = await getCacheState(contractKey);

  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '0', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || config.contractDetails[contractKey].pageSize, 10);

  const cachedData = await getCache(`${contractKey}_holders`, contractKey);
  const isBurnContract = ['stax', 'element280', 'element369'].includes(contractKey);

  if (cachedData) {
    const holders = cachedData.holders.slice(page * pageSize, (page + 1) * pageSize);
    const totalPages = Math.ceil(cachedData.holders.length / pageSize);
    const totalTokens = cachedData.holders.reduce((sum, h) => sum + h.total, 0);
    const totalBurned = isBurnContract ? Number(cachedData.totalBurned) || 0 : 0;
    const maxTier = Math.max(...Object.keys(config.nftContracts[contractKey]?.tiers || {}).map(Number), 0);
    const response = {
      holders: sanitizeBigInt(holders),
      totalPages,
      totalTokens,
      totalBurned,
      summary: {
        totalLive: totalTokens,
        totalBurned,
        totalMinted: totalTokens + totalBurned,
        tierDistribution: cachedData.holders.reduce((acc, h) => {
          h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
          return acc;
        }, Array(contractKey === 'ascendant' ? maxTier + 1 : maxTier).fill(0)), // 9 tiers for ascendant
        multiplierPool: cachedData.holders.reduce((sum, h) => sum + h.multiplierSum, 0),
        ...(contractKey === 'ascendant' ? {
          rarityDistribution: cacheState.globalMetrics.rarityDistribution || Array(3).fill(0)
        } : {})
      },
      globalMetrics: cacheState.globalMetrics || {},
    };
    if (!config.debug.suppressDebug) {
      logger.debug('utils', `GET response for ${contractKey}: holders=${holders.length}, totalPages=${totalPages}`, 'eth', contractKey);
    }
    return NextResponse.json(response);
  }

  const { status, holders } = await populateHoldersMapCache(contractKey, contractAddress, abi, null, null);
  if (status === 'error') {
    logger.error('utils', `Cache population failed for ${contractKey}`, 'eth', contractKey);
    throw new Error('Cache population failed');
  }

  const paginatedHolders = holders.slice(page * pageSize, (page + 1) * pageSize);
  const totalPages = Math.ceil(holders.length / pageSize);
  const cachedDataAfterPopulation = await getCache(`${contractKey}_holders`, contractKey);
  const totalBurned = isBurnContract ? Number(cachedDataAfterPopulation?.totalBurned) || 0 : 0;
  const totalTokens = holders.reduce((sum, h) => sum + h.total, 0);
  const maxTier = Math.max(...Object.keys(config.nftContracts[contractKey]?.tiers || {}).map(Number), 0);
  const response = {
    holders: sanitizeBigInt(paginatedHolders),
    totalPages,
    totalTokens,
    totalBurned,
    summary: {
      totalLive: totalTokens,
      totalBurned,
      totalMinted: totalTokens + totalBurned,
      tierDistribution: holders.reduce((acc, h) => {
        h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
        return acc;
      }, Array(contractKey === 'ascendant' ? maxTier + 1 : maxTier).fill(0)), // 9 tiers for ascendant
      multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      ...(contractKey === 'ascendant' ? {
        rarityDistribution: cacheState.globalMetrics.rarityDistribution || Array(3).fill(0)
      } : {})
    },
    globalMetrics: cacheState.globalMetrics || {},
  };
  if (!config.debug.suppressDebug) {
    logger.debug('utils', `GET response for ${contractKey}: holders=${paginatedHolders.length}, totalPages=${totalPages}`, 'eth', contractKey);
  }
  return NextResponse.json(response);
}

// POST handler
export async function POST(request, { params }) {
  const resolvedParams = await params; // Await params for Next.js App Router
  const { contract: contractKey } = resolvedParams;
  const normalizedContractKey = contractKey.toLowerCase();

  const { forceUpdate = false } = await request.json().catch(() => ({}));

  // Early validation of contractKey
  if (!config.nftContracts[normalizedContractKey]) {
    logger.error('utils', `Invalid contract: ${normalizedContractKey}`, 'eth', normalizedContractKey);
    return NextResponse.json({ message: `Invalid contract: ${normalizedContractKey}`, status: 'error' }, { status: 400 });
  }

  let contractAddress, abi, vaultAddress, vaultAbi;
  try {
    const contractConfig = config.nftContracts[normalizedContractKey];
    ({ contractAddress, abi, vaultAddress, vaultAbi } = contractConfig);
    logger.info('utils', `POST for ${normalizedContractKey}: abiType=${Array.isArray(abi) ? 'array' : typeof abi}, abiLength=${Array.isArray(abi) ? abi.length : 'N/A'}`, 'eth', normalizedContractKey);
    if (!contractAddress) {
      throw new Error(`Contract address not configured for ${normalizedContractKey}`);
    }
    if (!Array.isArray(abi) && !contractConfig.disabled) {
      throw new Error(`Invalid ABI for ${normalizedContractKey}: expected array, got ${typeof abi}`);
    }
    if (validateContract) {
      try {
        await validateContract(normalizedContractKey);
      } catch (error) {
        logger.warn('utils', `validateContract failed for ${normalizedContractKey}: ${error.message}. Proceeding without validation.`, 'eth', normalizedContractKey);
      }
    }
  } catch (error) {
    logger.error('utils', `Validation error for ${normalizedContractKey}: ${error.message}`, { stack: error.stack }, 'eth', normalizedContractKey);
    return NextResponse.json({ message: error.message, status: 'error' }, { status: 400 });
  }

  const cacheState = await getCacheState(normalizedContractKey);
  if (cacheState.isPopulating) {
    logger.info('utils', `Cache population already in progress for ${normalizedContractKey}`, 'eth', normalizedContractKey);
    return NextResponse.json({ message: `${normalizedContractKey} cache population already in progress`, status: 'in_progress' }, { status: 202 });
  }

  if (forceUpdate) {
    await setCache(`${normalizedContractKey}_holders`, null, 0, normalizedContractKey);
    cacheState.progressState = { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] };
    logger.info('utils', `Cleared cache for ${normalizedContractKey} due to forceUpdate`, 'eth', normalizedContractKey);
  }

  cacheState.isPopulating = true;
  await saveCacheStateContract(normalizedContractKey, cacheState);

  setTimeout(async () => {
    try {
      await getHoldersMap(normalizedContractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState, forceUpdate);
      logger.info('utils', `Cache population completed for ${normalizedContractKey}: ${cacheState.totalOwners} holders`, 'eth', normalizedContractKey);
    } catch (error) {
      cacheState.progressState.error = error.message;
      cacheState.progressState.errorLog.push({
        timestamp: new Date().toISOString(),
        phase: 'cache_update',
        error: error.message,
      });
      logger.error('utils', `Cache population failed for ${normalizedContractKey}: ${error.message}`, { stack: error.stack }, 'eth', normalizedContractKey);
    } finally {
      cacheState.isPopulating = false;
      cacheState.lastUpdated = new Date().toISOString();
      await saveCacheStateContract(normalizedContractKey, cacheState);
    }
  }, 0);

  logger.info('utils', `Cache population triggered for ${normalizedContractKey}`, 'eth', normalizedContractKey);
  return NextResponse.json({ message: `${normalizedContractKey} cache population triggered`, status: 'success' }, { status: 202 });
}
----- ./app/api/utils.js -----

import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { Redis } from '@upstash/redis';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy } from 'alchemy-sdk';
import config from '@/contracts/config';
import pLimit from 'p-limit';
import { logger } from '@/app/lib/logger';
import chalk from 'chalk';

console.log(chalk.cyan('[Utils] Initializing utils...'));
logger.info('utils', 'Utils module loaded', 'eth', 'general').catch(error => {
  console.error(chalk.red('[Utils] Logger error:'), error.message);
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const isDebug = process.env.DEBUG === 'true';
const isProduction = process.env.NODE_ENV === 'production';

const cache = new NodeCache({
  stdTTL: 0,
  checkperiod: 120,
});

const cacheDir = path.join(process.cwd(), 'cache');

const redisEnabled = Object.keys(config.nftContracts).some(
  contract => process.env[`DISABLE_${contract.toUpperCase()}_REDIS`] !== 'true' && process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN
);
let redis = null;

if (redisEnabled) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });
    logger.info('utils', 'Upstash Redis initialized', 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to initialize Upstash Redis: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    redis = null;
  }
}

const alchemyApiKey = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  logger.error('utils', 'Alchemy API key is missing', {}, 'eth', 'general');
  throw new Error('Alchemy API key is missing');
}

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`),
});

const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: 'eth-mainnet',
});

async function ensureCacheDir() {
  try {
    await fs.mkdir(cacheDir, { recursive: true });
    await fs.chmod(cacheDir, 0o755);
    logger.info('utils', `Created/chmod cache directory: ${cacheDir}`, 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to create/chmod cache directory ${cacheDir}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function initializeCache() {
  try {
    logger.info('utils', 'Starting cache initialization', 'eth', 'general');
    await ensureCacheDir();

    const testKey = 'test_node_cache';
    const testValue = { ready: true };
    const nodeCacheSuccess = cache.set(testKey, testValue);
    if (nodeCacheSuccess) {
      logger.info('utils', 'Node-cache is ready', 'eth', 'general');
      cache.del(testKey);
    } else {
      logger.error('utils', 'Node-cache failed to set test key', {}, 'eth', 'general');
    }

    if (redisEnabled && redis) {
      try {
        await redis.set('test_redis', JSON.stringify(testValue));
        const redisData = await redis.get('test_redis');
        if (redisData && JSON.parse(redisData).ready) {
          logger.info('utils', 'Redis cache is ready', 'eth', 'general');
          await redis.del('test_redis');
        } else {
          logger.error('utils', 'Redis cache test failed: invalid data', {}, 'eth', 'general');
        }
      } catch (error) {
        logger.error('utils', `Redis cache test failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      }
    }

    const collections = Object.keys(config.nftContracts).filter(key => !config.nftContracts[key].disabled).map(key => key.toLowerCase());
    for (const collection of collections) {
      const cacheFile = path.join(cacheDir, `${collection}_holders.json`);
      try {
        await fs.access(cacheFile);
        logger.info('utils', `Cache file exists: ${cacheFile}`, 'eth', collection);
      } catch (error) {
        if (error.code === 'ENOENT') {
          await fs.writeFile(cacheFile, JSON.stringify({ holders: [], totalBurned: 0, timestamp: Date.now() }));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Created empty cache file: ${cacheFile}`, 'eth', collection);
        } else {
          logger.error('utils', `Failed to access cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', collection);
        }
      }
    }

    logger.info('utils', 'Cache initialization completed', 'eth', 'general');
    return true;
  } catch (error) {
    logger.error('utils', `Cache initialization error: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return false;
  }
}

async function retry(operation, { retries, delay = 1000 }) {
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.message.includes('429') && attempt === retries) {
        logger.error('utils', `Circuit breaker: Rate limit exceeded after ${retries} attempts`, {}, 'eth', 'general');
        throw new Error('Rate limit exceeded');
      }
      logger.warn('utils', `Retry attempt ${attempt}/${retries} failed: ${error.message}`, 'eth', 'general');
      await new Promise(resolve => setTimeout(resolve, delay * Math.min(attempt, 3)));
    }
  }
  throw lastError;
}

async function batchMulticall(calls, batchSize = config.alchemy.batchSize || 10) {
  const results = [];
  const delay = async () => new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs || 500));

  const concurrencyLimit = pLimit(3);
  const batchPromises = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    batchPromises.push(
      concurrencyLimit(async () => {
        try {
          await delay();
          const batchResults = await client.multicall({
            contracts: batch.map(call => ({
              address: call.address,
              abi: call.abi,
              functionName: call.functionName,
              args: call.args || [],
            })),
            allowFailure: true,
          });

          const batchResult = batchResults.map((result, index) => ({
            status: result.status === 'success' ? 'success' : 'failure',
            result: result.status === 'success' ? result.result : null,
            error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
          }));
          return batchResult;
        } catch (error) {
          logger.error('utils', `Batch multicall failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
          return batch.map(() => ({
            status: 'failure',
            result: null,
            error: error.message,
          }));
        }
      })
    );
  }

  const batchResults = (await Promise.all(batchPromises)).flat();
  results.push(...batchResults);
  return results;
}

async function getOwnersForContract(contractAddress, abi, options = {}) {
  let owners = [];
  let pageKey = options.pageKey || null;
  const maxPages = options.maxPages || 10;
  let pageCount = 0;

  logger.debug('utils', `Fetching owners for contract: ${contractAddress} with options: ${JSON.stringify(options)}`, 'eth', 'general');

  do {
    try {
      const response = await alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: options.withTokenBalances || false,
        pageKey,
      });

      logger.debug('utils', `Raw Alchemy response: ownersExists=${!!response.owners}, isArray=${Array.isArray(response.owners)}, ownersLength=${response.owners?.length || 0}, pageKey=${response.pageKey || null}, responseKeys=${Object.keys(response)}, sampleOwners=${JSON.stringify(response.owners?.slice(0, 2) || [])}`, 'eth', 'general');

      if (!response.owners || !Array.isArray(response.owners)) {
        logger.error('utils', `Invalid Alchemy response for ${contractAddress}: ${JSON.stringify(response)}`, {}, 'eth', 'general');
        throw new Error('Invalid owners response from Alchemy API');
      }

      for (const owner of response.owners) {
        const tokenBalances = owner.tokenBalances || [];
        logger.debug('utils', `Processing owner: ${owner.ownerAddress}, tokenBalancesCount=${tokenBalances.length}`, 'eth', 'general');

        if (tokenBalances.length > 0) {
          const validBalances = tokenBalances.filter(
            tb => tb.tokenId && Number(tb.balance) > 0
          );
          if (validBalances.length > 0) {
            owners.push({
              ownerAddress: owner.ownerAddress.toLowerCase(),
              tokenBalances: validBalances.map(tb => ({
                tokenId: Number(tb.tokenId),
                balance: Number(tb.balance),
              })),
            });
          }
        }
      }

      pageKey = response.pageKey || null;
      pageCount++;
      logger.debug('utils', `Fetched page ${pageCount}, owners: ${owners.length}, pageKey: ${pageKey}`, 'eth', 'general');

      if (pageCount >= maxPages) {
        logger.warn('utils', `Reached max pages (${maxPages}) for owner fetching`, 'eth', 'general');
        break;
      }
    } catch (error) {
      logger.error('utils', `Failed to fetch owners for ${contractAddress}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      throw error;
    }
  } while (pageKey);

  logger.debug('utils', `Processed owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, 'eth', 'general');
  logger.info('utils', `Fetched ${owners.length} owners for contract: ${contractAddress}`, 'eth', 'general');
  return owners;
}

async function setCache(key, value, ttl, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    const success = cache.set(cacheKey, value);
    logger.info('utils', `Set in-memory cache: ${cacheKey}, success: ${success}, holders: ${value.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          await redis.set(cacheKey, JSON.stringify(value));
          logger.info('utils', `Persisted ${cacheKey} to Redis, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to persist ${cacheKey} to Redis: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      } else {
        const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
        logger.info('utils', `Writing to cache file: ${cacheFile}`, 'eth', prefix.toLowerCase());
        await ensureCacheDir();
        try {
          await fs.writeFile(cacheFile, JSON.stringify(value));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Persisted ${cacheKey} to ${cacheFile}, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to write cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
          throw error;
        }
      }
    }
    return success;
  } catch (error) {
    logger.error('utils', `Failed to set cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return false;
  }
}

async function getCache(key, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    let data = cache.get(cacheKey);
    if (data !== undefined) {
      logger.debug('utils', `Cache hit: ${cacheKey}, holders: ${data.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());
      return data;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          const redisData = await redis.get(cacheKey);
          if (redisData) {
            const parsed = typeof redisData === 'string' ? JSON.parse(redisData) : redisData;
            if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
              const success = cache.set(cacheKey, parsed);
              logger.info('utils', `Loaded ${cacheKey} from Redis, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
              return parsed;
            } else {
              logger.warn('utils', `Invalid data in Redis for ${cacheKey}`, 'eth', prefix.toLowerCase());
            }
          }
        } catch (error) {
          logger.error('utils', `Failed to load cache from Redis for ${cacheKey}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      }

      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        const parsed = JSON.parse(fileData);
        if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
          const success = cache.set(cacheKey, parsed);
          logger.info('utils', `Loaded ${cacheKey} from ${cacheFile}, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
          return parsed;
        } else {
          logger.warn('utils', `Invalid data in ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      } catch (error) {
        if (error.code !== 'ENOENT') {
          logger.error('utils', `Failed to load cache from ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        } else {
          logger.debug('utils', `No cache file at ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      }
    }

    logger.info('utils', `Cache miss: ${cacheKey}`, 'eth', prefix.toLowerCase());
    return null;
  } catch (error) {
    logger.error('utils', `Failed to get cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function saveCacheState(collection, state, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    await ensureCacheDir();
    await fs.writeFile(cacheFile, JSON.stringify(state, null, 2));
    await fs.chmod(cacheFile, 0o644);
    logger.debug('utils', `Saved cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
  } catch (error) {
    logger.error('utils', `Failed to save cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
  }
}

async function loadCacheState(collection, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    const data = await fs.readFile(cacheFile, 'utf8');
    const parsed = JSON.parse(data);
    logger.debug('utils', `Loaded cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
    return parsed;
  } catch (error) {
    if (error.code === 'ENOENT') {
      logger.debug('utils', `No cache state found for ${prefix}, initializing new state`, 'eth', prefix.toLowerCase());
      const defaultState = {
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: {
          step: 'idle',
          processedNfts: 0,
          totalNfts: 0,
          processedTiers: 0,
          totalTiers: 0,
          error: null,
          errorLog: [],
        },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      };
      await saveCacheState(collection, defaultState, prefix);
      return defaultState;
    }
    logger.error('utils', `Failed to load cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function getTransactionReceipt(transactionHash) {
  try {
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    logger.debug('utils', `Fetched transaction receipt for ${transactionHash}`, 'eth', 'general');
    return receipt;
  } catch (error) {
    logger.error('utils', `Failed to fetch transaction receipt for ${transactionHash}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function validateContract(contractKey) {
  const normalizedKey = contractKey.toLowerCase();
  if (!config.contractDetails[normalizedKey]) {
    throw new Error(`Invalid contract: ${normalizedKey}`);
  }
  if (config.contractDetails[normalizedKey].disabled) {
    throw new Error(`${normalizedKey} contract not deployed`);
  }
  const abi = config.abis[normalizedKey]?.nft;
  if (!abi || !Array.isArray(abi)) {
    throw new Error(`${normalizedKey} NFT ABI missing or invalid`);
  }
  const contractAddress = config.contractAddresses[normalizedKey]?.address;
  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    throw new Error(`${normalizedKey} contract address missing or invalid`);
  }
  return {
    contractAddress,
    abi,
  };
}

async function log(scope, message, chain = 'eth', collection = 'general') {
  await logger.info(scope, message, chain, collection);
}

export {
  client,
  retry,
  logger,
  getCache,
  setCache,
  saveCacheState,
  loadCacheState,
  batchMulticall,
  getOwnersForContract,
  getTransactionReceipt,
  initializeCache,
  validateContract,
  log,
};
----- ./app/auctions/page.js -----

// app/auctions/page.js
'use client';
import { useState } from 'react';

export default function Auctions() {
  const [selectedAuction, setSelectedAuction] = useState(null);

  const auctions = [
    { name: 'Ascendant', url: 'https://app.ascendant.win/auction' },
    { name: 'Flare', url: 'https://www.flare.win/auction' },
    { name: 'Shogun', url: 'https://app.shogun.win/auction' },
    { name: 'Blaze', url: 'https://app.titanblaze.win/auction' },
    { name: 'Volt', url: 'https://app.volt.win/auction' },
    { name: 'Vyper', url: 'https://app.vyper.win/auction' },
    { name: 'Flux', url: 'https://app.flux.win/auction' },
    { name: 'Phoenix', url: 'https://app.phoenix.win/' },
    { name: 'Turbo', url: 'https://app.turbo.win/auction' },
    { name: 'GoatX', url: 'https://app.thegoatx.win/auction' },
  ];

  const openModal = (auction) => {
    setSelectedAuction(auction);
  };

  const closeModal = () => {
    setSelectedAuction(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Auctions
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current auctions running in the TitanX ecosystem. Click any auction to view it.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((auction) => (
            <div
              key={auction.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(auction)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {auction.name} Auction
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{auction.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedAuction && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedAuction.name} Auction</h2>
            <iframe
              src={selectedAuction.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedAuction.name} Auction`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}
----- ./app/layout.js -----

// File: app/layout.js

import Navbar from '@/client/components/Navbar';
import '@/app/global.css'; // Target global.css in app directory
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'TitanXUtils',
  description: 'TitanX ecosystem utilities',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en" className="bg-gray-900 text-gray-100">
      <head>
        <title>TitanXUtils</title>
      </head>
      <body className={inter.className}>
        <Navbar />
        <main className="flex-grow container page-content">{children}</main>
        <footer className="footer">
          <p>© {new Date().getFullYear()} TitanXUtils. All rights reserved.</p>
        </footer>
      </body>
    </html>
  );
}
----- ./app/lib/chartOptions.js -----

export const barChartOptions = {
    responsive: true,
    plugins: {
      legend: { position: 'top', labels: { color: '#e5e7eb' } }, // Gray-200
      title: {
        display: true,
        text: 'NFT Tier Distribution',
        color: '#e5e7eb',
        font: { size: 16, weight: 'bold' },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: 'Number of NFTs', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' }, // Gray-300
      },
      x: {
        title: { display: true, text: 'Tiers', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' },
      },
    },
  };
----- ./app/lib/fetchCollectionData.js -----

import config from '@/contracts/config';
import { HoldersResponseSchema, ProgressResponseSchema } from '@/app/lib/schemas';

// Debounce utility to prevent concurrent POST requests
const debounce = (func, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    return new Promise(resolve => {
      timeout = setTimeout(() => resolve(func(...args)), wait);
    });
  };
};

export async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  console.log(`[FetchCollectionData] [INFO] Fetching ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      console.log(`[FetchCollectionData] [INFO] ${apiKey} is disabled`);
      return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Contract not deployed' };
    }

    const endpoint = apiEndpoint.startsWith('http')
      ? apiEndpoint
      : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;

    const pollProgress = async () => {
      const res = await fetch(`${endpoint}/progress`, {
        cache: 'no-store',
        signal: AbortSignal.timeout(config.alchemy.timeoutMs),
      });
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Progress fetch failed: ${res.status} ${errorText}`);
      }
      const progress = await res.json();
      console.log(`[FetchCollectionData] [DEBUG] Progress: ${JSON.stringify(progress)}`);
      const validation = ProgressResponseSchema.safeParse(progress);
      if (!validation.success) {
        console.error(`[FetchCollectionData] [ERROR] Invalid progress data: ${JSON.stringify(validation.error.errors)}`);
        throw new Error('Invalid progress data');
      }
      return validation.data;
    };

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;
    let postAttempts = 0;
    const maxPostAttempts = 5;
    let pollAttempts = 0;
    const maxPollAttempts = 600; // 300 seconds / 500ms = 600 attempts
    const maxPollTime = 300000; // 300 seconds
    const startTime = Date.now();

    // Debounced POST request
    const triggerPost = debounce(async () => {
      console.log(`[FetchCollectionData] [INFO] Triggering POST for ${apiKey}, attempt ${postAttempts + 1}/${maxPostAttempts}`);
      const res = await fetch(endpoint, {
        method: 'POST',
        cache: 'no-store',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ forceUpdate: false }), // Never force update automatically
      });
      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] POST failed: ${res.status} ${errorText}`);
        throw new Error(`POST request failed: ${res.status} ${errorText}`);
      }
      const response = await res.json();
      if (response.error) {
        throw new Error(`POST response error: ${response.error}`);
      }
      console.log(`[FetchCollectionData] [INFO] POST successful: ${JSON.stringify(response)}`);
      return response;
    }, 2000);

    let progress = await pollProgress();
    // Only trigger POST for element280 if phase is Idle and no valid data exists
    if (apiKey === 'element280' && progress.phase === 'Idle' && progress.totalOwners === 0 && progress.lastProcessedBlock === null) {
      if (postAttempts >= maxPostAttempts) {
        console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max POST attempts reached for cache population' };
      }
      try {
        console.log(`[FetchCollectionData] [DEBUG] Sending POST request, attempt ${postAttempts + 1}/${maxPostAttempts}`);
        await triggerPost();
        postAttempts++;
      } catch (error) {
        console.error(`[FetchCollectionData] [ERROR] POST attempt failed: ${error.message}`);
        postAttempts++;
        if (postAttempts >= maxPostAttempts) {
          console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached after error`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Max POST attempts reached: ${error.message}` };
        }
      }
    } else if (apiKey !== 'element280' && (progress.phase === 'Idle' || progress.totalOwners === 0)) {
      // Original POST triggering logic for other contracts
      if (postAttempts >= maxPostAttempts) {
        console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max POST attempts reached for cache population' };
      }
      try {
        console.log(`[FetchCollectionData] [DEBUG] Sending POST request, attempt ${postAttempts + 1}/${maxPostAttempts}`);
        await triggerPost();
        postAttempts++;
      } catch (error) {
        console.error(`[FetchCollectionData] [ERROR] POST attempt failed: ${error.message}`);
        postAttempts++;
        if (postAttempts >= maxPostAttempts) {
          console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached after error`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Max POST attempts reached: ${error.message}` };
        }
      }
    }

    while (progress.phase !== 'Completed' && progress.phase !== 'Error') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[FetchCollectionData] [ERROR] Cache population timeout for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Cache population timed out' };
      }
      if (pollAttempts >= maxPollAttempts) {
        console.error(`[FetchCollectionData] [ERROR] Max poll attempts (${maxPollAttempts}) reached for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max poll attempts reached' };
      }
      console.log(`[FetchCollectionData] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%), poll attempt ${pollAttempts + 1}/${maxPollAttempts}`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      try {
        progress = await pollProgress();
      } catch (error) {
        console.error(`[FetchCollectionData] [ERROR] Poll attempt failed: ${error.message}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Polling failed: ${error.message}` };
      }
      pollAttempts++;
    }

    if (progress.phase === 'Error') {
      console.error(`[FetchCollectionData] [ERROR] Cache population failed for ${apiKey}: ${progress.error || 'Unknown error'}`);
      return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Cache population failed: ${progress.error || 'Unknown error'}` };
    }

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      console.log(`[FetchCollectionData] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      console.log(`[FetchCollectionData] [DEBUG] Status: ${res.status}, headers: ${JSON.stringify([...res.headers])}`);

      if (res.status === 202) {
        console.log(`[FetchCollectionData] [INFO] Cache still populating for ${apiKey}, retrying...`);
        await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
        continue;
      }

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] Failed: ${res.status} ${errorText}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `API request failed: ${res.status} ${errorText}` };
      }

      const json = await res.json();
      console.log(`[FetchCollectionData] [DEBUG] Response: ${JSON.stringify(json, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);

      if (json.error) {
        console.error(`[FetchCollectionData] [ERROR] API error for ${apiKey}: ${json.error}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: json.error };
      }

      const validation = HoldersResponseSchema.safeParse(json);
      if (!validation.success) {
        console.error(`[FetchCollectionData] [ERROR] Invalid holders data: ${JSON.stringify(validation.error.errors)}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Invalid holders data' };
      }

      allHolders = allHolders.concat(json.holders);
      totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
      totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
      totalBurned = json.totalBurned || totalBurned;
      summary = json.summary || summary;
      totalPages = json.totalPages || 1;
      page++;
      console.log(`[FetchCollectionData] [INFO] Fetched page ${page}: ${json.holders.length} holders`);
    }

    return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
  } catch (error) {
    console.error(`[FetchCollectionData] [ERROR] ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: error.message };
  }
}
----- ./app/lib/logger.js -----

import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

// Use process.cwd() to reference the project root
const logDir = path.join(process.cwd(), 'logs');

console.log(chalk.cyan('[Logger] Initializing logger...'));
console.log(chalk.cyan('[Logger] process.env.DEBUG:'), process.env.DEBUG);
console.log(chalk.cyan('[Logger] process.env.NODE_ENV:'), process.env.NODE_ENV);
console.log(chalk.cyan('[Logger] Log directory:'), logDir);

const isDebug = process.env.DEBUG === 'true';
console.log(chalk.cyan('[Logger] isDebug:'), isDebug);

async function ensureLogDir() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log(chalk.cyan('[Logger] Created or verified log directory:'), logDir);
  } catch (error) {
    console.error(chalk.red('[Logger] Failed to create log directory:'), error.message);
  }
}

ensureLogDir().catch(error => {
  console.error(chalk.red('[Logger] ensureLogDir error:'), error.message);
});

export const logger = {
  info: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [INFO] ${message}`;
    console.log(chalk.green(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote INFO log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write INFO log:'), error.message);
      }
    }
  },
  warn: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [WARN] ${message}`;
    console.log(chalk.yellow(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote WARN log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write WARN log:'), error.message);
      }
    }
  },
  error: async (scope, message, details = {}, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [ERROR] ${message} ${JSON.stringify(details)}`;
    console.error(chalk.red(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote ERROR log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write ERROR log:'), error.message);
      }
    }
  },
  debug: async (scope, message, chain = 'eth', collection = 'general') => {
    if (!isDebug) return;
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [DEBUG] ${message}`;
    console.log(chalk.blue(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
      console.log(chalk.cyan('[Logger] Wrote DEBUG log to:'), logFile);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write DEBUG log:'), error.message);
    }
  },
};

try {
  logger.info('startup', 'Logger module loaded').catch(error => {
    console.error(chalk.red('[Logger] Startup log error:'), error.message);
  });
} catch (error) {
  console.error(chalk.red('[Logger] Immediate log error:'), error.message);
}
----- ./app/lib/schemas.js -----

import { z } from 'zod';

export const HoldersResponseSchema = z.object({
  holders: z.array(
    z.object({
      wallet: z.string(),
      tokenIds: z.array(z.number()),
      tiers: z.array(z.number()),
      total: z.number(),
      multiplierSum: z.number(),
      shares: z.number().optional(),
      lockedAscendant: z.number().optional(),
      claimableRewards: z.number().optional(),
      pendingDay8: z.number().optional(),
      pendingDay28: z.number().optional(),
      pendingDay90: z.number().optional(),
      infernoRewards: z.number().optional(),
      fluxRewards: z.number().optional(),
      e280Rewards: z.number().optional(),
      percentage: z.number().optional(),
      displayMultiplierSum: z.number().optional(),
      rank: z.number(),
      tokens: z.array(
        z.object({
          tokenId: z.number(),
          tier: z.number(),
          rawTier: z.number().optional(), // Added for debugging
          rarityNumber: z.number(),
          rarity: z.number()
        })
      ).optional()
    })
  ),
  totalPages: z.number(),
  totalTokens: z.number(),
  totalBurned: z.number().nullable(),
  summary: z.object({
    totalLive: z.number(),
    totalBurned: z.number().nullable(),
    totalMinted: z.number(),
    tierDistribution: z.array(z.number()),
    multiplierPool: z.number(),
    rarityDistribution: z.array(z.number()).optional()
  }),
  globalMetrics: z.object({}).optional(),
  contractKey: z.string().optional(),
}).refine(
  (data) => {
    const contractKey = data.contractKey?.toLowerCase();
    if (['stax', 'element280', 'element369'].includes(contractKey)) {
      return typeof data.totalBurned === 'number' && data.totalBurned >= 0 && data.summary != null;
    }
    return true;
  },
  {
    message: 'totalBurned must be a non-negative number and summary must exist for stax, element280, and element369',
    path: ['totalBurned', 'summary'],
  }
);

export const ProgressResponseSchema = z.object({
  isPopulating: z.boolean(),
  totalLiveHolders: z.number(),
  totalOwners: z.number(),
  phase: z.string(),
  progressPercentage: z.string(),
  lastProcessedBlock: z.number().nullable(),
  lastUpdated: z.number().nullable(),
  error: z.string().nullable(),
  errorLog: z.array(z.any()),
  globalMetrics: z.object({}).optional(),
});
----- ./app/lib/serverInit.js -----

// File: server/lib/serverInit.js
import { logger } from '@/app/lib/logger';
import { initializeCache } from '@/app/api new code/utils';
import chalk from 'chalk';

console.log(chalk.cyan('[ServerInit] Initializing server...'));

try {
  logger.info('serverInit', 'Server initialization started');
  await initializeCache();
} catch (error) {
  logger.error('serverInit', `Initialize cache error: ${error.message}`, { stack: error.stack });
  console.error(chalk.red('[ServerInit] Initialization error:'), error.message);
}

export const serverInit = true;
----- ./app/lib/useNFTData.js -----

// client/lib/useNFTData.js
'use client';
import { useQuery } from '@tanstack/react-query';
import { useNFTStore } from '@/app/store';
import config from '@/contracts/config';
import { HoldersResponseSchema } from '@/app/lib/schemas';

async function fetchNFTData(apiKey, apiEndpoint, pageSize, page = 0) {
  if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
    return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Contract not deployed' };
  }

  const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;
  const progressUrl = `${endpoint}/progress`;

  const progressRes = await fetch(progressUrl, { cache: 'no-store' });
  if (!progressRes.ok) throw new Error(`Progress fetch failed: ${progressRes.status}`);
  const progress = await progressRes.json();

  if (progress.isPopulating || progress.phase !== 'Completed') {
    throw new Error('Cache is populating');
  }

  let allHolders = [];
  let totalTokens = 0;
  let totalShares = 0;
  let totalBurned = 0;
  let summary = {};
  let totalPages = Infinity;

  while (page < totalPages) {
    const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error(`API request failed: ${res.status}`);
    const json = await res.json();

    if (json.message === 'Cache is populating' || json.isCachePopulating) {
      throw new Error('Cache is populating');
    }

    const validation = HoldersResponseSchema.safeParse(json);
    if (!validation.success) {
      throw new Error(`Invalid holders schema: ${JSON.stringify(validation.error.errors)}`);
    }

    allHolders = allHolders.concat(json.holders);
    totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
    totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
    totalBurned = json.totalBurned || totalBurned;
    summary = json.summary || summary;
    totalPages = json.totalPages || 1;
    page++;
  }

  return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
}

export function useNFTData(apiKey, pageSize) {
  const { getCache, setCache } = useNFTStore();

  return useQuery({
    queryKey: ['nft', apiKey],
    queryFn: async () => {
      const cachedData = getCache(apiKey);
      if (cachedData) return cachedData;

      const data = await fetchNFTData(apiKey, config.contractDetails[apiKey].apiEndpoint, pageSize);
      setCache(apiKey, data);
      return data;
    },
    retry: config.alchemy.maxRetries,
    retryDelay: attempt => config.alchemy.batchDelayMs * (attempt + 1),
    staleTime: 30 * 60 * 1000, // 30 minutes
    refetchInterval: progress => (progress?.isPopulating ? 2000 : false),
    onError: error => console.error(`[useNFTData] [ERROR] ${apiKey}: ${error.message}`),
  });
}
----- ./app/mining/page.js -----

// app/mining/page.js
'use client';
import { useState } from 'react';

export default function Mining() {
  const [selectedMine, setSelectedMine] = useState(null);

  const auctions = [
    { name: 'TitanX', url: 'https://app.titanx.win/mine' },
    { name: 'Hyper', url: 'https://app.hyper.win/mine' },
    { name: 'Hydra', url: 'https://app.hydra.win/mine' },
    { name: 'Helios', url: 'https://app.helios.win/mine' },
    { name: 'Bonfire', url: 'https://www.bonfire.win/dapp' },
    { name: 'Eden', url: 'https://www.eden.win/mine' },
    { name: 'Lotus', url: 'https://lotus.win/mine' },
  ];

  const openModal = (mine) => {
    setSelectedMine(mine);
  };

  const closeModal = () => {
    setSelectedMine(null);
  };

  const handleBackgroundClick = (e) => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-center mb-6">
          TitanX Ecosystem Mining
        </h1>
        <p className="mt-4 text-lg sm:text-xl text-gray-300 text-center max-w-2xl mx-auto">
          Explore the current mining options available in the TitanX ecosystem.
        </p>
        <div className="mt-12 grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {auctions.map((mine) => (
            <div
              key={mine.name}
              className="bg-gray-800 rounded-lg shadow-md p-6 hover:bg-gray-700 
                transition-all duration-200 hover:shadow-lg transform hover:-translate-y-1"
            >
              <button
                onClick={() => openModal(mine)}
                className="text-blue-400 hover:text-blue-300 text-xl font-semibold 
                  transition-colors duration-200 text-left w-full"
              >
                {mine.name} Mining
              </button>
              <p className="text-gray-400 mt-2 text-sm truncate">
                <span className="hover:underline">{mine.url}</span>
              </p>
            </div>
          ))}
        </div>
      </main>

      {selectedMine && (
        <div
          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
          onClick={handleBackgroundClick}
        >
          <div className="bg-gray-900 rounded-lg p-4 w-full max-w-4xl h-[80vh] relative">
            <button
              onClick={closeModal}
              className="absolute top-2 right-2 text-gray-300 hover:text-white 
                bg-gray-800 rounded-full w-8 h-8 flex items-center justify-center"
            >
              ✕
            </button>
            <h2 className="text-2xl font-bold text-white mb-4">{selectedMine.name} Mine</h2>
            <iframe
              src={selectedMine.url}
              className="w-full h-[calc(100%-4rem)] border-0 rounded"
              title={`${selectedMine.name} Mine`}
              allowFullScreen
            />
          </div>
        </div>
      )}
    </div>
  );
}
----- ./app/nft/[chain]/[contract]/page.js -----

// ./app/nft/[chain]/[contract]/page.js
'use client';
import { useState, useEffect } from 'react';
import { notFound } from 'next/navigation';
import nextDynamic from 'next/dynamic';
import config from '@/contracts/config';
import LoadingIndicator from '@/client/components/LoadingIndicator';
import { useNFTStore } from '@/app/store';
import { HoldersResponseSchema } from '@/app/lib/schemas';
import * as React from 'react';
import { z } from 'zod'; // Import Zod for schema validation

const NFTPageWrapper = nextDynamic(() => import('@/client/components/NFTPageWrapper'), { ssr: false });
export const dynamic = 'force-dynamic';

// Schema for progress endpoint response
const ProgressResponseSchema = z.object({
  isPopulating: z.boolean(),
  totalLiveHolders: z.number(),
  totalOwners: z.number(),
  phase: z.string(),
  progressPercentage: z.string(),
  lastProcessedBlock: z.number().nullable(),
  error: z.any().nullable(),
  errorLog: z.array(z.any()),
});

async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  console.log(`[NFTContractPage] [INFO] Fetching data for ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      console.log(`[NFTContractPage] [INFO] ${apiKey} is disabled`);
      return { error: `${apiKey} is not available` };
    }

    const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
    const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${baseUrl}${apiEndpoint}`;

    const pollProgress = async () => {
      const progressUrl = `${endpoint}/progress`;
      const res = await fetch(progressUrl, { cache: 'no-store', signal: AbortSignal.timeout(config.alchemy.timeoutMs) });
      if (!res.ok) throw new Error(`Progress fetch failed: ${res.status}`);
      const progress = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Progress: ${JSON.stringify(progress)}`);

      // Validate progress response
      const validation = ProgressResponseSchema.safeParse(progress);
      if (!validation.success) {
        console.error(`[NFTContractPage] [ERROR] Invalid progress data: ${JSON.stringify(validation.error.errors)}`);
        throw new Error('Invalid progress data');
      }
      return validation.data;
    };

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;

    const maxPollTime = 180000; // 180 seconds
    const startTime = Date.now();
    let progress = await pollProgress();

    while (progress.isPopulating || progress.phase !== 'Completed') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[NFTContractPage] [ERROR] Cache population timeout for ${apiKey}`);
        return { error: 'Cache population timed out' };
      }
      console.log(`[NFTContractPage] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%)`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      progress = await pollProgress();
      if (progress.phase === 'Error') {
        console.error(`[NFTContractPage] [ERROR] Cache population failed: ${progress.error || 'Unknown error'}`);
        return { error: `Cache population failed: ${progress.error || 'Unknown error'}` };
      }
    }

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      console.log(`[NFTContractPage] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      console.log(`[NFTContractPage] [DEBUG] Response status: ${res.status}`);

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[NFTContractPage] [ERROR] Failed to fetch ${url}: ${res.status} ${errorText}`);
        return { error: `Failed to fetch data: ${res.status}` };
      }

      const json = await res.json();
      console.log(`[NFTContractPage] [DEBUG] Response body: ${JSON.stringify(json, (key, value) => typeof value === 'bigint' ? value.toString() : value)}`);

      if (json.isCachePopulating) {
        return { isCachePopulating: true, progress }; // Trigger polling
      }

      const validation = HoldersResponseSchema.safeParse(json);
      if (!validation.success) {
        console.error(`[NFTContractPage] [ERROR] Invalid holders data: ${JSON.stringify(validation.error.errors)}`);
        if (apiKey === 'ascendant') {
          console.log(`[NFTContractPage] [INFO] Triggering POST for ${apiKey}`);
          await fetch(endpoint, { method: 'POST', cache: 'no-store', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ forceUpdate: false }) });
          const retryRes = await fetch(url, { cache: 'no-store' });
          if (!retryRes.ok) {
            const retryError = await retryRes.text();
            console.error(`[NFTContractPage] [ERROR] Retry failed: ${retryRes.status} ${retryError}`);
            return { error: `Retry failed: ${retryRes.status}` };
          }
          const retryJson = await retryRes.json();
          const retryValidation = HoldersResponseSchema.safeParse(retryJson);
          if (!retryValidation.success) {
            console.error(`[NFTContractPage] [ERROR] Retry invalid holders data: ${JSON.stringify(retryValidation.error.errors)}`);
            return { error: 'Invalid holders data after retry' };
          }
          json.holders = retryJson.holders;
          json.totalTokens = retryJson.totalTokens;
          json.totalShares = retryJson.totalShares;
          json.totalBurned = retryJson.totalBurned;
          json.summary = retryJson.summary;
          json.totalPages = retryJson.totalPages;
        } else {
          return { error: 'Invalid holders data' };
        }
      }

      allHolders = allHolders.concat(json.holders);
      totalTokens = json.totalTokens || totalTokens;
      totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
      totalBurned = json.totalBurned || totalBurned;
      summary = json.summary || summary;
      totalPages = json.totalPages || 1;
      page++;
      console.log(`[NFTContractPage] [INFO] Fetched page ${page} for ${apiKey}: ${json.holders.length} holders`);
    }

    return {
      holders: allHolders,
      totalTokens,
      totalShares,
      totalBurned,
      summary,
    };
  } catch (error) {
    console.error(`[NFTContractPage] [ERROR] Error fetching ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { error: error.message };
  }
}

export default function NFTContractPage({ params }) {
  const { chain, contract } = React.use(params);
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [progress, setProgress] = useState(null);

  const { getCache, setCache } = useNFTStore();

  const apiKeyMap = {
    Element280: 'element280',
    Element369: 'element369',
    Stax: 'stax',
    Ascendant: 'ascendant',
    E280: 'e280',
  };
  const apiKey = apiKeyMap[contract];

  useEffect(() => {
    if (!config.supportedChains.includes(chain) || !apiKey) {
      console.log(`[NFTContractPage] [ERROR] Invalid chain=${chain} or contract=${contract}`);
      notFound();
    }

    async function fetchData() {
      setLoading(true);
      setError(null);
      setData(null);

      const contractConfig = config.contractDetails[apiKey] || {};
      const cacheKey = `contract_${apiKey}`;
      const cachedData = getCache(cacheKey);

      if (cachedData) {
        console.log(`[NFTContractPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      console.log(`[NFTContractPage] [INFO] Cache miss for ${cacheKey}, fetching data`);
      const result = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);

      if (result.isCachePopulating) {
        const poll = async () => {
          const progressResult = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);
          setProgress(progressResult.progress);
          if (progressResult.isCachePopulating) {
            setTimeout(poll, config.alchemy.batchDelayMs);
          } else if (progressResult.error) {
            setError(progressResult.error);
            setLoading(false);
          } else {
            setCache(cacheKey, progressResult);
            setData(progressResult);
            setLoading(false);
          }
        };
        poll();
      } else if (result.error) {
        setError(result.error);
        setLoading(false);
      } else {
        setCache(cacheKey, result);
        setData(result);
        setLoading(false);
      }
    }

    fetchData();
  }, [chain, contract, apiKey, getCache, setCache]);

  if (!config.supportedChains.includes(chain) || !apiKey) {
    notFound();
  }

  if (loading) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{contract} Collection</h1>
        <LoadingIndicator
          status={`Loading ${contract} data... ${progress ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''}`}
          progress={progress}
        />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{contract} Collection</h1>
        <p className="text-error">{error}</p>
      </div>
    );
  }

  return (
    <div className="container page-content">
      <h1 className="title mb-6">{contract} Collection</h1>
      <NFTPageWrapper
        chain={chain}
        contract={apiKey}
        data={data}
        rewardToken={config.contractDetails[apiKey]?.rewardToken}
      />
    </div>
  );
}
----- ./app/nft/layout.js -----

// File: app/nft/layout.js
'use client';
import Navbar from '@/client/components/Navbar';
import NFTLayoutWrapper from '@/client/components/NFTLayoutWrapper';
import '@/app/global.css'; // Target global.css in app directory
import { Inter } from 'next/font/google';
import { Suspense } from 'react';

const inter = Inter({ subsets: ['latin'] });

export default function NFTLayout({ children }) {
  return (
    <NFTLayoutWrapper>
      <main className={`flex-grow container page-content ${inter.className}`}>
        <Suspense fallback={<div>Loading...</div>}>
          {children}
        </Suspense>
      </main>
      <footer className="footer">
        <p>© {new Date().getFullYear()} TitanXUtils. All rights reserved.</p>
      </footer>
    </NFTLayoutWrapper>
  );
}
----- ./app/nft/page.js -----

// app/nft/page.js
'use client';
import { motion } from 'framer-motion';
import { fetchCollectionData } from '@/app/lib/fetchCollectionData';
import config from '@/contracts/config';
import LoadingIndicator from '@/client/components/LoadingIndicator';
import NFTSummary from '@/client/components/NFTSummary';
import React from 'react';


const collections = Object.entries(config.contractDetails).map(([apiKey, { name, apiEndpoint, pageSize, disabled }]) => ({
  apiKey,
  name,
  apiEndpoint,
  pageSize,
  disabled,
}));

export default function NFTOverview() {
  const [collectionsData, setCollectionsData] = React.useState([]);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(null);

  const handleCollectionClick = async (apiKey, apiEndpoint, pageSize, disabled) => {
    if (disabled) return;
    setLoading(true);
    setError(null);
    try {
      const data = await fetchCollectionData(apiKey, apiEndpoint, pageSize);
      if (data.error) {
        setError(data.error);
      } else {
        setCollectionsData([{ apiKey, data }]);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100 p-6 flex flex-col items-center">
      <h1 className="title mb-6">NFT Collections</h1>
      <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl mb-6">
        {collections.map(({ apiKey, name, apiEndpoint, pageSize, disabled }) => (
          <motion.button
            key={apiKey}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleCollectionClick(apiKey, apiEndpoint, pageSize, disabled)}
            className={`btn btn-secondary w-full ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
            disabled={disabled}
          >
            {name}
          </motion.button>
        ))}
      </div>
      {loading && <LoadingIndicator status="Loading collection..." />}
      {error && <p className="text-error">{error}</p>}
      {collectionsData.some(c => c.data.error?.includes('Cache is populating') || c.data.error?.includes('Failed to fetch cache progress') || c.data.error?.includes('timed out')) && (
        <p className="text-body">Data is being loaded, please wait a moment...</p>
      )}
      {collectionsData.length > 0 && !loading && <NFTSummary collectionsData={collectionsData} />}
    </div>
  );
}
----- ./app/page.js -----

// app/page.js

'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-gray-100">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-body">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, mining, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4">
                <motion.div
                  className="inline-block bg-orange-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-orange-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/nft">NFT Protocols</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-blue-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-blue-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/auctions">TitanX Auctions</Link>
                </motion.div>
                <motion.div
                  className="inline-block bg-green-500 text-gray-100 px-6 py-3 rounded-lg shadow-lg hover:bg-green-600 transition-colors duration-200"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Link href="/mining">Mining</Link>
                </motion.div>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}
----- ./app/store.js -----

// File: app/store.js

'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {},
  setCache: (contractKey, data) => {
    const key = `nft:${contractKey}`;
    console.log(`[NFTStore] Setting cache for ${key}: ${data.holders?.length || 0} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [key]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const key = `nft:${contractKey}`;
    console.log(`[NFTStore] Getting cache for ${key}`);
    const cachedEntry = get().cache[key];
    if (!cachedEntry) {
      console.log(`[NFTStore] Cache miss for ${key}`);
      return null;
    }
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${key}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[key];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Cache hit for ${key}: ${cachedEntry.data.holders?.length || 0} holders`);
    return cachedEntry.data;
  },
}));
----- ./client/components/HolderTable/Ascendant.js -----

'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/contracts/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalShares, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const ascendantTierOrder = [
    { tierId: '8', name: 'Tier 8', index: 7 },
    { tierId: '7', name: 'Tier 7', index: 6 },
    { tierId: '6', name: 'Tier 6', index: 5 },
    { tierId: '5', name: 'Tier 5', index: 4 },
    { tierId: '4', name: 'Tier 4', index: 3 },
    { tierId: '3', name: 'Tier 3', index: 2 },
    { tierId: '2', name: 'Tier 2', index: 1 },
    { tierId: '1', name: 'Tier 1', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0xF98f0ee190d9f2E6531E226933f1E47a2890CbDA';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Ascendant] Holder Data for Wallet:', targetHolder);
      console.log('[Ascendant] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Ascendant] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = ascendantTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId)]) ||
          (Array.isArray(targetHolder.tiers) && targetHolder.tiers[Number(tier.tierId) - 1]) ||
          (targetHolder.tiers && typeof targetHolder.tiers === 'object' && targetHolder.tiers[tier.tierId]) ||
          0;
        return { tier: tier.name, count };
      });
      console.log('[Ascendant] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Ascendant] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 8) {
        console.warn('[Ascendant] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 8');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Ascendant] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
                {ascendantTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {ascendantTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.ascendant;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Ascendant.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
          <p><strong>Total Shares:</strong> {totalShares?.toLocaleString() || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">% Share of Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">Shares</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY8 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY28 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">DAY90 Rewards</th>
            {ascendantTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {totalShares ? ((holder.shares || 0) / totalShares * 100).toFixed(2) : '0.00'}%
              </td>
              <td className="table-cell">
                {Math.floor(holder.shares || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay8 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay28 || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {Math.floor(holder.pendingDay90 || 0).toLocaleString()}
              </td>
              {ascendantTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId)]) ||
                    (Array.isArray(holder.tiers) && holder.tiers[Number(tier.tierId) - 1]) ||
                    (holder.tiers && typeof holder.tiers === 'object' && holder.tiers[tier.tierId]) ||
                    0
                  }
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);
----- ./client/components/HolderTable/E280.js -----

'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/contracts/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const e280TierOrder = [
    { tierId: '1', name: 'Common' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '6', name: 'Legendary Amped' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {e280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {e280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.e280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for E280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {e280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {e280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);
----- ./client/components/HolderTable/Element280.js -----

'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/contracts/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const element280TierOrder = [
    { tierId: '6', name: 'Legendary Amped' },
    { tierId: '5', name: 'Legendary' },
    { tierId: '4', name: 'Rare Amped' },
    { tierId: '2', name: 'Common Amped' },
    { tierId: '3', name: 'Rare' },
    { tierId: '1', name: 'Common' },
  ];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element280TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element280TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element280;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element280.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element280TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {(holder.claimableRewards || 0).toFixed(2).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.displayMultiplierSum === 'number' ? holder.displayMultiplierSum.toFixed(2) : '-'}
              </td>
              {element280TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {holder.tiers?.[Number(tier.tierId) - 1] || 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);
----- ./client/components/HolderTable/Element369.js -----

'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/contracts/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

const element369TierOrder = config.contractTiers.element369.tierOrder || [
  { tierId: '3', name: 'Legendary' },
  { tierId: '2', name: 'Rare' },
  { tierId: '1', name: 'Common' },
];

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Flux Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">E280 Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {element369TierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {element369TierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.element369;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Element369.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Inferno Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">Flux Rewards</th>
            <th className="reward-cell w-[80px] md:w-[120px]">E280 Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {element369TierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="reward-cell">
                {(holder.infernoRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.fluxRewards || 0).toLocaleString()}
              </td>
              <td className="reward-cell">
                {(holder.e280Rewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {(holder.percentage || 0).toFixed(2)}%
              </td>
              <td className="table-cell">
                {(holder.multiplierSum || 0).toFixed(2)}
              </td>
              {element369TierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? holder.tiers[Number(tier.tierId) - 1] || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);
----- ./client/components/HolderTable/Stax.js -----

'use client';

import { memo } from 'react';
import { motion } from 'framer-motion';
import config from '@/contracts/config.js';

const rowVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3 } },
};

function HolderTable({ holders, loading, totalTokens, rewardToken }) {
  const safeHolders = Array.isArray(holders) ? holders.filter(h => h && h.wallet) : [];

  const staxTierOrder = [
    { tierId: '12', name: 'Legendary LFG', index: 11 },
    { tierId: '11', name: 'Legendary Super', index: 10 },
    { tierId: '10', name: 'Legendary Amped', index: 9 },
    { tierId: '9', name: 'Legendary', index: 8 },
    { tierId: '8', name: 'Rare LFG', index: 7 },
    { tierId: '7', name: 'Rare Super', index: 6 },
    { tierId: '6', name: 'Rare Amped', index: 5 },
    { tierId: '5', name: 'Rare', index: 4 },
    { tierId: '4', name: 'Common LFG', index: 3 },
    { tierId: '3', name: 'Common Super', index: 2 },
    { tierId: '2', name: 'Common Amped', index: 1 },
    { tierId: '1', name: 'Common', index: 0 },
  ];

  // Debugging: Log holders data for the specific wallet
  if (safeHolders.length) {
    const targetWallet = '0x15702443110894B26911B913b17ea4931F803B02';
    const targetHolder = safeHolders.find(h => h.wallet.toLowerCase() === targetWallet.toLowerCase());
    if (targetHolder) {
      console.log('[Stax] Holder Data for Wallet:', targetHolder);
      console.log('[Stax] Tiers Raw Data:', targetHolder.tiers);
      console.log('[Stax] Tiers Length:', targetHolder.tiers?.length);
      const tierCounts = staxTierOrder.map(tier => {
        const count =
          (Array.isArray(targetHolder.tiers) && Number(targetHolder.tiers[Number(tier.tierId) - 1]) || 0);
        return { tier: tier.name, count };
      });
      console.log('[Stax] Computed Tier Counts:', tierCounts);
      const tierSum = tierCounts.reduce((sum, { count }) => sum + Number(count), 0);
      console.log('[Stax] Tier Sum vs Total NFTs:', { tierSum, total: targetHolder.total });
      const multipliers = {
        '12': 200, '11': 140, '10': 120, '9': 100, '8': 20, '7': 14, '6': 12, '5': 10,
        '4': 2, '3': 1.4, '2': 1.2, '1': 1
      };
      const expectedMultiplierSum = tierCounts.reduce((sum, { count }, idx) => {
        const tierId = staxTierOrder[idx].tierId;
        return sum + count * multipliers[tierId];
      }, 0);
      console.log('[Stax] Multiplier Sum:', {
        actual: targetHolder.multiplierSum,
        expected: expectedMultiplierSum
      });
      if (targetHolder.tiers?.length && targetHolder.tiers.length !== 12) {
        console.warn('[Stax] Warning: Unexpected tiers array length:', targetHolder.tiers.length, 'Expected: 12');
      }
      if (tierSum !== targetHolder.total) {
        console.warn('[Stax] Warning: Tier sum does not match Total NFTs for wallet', targetWallet);
      }
      if (targetHolder.multiplierSum !== expectedMultiplierSum) {
        console.warn('[Stax] Warning: Multiplier sum mismatch for wallet', targetWallet, {
          actual: targetHolder.multiplierSum,
          expected: expectedMultiplierSum
        });
      }
    } else {
      console.warn('[Stax] Warning: Wallet not found in holders:', targetWallet);
    }
  }

  if (!safeHolders.length) {
    if (loading) {
      return (
        <div className="table-container">
          <table className="table">
            <thead className="table-head">
              <tr>
                <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
                <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
                <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
                <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
                <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
                {staxTierOrder.map(tier => (
                  <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                    {tier.name}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="table-body">
              {Array(5).fill().map((_, i) => (
                <motion.tr
                  key={i}
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: i * 0.1, duration: 0.5 }}
                  className="table-row table-pulse"
                >
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  <td className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  {staxTierOrder.map(tier => (
                    <td key={tier.tierId} className="table-cell"><div className="table-pulse-placeholder"></div></td>
                  ))}
                </motion.tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }
    return <div className="text-body text-center py-4 w-full">No holders found.</div>;
  }

  const tiers = config.contractTiers.stax;
  if (!tiers) {
    return <div className="text-error text-center py-4 w-full">Error: Contract tiers not found for Stax.</div>;
  }

  return (
    <div className="table-container">
      {safeHolders.length > 0 && (
        <div className="text-body mb-4">
          <p><strong>Total Tokens:</strong> {totalTokens?.toLocaleString() || 'N/A'}</p>
          <p><strong>Reward Token:</strong> {rewardToken || 'N/A'}</p>
        </div>
      )}
      <table className="table">
        <thead className="table-head">
          <tr>
            <th className="table-cell w-[60px] md:w-[80px] rounded-tl-lg">Rank</th>
            <th className="table-cell w-[120px] md:w-[200px]">Wallet</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total NFTs</th>
            <th className="table-cell w-[80px] md:w-[120px]">Claimable Rewards</th>
            <th className="table-cell w-[80px] md:w-[120px]">Reward %</th>
            <th className="table-cell w-[80px] md:w-[120px]">Total Multiplier</th>
            {staxTierOrder.map(tier => (
              <th key={tier.tierId} className="table-cell w-[80px] md:w-[120px]">
                {tier.name}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="table-body">
          {safeHolders.map((holder, index) => (
            <motion.tr
              key={holder.wallet}
              variants={rowVariants}
              initial="hidden"
              animate="visible"
              whileHover={{ scale: 1.02 }}
              transition={{ delay: index * 0.05 }}
              className={`table-row ${index % 2 === 0 ? 'table-row-even' : 'table-row-odd'}`}
            >
              <td className="table-cell">{holder.rank || '-'}</td>
              <td className="table-cell">
                <a
                  href={`https://etherscan.io/address/${holder.wallet}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="table-link"
                >
                  {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                </a>
              </td>
              <td className="table-cell">{holder.total || 0}</td>
              <td className="table-cell">
                {Math.floor(holder.claimableRewards || 0).toLocaleString()}
              </td>
              <td className="table-cell">
                {typeof holder.percentage === 'number' ? holder.percentage.toFixed(2) + '%' : '-'}
              </td>
              <td className="table-cell">
                {typeof holder.multiplierSum === 'number' ? holder.multiplierSum.toFixed(2) : '-'}
              </td>
              {staxTierOrder.map(tier => (
                <td key={tier.tierId} className="table-cell">
                  {Array.isArray(holder.tiers) ? Number(holder.tiers[Number(tier.tierId) - 1]) || 0 : 0}
                </td>
              ))}
            </motion.tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default memo(HolderTable);
----- ./client/components/HolderTable/index.js -----

// client/components/HolderTable/index.js
'use client';

import Element280 from './Element280';
import Element369 from './Element369';
import Stax from './Stax';
import Ascendant from './Ascendant';
import E280 from './E280';

const HolderTable = ({ chain, contract, holders, totalTokens, totalShares, rewardToken, totalBurned }) => {
  const components = {
    element280: Element280,
    element369: Element369,
    stax: Stax,
    ascendant: Ascendant,
    e280: E280,
  };

  const TableComponent = components[contract];
  if (!TableComponent) {
    return <div>Invalid contract: {contract}</div>;
  }

  return (
    <TableComponent
      chain={chain}
      holders={holders}
      totalTokens={totalTokens}
      totalShares={totalShares}
      rewardToken={rewardToken}
      totalBurned={totalBurned}
    />
  );
};

export default HolderTable;
----- ./client/components/LoadingIndicator.js -----

import { memo } from 'react';

function LoadingIndicator({ status, progress }) {
  return (
    <div className="flex flex-col items-center justify-center p-6 bg-gray-800 rounded-lg">
      <svg className="animate-spin h-8 w-8 text-blue-500" viewBox="0 0 24 24">
        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z" />
      </svg>
      <p className="mt-4 text-gray-200">{status}</p>
      {progress && (
        <div className="mt-2 w-64 bg-gray-700 rounded-full h-2.5">
          <div
            className="bg-blue-600 h-2.5 rounded-full"
            style={{ width: `${progress.progressPercentage}%` }}
          />
        </div>
      )}
    </div>
  );
}

export default memo(LoadingIndicator);
----- ./client/components/NFTLayout.js -----

// File: components/NFTLayout.js

'use client';

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import dynamic from 'next/dynamic';
import config from '@/contracts/config.js';
import { useNFTStore } from '@/app/store';

// Dynamically import SearchResultsModal
const SearchResultsModal = dynamic(() => import('@/client/components/SearchResultsModal'), { ssr: false });

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isClient, setIsClient] = useState(false);

  const { getCache, setCache } = useNFTStore();

  useEffect(() => {
    setIsClient(true);
  }, []);

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'stax' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendant' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(config.contractDetails).map((key) => ({
    name: config.contractDetails[key].name,
    apiKey: key,
    href:
      key === 'e280'
        ? null
        : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${config.contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (apiKey, apiEndpoint, pageSize) => {
    console.log(`[NFTLayout] Fetching data for ${apiKey} from ${apiEndpoint}`);
    try {
      if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
        console.log(`[NFTLayout] ${apiKey} is disabled`);
        return { error: `${apiKey} is not available` };
      }

      let endpoint = apiEndpoint;
      if (!endpoint || !endpoint.startsWith('http')) {
        const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000';
        endpoint = `${baseUrl}${apiEndpoint}`;
        console.log(`[NFTLayout] Adjusted endpoint: ${endpoint}`);
      }

      let allHolders = [];
      let totalTokens = 0;
      let totalShares = 0;
      let summary = {};
      let page = 0;
      let totalPages = Infinity;

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries || 3;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
            console.log(`[NFTLayout] Attempt ${attempts + 1} fetching ${url}`);
            const res = await fetch(url, {
              cache: 'force-cache',
              signal: AbortSignal.timeout(config.alchemy.timeoutMs || 30000),
            });
            if (!res.ok) {
              const errorText = await res.text();
              throw new Error(`Failed to fetch ${url}: ${res.status} ${errorText}`);
            }

            const json = await res.json();
            if (json.error) {
              console.log(`[NFTLayout] API error for ${apiKey}: ${json.error}`);
              return { error: json.error };
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              throw new Error(`Invalid holders data for ${url}`);
            }

            allHolders = allHolders.concat(json.holders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            summary = json.summary || summary;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            console.log(`[NFTLayout] Fetched page ${page} for ${apiKey}: ${json.holders.length} holders`);
          } catch (err) {
            attempts++;
            console.error(`[NFTLayout] Fetch attempt ${attempts} failed for ${apiKey}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page}: ${err.message}`);
            }
            await new Promise((resolve) => setTimeout(resolve, (config.alchemy.batchDelayMs || 1000) * attempts));
          }
        }
      }

      const data = {
        holders: allHolders,
        totalTokens,
        totalShares,
        summary,
      };
      console.log(`[NFTLayout] Setting cache for ${apiKey}: ${allHolders.length} holders`);
      setCache(apiKey, data);
      return data;
    } catch (error) {
      console.error(`[NFTLayout] Error fetching ${apiKey}: ${error.message}`);
      return { error: error.message };
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();

      for (const { apiKey } of allNFTs) {
        if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
          searchResults[apiKey] = { error: `${apiKey} is not available` };
          console.log(`[NFTLayout] Skipping disabled contract ${apiKey}`);
          continue;
        }

        let data = getCache(apiKey);
        console.log(`[NFTLayout] Cache check for ${apiKey}: ${data ? 'hit' : 'miss'}`);
        if (!data) {
          console.log(`[NFTLayout] Cache miss for ${apiKey}, fetching data`);
          const contractConfig = config.contractDetails[apiKey] || {};
          data = await fetchCollectionData(apiKey, contractConfig.apiEndpoint, contractConfig.pageSize || 1000);
        }

        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else {
          const holder = data.holders.find(
            (h) => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress
          );
          searchResults[apiKey] = holder
            ? {
                ...holder,
                totalShares: apiKey === 'ascendant' ? data.totalShares : undefined,
                totalTokens: data.totalTokens,
                rewardToken: config.contractDetails[apiKey]?.rewardToken,
              }
            : { error: 'No holdings found for this address' };
          console.log(`[NFTLayout] ${apiKey} search result:`, searchResults[apiKey]);
        }
      }

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err.message, err.stack);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    console.log('[NFTLayout] Chain selected:', chainId);
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    console.log('[NFTLayout] E280 button clicked, selectedChain:', selectedChain);
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  const handleCollectionClick = (name, href) => {
    console.log(`[NFTLayout] Collection button clicked: ${name}, href: ${href}`);
    setShowE280Message(false);
  };

  if (!isClient) {
    return (
      <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
        <h1 className="title mb-8">TitanX NFT Protocols</h1>
        <p>Loading...</p>
      </div>
    );
  }

  return (
    <div className="flex-1 p-6 flex flex-col items-center bg-gray-900 min-h-screen">
      <h1 className="title mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="search-input"
            disabled={searchLoading}
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`btn btn-primary ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-error mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`btn btn-secondary ${
              selectedChain === chain.id ? 'bg-blue-500 text-gray-100' : ''
            }`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => handleCollectionClick(nft.name, nft.href)}
                className="btn btn-secondary w-full"
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl">
          {baseNFTs.map((nft) =>
            nft.href ? (
              <Link key={nft.name} href={nft.href} className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => handleCollectionClick(nft.name, nft.href)}
                  className="btn btn-secondary w-full"
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <motion.button
                key={nft.name}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={handleE280Click}
                className="btn btn-secondary flex-1 w-full"
              >
                {nft.name}
              </motion.button>
            )
          )}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-gray-100">
          <p className="text-body">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl mt-6">{children}</div>
    </div>
  );
}
----- ./client/components/NFTLayoutWrapper.js -----

// File: components/NFTLayoutWrapper.js

'use client';

import dynamic from 'next/dynamic';

// Dynamically import NFTLayout
const NFTLayout = dynamic(() => import('@/client/components/NFTLayout'), { ssr: false });

export default function NFTLayoutWrapper({ children }) {
  return <NFTLayout>{children}</NFTLayout>;
}
----- ./client/components/NFTPage.js -----

'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';
import LoadingIndicator from '@/client/components/LoadingIndicator';
import config from '@/contracts/config.js';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { useNFTStore } from '@/app/store';
import { barChartOptions } from '@/app/lib/chartOptions';

// Dynamically import chart component
const Bar = dynamic(() => import('react-chartjs-2').then(mod => mod.Bar), { ssr: false });

// Default timeout for fetches
const DEFAULT_TIMEOUT_MS = 30000; // 30 seconds

// Retry utility
async function retry(fn, attempts = config.alchemy.maxRetries, delay = (retryCount) => Math.min(config.alchemy.batchDelayMs * 2 ** retryCount, config.alchemy.retryMaxDelayMs)) {
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      console.error(`[NFTPage] [ERROR] Retry ${i + 1}/${attempts}: ${error.message}`);
      if (i === attempts - 1) {
        throw new Error(`Failed after ${attempts} attempts: ${error.message}`);
      }
      await new Promise(resolve => setTimeout(resolve, delay(i)));
    }
  }
}

// Fetch summary data for Element280
async function fetchContractData() {
  const contractAddress = config.contractAddresses.element280.address;
  const vaultAddress = config.vaultAddresses.element280.address;
  console.log(`[NFTPage] [INFO] Fetching contract data for Element280: contract=${contractAddress}, vault=${vaultAddress}`);
  if (!contractAddress || !vaultAddress) {
    throw new Error('Element280 contract or vault address not configured');
  }
  if (!config.alchemy.apiKey) {
    throw new Error('Alchemy API key not configured');
  }

  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`, { timeout: Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS }),
  });

  try {
    const results = await retry(() =>
      client.multicall({
        contracts: [
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'totalSupply' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'getTotalNftsPerTiers' },
          { address: contractAddress, abi: config.abis.element280.main, functionName: 'multiplierPool' },
          { address: vaultAddress, abi: config.abis.element280.vault, functionName: 'totalRewardPool' },
        ],
      })
    );
    console.log(`[NFTPage] [DEBUG] multicall results: ${JSON.stringify(results, (k, v) => (typeof v === 'bigint' ? v.toString() : v), 2)}`);
    const [totalSupply, tierCounts, multiplierPool, totalRewardPool] = results;
    if (totalSupply.status === 'failure') {
      throw new Error(`totalSupply call failed: ${totalSupply.error}`);
    }
    if (tierCounts.status === 'failure' || !tierCounts.result) {
      console.warn(`[NFTPage] [WARN] getTotalNftsPerTiers failed or returned no data: ${tierCounts.error || 'empty result'}`);
    }
    if (multiplierPool.status === 'failure' || !multiplierPool.result) {
      console.warn(`[NFTPage] [WARN] multiplierPool failed or returned no data: ${multiplierPool.error || 'empty result'}`);
    }
    if (totalRewardPool.status === 'failure') {
      throw new Error(`totalRewardPool call failed: ${totalRewardPool.error}`);
    }

    let burnedDistribution = [0, 0, 0, 0, 0, 0];
    let totalBurned = 0;
    try {
      const res = await fetch('/api/holders/Element280/validate-burned', { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
      if (res.ok) {
        const reader = res.body.getReader();
        let events = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(line => line);
          for (const line of lines) {
            const data = JSON.parse(line);
            if (data.event) {
              const tier = data.event.tier;
              if (tier >= 1 && tier <= 6) {
                burnedDistribution[tier - 1]++;
              }
            }
            if (data.complete) {
              events = data.result.events;
              totalBurned = data.result.burnedCount;
            }
          }
        }
        console.log(`[NFTPage] [DEBUG] Burned distribution: ${burnedDistribution}, total events: ${events.length}, totalBurned: ${totalBurned}`);
      } else {
        console.error(`[NFTPage] [ERROR] Failed to fetch burned distribution: ${res.status}`);
      }
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Burned distribution fetch error: ${err.message}, stack: ${err.stack}`);
    }

    return {
      totalMinted: Number(totalSupply.result) + totalBurned,
      totalBurned,
      totalLive: Number(totalSupply.result),
      tierDistribution: tierCounts.status === 'success' && tierCounts.result ? tierCounts.result.map(Number) : [0, 0, 0, 0, 0, 0],
      multiplierPool: multiplierPool.status === 'success' && multiplierPool.result ? Number(multiplierPool.result) : 0,
      totalRewardPool: Number(totalRewardPool.result) / 1e18,
      burnedDistribution,
    };
  } catch (error) {
    console.error(`[NFTPage] [ERROR] fetchContractData failed: ${error.message}, stack: ${error.stack}`);
    throw new Error(`Failed to fetch contract data: ${error.message}`);
  }
}

// Map contract to HolderTable component
const holderTableComponents = {
  e280: dynamic(() => import('./HolderTable/E280'), { ssr: false }),
  ascendant: dynamic(() => import('./HolderTable/Ascendant'), { ssr: false }),
  element280: dynamic(() => import('./HolderTable/Element280'), { ssr: false }),
  element369: dynamic(() => import('./HolderTable/Element369'), { ssr: false }),
  stax: dynamic(() => import('./HolderTable/Stax'), { ssr: false }),
};

export default function NFTPage({ chain, contract }) {
  console.log(`[NFTPage] [INFO] Received props: chain=${chain}, contract=${contract}`);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showChart, setShowChart] = useState(false);
  const [progress, setProgress] = useState({ isPopulating: true, totalWallets: 0, totalOwners: 0, phase: 'Initializing', progressPercentage: 0 });
  const [isInvalidContract, setIsInvalidContract] = useState(false);
  const [isClient, setIsClient] = useState(false);

  // Call useNFTStore unconditionally
  const { getCache, setCache } = useNFTStore();
  // Use useMemo to stabilize effectiveGetCache and effectiveSetCache
  const effectiveGetCache = useMemo(() => (isClient ? getCache : () => null), [isClient, getCache]);
  const effectiveSetCache = useMemo(() => (isClient ? setCache : () => {}), [isClient, setCache]);

  useEffect(() => {
    setIsClient(true);
  }, []);

  const contractId = contract ? contract.toLowerCase() : null;
  console.log(`[NFTPage] [INFO] Derived contractId: ${contractId}`);

  const contractConfig = config.contractDetails[contractId] || {};
  const { name, apiEndpoint, rewardToken, pageSize, disabled } = contractConfig;
  const isElement280 = contractId === 'element280';

  const fetchData = useCallback(async () => {
    if (!apiEndpoint) {
      console.error(`[NFTPage] [ERROR] Invalid contract configuration for ${contractId}`);
      setError('Invalid contract configuration');
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      let progressData = { isPopulating: false, phase: 'Idle', progressPercentage: 0, totalOwners: 0 };
      if (isElement280) {
        try {
          console.log(`[NFTPage] [INFO] Fetching progress from ${apiEndpoint}/progress`);
          const res = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
          if (!res.ok) {
            console.error(`[NFTPage] [ERROR] Progress fetch failed: ${res.status}`);
          } else {
            progressData = await res.json();
            if (progressData.totalOwners === 0 && progressData.phase === 'Idle') {
              console.log(`[NFTPage] [INFO] Stale progress, triggering cache refresh`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              const retryRes = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
              if (retryRes.ok) progressData = await retryRes.json();
            }
          }
        } catch (err) {
          console.error(`[NFTPage] [ERROR] Progress fetch error: ${err.message}, stack: ${err.stack}`);
        }
        setProgress(progressData);
      }

      const cacheKey = `contract_data_${contractId}`;
      const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
      if (cachedData && cachedData.totalMinted > 0) {
        console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}`);
        setData(cachedData);
        setLoading(false);
        return;
      }

      let contractData;
      if (isElement280) {
        contractData = await fetchContractData();
      } else {
        contractData = {
          totalMinted: 0,
          totalBurned: 0,
          totalLive: 0,
          tierDistribution: [0, 0, 0, 0, 0, 0],
          multiplierPool: 0,
          totalRewardPool: 0,
          burnedDistribution: [0, 0, 0, 0, 0, 0],
        };
        console.log(`[NFTPage] [INFO] Using placeholder data for non-Element280 contract: ${contractId}`);
      }

      if (isClient) {
        effectiveSetCache(cacheKey, contractData);
      }
      setData(contractData);
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isElement280, isClient, effectiveGetCache, effectiveSetCache, name]);

  const fetchAllHolders = useCallback(async () => {
    const cacheKey = `holders_${contractId}`;
    const cachedData = isClient ? effectiveGetCache(cacheKey) : null;
    if (cachedData) {
      console.log(`[NFTPage] [INFO] Cache hit for ${cacheKey}, holders: ${cachedData.holders.length}`);
      setData(prev => ({ ...prev, holders: cachedData.holders, summary: cachedData.summary }));
      setLoading(false);
      return;
    }
    console.log(`[NFTPage] [INFO] Cache miss for ${cacheKey}, fetching holders`);

    try {
      console.log(`[NFTPage] [INFO] Starting holders fetch for ${contractId} at ${apiEndpoint}`);

      let allHolders = [];
      let totalTokens = 0;
      let totalLockedAscendant = 0;
      let totalShares = 0;
      let toDistributeDay8 = 0;
      let toDistributeDay28 = 0;
      let toDistributeDay90 = 0;
      let pendingRewards = 0;
      let totalClaimableRewards = 0;
      let totalInfernoRewards = 0;
      let totalFluxRewards = 0;
      let totalE280Rewards = 0;
      let summary = {};
      let burnedNfts = [];
      let page = 0;
      let totalPages = Infinity;
      const effectivePageSize = pageSize || config.contractDetails[contractId]?.pageSize;

      let progressData = await fetch(`${apiEndpoint}/progress`, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) }).then(res => res.json()).catch(() => ({}));
      if (progressData.phase === 'Idle' || progressData.totalOwners === 0) {
        console.log(`[NFTPage] [INFO] Cache is Idle or empty, triggering POST`);
        await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
      }

      while (page < totalPages) {
        let attempts = 0;
        const maxAttempts = config.alchemy.maxRetries;
        let success = false;

        while (attempts < maxAttempts && !success) {
          try {
            const url = `${apiEndpoint}?page=${page}&pageSize=${effectivePageSize}`;
            console.log(`[NFTPage] [INFO] Fetching ${contractId} page ${page} at ${url}`);
            const res = await fetch(url, { cache: 'force-cache', signal: AbortSignal.timeout(Number.isFinite(config.alchemy.timeoutMs) ? config.alchemy.timeoutMs : DEFAULT_TIMEOUT_MS) });
            if (!res.ok) {
              const errorText = await res.text();
              console.error(`[NFTPage] [ERROR] Fetch failed for ${url}: ${res.status} - ${errorText}`);
              throw new Error(`Page ${page} failed with status: ${res.status} - ${errorText}`);
            }

            const json = await res.json();
            console.log(`[NFTPage] [DEBUG] API response for ${url}: holders=${json.holders?.length}, totalTokens=${json.totalTokens}`);
            if (json.error) {
              console.error(`[NFTPage] [ERROR] API error for ${url}: ${json.error}`);
              throw new Error(json.error);
            }
            if (!json.holders || !Array.isArray(json.holders)) {
              console.error(`[NFTPage] [ERROR] Invalid holders data for ${url}: ${JSON.stringify(json, null, 2)}`);
              await fetch(apiEndpoint, { method: 'POST', cache: 'force-cache' });
              throw new Error(`Invalid holders data: retrying after POST`);
            }
            const newHolders = json.holders;
            allHolders = allHolders.concat(newHolders);
            totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
            totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
            totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
            toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
            toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
            toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
            pendingRewards = json.pendingRewards || pendingRewards;
            totalClaimableRewards = json.totalClaimableRewards || totalClaimableRewards;
            totalInfernoRewards = json.totalInfernoRewards || totalInfernoRewards;
            totalFluxRewards = json.totalFluxRewards || totalFluxRewards;
            totalE280Rewards = json.totalE280Rewards || totalE280Rewards;
            summary = json.summary || summary;
            burnedNfts = json.burnedNfts || burnedNfts;
            totalPages = json.totalPages || 1;
            page++;
            success = true;
            if (!newHolders.length && json.totalPages === 0) {
              console.log(`[NFTPage] [INFO] Empty holders with zero pages, accepting as valid`);
              break;
            }
          } catch (err) {
            attempts++;
            console.error(`[NFTPage] [ERROR] Attempt ${attempts}/${maxAttempts} failed for page ${page}: ${err.message}`);
            if (attempts >= maxAttempts) {
              throw new Error(`Failed to fetch page ${page} after ${maxAttempts} attempts: ${err.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs * attempts));
          }
        }
      }

      const holdersData = {
        holders: allHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalClaimableRewards,
        totalInfernoRewards,
        totalFluxRewards,
        totalE280Rewards,
        summary,
        burnedNfts,
      };

      console.log(`[NFTPage] [INFO] Fetched ${allHolders.length} holders for ${contractId}`);
      if (isClient) {
        effectiveSetCache(cacheKey, holdersData);
      }
      setData(prev => ({ ...prev, ...holdersData }));
      setLoading(false);
    } catch (err) {
      console.error(`[NFTPage] [ERROR] Holders fetch error: ${err.message}, stack: ${err.stack}`);
      setError(`Failed to load ${name} data: ${err.message}. Please try again later.`);
      setLoading(false);
    }
  }, [apiEndpoint, contractId, isClient, effectiveGetCache, effectiveSetCache, name, pageSize]);

  useEffect(() => {
    if (!contractId || !config.contractDetails[contractId]) {
      console.error(`[NFTPage] [ERROR] Invalid or missing contract: chain=${chain}, contract=${contract}`);
      setIsInvalidContract(true);
      setLoading(false);
    } else if (disabled) {
      console.log(`[NFTPage] [INFO] Contract ${name} is disabled`);
      setError(`${name} is not yet supported (contract not deployed).`);
      setLoading(false);
    } else {
      setIsInvalidContract(false);
      fetchData();
      fetchAllHolders();
    }
  }, [contractId, chain, contract, disabled, name, fetchData, fetchAllHolders]);

  if (!isClient) {
    return (
      <div className="container page-content">
        <h1 className="title mb-6">{name || 'Unknown Contract'} Holders</h1>
        <p>Loading...</p>
      </div>
    );
  }

  const HolderTable = holderTableComponents[contractId] || null;

  const chartData = data && isElement280 ? {
    labels: ['Tier 1', 'Tier 2', 'Tier 3', 'Tier 4', 'Tier 5', 'Tier 6'],
    datasets: [
      {
        label: 'Live NFTs',
        data: data.tierDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(96, 165, 250, 0.6)', // text-blue-400
      },
      {
        label: 'Burned NFTs',
        data: data.burnedDistribution || [0, 0, 0, 0, 0, 0],
        backgroundColor: 'rgba(248, 113, 113, 0.6)', // text-red-400
      },
    ],
  } : null;

  if (isInvalidContract) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">Invalid Contract</h1>
        <p className="text-error text-lg">
          The contract "{contractId || 'none specified'}" is not supported.
        </p>
      </motion.div>
    );
  }

  if (!HolderTable) {
    return (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="container text-center-section"
      >
        <h1 className="title mb-4">{name || 'Unknown Contract'} Holders</h1>
        <p className="text-error text-lg">
          Error: Holder table component for {contractId} not found.
        </p>
      </motion.div>
    );
  }

  // Define props for each HolderTable component
  const holderTableProps = {
    e280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    ascendant: { holders: data?.holders || [], loading, totalShares: data?.totalShares || 0, totalTokens: data?.totalTokens || 0, rewardToken },
    element280: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    element369: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
    stax: { holders: data?.holders || [], loading, totalTokens: data?.totalTokens || 0, rewardToken },
  };

  return (
    <div className="container page-content">
      <motion.h1
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="title mb-6"
      >
        {name || 'Unknown Contract'} Holders
      </motion.h1>

      <AnimatePresence>
        {loading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="card text-center-section"
          >
            <LoadingIndicator
              status={`Loading ${name} data... ${
                isElement280 ? `Phase: ${progress.phase} (${progress.progressPercentage}%)` : ''
              }`}
              progress={progress}
            />
          </motion.div>
        )}
      </AnimatePresence>

      {error && (
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
          className="text-error text-lg mb-6 text-center"
        >
          {error}
        </motion.p>
      )}

      {!loading && !error && data && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="space-y-section"
        >
          <div className="card">
            <h2 className="subtitle mb-4">Contract Summary</h2>
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Minted:</strong> {data.totalMinted?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Live:</strong> {data.totalLive?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Burned:</strong> {data.totalBurned?.toLocaleString() || 'N/A'}
                </p>
              </div>
              <div>
                <p>
                  <strong>Multiplier Pool:</strong>{' '}
                  {data.multiplierPool?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Reward Pool:</strong>{' '}
                  {data.totalRewardPool?.toLocaleString(undefined, {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  }) || 'N/A'}{' '}
                  {rewardToken}
                </p>
                <p>
                  <strong>Total Holders:</strong>{' '}
                  {progress.totalOwners?.toLocaleString() || 'N/A'}
                </p>
              </div>
            </div>
            {isElement280 && (
              <div className="mt-6">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowChart(!showChart)}
                  className="btn btn-primary"
                >
                  {showChart ? 'Hide Tier Distribution' : 'Show Tier Distribution'}
                </motion.button>
                <AnimatePresence>
                  {showChart && chartData && (
                    <motion.div
                      initial={{ opacity: 0, height: 0 }}
                      animate={{ opacity: 1, height: 'auto' }}
                      exit={{ opacity: 0, height: 0 }}
                      transition={{ duration: 0.3 }}
                      className="chart-container mt-6"
                    >
                      <Bar data={chartData} options={barChartOptions} />
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            )}
          </div>

          <div className="card">
            <h2 className="subtitle mb-4">Holders</h2>
            <HolderTable {...holderTableProps[contractId]} />
          </div>
        </motion.div>
      )}
    </div>
  );
}
----- ./client/components/NFTPageWrapper.js -----

// File: components/NFTPageWrapper.js

'use client';

import { useState, useEffect } from 'react';
import HolderTable from './HolderTable';

export default function NFTPageWrapper({ chain, contract, data, rewardToken }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return (
      <div>
        <p>Loading...</p>
      </div>
    );
  }

  if (!data || data.error) {
    return (
      <div>
        <p className="text-error">
          {data?.error || 'Failed to load collection data'}
        </p>
      </div>
    );
  }

  return (
    <HolderTable
      chain={chain}
      contract={contract}
      holders={data.holders}
      totalTokens={data.totalTokens}
      totalShares={data.totalShares}
      rewardToken={rewardToken}
      totalBurned={data.totalBurned}
    />
  );
}
----- ./client/components/NFTSummary.js -----

// File: components/NFTSummary.js

'use client';

import { useState, useEffect } from 'react';
import config from '@/contracts/config.js';

export default function NFTSummary({ collectionsData }) {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return <div>Loading...</div>;
  }

  return (
    <div className="space-y-section w-full max-w-6xl">
      {collectionsData.map(({ apiKey, data }) => (
        <div key={apiKey} className="card">
          <h2 className="subtitle">{config.contractDetails[apiKey]?.name || apiKey}</h2>
          {data.error ? (
            <p className="text-error">{data.error}</p>
          ) : (
            <div className="grid-responsive text-body">
              <div>
                <p>
                  <strong>Total Tokens:</strong> {data.totalTokens?.toLocaleString() || 'N/A'}
                </p>
                <p>
                  <strong>Total Holders:</strong> {data.holders?.length || 0}
                </p>
              </div>
              {data.totalLockedAscendant > 0 && (
                <p>
                  <strong>Total Locked Ascendant:</strong>{' '}
                  {data.totalLockedAscendant?.toLocaleString() || 'N/A'}
                </p>
              )}
              {data.pendingRewards > 0 && (
                <p>
                  <strong>Pending Rewards:</strong>{' '}
                  {data.pendingRewards?.toLocaleString() || 'N/A'}
                </p>
              )}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
----- ./client/components/SearchResultsModal.js -----

'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import config from '@/contracts/config.js';

// Loading components
const Element280Loading = () => <div className="text-body">Loading Element280 data...</div>;
Element280Loading.displayName = 'Element280Loading';

const Element369Loading = () => <div className="text-body">Loading Element369 data...</div>;
Element369Loading.displayName = 'Element369Loading';

const StaxNFTLoading = () => <div className="text-body">Loading Stax data...</div>;
StaxNFTLoading.displayName = 'StaxNFTLoading';

const AscendantNFTLoading = () => <div className="text-body">Loading Ascendant data...</div>;
AscendantNFTLoading.displayName = 'AscendantNFTLoading';

const E280Loading = () => <div className="text-body">Loading E280 data...</div>;
E280Loading.displayName = 'E280Loading';

// Fallback components
const Element280Fallback = () => <div className="text-error">Error loading data for Element280</div>;
Element280Fallback.displayName = 'Element280ErrorFallback';

const Element369Fallback = () => <div className="text-error">Error loading data for Element369</div>;
Element369Fallback.displayName = 'Element369ErrorFallback';

const StaxNFTFallback = () => <div className="text-error">Error loading data for Stax</div>;
StaxNFTFallback.displayName = 'StaxNFTErrorFallback';

const AscendantNFTFallback = () => <div className="text-error">Error loading data for Ascendant</div>;
AscendantNFTFallback.displayName = 'AscendantNFTErrorFallback';

const E280Fallback = () => <div className="text-error">Error loading data for E280</div>;
E280Fallback.displayName = 'E280ErrorFallback';

const holderTableComponents = {
  element280: dynamic(
    () => import('./HolderTable/Element280').catch((err) => {
      console.error('Failed to load Element280 HolderTable:', err);
      return { default: Element280Fallback };
    }),
    { ssr: false, loading: Element280Loading }
  ),
  element369: dynamic(
    () => import('./HolderTable/Element369').catch((err) => {
      console.error('Failed to load Element369 HolderTable:', err);
      return { default: Element369Fallback };
    }),
    { ssr: false, loading: Element369Loading }
  ),
  stax: dynamic(
    () => import('./HolderTable/Stax').catch((err) => {
      console.error('Failed to load Stax HolderTable:', err);
      return { default: StaxNFTFallback };
    }),
    { ssr: false, loading: StaxNFTLoading }
  ),
  ascendantNFT: dynamic(
    () => import('./HolderTable/Ascendant').catch((err) => {
      console.error('Failed to load Ascendant HolderTable:', err);
      return { default: AscendantNFTFallback };
    }),
    { ssr: false, loading: AscendantNFTLoading }
  ),
  e280: dynamic(
    () => import('./HolderTable/E280').catch((err) => {
      console.error('Failed to load E280 HolderTable:', err);
      return { default: E280Fallback };
    }),
    { ssr: false, loading: E280Loading }
  ),
};

Object.keys(holderTableComponents).forEach((key) => {
  holderTableComponents[key].displayName = `${key}HolderTable`;
});

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  const modalVariants = {
    hidden: { opacity: 0, y: -50 },
    visible: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -50 },
  };

  const collections = [
    { apiKey: 'element280', name: 'Element280' },
    { apiKey: 'element369', name: 'Element369' },
    { apiKey: 'stax', name: 'Stax' },
    { apiKey: 'ascendantNFT', name: 'Ascendant' },
    { apiKey: 'e280', name: 'E280' },
  ];

  return (
    <div className="modal-overlay" onClick={handleBackgroundClick}>
      <motion.div
        className="card w-full max-w-4xl max-h-[90vh] overflow-y-auto border-gray-700"
        variants={modalVariants}
        initial="hidden"
        animate="visible"
        exit="exit"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h2 className="subtitle">
            NFT Ownership for {searchAddress.slice(0, 6)}...{searchAddress.slice(-4)}
          </h2>
          <button onClick={closeModal} className="text-gray-300 hover:text-gray-100 text-2xl">
            ×
          </button>
        </div>

        <div className="space-y-section">
          {collections.map(({ apiKey, name }) => {
            const data = searchResult[apiKey];
            const HolderTable = holderTableComponents[apiKey] || (() => <div>Holder table not found for {apiKey}</div>);
            return (
              <div key={apiKey} className="border-b border-gray-700 pb-4">
                <h3 className="subtitle mb-2">{name}</h3>
                {data === null ? (
                  <p className="text-body">No NFTs owned in this collection.</p>
                ) : data?.error ? (
                  <p className="text-error">Error: {data.error}</p>
                ) : data?.message ? (
                  <p className="text-body">{data.message}</p>
                ) : (
                  <HolderTable
                    holders={[data]}
                    contract={apiKey}
                    loading={false}
                    totalTokens={data.totalTokens || 0}
                    totalShares={data.totalShares}
                    rewardToken={data.rewardToken || config.contractDetails[apiKey]?.rewardToken}
                  />
                )}
              </div>
            );
          })}
        </div>
      </motion.div>
    </div>
  );
}

================= Includes the following files under ./app =================
./app/about/page.js
./app/api/holders/Element280/validate-burned/route.js
./app/api/holders/[contract]/progress/route.js
./app/api/holders/[contract]/route.js
./app/api/utils.js
./app/auctions/page.js
./app/layout.js
./app/lib/chartOptions.js
./app/lib/fetchCollectionData.js
./app/lib/logger.js
./app/lib/schemas.js
./app/lib/serverInit.js
./app/lib/useNFTData.js
./app/mining/page.js
./app/nft/[chain]/[contract]/page.js
./app/nft/layout.js
./app/nft/page.js
./app/page.js
./app/store.js
./client/components/HolderTable/Ascendant.js
./client/components/HolderTable/E280.js
./client/components/HolderTable/Element280.js
./client/components/HolderTable/Element369.js
./client/components/HolderTable/Stax.js
./client/components/HolderTable/index.js
./client/components/LoadingIndicator.js
./client/components/NFTLayout.js
./client/components/NFTLayoutWrapper.js
./client/components/NFTPage.js
./client/components/NFTPageWrapper.js
./client/components/NFTSummary.js
./client/components/SearchResultsModal.js
