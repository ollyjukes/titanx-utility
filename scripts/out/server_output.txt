================= Includes the following JS files under ./server =================
./.env.local
./app/api/holders/ascendant/route.js
./app/api/holders/blockchain/events.js
./app/api/holders/blockchain/multicall.js
./app/api/holders/blockchain/owners.js
./app/api/holders/cache/getHoldersMap.js
./app/api/holders/cache/holders.js
./app/api/holders/cache/populateHoldersMapCache.js
./app/api/holders/cache/state.js
./app/api/holders/cache/state/[contractKey]/route.js
./app/api/holders/cache/utils.js
./app/api/holders/e280/route.js
./app/api/holders/element280/route.js
./app/api/holders/element369/route.js
./app/api/holders/shared.js
./app/api/holders/stax/route.js
./app/api/utils.js
./app/api/utils/cache.js
./app/api/utils/client.js
./app/api/utils/logging.js
./app/api/utils/retry.js
./app/contracts/abi_nft.js
./app/contracts/abi_nft_vault.js
./app/contracts/contracts_auct_mint.js
./app/contracts/contracts_nft.js
./app/layout.js
./app/lib/constants.js
./app/lib/logger.js
./app/lib/schemas.js
./app/lib/serverInit.js
./app/nft/[chain]/[contract]/page.js
./app/nft/layout.js
./app/nft/page.js
./app/page.js
./app/store.js
./components/CollectionSelector.js
./components/HolderTable.js
./components/LoadingIndicator.js
./components/NFTPage.js
./components/SearchResultsModal.js


================= Manually Excluded JS files =================
./app/about/page.js
./app/auctions/page.js
./app/mining/page.js
./components/Dialog.js
./components/ShootingStars.js


================= Contents of Included Files =================

----- ./.env.local -----

# env/.env.local
ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
NEXT_PUBLIC_ALCHEMY_API_KEY=rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI
ETHERSCAN_API_KEY=GZDQAWE7C9MKSWQ3ANT2BFPUW8SXXZJ9MF
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=1dd2a69d54ac94fdefad918243183710
UPSTASH_REDIS_REST_URL=https://splendid-sunbird-26504.upstash.io
UPSTASH_REDIS_REST_TOKEN=AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
#KV_REST_API_URL=https://splendid-sunbird-26504.upstash.io
#KV_REST_API_TOKEN=AWeIAAIjcDE5ODI2M3QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA
#KV_REST_API_READ_ONLY_TOKEN=AmeIAAIgcDFuapUIQ7Gfl8xCFpd9nryMqcpkq_DbU-d9DkuesRnhQg
#KV_URL=rediss://default:AWeIAAIjcDE5ODI2M2QyMGMzNWU0MmE1YWZmYjRhNTljZmQwMzU0YXAxMA@splendid-sunbird-26504.upstash.io:6379
PERSIST_CACHE=true
DEBUG=true
LOG_LEVEL=info
USE_FALLBACK_DATA=false
ESLINT_NO_DEV_ERRORS=true
USE_ALCHEMY_FOR_OWNERS=true
NEXT_NO_WORKER_THREADS=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:3000
DISABLE_ELEMENT369_REDIS=true
DISABLE_STAX_REDIS=true
DISABLE_ASCENDANT_REDIS=true
DISABLE_E280_REDIS=true
DISABLE_ELEMENT280_REDIS=true

----- ./app/api/holders/ascendant/route.js -----

// app/api/holders/ascendant/route.js
import { NextResponse } from 'next/server';
import { getAllHolders, getHolderData } from '@/app/api/holders/shared';
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  const contractKey = 'ascendant';
  const contractConfig = config.nftContracts[contractKey];
  if (!contractConfig?.contractAddress) {
    return NextResponse.json({ error: 'Ascendant contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(
        contractKey,
        contractConfig.contractAddress,
        wallet,
        config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
          ...acc,
          [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
        }), {}),
        null, // No vault
        null // No vault ABI
      );
      return NextResponse.json({ holders: holderData ? [holderData] : [] });
    }

    const result = await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      null, // No vault
      null, // No vault ABI
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      page,
      pageSize
    );
    return NextResponse.json(result);
  } catch (error) {
    logger.error('holders', `Error in Ascendant GET: ${error.message}`, { stack: error.stack }, 'ETH', contractKey);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

async function preWarmCache() {
  logger.info('ascendant', 'Starting pre-warm cache', 'ETH', 'ascendant');
  try {
    const contractConfig = config.nftContracts['ascendant'];
    if (!contractConfig?.contractAddress) {
      logger.error('ascendant', 'Contract address not found', {}, 'ETH', 'ascendant');
      return;
    }
    await getAllHolders(
      'ascendant',
      contractConfig.contractAddress,
      null,
      null,
      config.contractTiers['ascendant'].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      0,
      1000
    );
    logger.info('ascendant', 'Pre-warm cache completed', 'ETH', 'ascendant');
  } catch (err) {
    logger.error('ascendant', `Pre-warm cache failed: ${err.message}`, { stack: err.stack }, 'ETH', 'ascendant');
  }
}

preWarmCache().catch(err => logger.error('ascendant', `Pre-warm cache init failed: ${err.message}`, { stack: err.stack }, 'ETH', 'ascendant'));
----- ./app/api/holders/blockchain/events.js -----

import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http, parseAbiItem } from 'viem';
import { mainnet } from 'viem/chains';
import pino from 'pino';
import { getCache, setCache } from '@/app/api/utils/cache';
import { retry } from '@/app/api/utils/retry';
import config from '@/app/contracts_nft';

const logger = pino({ level: 'info', base: { context: 'events' } });



const alchemyApiKey = config.alchemy.apiKey;
if (!alchemyApiKey) throw new Error('ALCHEMY_API_KEY is not set');
const alchemy = new Alchemy({
  apiKey: alchemyApiKey,
  network: Network.ETH_MAINNET,
});

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`, { timeout: 60000 }),
});

const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
const MAX_BLOCK_RANGE = 2000; // Reduced from 10000 to prevent rate limits
const MIN_BLOCK_RANGE = 1000;
const BATCH_SIZE = 25;
const BATCH_DELAY_MS = 1000;

// Contracts using getLogs
const LOG_CONTRACTS = ['element280', 'element369', 'stax'];

export async function getNewEvents(
  contractKey,
  contractAddress,
  startBlock,
  endBlock,
  config,
  chain = 'ETH',
  forceUpdate = false
) {
  const context = `events/${contractKey}`;
  const cacheKey = `${contractKey}_transfers`;
  const cachedTransfers = await getCache(cacheKey, contractKey, 'transfers');
  const now = Date.now();

  // Determine start block from cache
  let effectiveStartBlock = startBlock;
  if (!forceUpdate && cachedTransfers && cachedTransfers.lastBlock) {
    effectiveStartBlock = Math.max(startBlock, cachedTransfers.lastBlock + 1);
    logger.info(`[${context}] Using cached lastBlock: ${cachedTransfers.lastBlock}, starting from ${effectiveStartBlock}`, chain, contractKey);
  }

  if (effectiveStartBlock > endBlock) {
    logger.info(`[${context}] No new blocks to process (start: ${effectiveStartBlock}, end: ${endBlock})`, chain, contractKey);
    return cachedTransfers || { buys: [], sells: [], burns: [], lastBlock: Number(endBlock), timestamp: now, errorLog: [] };
  }

  const buys = cachedTransfers?.buys || [];
  const sells = cachedTransfers?.sells || [];
  const burns = cachedTransfers?.burns || [];
  const errorLog = cachedTransfers?.errorLog || [];
  let lastProcessedBlock = cachedTransfers?.lastBlock || effectiveStartBlock - 1;

  if (LOG_CONTRACTS.includes(contractKey)) {
    logger.info(`[${context}] Fetching transfers from block ${effectiveStartBlock} to ${endBlock} using getLogs`, chain, contractKey);
    const blockRanges = [];
    let currentFromBlock = Number(effectiveStartBlock);
    const endBlockNumber = Number(endBlock);

    for (let block = currentFromBlock; block <= endBlockNumber; block += MAX_BLOCK_RANGE) {
      const toBlock = Math.min(block + MAX_BLOCK_RANGE - 1, endBlockNumber);
      blockRanges.push({ fromBlock: block, toBlock });
    }

    const concurrencyLimit = 8;
    for (let i = 0; i < blockRanges.length; i += concurrencyLimit) {
      const batch = blockRanges.slice(i, i + concurrencyLimit);
      await Promise.all(
        batch.map(async ({ fromBlock, toBlock }) => {
          let currentMaxBlockRange = MAX_BLOCK_RANGE;
          let currentFromBlock = fromBlock;
          while (currentFromBlock <= toBlock) {
            const currentToBlock = Math.min(currentFromBlock + currentMaxBlockRange - 1, toBlock);
            try {
              const logs = await retry(
                () =>
                  client.getLogs({
                    address: contractAddress,
                    event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
                    fromBlock: BigInt(currentFromBlock),
                    toBlock: BigInt(currentToBlock),
                  }),
                { retries: 5, delay: 500, backoff: true, timeout: 60000 }
              );
              logger.debug(`[${context}] Fetched ${logs.length} transfers for blocks ${currentFromBlock}-${currentToBlock}`, chain, contractKey);

              logs.forEach((log) => {
                const fromAddr = log.args.from.toLowerCase();
                const toAddr = log.args.to.toLowerCase();
                const tokenId = Number(log.args.tokenId);
                const blockNumber = Number(log.blockNumber);
                const timestamp = now;

                if (toAddr === burnAddress.toLowerCase()) {
                  burns.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
                } else if (fromAddr === '0x0000000000000000000000000000000000000000') {
                  buys.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
                } else {
                  sells.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
                }
              });

              if (currentToBlock > lastProcessedBlock) {
                lastProcessedBlock = currentToBlock;
              }
            } catch (error) {
              logger.error(`[${context}] Failed to fetch transfers for blocks ${currentFromBlock}-${currentToBlock}: ${error.message}`, { stack: error.stack }, chain, contractKey);
              errorLog.push({
                timestamp: new Date().toISOString(),
                phase: 'fetch_transfers',
                fromBlock: currentFromBlock,
                toBlock: currentToBlock,
                error: error.message,
              });

              if (error.message.includes('Log response size exceeded') && currentMaxBlockRange > MIN_BLOCK_RANGE) {
                currentMaxBlockRange = Math.floor(currentMaxBlockRange / 2);
                logger.info(`[${context}] Reducing block range to ${currentMaxBlockRange} due to log size limit`, chain, contractKey);
                continue;
              }

              currentFromBlock = currentToBlock + 1;
              if (currentToBlock > lastProcessedBlock) {
                lastProcessedBlock = currentToBlock;
              }
            }
            currentFromBlock = currentToBlock + 1;
          }
        })
      );

      const progress = Math.min(((i + batch.length) / blockRanges.length) * 100, 100).toFixed(2);
      logger.info(`[${context}] Transfers progress: ${progress}%`, chain, contractKey);
      if (i + concurrencyLimit < blockRanges.length) {
        await new Promise((resolve) => setTimeout(resolve, BATCH_DELAY_MS));
      }
    }
  } else {
    logger.info(`[${context}] Fetching transfers from block ${effectiveStartBlock} to ${endBlock} using getAssetTransfers`, chain, contractKey);
    const blockRanges = [];
    let currentFromBlock = BigInt(effectiveStartBlock);
    const endBlockNumber = BigInt(endBlock);

    while (currentFromBlock <= endBlockNumber) {
      const toBlock = BigInt(Math.min(Number(currentFromBlock) + MAX_BLOCK_RANGE - 1, Number(endBlockNumber)));
      blockRanges.push({ fromBlock: currentFromBlock, toBlock });
      currentFromBlock = toBlock + 1n;
    }

    for (const range of blockRanges) {
      try {
        const transfers = await retry(() =>
          alchemy.core.getAssetTransfers({
            fromBlock: `0x${range.fromBlock.toString(16)}`,
            toBlock: `0x${range.toBlock.toString(16)}`,
            contractAddresses: [contractAddress],
            category: ['erc721', 'erc1155'],
            withMetadata: true,
          })
        );

        for (const transfer of transfers.transfers) {
          const fromAddr = transfer.from.toLowerCase();
          const toAddr = transfer.to.toLowerCase();
          const tokenId = Number(transfer.tokenId);
          if (!tokenId) {
            logger.warn(`[${context}] Skipping transfer with missing tokenId: ${JSON.stringify(transfer)}`, chain, contractKey);
            continue;
          }

          const blockNumber = Number(transfer.blockNum);
          const timestamp = new Date(transfer.metadata.blockTimestamp).getTime();

          if (toAddr === burnAddress.toLowerCase()) {
            burns.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
          } else if (fromAddr === '0x0000000000000000000000000000000000000000') {
            buys.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
          } else {
            sells.push({ from: fromAddr, to: toAddr, tokenId, blockNumber, timestamp });
          }
        }

        if (Number(range.toBlock) > lastProcessedBlock) {
          lastProcessedBlock = Number(range.toBlock);
        }
      } catch (error) {
        logger.error(`[${context}] Failed to fetch transfers for blocks ${range.fromBlock}-${range.toBlock}: ${error.message}`, { stack: error.stack }, chain, contractKey);
        errorLog.push({
          timestamp: new Date().toISOString(),
          phase: 'fetch_transfers',
          fromBlock: Number(range.fromBlock),
          toBlock: Number(range.toBlock),
          error: error.message,
        });
      }
    }
  }

  const result = {
    buys,
    sells,
    burns,
    lastBlock: lastProcessedBlock,
    timestamp: now,
    errorLog,
  };

  if (typeof result.lastBlock !== 'number') {
    logger.error(`[${context}] Invalid lastBlock in result: ${result.lastBlock}`, {}, chain, contractKey);
    throw new Error('lastBlock is not defined in events result');
  }

  await setCache(cacheKey, result, config.cache.nodeCache.stdTTL, contractKey, 'transfers');
  logger.info(
    `[${context}] Transfers completed: ${buys.length} buys, ${sells.length} sells, ${burns.length} burns, lastBlock: ${result.lastBlock}`,
    chain,
    contractKey
  );
  return result;
}
----- ./app/api/holders/blockchain/multicall.js -----

// app/api/holders/blockchain/multicall.js
import pLimit from 'p-limit';
import { client } from '@/app/api/utils/client';
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';
import { BATCH_SIZE, BATCH_DELAY_MS } from '@/app/lib/constants';

const concurrencyLimit = pLimit(config.alchemy.concurrencyLimit || 100);

export async function batchMulticall(calls, batchSize = BATCH_SIZE) {
  const results = [];
  const delay = async () => new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));

  const batchPromises = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    batchPromises.push(
      concurrencyLimit(async () => {
        try {
          await delay();
          const batchResults = await client.multicall({
            contracts: batch.map(call => ({
              address: call.address,
              abi: call.abi,
              functionName: call.functionName,
              args: call.args || [],
            })),
            allowFailure: true,
          });
          logger.debug('multicall', `Processed batch ${i}-${i + batchSize - 1}: ${batchResults.length} results`, 'ETH', 'general');
          return batchResults.map((result, index) => ({
            status: result.status === 'success' ? 'success' : 'failure',
            result: result.status === 'success' ? result.result : null,
            error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
          }));
        } catch (error) {
          logger.error('multicall', `Batch failed ${i}-${i + batchSize - 1}: ${error.message}`, { stack: error.stack }, 'ETH', 'general');
          return batch.map(() => ({
            status: 'failure',
            result: null,
            error: error.message,
          }));
        }
      })
    );
  }

  const batchResults = (await Promise.all(batchPromises)).flat();
  results.push(...batchResults);
  return results;
}
----- ./app/api/holders/blockchain/owners.js -----

import { alchemy } from '@/app/api/utils/client';
import { logger } from '@/app/lib/logger';
import { retry } from '@/app/api/utils/retry';

export async function fetchOwnersAlchemy(contractAddress, contractKey, chain = 'eth') {
  logger.debug(
    'owners',
    `Fetching owners for contract: ${contractAddress} (contractKey: ${contractKey})`,
    chain,
    contractKey
  );

  try {
    const response = await retry(() =>
      alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: true,
        pageSize: 1000,
      })
    );

    logger.debug(
      'owners',
      `Raw Alchemy response: ownersExists=${!!response.owners}, isArray=${Array.isArray(response.owners)}, ownersLength=${
        response.owners?.length || 0
      }, pageKey=${response.pageKey || null}, responseKeys=${Object.keys(response)}, sampleOwners=${JSON.stringify(
        response.owners?.slice(0, 2) || []
      )}`,
      chain,
      contractKey
    );

    if (!response.owners || !Array.isArray(response.owners)) {
      logger.error('owners', `Invalid Alchemy response for ${contractAddress}: ${JSON.stringify(response)}`, {}, chain, contractKey);
      throw new Error('Invalid owners response from Alchemy API');
    }

    const owners = response.owners
      .filter(owner => owner?.ownerAddress && owner.tokenBalances?.length > 0)
      .map(owner => ({
        ownerAddress: owner.ownerAddress.toLowerCase(),
        tokenBalances: owner.tokenBalances
          .filter(tb => tb.tokenId && Number(tb.balance) > 0)
          .map(tb => ({
            tokenId: Number(tb.tokenId),
            balance: Number(tb.balance),
          })),
      }));

    logger.debug('owners', `Processed owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, chain, contractKey);
    logger.info('owners', `Fetched ${owners.length} owners for contract: ${contractAddress}`, chain, contractKey);
    return owners;
  } catch (error) {
    logger.error('owners', `Failed to fetch owners for ${contractAddress}: ${error.message}`, { stack: error.stack }, chain, contractKey);
    throw error;
  }
}
----- ./app/api/holders/cache/getHoldersMap.js -----

// app/api/holders/cache/getHoldersMap.js
import pLimit from 'p-limit';
import config from '@/app/contracts_nft';
import { logger } from '@/app/lib/logger';
import { getCacheState, saveCacheStateContract } from '@/app/api/holders/cache/state';
import { getNewEvents } from '@/app/api/holders/blockchain/events';
import { client } from '@/app/api/utils/client';
import { batchMulticall } from '@/app/api/holders/blockchain/multicall';
import { retry } from '@/app/api/utils/retry';
import { getCache, setCache } from '@/app/api/utils/cache';
import { fetchOwnersAlchemy } from '@/app/api/holders/blockchain/owners';
import { sanitizeBigInt } from './utils';
import { getAddress } from 'viem';

const limit = pLimit(5);
const ownershipChunkLimit = pLimit(2);
const ALCHEMY_CONTRACTS = ['element280', 'element369', 'stax'];

export async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState, forceUpdate = false) {
  if (!contractAddress) throw new Error('Contract address missing');
  if (!abi) throw new Error(`${contractKey} ABI missing`);

  contractKey = contractKey.toLowerCase();
  const chain = config.nftContracts[contractKey]?.chain || 'eth';
  logger.info('holders', `Starting getHoldersMap: contractKey=${contractKey}, forceUpdate=${forceUpdate}`, chain, contractKey);

  let lastBlock = BigInt(cacheState.lastProcessedBlock || config.nftContracts[contractKey]?.deploymentBlock || 0);
  let currentBlock;
  let totalBurned = Number(cacheState.totalBurned) || 0;
  let totalTokens = 0;
  let tokenOwnerMap = new Map();
  let holdersMap = new Map();
  let errorLog = cacheState.progressState?.errorLog || [];
  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const contractTiers = config.nftContracts[contractKey]?.tiers || {};
  const maxTier = Math.max(...Object.keys(contractTiers).map(Number), 0);
  let tierDistribution = Array(maxTier + 1).fill(0);
  let rarityDistribution = contractKey === 'ascendant' ? Array(3).fill(0) : [];
  const cachedTokenTiers = new Map();

  if (!cacheState.progressState) {
    cacheState.progressState = {
      step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [],
      progressPercentage: '0%', totalLiveHolders: 0, totalOwners: 0, lastProcessedBlock: cacheState.lastProcessedBlock || null,
      lastUpdated: Date.now(), isPopulating: false, status: 'idle',
    };
  }

  const requiredFunctions = contractKey === 'ascendant' ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute', 'batchClaimableAmount'] : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
  const missingFunctions = requiredFunctions.filter(fn => !abi.some(item => item.name === fn && item.type === 'function'));
  if (missingFunctions.length > 0) throw new Error(`Missing ABI functions: ${missingFunctions.join(', ')}`);

  try {
    currentBlock = await retry(() => client.getBlockNumber(), { retries: 3, delay: 1000, backoff: true });
    logger.debug('holders', `Current block: ${currentBlock}`, chain, contractKey);
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (!cacheState.lastProcessedBlock) {
    cacheState.lastProcessedBlock = config.nftContracts[contractKey]?.deploymentBlock || 0;
    cacheState.progressState.lastProcessedBlock = cacheState.lastProcessedBlock;
    cacheState.lastUpdated = Date.now();
    await saveCacheStateContract(contractKey, cacheState);
    await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');
  }

  cacheState.progressState.step = 'checking_cache';
  cacheState.progressState.progressPercentage = '0%';
  cacheState.lastUpdated = Date.now();
  cacheState.progressState.lastUpdated = Date.now();
  await saveCacheStateContract(contractKey, cacheState);
  await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

  if (config.nftContracts[contractKey] && !forceUpdate) {
    let fromBlock = BigInt(cacheState.lastProcessedBlock);
    let cachedHolders, cachedTiers;
    let updatedTokenIds = new Set();
    let burnedTokenIds = [];
    let transferTokenIds = [];

    try {
      cachedHolders = await getCache(`${contractKey}_holders`, contractKey);
      cachedTiers = await getCache(`${contractKey}_tiers`, contractKey) || {};
      if (cachedHolders?.holders && Array.isArray(cachedHolders.holders) && Number.isInteger(cachedHolders.totalBurned)) {
        holdersMap = new Map(cachedHolders.holders.map(h => [h.wallet, h]));
        totalBurned = Number(cachedHolders.totalBurned) || totalBurned;
        totalTokens = Number(cacheState.progressState.totalNfts) || 0;
        holdersMap.forEach(holder => holder.tokenIds.forEach(tokenId => tokenOwnerMap.set(Number(tokenId), holder.wallet)));
        Object.entries(cachedTiers).forEach(([tokenId, tierData]) => {
          if (tierData && typeof tierData.tier === 'number') {
            cachedTokenTiers.set(Number(tokenId), tierData);
            tierDistribution[tierData.tier] += 1;
          }
        });
        logger.info('holders', `Cache hit: holders=${holdersMap.size}, tiers=${cachedTokenTiers.size}, lastBlock=${cacheState.lastProcessedBlock}`, chain, contractKey);
      }
    } catch (error) {
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'load_cache', error: error.message });
      cachedHolders = null;
    }

    const blockRanges = [];
    for (let block = Number(fromBlock); block <= Number(currentBlock); block += config.MAX_BLOCK_RANGE) {
      blockRanges.push({ fromBlock: block, toBlock: Math.min(block + config.MAX_BLOCK_RANGE - 1, Number(currentBlock)) });
    }

    const concurrencyLimit = 8;
    for (let i = 0; i < blockRanges.length; i += concurrencyLimit) {
      const batch = blockRanges.slice(i, i + concurrencyLimit);
      await Promise.all(batch.map(async ({ fromBlock, toBlock }) => {
        let currentMaxBlockRange = config.MAX_BLOCK_RANGE;
        let currentFromBlock = fromBlock;
        while (currentFromBlock <= toBlock) {
          const currentToBlock = Math.min(currentFromBlock + currentMaxBlockRange - 1, toBlock);
          try {
            const events = await getNewEvents(contractKey, contractAddress, currentFromBlock, currentToBlock, config, chain, forceUpdate);
            if (!events || typeof events.lastBlock !== 'number') throw new Error(`Invalid events response: ${JSON.stringify(events)}`);
            burnedTokenIds.push(...(Array.isArray(events.burns) ? events.burns.map(event => event.tokenId) : []));
            transferTokenIds.push(...[
              ...(Array.isArray(events.buys) ? events.buys : []),
              ...(Array.isArray(events.sells) ? events.sells : []),
            ].map(event => ({ tokenId: event.tokenId, from: event.from, to: event.to })));
            lastBlock = BigInt(events.lastBlock);
            errorLog.push(...(events.errorLog || []));
          } catch (error) {
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_events', fromBlock: currentFromBlock, toBlock: currentToBlock, error: error.message });
            lastBlock = BigInt(currentToBlock);
          }
          currentFromBlock = currentToBlock + 1;
        }
      }));
    }

    if (cachedHolders) {
      burnedTokenIds.forEach(tokenId => {
        const wallet = tokenOwnerMap.get(tokenId);
        if (wallet) {
          const holder = holdersMap.get(wallet);
          if (holder) {
            holder.tokenIds = holder.tokenIds.filter(id => id !== tokenId);
            holder.total -= 1;
            const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
            holder.tiers[tier] -= 1;
            holder.multiplierSum -= contractTiers[tier + 1]?.multiplier || tier + 1;
            if (holder.total === 0) holdersMap.delete(wallet);
            tokenOwnerMap.delete(tokenId);
            cachedTokenTiers.delete(tokenId);
            totalTokens -= 1;
            totalBurned += 1;
            tierDistribution[tier] -= 1;
          }
        }
      });

      transferTokenIds.forEach(({ tokenId, from, to }) => {
        updatedTokenIds.add(tokenId);
        const oldHolder = holdersMap.get(from);
        if (oldHolder) {
          oldHolder.tokenIds = oldHolder.tokenIds.filter(id => id !== tokenId);
          oldHolder.total -= 1;
          const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
          oldHolder.tiers[tier] -= 1;
          oldHolder.multiplierSum -= contractTiers[tier + 1]?.multiplier || tier + 1;
          if (oldHolder.total === 0) holdersMap.delete(from);
        }
        let newHolder = holdersMap.get(to) || {
          wallet: to, tokenIds: [], tiers: Array(maxTier + 1).fill(0), total: 0, multiplierSum: 0, claimableRewards: 0,
        };
        newHolder.tokenIds.push(tokenId);
        newHolder.total += 1;
        const tier = cachedTokenTiers.get(tokenId)?.tier || 0;
        newHolder.tiers[tier] += 1;
        newHolder.multiplierSum += contractTiers[tier + 1]?.multiplier || tier + 1;
        holdersMap.set(to, newHolder);
        tokenOwnerMap.set(tokenId, to);
      });

      cacheState.lastProcessedBlock = Number(lastBlock);
      cacheState.progressState.lastProcessedBlock = Number(lastBlock);
      cacheState.lastUpdated = Date.now();
      cacheState.progressState.lastUpdated = Date.now();
      await saveCacheStateContract(contractKey, cacheState);
      await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');
    }
  }

  cacheState.progressState.step = 'fetching_holders';
  cacheState.progressState.isPopulating = true;
  cacheState.progressState.progressPercentage = '20%';
  cacheState.lastUpdated = Date.now();
  cacheState.progressState.lastUpdated = Date.now();
  await saveCacheStateContract(contractKey, cacheState);
  await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

  if (ALCHEMY_CONTRACTS.includes(contractKey)) {
    try {
      const owners = await fetchOwnersAlchemy(contractAddress, contractKey, chain);
      const filteredOwners = owners.filter(owner => owner?.ownerAddress && owner.ownerAddress.toLowerCase() !== burnAddress.toLowerCase() && owner.tokenBalances?.length > 0);
      tokenOwnerMap.clear();
      totalTokens = 0;
      const seenTokenIds = new Set();
      filteredOwners.forEach(owner => {
        if (!owner.ownerAddress) return;
        let wallet = getAddress(owner.ownerAddress).toLowerCase();
        owner.tokenBalances.forEach(tb => {
          if (!tb.tokenId) return;
          const tokenId = Number(tb.tokenId);
          if (seenTokenIds.has(tokenId)) {
            errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_token', tokenId, wallet, error: 'Duplicate tokenId' });
            return;
          }
          seenTokenIds.add(tokenId);
          tokenOwnerMap.set(tokenId, wallet);
          totalTokens++;
        });
      });
      lastBlock = currentBlock;
    } catch (error) {
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_owners_alchemy', error: error.message, details: error.stack });
      const fromBlock = BigInt(config.nftContracts[contractKey].deploymentBlock || cacheState.lastProcessedBlock || 0);
      tokenOwnerMap.clear();
      totalTokens = 0;
      const seenTokenIds = new Set();
      try {
        const events = await getNewEvents(contractKey, contractAddress, Number(fromBlock), Number(currentBlock), config, chain, forceUpdate);
        if (!events || typeof events.lastBlock !== 'number') throw new Error(`Invalid events response: lastBlock is missing`);
        events.burns?.forEach(event => {
          seenTokenIds.delete(event.tokenId);
          tokenOwnerMap.delete(event.tokenId);
          totalBurned += 1;
        });
        [...(events.buys || []), ...(events.sells || [])].forEach(event => {
          if (event.to !== burnAddress.toLowerCase()) {
            if (event.from === '0x0000000000000000000000000000000000000000' && !seenTokenIds.has(event.tokenId)) totalTokens++;
            tokenOwnerMap.set(event.tokenId, event.to);
            seenTokenIds.add(event.tokenId);
          }
        });
        lastBlock = BigInt(events.lastBlock);
        errorLog.push(...(events.errorLog || []));
        cacheState.lastProcessedBlock = Number(lastBlock);
        cacheState.progressState.lastProcessedBlock = Number(lastBlock);
        cacheState.lastUpdated = Date.now();
        cacheState.progressState.lastUpdated = Date.now();
        await saveCacheStateContract(contractKey, cacheState);
        await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');
      } catch (eventError) {
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_transfer_events', fromBlock: Number(fromBlock), toBlock: Number(currentBlock), error: eventError.message });
        lastBlock = currentBlock;
      }
    }
  }

  try {
    const results = await retry(() => client.multicall({
      contracts: [
        { address: contractAddress, abi, functionName: 'totalSupply' },
        { address: contractAddress, abi, functionName: 'totalBurned' },
      ],
      allowFailure: true,
    }), { retries: 3, delay: 1000, backoff: true });
    totalTokens = results[0]?.status === 'success' && results[0].result != null ? Number(results[0].result) : totalTokens;
    totalBurned = results[1]?.status === 'success' && results[1].result != null ? Number(results[1].result) : totalBurned;
    if (results[0]?.status !== 'success') errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_supply', error: `totalSupply call failed: ${results[0]?.error || 'Unknown error'}` });
    if (results[1]?.status !== 'success') errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned', error: `totalBurned call failed: ${results[1]?.error || 'Unknown error'}` });
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_supply', error: error.message });
  }

  cacheState.progressState.step = 'building_holders';
  cacheState.progressState.progressPercentage = '50%';
  cacheState.lastUpdated = Date.now();
  cacheState.progressState.lastUpdated = Date.now();
  await saveCacheStateContract(contractKey, cacheState);
  await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

  for (const [tokenId, wallet] of tokenOwnerMap) {
    if (!holdersMap.has(wallet)) {
      holdersMap.set(wallet, { wallet, tokenIds: [], tiers: Array(maxTier + 1).fill(0), total: 0, multiplierSum: 0, claimableRewards: 0 });
    }
    const holder = holdersMap.get(wallet);
    holder.tokenIds.push(tokenId);
    holder.total += 1;
  }

  cacheState.progressState.step = 'fetching_tiers';
  cacheState.progressState.processedTiers = 0;
  cacheState.progressState.totalTiers = tokenOwnerMap.size;
  cacheState.progressState.progressPercentage = '60%';
  cacheState.lastUpdated = Date.now();
  cacheState.progressState.lastUpdated = Date.now();
  await saveCacheStateContract(contractKey, cacheState);
  await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state'); // Corrected line
  logger.debug('holders', `Starting tier fetching: totalTokens=${tokenOwnerMap.size}`, chain, contractKey);
  
  const tierCalls = Array.from(tokenOwnerMap.keys()).map(tokenId => ({
    address: contractAddress,
    abi,
    functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
    args: [BigInt(tokenId)],
  }));

  const tierResults = [];
  const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 200;
  for (let i = 0; i < tierCalls.length; i += chunkSize) {
    const chunk = tierCalls.slice(i, i + chunkSize);
    const chunkTokenIds = Array.from(tokenOwnerMap.keys()).slice(i, i + chunkSize);
    logger.debug('holders', `Fetching tiers for chunk ${i / chunkSize + 1}: tokenIds=${chunkTokenIds.join(',')}`, chain, contractKey);
    try {
      const results = await retry(() => batchMulticall(chunk, 100), { retries: 3, delay: 500, backoff: true });
      tierResults.push(...results);
      cacheState.progressState.processedTiers = Math.min(i + chunkSize, tierCalls.length);
      cacheState.progressState.progressPercentage = `${Math.round(60 + (cacheState.progressState.processedTiers / cacheState.progressState.totalTiers) * 30)}%`;
      cacheState.lastUpdated = Date.now();
      cacheState.progressState.lastUpdated = Date.now();
      await saveCacheStateContract(contractKey, cacheState);
      await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');
      logger.debug('holders', `Processed chunk ${i / chunkSize + 1}: ${results.length} tiers`, chain, contractKey);
    } catch (error) {
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', chunk: i / chunkSize + 1, error: error.message });
      chunk.forEach(() => tierResults.push({ status: 'failure', result: 0, error: error.message }));
    }
  }

  tierResults.forEach((result, i) => {
    const tokenId = Array.from(tokenOwnerMap.keys())[i];
    const tier = result.status === 'success' && typeof result.result === 'number' ? Number(result.result) : (contractKey === 'ascendant' && result.status === 'success' ? Number(result.result[1]) : 0);
    cachedTokenTiers.set(tokenId, { tier, timestamp: Date.now() });
    tierDistribution[tier] += 1;
    const wallet = tokenOwnerMap.get(tokenId);
    const holder = holdersMap.get(wallet);
    if (holder) {
      holder.tiers[tier] += 1;
      holder.multiplierSum += contractTiers[tier + 1]?.multiplier || tier + 1;
      logger.debug('holders', `Assigned tier=${tier} to tokenId=${tokenId}, wallet=${wallet}`, chain, contractKey);
    }
  });
  logger.debug('holders', `Completed tier fetching: totalTiers=${tierResults.length}, distribution=${JSON.stringify(tierDistribution)}`, chain, contractKey);

  cacheState.progressState.step = 'completed';
  cacheState.progressState.isPopulating = false;
  cacheState.isPopulating = false;
  cacheState.progressState.progressPercentage = '100%';
  cacheState.progressState.totalNfts = totalTokens;
  cacheState.progressState.processedNfts = totalTokens;
  cacheState.progressState.totalOwners = holdersMap.size;
  cacheState.progressState.totalLiveHolders = totalTokens;
  cacheState.globalMetrics = { totalMinted: totalTokens + totalBurned, totalLive: totalTokens, totalBurned, tierDistribution };
  cacheState.lastProcessedBlock = Number(lastBlock);
  cacheState.progressState.lastProcessedBlock = Number(lastBlock);
  cacheState.lastUpdated = Date.now();
  cacheState.progressState.lastUpdated = Date.now();

  await saveCacheStateContract(contractKey, cacheState);
  await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

  const holderList = Array.from(holdersMap.values());
  holderList.sort((a, b) => b.total - a.total || b.multiplierSum - a.multiplierSum);
  holderList.forEach((holder, index) => {
    holder.rank = index + 1;
    holder.percentage = totalTokens ? (holder.total / totalTokens * 100) : 0;
    holder.displayMultiplierSum = holder.multiplierSum;
  });

  await setCache(`${contractKey}_holders`, { holders: holderList, totalBurned, timestamp: Date.now(), rarityDistribution }, 0, contractKey);
  await setCache(`${contractKey}_tiers`, Object.fromEntries(cachedTokenTiers), config.cache.nodeCache.stdTTL || 86400, contractKey);

  const summary = {
    totalLive: totalTokens,
    totalBurned,
    totalMinted: totalTokens + totalBurned,
    tierDistribution,
    multiplierPool: holderList.reduce((sum, h) => sum + h.multiplierSum, 0),
  };
  await setCache(`${contractKey}_summary`, { holders: holderList, summary, totalBurned, timestamp: Date.now() }, config.cache.nodeCache.stdTTL, contractKey, 'summary');

  return sanitizeBigInt({ holders: holderList, totalBurned, lastBlock: Number(lastBlock), errorLog, rarityDistribution });
}
----- ./app/api/holders/cache/holders.js -----

export { ensureCacheDirectory, sanitizeBigInt } from './utils';
export { getHoldersMap } from './getHoldersMap';
export { populateHoldersMapCache } from './populateHoldersMapCache';
----- ./app/api/holders/cache/populateHoldersMapCache.js -----

// app/api/holders/cache/populateHoldersMapCache.js
import config from '@/app/contracts_nft';
import { logger } from '@/app/lib/logger';
import { getCacheState, saveCacheStateContract } from '@/app/api/holders/cache/state';
import { getCache, setCache, validateContract } from '@/app/api/utils/cache';
import { ensureCacheDirectory, sanitizeBigInt } from './utils';
import { getHoldersMap } from './getHoldersMap';

export async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) {
  let cacheState;
  const chain = config.nftContracts[contractKey.toLowerCase()]?.chain || 'eth';
  try {
    await ensureCacheDirectory();
    cacheState = await getCacheState(contractKey.toLowerCase());

    if (!forceUpdate && cacheState.isPopulating) {
      logger.info('holders', `Cache population already in progress for ${contractKey}`, chain, contractKey);
      return { status: 'pending', holders: [], totalPages: 1, totalTokens: 0, summary: {}, globalMetrics: {}, contractKey };
    }

    cacheState.isPopulating = true;
    cacheState.progressState.step = 'initializing';
    cacheState.progressState.progressPercentage = '0%';
    cacheState.lastUpdated = Date.now();
    cacheState.progressState.lastUpdated = Date.now();
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);
    await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

    const isValid = await validateContract(contractKey);
    if (!isValid) throw new Error(`Invalid contract configuration for ${contractKey}`);

    const { holders, totalBurned, lastBlock, errorLog, rarityDistribution } = await getHoldersMap(
      contractKey,
      contractAddress,
      abi,
      vaultAddress,
      vaultAbi,
      cacheState,
      forceUpdate
    );

    const holderList = holders.map(data => ({
      wallet: data.wallet,
      total: data.total,
      tokenIds: data.tokenIds,
      tiers: data.tiers,
      multiplierSum: data.multiplierSum,
      shares: data.shares || 0,
      lockedAscendant: data.lockedAscendant || 0,
      claimableRewards: data.claimableRewards || 0,
      pendingDay8: data.pendingDay8 || 0,
      pendingDay28: data.pendingDay28 || 0,
      pendingDay90: data.pendingDay90 || 0,
      infernoRewards: data.infernoRewards || 0,
      fluxRewards: data.fluxRewards || 0,
      e280Rewards: data.e280Rewards || 0,
      percentage: data.percentage || 0,
      displayMultiplierSum: data.displayMultiplierSum || data.multiplierSum,
      rank: data.rank || 0,
      ...(contractKey === 'ascendant' ? { tokens: data.tokens || [] } : {}),
    }));

    cacheState.isPopulating = false;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.status = 'success';
    cacheState.progressState.progressPercentage = '100%';
    cacheState.totalOwners = holderList.length;
    cacheState.totalLiveHolders = holderList.reduce((sum, h) => sum + h.total, 0);
    cacheState.lastUpdated = Date.now();
    cacheState.progressState.lastUpdated = Date.now();
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);
    await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');

    const totalTokens = cacheState.globalMetrics.totalLive || 0;
    const summary = {
      totalLive: totalTokens,
      totalBurned: totalBurned || 0,
      totalMinted: (totalTokens + totalBurned) || 0,
      tierDistribution: cacheState.globalMetrics.tierDistribution || Array(Math.max(...Object.keys(config.nftContracts[contractKey]?.tiers || {}).map(Number), 0) + 1).fill(0),
      multiplierPool: holderList.reduce((sum, h) => sum + h.multiplierSum, 0),
      ...(contractKey === 'ascendant' ? { rarityDistribution } : {}),
    };
    await setCache(`${contractKey}_summary`, { holders: holderList, summary, totalBurned, timestamp: Date.now() }, config.cache.nodeCache.stdTTL, contractKey, 'summary');

    return {
      status: 'success',
      holders: holderList,
      totalBurned: totalBurned || 0,
      lastBlock,
      errorLog,
      totalPages: 1,
      totalTokens,
      summary,
      globalMetrics: cacheState.globalMetrics,
      contractKey,
    };
  } catch (error) {
    cacheState = cacheState || (await getCacheState(contractKey.toLowerCase()));
    cacheState.isPopulating = false;
    cacheState.progressState.step = 'failed';
    cacheState.progressState.status = 'error';
    cacheState.progressState.error = error.message;
    cacheState.progressState.errorLog = cacheState.progressState.errorLog || [];
    cacheState.progressState.errorLog.push({ timestamp: new Date().toISOString(), phase: cacheState.progressState.step || 'unknown', error: error.message });
    cacheState.lastUpdated = Date.now();
    cacheState.progressState.lastUpdated = Date.now();
    await saveCacheStateContract(contractKey.toLowerCase(), cacheState);
    await setCache(`${contractKey}_state`, cacheState, config.cache.nodeCache.stdTTL, contractKey, 'state');
    throw error;
  }
}
----- ./app/api/holders/cache/state.js -----

// app/api/holders/cache/state.js
import { logger } from '@/app/lib/logger';
import { getCache, setCache } from '@/app/api/utils/cache';

const DEFAULT_STATE = {
  isPopulating: false,
  totalOwners: 0,
  totalLiveHolders: 0,
  progressState: {
    step: 'idle',
    processedNfts: 0,
    totalNfts: 0,
    processedTiers: 0,
    totalTiers: 0,
    error: null,
    errorLog: [],
    progressPercentage: '0%',
    totalLiveHolders: 0,
    totalOwners: 0,
    lastProcessedBlock: null,
    lastUpdated: null,
  },
  lastUpdated: null,
  lastProcessedBlock: null,
  globalMetrics: {},
};

export async function loadCacheState(contractKey, chain = 'eth') {
  try {
    const data = await getCache(`${contractKey}_state`, contractKey, 'state');
    return data || null;
  } catch (error) {
    logger.error('cache/state', `Failed to load cache state for ${contractKey}: ${error.message}`, { stack: error.stack }, chain, contractKey);
    throw error;
  }
}

export async function saveCacheStateContract(contractKey, state, chain = 'eth') {
  try {
    await setCache(`${contractKey}_state`, state, 0, contractKey, 'state');
    logger.debug('cache/state', `Saved cache state for ${contractKey}`, chain, contractKey);
  } catch (error) {
    logger.error('cache/state', `Failed to save cache state for ${contractKey}: ${error.message}`, { stack: error.stack }, chain, contractKey);
    throw error;
  }
}

export async function getCacheState(contractKey) {
  const cacheState = { ...DEFAULT_STATE };
  try {
    logger.debug('cache/state', `Loading cache state for ${contractKey}`, 'eth', contractKey);
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object' && savedState.progressState) {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.totalLiveHolders = savedState.totalLiveHolders ?? 0;
      cacheState.progressState = {
        ...cacheState.progressState,
        ...savedState.progressState,
        error: savedState.progressState.error || null,
        errorLog: Array.isArray(savedState.progressState.errorLog) ? savedState.progressState.errorLog : [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
      cacheState.globalMetrics = savedState.globalMetrics ?? {};
      logger.info(
        'cache/state',
        `Loaded cache state for ${contractKey}: step=${cacheState.progressState.step}, progress=${cacheState.progressState.progressPercentage}`,
        'eth',
        contractKey
      );
    } else {
      await saveCacheStateContract(contractKey, cacheState);
      logger.warn('cache/state', `No valid cache state found for ${contractKey}, initialized and saved default`, 'eth', contractKey);
    }
  } catch (error) {
    logger.error(
      'cache/state',
      `Failed to load cache state for ${contractKey}: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    cacheState.progressState.error = `Failed to load cache state: ${error.message}`;
    cacheState.progressState.errorLog.push({
      timestamp: new Date().toISOString(),
      phase: 'load_cache_state',
      error: error.message,
    });
    await saveCacheStateContract(contractKey, cacheState);
  }
  return cacheState;
}
----- ./app/api/holders/cache/state/[contractKey]/route.js -----

// app/api/holders/cache/state/[contractKey]/route.js
import { NextResponse } from 'next/server';
import { getCacheState } from '@/app/api/holders/cache/state';
import { logger } from '@/app/lib/logger';

// In app/api/holders/cache/state/[contractKey]/route.js
export async function GET(request, { params }) {
  const { contractKey } = await params;
  if (!contractKey) {
    logger.error('cache/state', 'Contract key missing in request', 'eth', 'general');
    return NextResponse.json({ error: 'Contract key is required' }, { status: 400 });
  }
  try {
    const cacheState = await getCacheState(contractKey.toLowerCase());
    logger.info('cache/state', `Fetched cache state for ${contractKey}`, 'eth', contractKey);
    return NextResponse.json({
      ...cacheState,
      errorLog: cacheState.progressState.errorLog, // Explicitly include errorLog
    });
  } catch (error) {
    logger.error(
      'cache/state',
      `Failed to fetch cache state for ${contractKey}: ${error.message}`,
      { stack: error.stack },
      'eth',
      contractKey
    );
    return NextResponse.json({ error: `Failed to fetch cache state: ${error.message}` }, { status: 500 });
  }
}
----- ./app/api/holders/cache/utils.js -----

import { mkdir } from 'fs/promises';
import { join } from 'path';
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';
import { Alchemy, Network } from 'alchemy-sdk';

export const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`),
});

export async function ensureCacheDirectory() {
  const cacheDir = join(process.cwd(), 'cache');
  const chain = 'eth';
  const collection = 'general';
  try {
    logger.debug('holders', `Ensuring cache directory at: ${cacheDir}`, chain, collection);
    await mkdir(cacheDir, { recursive: true });
    logger.info('holders', `Cache directory created or exists: ${cacheDir}`, chain, collection);
  } catch (error) {
    logger.error('holders', `Failed to create cache directory: ${error.message}`, { stack: error.stack }, chain, collection);
    throw new Error(`Cache directory creation failed: ${error.message}`);
  }
}

export function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') return obj.toString();
  if (Array.isArray(obj)) return obj.map(item => sanitizeBigInt(item));
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}
----- ./app/api/holders/e280/route.js -----

// app/api/holders/E280/route.js
import { NextResponse } from 'next/server';
import { log } from '../../utils';

export async function GET(request) {
  log('GET /api/holders/E280: Data not available yet');
  return NextResponse.json({ message: 'E280 data will go live after deployment' });
}
----- ./app/api/holders/element280/route.js -----

// app/api/holders/element280/route.js
import { NextResponse } from 'next/server';
import pino from 'pino';
import { populateHoldersMapCache } from '@/app/api/holders/cache/holders';
import { getHolderData, getAllHolders } from '@/app/api/holders/shared';
import config from '@/app/contracts_nft';
import { getContractAbi } from '@/app/contracts_nft';
import { HoldersResponseSchema } from '@/app/lib/schemas';

const logger = pino({ level: 'info', base: { context: 'element280' } });
const contractKey = 'element280';
const contractConfig = config.nftContracts[contractKey];

async function preWarmCache() {
  logger.info(`[element280] Starting pre-warm cache`, 'ETH', contractKey);
  try {
    if (!contractConfig?.contractAddress) throw new Error('Element280 contract address not found');
    await populateHoldersMapCache(
      contractKey,
      contractConfig.contractAddress,
      getContractAbi(contractKey, 'nft'),
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault')
    );
    logger.info('[element280] Pre-warm cache completed', 'ETH', contractKey);
  } catch (err) {
    logger.error(`[element280] Pre-warm cache failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey);
  }
}

preWarmCache().catch(err => logger.error(`[element280] Pre-warm cache init failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey));

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  if (!contractConfig?.contractAddress) {
    logger.error('[element280] Contract address not found', {}, 'ETH', contractKey);
    return NextResponse.json({ error: 'Element280 contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(
        contractKey,
        contractConfig.contractAddress,
        wallet,
        config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
          ...acc,
          [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
        }), {}),
        contractConfig.vaultAddress,
        getContractAbi(contractKey, 'vault')
      );
      const response = { holders: holderData ? [holderData] : [], totalPages: 1, totalTokens: holderData?.total || 0, totalBurned: 0, summary: {}, contractKey };
      HoldersResponseSchema.parse(response);
      logger.info(`[element280] GET wallet=${wallet} succeeded: ${holderData ? 1 : 0} holders`, 'ETH', contractKey);
      return NextResponse.json(response);
    }

    const result = await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault'),
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      page,
      pageSize
    );

    HoldersResponseSchema.parse(result);
    logger.info(`[element280] GET succeeded: ${result.holders.length} holders`, 'ETH', contractKey);
    return NextResponse.json(result);
  } catch (error) {
    logger.error(`[element280] GET failed: ${error.message}`, { stack: error.stack }, 'ETH', contractKey);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
----- ./app/api/holders/element369/route.js -----

// app/api/holders/element369/route.js
import { NextResponse } from 'next/server';
import { getAllHolders, getHolderData } from '@/app/api/holders/shared';
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';
import { getContractAbi } from '@/app/contracts_nft';
import { HoldersResponseSchema } from '@/app/lib/schemas';

const contractKey = 'element369';
const contractConfig = config.nftContracts[contractKey];

async function preWarmCache() {
  logger.info('element369', 'Starting pre-warm cache', 'ETH', contractKey);
  try {
    if (!contractConfig?.contractAddress) throw new Error('Element369 contract address not found');
    await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault'),
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      0,
      1000
    );
    logger.info('element369', 'Pre-warm cache completed', 'ETH', contractKey);
  } catch (err) {
    logger.error('element369', `Pre-warm cache failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey);
  }
}

preWarmCache().catch(err => logger.error('element369', `Pre-warm cache init failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey));

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  if (!contractConfig?.contractAddress) {
    logger.error('element369', 'Contract address not found', {}, 'ETH', contractKey);
    return NextResponse.json({ error: 'Element369 contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(
        contractKey,
        contractConfig.contractAddress,
        wallet,
        config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
          ...acc,
          [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
        }), {}),
        contractConfig.vaultAddress,
        getContractAbi(contractKey, 'vault')
      );
      const response = { holders: holderData ? [holderData] : [], totalPages: 1, totalTokens: holderData?.total || 0, totalBurned: 0, summary: {}, contractKey };
      HoldersResponseSchema.parse(response);
      logger.info('element369', `GET wallet=${wallet} succeeded: ${holderData ? 1 : 0} holders`, 'ETH', contractKey);
      return NextResponse.json(response);
    }

    const result = await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault'),
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      page,
      pageSize
    );

    HoldersResponseSchema.parse(result);
    logger.info('element369', `GET succeeded: ${result.holders.length} holders`, 'ETH', contractKey);
    return NextResponse.json(result);
  } catch (error) {
    logger.error('element369', `GET failed: ${error.message}`, { stack: err.stack }, 'ETH', contractKey);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
----- ./app/api/holders/shared.js -----

// app/api/holders/shared.js
import { alchemy } from '@/app/api/utils/client';
import { getCache, setCache } from '@/app/api/utils/cache';
import { logger } from '@/app/lib/logger';
import { getHoldersMap } from '@/app/api/holders/cache/holders';
import { HoldersResponseSchema } from '@/app/lib/schemas';
import { CACHE_TTL } from '@/app/lib/constants';
import config from '@/app/contracts_nft';
import { getContractAbi, commonFunctions } from '@/app/contracts_nft';
import { batchMulticall } from '@/app/api/holders/blockchain/multicall';
import { getCacheState } from '@/app/api/holders/cache/state';
import { sanitizeBigInt } from '@/app/api/holders/cache/holders';
import { createPublicClient, http, getAddress } from 'viem';
import { mainnet } from 'viem/chains';
import pLimit from 'p-limit';

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`, { timeout: 60000 }),
});

export async function fetchContractState(contractKey, contractAddress, vaultAddress, vaultAbi) {
  const calls = [
    { address: contractAddress, abi: getContractAbi(contractKey, 'nft'), functionName: commonFunctions.totalSupply.name },
    { address: contractAddress, abi: getContractAbi(contractKey, 'nft'), functionName: commonFunctions.totalBurned.name },
    ...(vaultAddress && vaultAbi ? [
      { address: vaultAddress, abi: vaultAbi, functionName: 'totalE280Burned' },
      { address: vaultAddress, abi: vaultAbi, functionName: 'totalRewardsPaid' },
      { address: vaultAddress, abi: vaultAbi, functionName: 'totalRewardPool' },
    ] : []),
  ];

  const results = await batchMulticall(calls);
  logger.debug('holders', `fetchContractState results for ${contractKey}: ${JSON.stringify(sanitizeBigInt(results))}`, 'ETH', contractKey);

  return sanitizeBigInt({
    totalSupply: results[0]?.status === 'success' && results[0].result != null ? Number(results[0].result) : 0,
    totalBurned: results[1]?.status === 'success' && results[1].result != null ? Number(results[1].result) : 0,
    totalE280Burned: vaultAddress && results[2]?.status === 'success' ? Number(results[2].result) / 1e18 : 0,
    totalRewardsPaid: vaultAddress && results[3]?.status === 'success' ? Number(results[3].result) / 1e18 : 0,
    totalRewardPool: vaultAddress && results[4]?.status === 'success' ? Number(results[4].result) / 1e18 : 0,
  });
}

export async function getAllHolders(contractKey, contractAddress, vaultAddress, vaultAbi, tiers, page = 0, pageSize = 1000) {
  const cacheKey = `${contractAddress}-all-${page}-${pageSize}`;
  const now = Date.now();
  const cacheData = await getCache(cacheKey, contractKey, 'holders');

  if (cacheData && now - cacheData.timestamp < CACHE_TTL) {
    logger.info('holders', `Cache hit: ${cacheKey}`, 'ETH', contractKey);
    return cacheData.data;
  }

  const state = await fetchContractState(contractKey, contractAddress, vaultAddress, vaultAbi);
  const cacheState = await getCacheState(contractKey.toLowerCase());
  const { holders, totalBurned, lastBlock, errorLog } = await getHoldersMap(
    contractKey,
    contractAddress,
    getContractAbi(contractKey, 'nft'),
    vaultAddress,
    vaultAbi,
    cacheState
  );

  const safeLastBlock = typeof lastBlock === 'number' && !isNaN(lastBlock) && lastBlock >= 0 ? lastBlock : 0;
  const totalBurnedSafe = typeof totalBurned === 'number' && !isNaN(totalBurned) && totalBurned >= 0 ? totalBurned : state.totalBurned || 0;
  const transferData = await getCache(`${contractAddress}-transfers`, contractKey, 'transfers') || { buys: [], sells: [], burns: [] };
  const totalTokens = state.totalSupply || 0;
  const totalMinted = totalTokens + totalBurnedSafe;
  const maxTier = Math.max(...Object.keys(tiers).map(Number), 0);
  const tierDistribution = Array(maxTier + 1).fill(0);

  const validHolders = holders.filter(holder => holder && typeof holder.wallet === 'string' && /^0x[a-fA-F0-9]{40}$/.test(holder.wallet));
  validHolders.forEach(holder => {
    holder.tiers = holder.tiers || Array(maxTier + 1).fill(0);
    holder.tiers.forEach((count, tier) => tierDistribution[tier] += count);
    holder.boughtNfts = transferData.buys
      .filter(t => t.to.toLowerCase() === holder.wallet.toLowerCase())
      .map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));
    holder.soldNfts = transferData.sells
      .filter(t => t.from.toLowerCase() === holder.wallet.toLowerCase())
      .map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));
    holder.burnedNfts = transferData.burns
      .filter(t => t.from.toLowerCase() === holder.wallet.toLowerCase())
      .map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));
    holder.buyCount = holder.boughtNfts.length;
    holder.sellCount = holder.soldNfts.length;
    holder.burnCount = holder.burnedNfts.length;
    holder.rank = holder.rank || 0;
    holder.percentage = holder.percentage || 0;
    holder.multiplierSum = holder.multiplierSum || 0;
    holder.displayMultiplierSum = holder.displayMultiplierSum || holder.multiplierSum;
    holder.claimableRewards = holder.claimableRewards || 0;
  });

  const totalMultiplierSum = validHolders.reduce((sum, h) => sum + h.multiplierSum, 0);
  validHolders.forEach((holder, index) => {
    holder.rank = index + 1;
    holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
  });

  const startPage = page * pageSize;
  const paginatedHolders = validHolders.slice(startPage, startPage + pageSize);
  const totalPages = Math.ceil(validHolders.length / pageSize) || 1;

  const result = {
    status: 'success',
    holders: paginatedHolders,
    totalPages,
    totalTokens,
    totalBurned: totalBurnedSafe,
    lastBlock: safeLastBlock,
    errorLog: errorLog || cacheState.progressState.errorLog || [],
    contractKey,
    summary: {
      totalLive: totalTokens,
      totalBurned: totalBurnedSafe,
      totalMinted,
      totalE280Burned: state.totalE280Burned || 0,
      totalRewardsPaid: state.totalRewardsPaid || 0,
      totalRewardPool: state.totalRewardPool || 0,
      tierDistribution,
      multiplierPool: totalMultiplierSum,
    },
    transferSummary: {
      buyCount: transferData.buys?.length || 0,
      sellCount: transferData.sells?.length || 0,
      burnCount: transferData.burns?.length || 0,
    },
    globalMetrics: cacheState.globalMetrics || { totalMinted, totalLive: totalTokens, totalBurned: totalBurnedSafe, tierDistribution },
  };

  const sanitizedResult = sanitizeBigInt(result);
  HoldersResponseSchema.parse(sanitizedResult);
  await setCache(cacheKey, { timestamp: now, data: sanitizedResult }, CACHE_TTL, contractKey, 'holders');
  await setCache('summary', { timestamp: now, data: sanitizedResult.summary }, CACHE_TTL, contractKey, 'summary');
  logger.info('holders', `getAllHolders completed: ${paginatedHolders.length} holders, totalPages=${totalPages}`, 'ETH', contractKey);
  return sanitizedResult;
}

export async function getHolderData(contractKey, contractAddress, wallet, tiers, vaultAddress, vaultAbi) {
  const cacheKey = `${contractAddress}-${wallet}`;
  const now = Date.now();
  const cacheData = await getCache(cacheKey, contractKey, 'holders');

  if (cacheData && now - cacheData.timestamp < CACHE_TTL) {
    logger.info('holders', `Cache hit: ${cacheKey}`, 'ETH', contractKey);
    return cacheData.data;
  }

  if (!/^0x[a-fA-F0-9]{40}$/.test(wallet)) throw new Error('Invalid wallet address');
  if (!vaultAddress || !vaultAbi) throw new Error('Vault configuration missing');

  const walletLower = getAddress(wallet).toLowerCase();
  const client = createPublicClient({
    chain: mainnet,
    transport: http(`https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`, { timeout: 60000 }),
  });

  const ownerCacheKey = `${contractAddress}-owner-${walletLower}`;
  const ownerCache = await getCache(ownerCacheKey, contractKey, 'owners');
  let nfts;
  if (ownerCache && now - ownerCache.timestamp < CACHE_TTL) {
    nfts = ownerCache.data;
    logger.info('holders', `Owner cache hit: ${ownerCacheKey}`, 'ETH', contractKey);
  } else {
    logger.debug('holders', `Fetching NFTs for wallet=${walletLower}`, 'ETH', contractKey);
    nfts = await alchemy.nft.getNftsForOwner(walletLower, { contractAddresses: [contractAddress] });
    await setCache(ownerCacheKey, { timestamp: now, data: nfts }, CACHE_TTL, contractKey, 'owners');
    logger.debug('holders', `Fetched ${nfts.totalCount} NFTs for wallet=${walletLower}`, 'ETH', contractKey);
  }

  if (nfts.totalCount === 0) {
    logger.info('holders', `No NFTs found for wallet=${walletLower}`, 'ETH', contractKey);
    return null;
  }

  const tokenIds = nfts.ownedNfts.map(nft => Number(nft.tokenId));
  const isAscendant = contractKey.toLowerCase() === 'ascendant';
  const tierFunction = isAscendant ? 'getNFTAttribute' : 'getNftTier';

  logger.debug('holders', `Starting tier fetching for wallet=${walletLower}, tokenIds=${tokenIds.join(',')}`, 'ETH', contractKey);
  let decimals = 18;
  try {
    const e280Result = await client.multicall({
      contracts: [{ address: vaultAddress, abi: vaultAbi, functionName: 'E280' }],
      multicallAddress: '0xcA11bde05977b3631167028862bE2a173976CA11',
      allowFailure: true,
    });
    const e280Address = e280Result[0]?.status === 'success' ? e280Result[0].result : null;
    if (e280Address && /^0x[a-fA-F0-9]{40}$/.test(e280Address)) {
      const decimalsResult = await client.multicall({
        contracts: [
          { address: e280Address, abi: [{ inputs: [], name: 'decimals', outputs: [{ type: 'uint8' }], stateMutability: 'view', type: 'function' }], functionName: 'decimals' },
        ],
        multicallAddress: '0xcA11bde05977b3631167028862bE2a173976CA11',
        allowFailure: true,
      });
      decimals = decimalsResult[0]?.status === 'success' ? Number(decimalsResult[0].result) : 18;
      logger.debug('holders', `E280 token decimals: ${decimals}`, 'ETH', contractKey);
    }
  } catch (error) {
    logger.error('holders', `Failed to fetch E280 decimals: ${error.message}`, { stack: error.stack }, 'ETH', contractKey);
  }

  const calls = [];
  tokenIds.forEach(tokenId => {
    calls.push({ address: contractAddress, abi: getContractAbi(contractKey, 'nft'), functionName: 'ownerOf', args: [BigInt(tokenId)] });
    calls.push({ address: contractAddress, abi: getContractAbi(contractKey, 'nft'), functionName: tierFunction, args: [BigInt(tokenId)] });
    calls.push({ address: vaultAddress, abi: vaultAbi, functionName: 'claimedCycles', args: [BigInt(tokenId)] });
  });
  calls.push({ address: vaultAddress, abi: vaultAbi, functionName: 'currentCycle' });
  calls.push({ address: vaultAddress, abi: vaultAbi, functionName: 'totalRewardPool' });

  const results = await client.multicall({
    contracts: calls,
    multicallAddress: '0xcA11bde05977b3631167028862bE2a173976CA11',
    allowFailure: true,
  });
  let resultIndex = 0;

  const validTokenIds = [];
  for (let i = 0; i < tokenIds.length; i++) {
    const ownerResult = results[resultIndex++];
    if (ownerResult?.status === 'success' && ownerResult.result.toLowerCase() === walletLower) {
      validTokenIds.push(tokenIds[i]);
    }
  }

  if (validTokenIds.length === 0) {
    logger.info('holders', `No valid NFTs owned by wallet=${walletLower}`, 'ETH', contractKey);
    return null;
  }

  const maxTier = Math.max(...Object.keys(tiers).map(Number), 0);
  const tiersArray = Array(maxTier + 1).fill(0);
  let total = 0;
  let multiplierSum = 0;
  const tokens = [];
  for (let i = 0; i < tokenIds.length; i++) {
    const tierResult = results[resultIndex++];
    const tokenId = tokenIds[i];
    if (validTokenIds.includes(tokenId) && tierResult?.status === 'success') {
      let tier = isAscendant ? Number(tierResult.result[1]) : Number(tierResult.result);
      if (tier >= 1 && tier <= maxTier) {
        tiersArray[tier] += 1;
        total += 1;
        multiplierSum += tiers[tier]?.multiplier || 0;
        tokens.push({ tokenId, tier, rarityNumber: tiers[tier]?.multiplier || 0, rarity: tier });
        logger.debug('holders', `Fetched tier for tokenId=${tokenId}: tier=${tier}, multiplier=${tiers[tier]?.multiplier || 0}`, 'ETH', contractKey);
      }
    }
  }
  logger.debug('holders', `Completed tier fetching for wallet=${walletLower}: totalTokens=${total}, tiers=${JSON.stringify(tiersArray)}`, 'ETH', contractKey);

  const claimedCycles = [];
  for (let i = 0; i < tokenIds.length; i++) {
    const cycleResult = results[resultIndex++];
    claimedCycles.push(cycleResult?.status === 'success' ? Number(cycleResult.result) : 0);
  }

  const currentCycle = results[resultIndex++]?.status === 'success' ? Number(results[resultIndex - 1].result) : 0;
  const totalRewardPool = results[resultIndex++]?.status === 'success' ? Number(results[resultIndex - 1].result) / 10 ** decimals : 0;

  const eligibleTokens = validTokenIds.filter((tokenId, i) => claimedCycles[i] < currentCycle);
  logger.debug('holders', `Starting claimable rewards calculation for wallet=${walletLower}, eligibleTokens=${eligibleTokens.length}`, 'ETH', contractKey);

  let claimableRewards = 0;
  const tokenChunks = eligibleTokens.reduce((chunks, id, idx) => {
    if (idx % 100 === 0) chunks.push([]);
    chunks[chunks.length - 1].push(BigInt(id));
    return chunks;
  }, []);

  const tokenCacheKeys = tokenIds.map(id => `${contractAddress}-token-${id}`);
  const tokenCaches = await Promise.all(tokenCacheKeys.map(key => getCache(key, contractKey, 'tokens')));
  const cachedRewards = tokenCaches.map(cache => cache?.data?.reward || 0);
  claimableRewards += cachedRewards.reduce((sum, reward) => sum + reward, 0);
  logger.debug('holders', `Cached rewards for wallet=${walletLower}: ${claimableRewards} ELMNT`, 'ETH', contractKey);

  const uncachedChunks = tokenChunks.filter((chunk, i) => !tokenCaches[i] || !tokenCaches[i].data?.reward);
  const limit = pLimit(50);
  const rewardPromises = uncachedChunks.map((chunk, i) => limit(async () => {
    const rewardCall = {
      address: vaultAddress,
      abi: vaultAbi,
      functionName: 'getRewards',
      args: [chunk, walletLower],
    };
    try {
      const rewardResult = await client.multicall({
        contracts: [rewardCall],
        multicallAddress: '0xcA11bde05977b3631167028862bE2a173976CA11',
        allowFailure: true,
      });
      if (rewardResult[0]?.status === 'success' && rewardResult[0].result) {
        const [, totalReward] = rewardResult[0].result;
        const rewardEth = Number(totalReward) / 10 ** decimals;
        logger.debug('holders', `Chunk ${i + 1}: ${chunk.length} tokens, totalReward=${rewardEth} ELMNT, tokenIds=${chunk.join(',')}`, 'ETH', contractKey);
        chunk.forEach(tokenId => {
          const tokenIndex = tokenIds.indexOf(Number(tokenId));
          if (tokenIndex !== -1) {
            setCache(`${contractAddress}-token-${tokenId}`, {
              timestamp: now,
              data: { claimedCycles: claimedCycles[tokenIndex], reward: rewardEth / chunk.length },
            }, CACHE_TTL, contractKey, 'tokens');
          }
        });
        return rewardEth;
      }
      logger.warn('holders', `getRewards failed for chunk ${i + 1}`, 'ETH', contractKey);
      return 0;
    } catch (error) {
      logger.error('holders', `Error fetching getRewards for chunk ${i + 1}: ${error.message}`, { stack: error.stack }, 'ETH', contractKey);
      return 0;
    }
  }));
  const rewardResults = await Promise.all(rewardPromises);
  claimableRewards += rewardResults.reduce((sum, reward) => sum + reward, 0);
  logger.debug('holders', `Completed claimable rewards calculation for wallet=${walletLower}: totalRewards=${claimableRewards} ELMNT`, 'ETH', contractKey);

  const transferData = await getCache(`${contractAddress}-transfers`, contractKey, 'transfers') || { buys: [], sells: [], burns: [] };
  const boughtNfts = transferData.buys.filter(t => t.to.toLowerCase() === walletLower).map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));
  const soldNfts = transferData.sells.filter(t => t.from.toLowerCase() === walletLower).map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));
  const burnedNfts = transferData.burns.filter(t => t.from.toLowerCase() === walletLower).map(t => ({ tokenId: t.tokenId, transactionHash: t.transactionHash || '', timestamp: t.timestamp || 0 }));

  const summaryCache = await getCache(`${contractAddress}-summary`, contractKey, 'summary');
  const totalMultiplierSum = summaryCache?.data?.multiplierPool || 1000;
  const percentage = totalMultiplierSum > 0 ? (multiplierSum / totalMultiplierSum) * 100 : 0;
  const rank = summaryCache?.data?.holders?.find(h => h.wallet === walletLower)?.rank || 1;

  const result = {
    wallet: walletLower,
    rank,
    total,
    multiplierSum,
    displayMultiplierSum: multiplierSum / (contractKey.toLowerCase() === 'ascendant' ? 1 : 10),
    percentage,
    tiers: tiersArray,
    claimableRewards,
    buyCount: boughtNfts.length,
    sellCount: soldNfts.length,
    burnCount: burnedNfts.length,
    boughtNfts,
    soldNfts,
    burnedNfts,
    tokens,
  };

  HoldersResponseSchema.parse({
    status: 'success',
    holders: [result],
    totalPages: 1,
    totalTokens: total,
    totalBurned: summaryCache?.data?.totalBurned || 0,
    lastBlock: summaryCache?.data?.lastBlock || 0,
    errorLog: [],
    contractKey,
    summary: summaryCache?.data || { totalLive: total, totalBurned: 0, totalMinted: total, tierDistribution: tiersArray, multiplierPool: totalMultiplierSum },
    globalMetrics: summaryCache?.data?.globalMetrics || {},
  });

  await setCache(cacheKey, { timestamp: now, data: result }, CACHE_TTL, contractKey, 'holders');
  logger.info('holders', `getHolderData completed for wallet=${walletLower}, claimableRewards=${claimableRewards}, totalTokens=${total}`, 'ETH', contractKey);
  return result;
}
----- ./app/api/holders/stax/route.js -----

// app/api/holders/stax/route.js
import { NextResponse } from 'next/server';
import { getAllHolders, getHolderData } from '@/app/api/holders/shared';
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';
import { getContractAbi } from '@/app/contracts_nft';
import { HoldersResponseSchema } from '@/app/lib/schemas';

const contractKey = 'stax';
const contractConfig = config.nftContracts[contractKey];

async function preWarmCache() {
  logger.info('stax', 'Starting pre-warm cache', 'ETH', contractKey);
  try {
    if (!contractConfig?.contractAddress) throw new Error('Stax contract address not found');
    await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault'),
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      0,
      1000
    );
    logger.info('stax', 'Pre-warm cache completed', 'ETH', contractKey);
  } catch (err) {
    logger.error('stax', `Pre-warm cache failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey);
  }
}

preWarmCache().catch(err => logger.error('stax', `Pre-warm cache init failed: ${err.message}`, { stack: err.stack }, 'ETH', contractKey));

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');
  const page = Math.max(0, parseInt(searchParams.get('page') || '0', 10));
  const pageSize = Math.max(1, Math.min(1000, parseInt(searchParams.get('pageSize') || '1000', 10)));

  if (!contractConfig?.contractAddress) {
    logger.error('stax', 'Contract address not found', {}, 'ETH', contractKey);
    return NextResponse.json({ error: 'Stax contract address not found' }, { status: 400 });
  }

  try {
    if (wallet) {
      const holderData = await getHolderData(
        contractKey,
        contractConfig.contractAddress,
        wallet,
        config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
          ...acc,
          [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
        }), {}),
        contractConfig.vaultAddress,
        getContractAbi(contractKey, 'vault')
      );
      const response = { holders: holderData ? [holderData] : [], totalPages: 1, totalTokens: holderData?.total || 0, totalBurned: 0, summary: {}, contractKey };
      HoldersResponseSchema.parse(response);
      logger.info('stax', `GET wallet=${wallet} succeeded: ${holderData ? 1 : 0} holders`, 'ETH', contractKey);
      return NextResponse.json(response);
    }

    const result = await getAllHolders(
      contractKey,
      contractConfig.contractAddress,
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault'),
      config.contractTiers[contractKey].tierOrder.reduce((acc, t) => ({
        ...acc,
        [t.tierId]: { multiplier: contractConfig.tiers[t.tierId].multiplier },
      }), {}),
      page,
      pageSize
    );

    HoldersResponseSchema.parse(result);
    logger.info('stax', `GET succeeded: ${result.holders.length} holders`, 'ETH', contractKey);
    return NextResponse.json(result);
  } catch (error) {
    logger.error('stax', `GET failed: ${error.message}`, { stack: err.stack }, 'ETH', contractKey);
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}
----- ./app/api/utils.js -----

// app/api/utils.js
import { createPublicClient, http, parseAbi } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy, Network } from 'alchemy-sdk';

export const alchemy = new Alchemy({
  apiKey: process.env.NEXT_PUBLIC_ALCHEMY_API_KEY || (() => { throw new Error('Alchemy API key missing'); })(),
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(
    process.env.ETH_RPC_URL ||
    `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}`
  ),
});

// Generic NFT ABI for common functions
export const nftAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNftTier(uint256 tokenId) view returns (uint8)',
]);

// Ascendant NFT ABI with specific functions
export const ascendantAbi = parseAbi([
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getNFTAttribute(uint256 tokenId) view returns (uint256 rarityNumber, uint8 tier, uint8 rarity)',
  'function userRecords(uint256 tokenId) view returns (uint256 shares, uint256 lockedAscendant, uint256 rewardDebt, uint32 startTime, uint32 endTime)',
  'function totalShares() view returns (uint256)',
  'function toDistribute(uint8 pool) view returns (uint256)',
  'function rewardPerShare() view returns (uint256)',
  'error NonExistentToken(uint256 tokenId)',
]);

export function log(message) {
  console.log(`[PROD_DEBUG] ${message}`);
}
----- ./app/api/utils/cache.js -----

// app/api/utils/cache.js
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { Redis } from '@upstash/redis';
import config from '@/app/contracts_nft';
import { logger } from '@/app/lib/logger';
import { getAddress } from 'viem';
import { client } from '@/app/api/utils/client';
import { sanitizeBigInt } from '@/app/api/holders/cache/utils'; // Add this import

// Initialize NodeCache
const cache = new NodeCache({
  stdTTL: config.cache.nodeCache.stdTTL,
  checkperiod: config.cache.nodeCache.checkperiod,
});

// Cache directory for file-based caching
const cacheDir = path.join(process.cwd(), 'cache');

// Determine environment and cache strategy
const isProduction = process.env.NODE_ENV === 'production';
const redisEnabled = isProduction && process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN;
let redis = null;

if (redisEnabled) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });
    logger.info('cache', 'Redis initialized for production', 'ETH', 'general');
  } catch (error) {
    logger.error('cache', `Redis initialization failed: ${error.message}`, { stack: error.stack }, 'ETH', 'general');
    throw new Error('Redis initialization failed in production');
  }
}

async function ensureCacheDir(collectionKey = 'general') {
  const chain = config.nftContracts[collectionKey.toLowerCase()]?.chain || 'ETH';
  if (!isProduction) {
    try {
      await fs.mkdir(cacheDir, { recursive: true });
      await fs.chmod(cacheDir, 0o755);
      logger.info('cache', `Cache directory ensured: ${cacheDir}`, chain, collectionKey);
    } catch (error) {
      logger.error('cache', `Cache directory creation failed: ${error.message}`, { stack: error.stack }, chain, collectionKey);
      throw error;
    }
  }
}

export async function initializeCache() {
  const chain = 'ETH';
  const collectionKey = 'general';
  try {
    if (!isProduction) {
      await ensureCacheDir();
      const collections = Object.keys(config.nftContracts)
        .filter(key => !config.nftContracts[key].disabled)
        .map(key => key.toLowerCase());
      for (const collection of collections) {
        const files = ['summary', 'holders', 'transfers', 'state'].map(type => path.join(cacheDir, `${collection}_${type}.json`));
        for (const file of files) {
          try {
            await fs.access(file);
          } catch {
            await fs.writeFile(file, JSON.stringify({ data: {}, timestamp: Date.now() }));
            await fs.chmod(file, 0o644);
          }
        }
      }
      logger.info('cache', 'File-based cache initialized for development', chain, collectionKey);
    } else if (redisEnabled) {
      await redis.ping();
      logger.info('cache', 'Redis cache initialized for production', chain, collectionKey);
    } else {
      throw new Error('Redis not configured in production');
    }
    return true;
  } catch (error) {
    logger.error('cache', `Cache initialization failed: ${error.message}`, { stack: error.stack }, chain, collectionKey);
    throw error;
  }
}

export async function getCache(key, prefix, type = 'holders') {
  const chain = config.nftContracts[prefix.toLowerCase()]?.chain || 'ETH';
  const cacheKey = `${prefix}_${type}_${key}`;
  try {
    // Check NodeCache first
    let data = cache.get(cacheKey);
    if (data) {
      logger.debug('cache', `Node-cache hit: ${cacheKey}`, chain, prefix);
      return data;
    }

    if (isProduction) {
      // Production: Check Redis
      if (redis && !config.cache.redis[`disable${prefix.charAt(0).toUpperCase() + prefix.slice(1)}`]) {
        const redisData = await redis.get(cacheKey);
        if (redisData) {
          data = JSON.parse(redisData);
          cache.set(cacheKey, data); // Sync to NodeCache
          logger.info('cache', `Redis hit: ${cacheKey}`, chain, prefix);
          return data;
        }
      }
      logger.debug('cache', `Redis cache miss: ${cacheKey}`, chain, prefix);
      return null;
    } else {
      // Development: Check file system
      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_${type}.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        data = JSON.parse(fileData);
        cache.set(cacheKey, data); // Sync to NodeCache
        logger.info('cache', `File cache hit: ${cacheFile}`, chain, prefix);
        return data;
      } catch (error) {
        logger.debug('cache', `File cache miss: ${cacheFile}`, chain, prefix);
        return null;
      }
    }
  } catch (error) {
    logger.error('cache', `Get cache failed: ${cacheKey}, ${error.message}`, { stack: error.stack }, chain, prefix);
    return null;
  }
}

export async function setCache(key, value, ttl, prefix, type = 'holders') {
  const chain = config.nftContracts[prefix.toLowerCase()]?.chain || 'ETH';
  const cacheKey = `${prefix}_${type}_${key}`;
  try {
    // Sanitize the value to handle BigInt
    const sanitizedValue = sanitizeBigInt(value);

    // Always set in NodeCache
    cache.set(cacheKey, sanitizedValue, ttl);

    if (isProduction) {
      // Production: Set in Redis
      if (redis && !config.cache.redis[`disable${prefix.charAt(0).toUpperCase() + prefix.slice(1)}`]) {
        await redis.set(cacheKey, JSON.stringify(sanitizedValue), { EX: ttl });
        logger.info('cache', `Set Redis: ${cacheKey}`, chain, prefix);
      }
    } else {
      // Development: Set in file system
      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_${type}.json`);
      await ensureCacheDir(prefix);
      await fs.writeFile(cacheFile, JSON.stringify(sanitizedValue, null, 2));
      await fs.chmod(cacheFile, 0o644);
      logger.info('cache', `Set file cache: ${cacheFile}`, chain, prefix);
    }
    return true;
  } catch (error) {
    logger.error('cache', `Set cache failed: ${cacheKey}, ${error.message}`, { stack: error.stack }, chain, prefix);
    return false;
  }
}

export async function saveCacheState(key, state, prefix) {
  return setCache(key, state, 0, prefix, 'state');
}

export async function loadCacheState(key, prefix) {
  return getCache(key, prefix, 'state');
}

export async function getTransactionReceipt(transactionHash) {
  try {
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    logger.debug('cache', `Fetched transaction receipt: ${transactionHash}`, 'ETH', 'general');
    return receipt;
  } catch (error) {
    logger.error('cache', `Failed to fetch receipt: ${transactionHash}, ${error.message}`, { stack: error.stack }, 'ETH', 'general');
    throw error;
  }
}

export async function validateContract(contractKey) {
  const chain = config.nftContracts[contractKey.toLowerCase()]?.chain || 'ETH';
  try {
    const contractConfig = config.nftContracts[contractKey.toLowerCase()];
    if (!contractConfig || !contractConfig.contractAddress) {
      logger.error('cache', `No config for ${contractKey}`, {}, chain, contractKey);
      return false;
    }
    const address = getAddress(contractConfig.contractAddress);
    const code = await client.getBytecode({ address });
    const isValid = !!code && code !== '0x';
    logger.info('cache', `Contract ${contractKey} (${address}): ${isValid ? 'valid' : 'invalid'}`, chain, contractKey);
    return isValid;
  } catch (error) {
    logger.error('cache', `Validate ${contractKey} failed: ${error.message}`, { stack: error.stack }, chain, contractKey);
    return false;
  }
}
----- ./app/api/utils/client.js -----

// app/api/utils/client.js
import { Alchemy, Network } from 'alchemy-sdk';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import config from '@/app/contracts_nft';

export const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: Network.ETH_MAINNET,
});

export const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${config.alchemy.apiKey}`),
});
----- ./app/api/utils/logging.js -----

// app/api/utils/logging.js
import { logger } from '@/app/lib/logger';

export { logger };
----- ./app/api/utils/retry.js -----

// app/api/utils/retry.js
import { logger } from '@/app/lib/logger';
import config from '@/app/contracts_nft';

export async function retry(operation, { retries = config.alchemy.maxRetries, delay = config.alchemy.batchDelayMs, backoff = true } = {}) {
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.message.includes('429')) {
        logger.error('retry', `Rate limit hit after ${attempt} attempts`, 'ETH', 'general');
        throw new Error('Rate limit exceeded');
      }
      logger.warn('retry', `Attempt ${attempt}/${retries} failed: ${error.message}`, 'ETH', 'general');
      const waitTime = backoff ? delay * Math.pow(2, attempt - 1) : delay;
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
  throw lastError;
}
----- ./app/contracts/abi_nft.js -----

// ./contracts/abi.js
import staxNFT from '@/abi/staxNFT.json';
import staxVault from '@/abi/staxVault.json';
import element280NFT from '@/abi/element280.json';
import element280Vault from '@/abi/element280Vault.json';
import element369NFT from '@/abi/element369.json';
import element369Vault from '@/abi/element369Vault.json';
import ascendantNFT from '@/abi/ascendantNFT.json';
import vaultAbiFunctions, { getVaultFunction } from './abi_nft_vault.js';

// ABI function mappings for each collection
const abiFunctions = {
  stax: {
    nft: staxNFT,
    vault: staxVault,
    rewardFunction: {
      name: 'getRewards',
      contract: 'vault',
      inputs: ['tokenIds', 'account'],
      outputs: ['availability', 'totalPayout'],
    },
    tierFunction: {
      name: 'getNftTier',
      contract: 'nft',
      inputs: ['tokenId'],
      outputs: ['tier'],
    },
    batchTokenData: {
      name: 'batchGetTokenData',
      contract: 'nft',
      inputs: ['tokenIds'],
      outputs: ['tiers', 'multipliers', 'mintCycles', 'burnCycles', 'burnAddresses'],
    },
    vaultFunctions: vaultAbiFunctions.stax.functions,
  },
  element280: {
    nft: element280NFT,
    vault: element280Vault,
    rewardFunction: {
      name: 'getRewards',
      contract: 'vault',
      inputs: ['tokenIds', 'account'],
      outputs: ['availability', 'totalReward'],
    },
    tierFunction: {
      name: 'getNftTier',
      contract: 'nft',
      inputs: ['tokenId'],
      outputs: ['tier'],
    },
    batchTokenData: {
      name: 'getBatchedTokensData',
      contract: 'nft',
      inputs: ['tokenIds', 'nftOwner'],
      outputs: ['timestamps', 'multipliers'],
    },
    vaultFunctions: vaultAbiFunctions.element280.functions,
  },
  element369: {
    nft: element369NFT,
    vault: element369Vault,
    rewardFunction: {
      name: 'getRewards',
      contract: 'vault',
      inputs: ['tokenIds', 'account', 'isBacking'],
      outputs: ['availability', 'burned', 'infernoPool', 'fluxPool', 'e280Pool'],
    },
    tierFunction: {
      name: 'getNftTier',
      contract: 'nft',
      inputs: ['tokenId'],
      outputs: ['tier'],
    },
    batchTokenData: {
      name: 'batchGetTokenData',
      contract: 'nft',
      inputs: ['tokenIds'],
      outputs: ['tiers', 'multipliers', 'mintCycles', 'burnCycles', 'burnAddresses'],
    },
    vaultFunctions: vaultAbiFunctions.element369.functions,
  },
  ascendant: {
    nft: ascendantNFT,
    vault: null,
    rewardFunction: {
      name: 'batchClaimableAmount',
      contract: 'nft',
      inputs: ['tokenIds'],
      outputs: ['toClaim'],
    },
    tierFunction: {
      name: 'getNFTAttribute',
      contract: 'nft',
      inputs: ['tokenId'],
      outputs: ['attributes'],
    },
    batchTokenData: null,
    vaultFunctions: null,
  },
  e280: {
    nft: null,
    vault: null,
    rewardFunction: null,
    tierFunction: null,
    batchTokenData: null,
    vaultFunctions: null,
  },
};

// Common ABI functions
export const commonFunctions = {
  totalSupply: {
    name: 'totalSupply',
    contract: 'nft',
    inputs: [],
    outputs: ['result'],
  },
  totalBurned: {
    name: 'totalBurned',
    contract: 'nft',
    inputs: [],
    outputs: ['result'],
  },
  ownerOf: {
    name: 'ownerOf',
    contract: 'nft',
    inputs: ['tokenId'],
    outputs: ['owner'],
  },
  tokenId: {
    name: 'tokenId',
    contract: 'nft',
    inputs: [],
    outputs: ['result'],
  },
};

// Validate ABIs at startup
Object.entries(abiFunctions).forEach(([key, { nft, vault, rewardFunction, tierFunction, vaultFunctions }]) => {
  if (key === 'e280') return; // Skip disabled
  if (!nft) throw new Error(`Missing NFT ABI for ${key}`);
  if (key !== 'ascendant' && !vault) throw new Error(`Missing vault ABI for ${key}`);
  if (!rewardFunction) throw new Error(`Missing reward function for ${key}`);
  if (!tierFunction) throw new Error(`Missing tier function for ${key}`);
  if (key !== 'ascendant' && !nft.find(f => f.name === commonFunctions.totalSupply.name)) {
    throw new Error(`Missing totalSupply for ${key}`);
  }
  if (key === 'ascendant' && !nft.find(f => f.name === commonFunctions.tokenId.name)) {
    throw new Error(`Missing tokenId for ${key}`);
  }
  if (!nft.find(f => f.name === commonFunctions.ownerOf.name)) {
    throw new Error(`Missing ownerOf for ${key}`);
  }
  // Validate vault functions
  if (vault && vaultFunctions) {
    Object.entries(vaultFunctions).forEach(([fnName, fn]) => {
      if (!vault.find(f => f.name === fn.name && f.type === 'function')) {
        throw new Error(`Missing vault function ${fnName} for ${key}`);
      }
    });
  }
});

// Utility functions
export function getContractAbi(contractKey, contractType = 'nft') {
  const collection = abiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection[contractType] || null;
}

export function getRewardFunction(contractKey) {
  const collection = abiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection.rewardFunction || null;
}

export function getTierFunction(contractKey) {
  const collection = abiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection.tierFunction || null;
}

export function getBatchTokenDataFunction(contractKey) {
  const collection = abiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection.batchTokenData || null;
}

export function getVaultFunctionAbi(contractKey, functionName) {
  const collection = abiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection.vaultFunctions && collection.vaultFunctions[functionName] || getVaultFunction(contractKey, functionName);
}

export const abis = {
  stax: { nft: staxNFT, vault: staxVault },
  element280: { nft: element280NFT, vault: element280Vault },
  element369: { nft: element369NFT, vault: element369Vault },
  ascendant: { nft: ascendantNFT, vault: null },
  e280: { nft: null, vault: null },
};
----- ./app/contracts/abi_nft_vault.js -----

// app/contracts/abi_vault.js
import element280Vault from '@/abi/element280Vault.json';
import element369Vault from '@/abi/element369Vault.json';
import staxVault from '@/abi/staxVault.json';

// Vault ABI function mappings for each collection
const vaultAbiFunctions = {
  element280: {
    vault: element280Vault,
    functions: {
      E280: {
        name: 'E280',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      E280_NFT: {
        name: 'E280_NFT',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      claimed: {
        name: 'claimed',
        contract: 'vault',
        inputs: ['user'],
        outputs: ['result'],
      },
      claimedCycles: {
        name: 'claimedCycles',
        contract: 'vault',
        inputs: ['tokenId'],
        outputs: ['result'],
      },
      currentCycle: {
        name: 'currentCycle',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      cycles: {
        name: 'cycles',
        contract: 'vault',
        inputs: ['id'],
        outputs: ['timestamp', 'tokensPerMultiplier'],
      },
      devWallet: {
        name: 'devWallet',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      getNextCyclePool: {
        name: 'getNextCyclePool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getNextCycleTime: {
        name: 'getNextCycleTime',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getRewards: {
        name: 'getRewards',
        contract: 'vault',
        inputs: ['tokenIds', 'account'],
        outputs: ['availability', 'totalReward'],
      },
      minCyclePool: {
        name: 'minCyclePool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      owner: {
        name: 'owner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      pendingOwner: {
        name: 'pendingOwner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      totalE280Burned: {
        name: 'totalE280Burned',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      totalRewadsPaid: {
        name: 'totalRewadsPaid',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      totalRewardPool: {
        name: 'totalRewardPool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      treasury: {
        name: 'treasury',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      acceptOwnership: {
        name: 'acceptOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      claimRewards: {
        name: 'claimRewards',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      renounceOwnership: {
        name: 'renounceOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      setMinCyclePool: {
        name: 'setMinCyclePool',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      setTreasury: {
        name: 'setTreasury',
        contract: 'vault',
        inputs: ['_address'],
        outputs: [],
      },
      transferOwnership: {
        name: 'transferOwnership',
        contract: 'vault',
        inputs: ['newOwner'],
        outputs: [],
      },
      updateCycle: {
        name: 'updateCycle',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
    },
  },
  element369: {
    vault: element369Vault,
    functions: {
      E369_NFT: {
        name: 'E369_NFT',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      FluxHub: {
        name: 'FluxHub',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      _getEndCycleForCycle777: {
        name: '_getEndCycleForCycle777',
        contract: 'vault',
        inputs: ['cycle777Id'],
        outputs: ['result'],
      },
      _getNextCyclePool: {
        name: '_getNextCyclePool',
        contract: 'vault',
        inputs: ['token'],
        outputs: ['result'],
      },
      _getStartCycleForCycle777: {
        name: '_getStartCycleForCycle777',
        contract: 'vault',
        inputs: ['cycle777Id'],
        outputs: ['result'],
      },
      cycle777AmountClaimed: {
        name: 'cycle777AmountClaimed',
        contract: 'vault',
        inputs: ['tokenId', 'token'],
        outputs: ['result'],
      },
      cycle777BackingClaimed: {
        name: 'cycle777BackingClaimed',
        contract: 'vault',
        inputs: ['tokenId', 'token'],
        outputs: ['result'],
      },
      cycles: {
        name: 'cycles',
        contract: 'vault',
        inputs: ['id'],
        outputs: ['initialized', 'infernoPerMulitplier', 'fluxPerMultiplier', 'e280PerMultiplier'],
      },
      cycles777: {
        name: 'cycles777',
        contract: 'vault',
        inputs: ['id'],
        outputs: ['startCycleId', 'endCycleId', 'multiplierPool', 'infernoPool', 'e280Pool'],
      },
      devWallet: {
        name: 'devWallet',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      get777Rewards: {
        name: 'get777Rewards',
        contract: 'vault',
        inputs: ['tokenIds', 'account', 'isBacking'],
        outputs: ['availability', 'burned', 'infernoPool', 'e280Pool'],
      },
      getCurrentCycle777: {
        name: 'getCurrentCycle777',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getCurrentE369Cycle: {
        name: 'getCurrentE369Cycle',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getNextCyclePools: {
        name: 'getNextCyclePools',
        contract: 'vault',
        inputs: [],
        outputs: ['infernoPool', 'fluxPool', 'e280Pool'],
      },
      getRewards: {
        name: 'getRewards',
        contract: 'vault',
        inputs: ['tokenIds', 'account', 'isBacking'],
        outputs: ['availability', 'burned', 'infernoPool', 'fluxPool', 'e280Pool'],
      },
      lastUpdatedCycle: {
        name: 'lastUpdatedCycle',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      minCyclePool: {
        name: 'minCyclePool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      nftLastBacking: {
        name: 'nftLastBacking',
        contract: 'vault',
        inputs: ['tokenId'],
        outputs: ['result'],
      },
      nftLastClaim: {
        name: 'nftLastClaim',
        contract: 'vault',
        inputs: ['tokenId'],
        outputs: ['result'],
      },
      owner: {
        name: 'owner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      pendingOwner: {
        name: 'pendingOwner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      totalTokenPaid: {
        name: 'totalTokenPaid',
        contract: 'vault',
        inputs: ['token'],
        outputs: ['result'],
      },
      totalTokenPool: {
        name: 'totalTokenPool',
        contract: 'vault',
        inputs: ['token'],
        outputs: ['result'],
      },
      acceptOwnership: {
        name: 'acceptOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      claim777Backing: {
        name: 'claim777Backing',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      claim777Rewards: {
        name: 'claim777Rewards',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      claimBacking: {
        name: 'claimBacking',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      claimRewards: {
        name: 'claimRewards',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      register777CycleTokens: {
        name: 'register777CycleTokens',
        contract: 'vault',
        inputs: ['infernoAmount', 'e280Amount'],
        outputs: [],
      },
      renounceOwnership: {
        name: 'renounceOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      setFluxHub: {
        name: 'setFluxHub',
        contract: 'vault',
        inputs: ['fluxHub'],
        outputs: [],
      },
      setMinCyclePool: {
        name: 'setMinCyclePool',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      transferOwnership: {
        name: 'transferOwnership',
        contract: 'vault',
        inputs: ['newOwner'],
        outputs: [],
      },
      updateCycle: {
        name: 'updateCycle',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      updateStoredMultipliers: {
        name: 'updateStoredMultipliers',
        contract: 'vault',
        inputs: ['cycleId', 'totalMultipliers'],
        outputs: [],
      },
      updateStoredMultipliersOnBurn: {
        name: 'updateStoredMultipliersOnBurn',
        contract: 'vault',
        inputs: ['cycleId', 'totalMultipliers', 'multiplierDeduction'],
        outputs: [],
      },
    },
  },
  stax: {
    vault: staxVault,
    functions: {
      STAX: {
        name: 'STAX',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      STAX_BANK: {
        name: 'STAX_BANK',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      STAX_BUY_BURN: {
        name: 'STAX_BUY_BURN',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      STAX_DEV: {
        name: 'STAX_DEV',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      STAX_NFT: {
        name: 'STAX_NFT',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      diamondHandPool: {
        name: 'diamondHandPool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getCycleDistribution: {
        name: 'getCycleDistribution',
        contract: 'vault',
        inputs: ['cycleId'],
        outputs: ['bankShare', 'buyBurnShare', 'genesisShare', 'nftHolderShare', 'diamondPoolShare'],
      },
      getNextCycleTime: {
        name: 'getNextCycleTime',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getRewards: {
        name: 'getRewards',
        contract: 'vault',
        inputs: ['tokenIds', 'account'],
        outputs: ['availability', 'totalPayout'],
      },
      getTitanXPool: {
        name: 'getTitanXPool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getX28Pool: {
        name: 'getX28Pool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      getX28MintStatus: {
        name: 'getX28MintStatus',
        contract: 'vault',
        inputs: [],
        outputs: ['isNativeMint'],
      },
      incentiveFeeBPS: {
        name: 'incentiveFeeBPS',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      lastClaimed: {
        name: 'lastClaimed',
        contract: 'vault',
        inputs: ['tokenId'],
        outputs: ['result'],
      },
      lastCycleMultipliers: {
        name: 'lastCycleMultipliers',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      lastCycleTs: {
        name: 'lastCycleTs',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      maxSwapValue: {
        name: 'maxSwapValue',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      minCyclePool: {
        name: 'minCyclePool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      owner: {
        name: 'owner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      pendingOwner: {
        name: 'pendingOwner',
        contract: 'vault',
        inputs: [],
        outputs: ['address'],
      },
      secondsAgo: {
        name: 'secondsAgo',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      tokensPerMultiplier: {
        name: 'tokensPerMultiplier',
        contract: 'vault',
        inputs: ['cycleId'],
        outputs: ['result'],
      },
      totalClaimed: {
        name: 'totalClaimed',
        contract: 'vault',
        inputs: ['user'],
        outputs: ['result'],
      },
      totalRewadsPaid: {
        name: 'totalRewadsPaid',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      totalRewardPool: {
        name: 'totalRewardPool',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      twapDeviation: {
        name: 'twapDeviation',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      x28Deviation: {
        name: 'x28Deviation',
        contract: 'vault',
        inputs: [],
        outputs: ['result'],
      },
      acceptOwnership: {
        name: 'acceptOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      batchClaimRewards: {
        name: 'batchClaimRewards',
        contract: 'vault',
        inputs: ['tokenIds'],
        outputs: [],
      },
      claimRewards: {
        name: 'claimRewards',
        contract: 'vault',
        inputs: ['tokenId'],
        outputs: [],
      },
      handleStartPresale: {
        name: 'handleStartPresale',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      renounceOwnership: {
        name: 'renounceOwnership',
        contract: 'vault',
        inputs: [],
        outputs: [],
      },
      setIncentiveFee: {
        name: 'setIncentiveFee',
        contract: 'vault',
        inputs: ['bps'],
        outputs: [],
      },
      setMaxSwapValue: {
        name: 'setMaxSwapValue',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      setMinCyclePool: {
        name: 'setMinCyclePool',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      setProtocolAddresses: {
        name: 'setProtocolAddresses',
        contract: 'vault',
        inputs: ['_staxNft', '_staxBank'],
        outputs: [],
      },
      setSecondsAgo: {
        name: 'setSecondsAgo',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      setTwapDeviation: {
        name: 'setTwapDeviation',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      setX28PriceDeviation: {
        name: 'setX28PriceDeviation',
        contract: 'vault',
        inputs: ['limit'],
        outputs: [],
      },
      transferOwnership: {
        name: 'transferOwnership',
        contract: 'vault',
        inputs: ['newOwner'],
        outputs: [],
      },
      updateCycle: {
        name: 'updateCycle',
        contract: 'vault',
        inputs: ['minAmountOut', 'deadline'],
        outputs: [],
      },
    },
  },
};

// Validate vault ABIs at startup
Object.entries(vaultAbiFunctions).forEach(([key, { vault, functions }]) => {
  if (!vault) throw new Error(`Missing vault ABI for ${key}`);
  Object.entries(functions).forEach(([fnName, fn]) => {
    if (!vault.find(f => f.name === fn.name && f.type === 'function')) {
      throw new Error(`Missing vault function ${fnName} for ${key}`);
    }
  });
});

// Utility function to get a specific vault function
export function getVaultFunction(contractKey, functionName) {
  const collection = vaultAbiFunctions[contractKey.toLowerCase()];
  if (!collection) throw new Error(`Unknown contract key: ${contractKey}`);
  return collection.functions[functionName] || null;
}

// Export vault ABI functions and vault ABIs
export const vaultAbis = {
  element280: element280Vault,
  element369: element369Vault,
  stax: staxVault,
};

export default vaultAbiFunctions;
----- ./app/contracts/contracts_auct_mint.js -----

// app/contracts/contracts_auct_mint.js
import { getAddress } from 'viem';

// Import ABIs from abi directory
import ascendantAuctionABI from '@/abi/ascendantAuction.json';
import blazeAuctionABI from '@/abi/blazeAuction.json';
import flareAuctionABI from '@/abi/flareAuction.json';
import flareMintingABI from '@/abi/flareMinting.json';
import fluxAuctionABI from '@/abi/fluxAuction.json';
import goatXAuctionABI from '@/abi/goatXAuction.json';
import matrixAuctionABI from '@/abi/matrixAuction.json';
import phoenixAuctionABI from '@/abi/phoenixAuction.json';
import shogunAuctionABI from '@/abi/shogunAuction.json';
import voltAuctionABI from '@/abi/voltAuction.json';
import vyperBoostAuctionABI from '@/abi/vyperBoostAuction.json';
import vyperClassicAuctionABI from '@/abi/vyperClassicAuction.json';

export const auctionMintContracts = {
  ascendantAuction: {
    name: 'Ascendant Auction',
    abi: ascendantAuctionABI,
    address: getAddress('0x592daEb53eB1cef8aa96305588310E997ec58c0c'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Ascendant NFT minting.',
  },
  blazeAuction: {
    name: 'Blaze Auction',
    abi: blazeAuctionABI,
    address: getAddress('0x200ed69de20Fe522d08dF5d7CE3d69aba4e02e74'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Blaze NFT minting.',
  },
  flareAuction: {
    name: 'Flare Auction',
    abi: flareAuctionABI,
    address: getAddress('0x58ad6EF28bFB092635454d02303aBBd4D87b503c'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Flare NFT minting.',
  },
  flareMinting: {
    name: 'Flare Minting',
    abi: flareMintingABI,
    address: getAddress('0x9983eF6Af4DE8fE58C45f6DC54Cf5Ad349431A82'),
    chainId: 1,
    type: 'minting',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Minting contract for Flare NFTs.',
  },
  fluxAuction: {
    name: 'Flux Auction',
    abi: fluxAuctionABI,
    address: getAddress('0x36e5a8105f000029d4B3B99d0C3D0e24aaA52adF'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Flux NFT minting.',
  },
  goatXAuction: {
    name: 'GoatX Auction',
    abi: goatXAuctionABI,
    address: getAddress('0x059511B0BED706276Fa98877bd00ee0dD7303D32'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for GoatX NFT minting.',
  },
  matrixAuction: {
    name: 'Matrix Auction',
    abi: matrixAuctionABI,
    address: getAddress('0x9f29E5b2d67C4a7315c5D6AbD448C45f9dD51CAF'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Matrix NFT minting.',
  },
  phoenixAuction: {
    name: 'Phoenix Auction',
    abi: phoenixAuctionABI,
    address: getAddress('0xF41b5c99b8B6b88cF1Bd0320cB57e562EaF17DE1'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Phoenix NFT minting.',
  },
  shogunAuction: {
    name: 'Shogun Auction',
    abi: shogunAuctionABI,
    address: getAddress('0x79bd712f876c364Aa5e775A1eD40dE1fDfdB2a50'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Shogun NFT minting.',
  },
  voltAuction: {
    name: 'Volt Auction',
    abi: voltAuctionABI,
    address: getAddress('0xb3f2bE29BA969588E07bF7512e07008D6fdeB17B'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Volt NFT minting.',
  },
  vyperBoostAuction: {
    name: 'Vyper Boost Auction',
    abi: vyperBoostAuctionABI,
    address: getAddress('0x4D994F53FE2d8BdBbF64dC2e53C58Df00b84e713'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Vyper Boost NFT minting.',
  },
  vyperClassicAuction: {
    name: 'Vyper Classic Auction',
    abi: vyperClassicAuctionABI,
    address: getAddress('0xC1da113c983b26aa2c3f4fFD5f10b47457FC3397'),
    chainId: 1,
    type: 'auction',
    deploymentBlock: 'TBD', // Replace with actual deployment block if available
    description: 'Auction contract for Vyper Classic NFT minting.',
  },
};

// Export ABIs for backward compatibility
export const abis = {
  ascendantAuction: auctionMintContracts.ascendantAuction.abi,
  blazeAuction: auctionMintContracts.blazeAuction.abi,
  flareAuction: auctionMintContracts.flareAuction.abi,
  flareMinting: auctionMintContracts.flareMinting.abi,
  fluxAuction: auctionMintContracts.fluxAuction.abi,
  goatXAuction: auctionMintContracts.goatXAuction.abi,
  matrixAuction: auctionMintContracts.matrixAuction.abi,
  phoenixAuction: auctionMintContracts.phoenixAuction.abi,
  shogunAuction: auctionMintContracts.shogunAuction.abi,
  voltAuction: auctionMintContracts.voltAuction.abi,
  vyperBoostAuction: auctionMintContracts.vyperBoostAuction.abi,
  vyperClassicAuction: auctionMintContracts.vyperClassicAuction.abi,
};
----- ./app/contracts/contracts_nft.js -----

// app/contracts/contract_nft.js
import staxNFT from '@/abi/staxNFT.json';
import element280NFT from '@/abi/element280.json';
import element369NFT from '@/abi/element369.json';
import ascendantNFT from '@/abi/ascendantNFT.json';
import { vaultAbiFunctions, vaultAbis, getVaultFunction } from './abi_nft_vault.js';
import { abiFunctions, commonFunctions, getContractAbi, getRewardFunction, getTierFunction, getBatchTokenDataFunction } from './abi_nft.js';


// NFT collection configurations
export const nftContracts = {
  element280: {
    name: 'Element 280',
    symbol: 'ELMNT',
    chain: 'ETH',
    contractAddress: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9',
    vaultAddress: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97',
    deploymentBlock: '20945304',
    totalMinted: 16883,
    abi: element280NFT,
    vaultAbi: vaultAbis.element280,
    tiers: {
      1: { name: 'Common', multiplier: 10, allocation: '100000000000000000000000000' },
      2: { name: 'Common Amped', multiplier: 12, allocation: '100000000000000000000000000' },
      3: { name: 'Rare', multiplier: 100, allocation: '1000000000000000000000000000' },
      4: { name: 'Rare Amped', multiplier: 120, allocation: '1000000000000000000000000000' },
      5: { name: 'Legendary', multiplier: 1000, allocation: '10000000000000000000000000000' },
      6: { name: 'Legendary Amped', multiplier: 1200, allocation: '10000000000000000000000000000' },
    },
    description: 'Element 280 NFTs can be minted with TitanX or ETH during a presale and redeemed for Element 280 tokens after a cooldown period. Multipliers contribute to a pool used for reward calculations.',
    maxTokensPerOwnerQuery: 100,
    availableVaultFunctions: Object.keys(vaultAbiFunctions.element280.functions),
    rewardToken: 'ELMNT',
    apiEndpoint: '/api/holders/element280',
    pageSize: 100,
  },
  element369: {
    name: 'Element 369',
    symbol: 'E369',
    chain: 'ETH',
    contractAddress: '0x024D64E2F65747d8bB02dFB852702D588A062575',
    vaultAddress: '0x4e3DBD6333e649AF13C823DAAcDd14f8507ECBc5?',
    deploymentBlock: '21224418',
    abi: element369NFT,
    vaultAbi: vaultAbis.element369,
    tiers: {
      1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
      2: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
      3: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
    },
    description: 'Element 369 NFTs are minted with TitanX or ETH during specific sale cycles. Burning NFTs updates a multiplier pool and tracks burn cycles for reward distribution in the Holder Vault.',
    availableVaultFunctions: Object.keys(vaultAbiFunctions.element369.functions),
    rewardToken: 'INFERNO/FLUX/E280',
    apiEndpoint: '/api/holders/element369',
    pageSize: 1000,
  },
  stax: {
    name: 'Stax',
    symbol: 'STAX',
    chain: 'ETH',
    contractAddress: '0x74270Ca3a274B4dbf26be319A55188690CACE6E1',
    vaultAddress: '0x5D27813C32dD705404d1A78c9444dAb523331717',
    deploymentBlock: '21452667',
    totalMinted: 503,
    abi: staxNFT,
    vaultAbi: vaultAbis.stax,
    tiers: {
      1: { name: 'Common', multiplier: 1, price: '100000000000000000000000000' },
      2: { name: 'Common Amped', multiplier: 1.2, price: '100000000000000000000000000', amplifier: '10000000000000000000000000' },
      3: { name: 'Common Super', multiplier: 1.4, price: '100000000000000000000000000', amplifier: '20000000000000000000000000' },
      4: { name: 'Common LFG', multiplier: 2, price: '100000000000000000000000000', amplifier: '50000000000000000000000000' },
      5: { name: 'Rare', multiplier: 10, price: '1000000000000000000000000000' },
      6: { name: 'Rare Amped', multiplier: 12, price: '1000000000000000000000000000', amplifier: '100000000000000000000000000' },
      7: { name: 'Rare Super', multiplier: 14, price: '1000000000000000000000000000', amplifier: '200000000000000000000000000' },
      8: { name: 'Rare LFG', multiplier: 20, price: '1000000000000000000000000000', amplifier: '500000000000000000000000000' },
      9: { name: 'Legendary', multiplier: 100, price: '10000000000000000000000000000' },
      10: { name: 'Legendary Amped', multiplier: 120, price: '10000000000000000000000000000', amplifier: '1000000000000000000000000000' },
      11: { name: 'Legendary Super', multiplier: 140, price: '10000000000000000000000000000', amplifier: '2000000000000000000000000000' },
      12: { name: 'Legendary LFG', multiplier: 200, price: '10000000000000000000000000000', amplifier: '5000000000000000000000000000' },
    },
    description: 'Stax NFTs are minted with TitanX or ETH during a presale. Burning NFTs after a cooldown period claims backing rewards, with multipliers contributing to a pool for cycle-based reward calculations.',
    availableVaultFunctions: Object.keys(vaultAbiFunctions.stax.functions),
    rewardToken: 'X28',
    apiEndpoint: '/api/holders/stax',
    pageSize: 1000,
  },
  ascendant: {
    name: 'Ascendant',
    symbol: 'ASCNFT',
    chain: 'ETH',
    contractAddress: '0x9da95c32c5869c84ba2c020b5e87329ec0adc97f',
    vaultAddress: null,
    deploymentBlock: '21112535',
    abi: ascendantNFT,
    vaultAbi: null,
    tiers: {
      1: { name: 'Tier 1', price: '7812500000000000000000', multiplier: 1.01 },
      2: { name: 'Tier 2', price: '15625000000000000000000', multiplier: 1.02 },
      3: { name: 'Tier 3', price: '31250000000000000000000', multiplier: 1.03 },
      4: { name: 'Tier 4', price: '62500000000000000000000', multiplier: 1.04 },
      5: { name: 'Tier 5', price: '125000000000000000000000', multiplier: 1.05 },
      6: { name: 'Tier 6', price: '250000000000000000000000', multiplier: 1.06 },
      7: { name: 'Tier 7', price: '500000000000000000000000', multiplier: 1.07 },
      8: { name: 'Tier 8', price: '1000000000000000000000000', multiplier: 1.08 },
    },
    description: 'Ascendant NFTs are minted with ASCENDANT tokens and offer staking rewards from DragonX pools over 8, 28, and 90-day periods. Features fusion mechanics to combine same-tier NFTs into higher tiers.',
    maxTokensPerOwnerQuery: 1000,
    availableVaultFunctions: null,
    rewardToken: 'DRAGONX',
    apiEndpoint: '/api/holders/ascendant',
    pageSize: 1000,
  },
  e280: {
    name: 'E280',
    symbol: 'E280',
    chain: 'BASE',
    contractAddress: null,
    vaultAddress: null,
    deploymentBlock: null,
    abi: null,
    vaultAbi: null,
    tiers: {},
    description: 'E280 NFTs on BASE chain. Contract not yet deployed.',
    disabled: true,
    availableVaultFunctions: null,
    rewardToken: 'E280',
    apiEndpoint: '/api/holders/e280',
    pageSize: 1000,
  },
};

// Tier order configurations
export const contractTiers = {
  element280: {
    tierOrder: [
      { tierId: '6', name: 'Legendary Amped' },
      { tierId: '5', name: 'Legendary' },
      { tierId: '4', name: 'Rare Amped' },
      { tierId: '3', name: 'Rare' },
      { tierId: '2', name: 'Common Amped' },
      { tierId: '1', name: 'Common' },
    ],
  },
  element369: {
    tierOrder: [
      { tierId: '3', name: 'Legendary' },
      { tierId: '2', name: 'Rare' },
      { tierId: '1', name: 'Common' },
    ],
  },
  stax: {
    tierOrder: [
      { tierId: '12', name: 'Legendary LFG' },
      { tierId: '11', name: 'Legendary Super' },
      { tierId: '10', name: 'Legendary Amped' },
      { tierId: '9', name: 'Legendary' },
      { tierId: '8', name: 'Rare LFG' },
      { tierId: '7', name: 'Rare Super' },
      { tierId: '6', name: 'Rare Amped' },
      { tierId: '5', name: 'Rare' },
      { tierId: '4', name: 'Common LFG' },
      { tierId: '3', name: 'Common Super' },
      { tierId: '2', name: 'Common Amped' },
      { tierId: '1', name: 'Common' },
    ],
  },
  ascendant: {
    tierOrder: [
      { tierId: '8', name: 'Tier 8' },
      { tierId: '7', name: 'Tier 7' },
      { tierId: '6', name: 'Tier 6' },
      { tierId: '5', name: 'Tier 5' },
      { tierId: '4', name: 'Tier 4' },
      { tierId: '3', name: 'Tier 3' },
      { tierId: '2', name: 'Tier 2' },
      { tierId: '1', name: 'Tier 1' },
    ],
  },
  e280: { tierOrder: [] },
};

// Main configuration object
const config = {
  // Supported blockchain networks
  supportedChains: ['ETH', 'BASE'],

  // Contract configurations
  nftContracts,

  alchemy: {
    apiKey: process.env.NODE_ENV === 'production'
      ? process.env.ALCHEMY_API_KEY || (() => { throw new Error('ALCHEMY_API_KEY is required in production'); })()
      : process.env.ALCHEMY_API_KEY || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY,
  },


  // Derived contract addresses
  getContractAddresses: () => Object.keys(nftContracts).reduce((acc, key) => ({
    ...acc,
    [key]: { chain: nftContracts[key].chain, address: nftContracts[key].contractAddress },
  }), {}),

  // Derived vault addresses
  getVaultAddresses: () => Object.keys(nftContracts).reduce((acc, key) => ({
    ...acc,
    [key]: { chain: nftContracts[key].chain, address: nftContracts[key].vaultAddress },
  }), {}),

  // Derived deployment blocks
  getDeploymentBlocks: () => Object.keys(nftContracts).reduce((acc, key) => ({
    ...acc,
    [key]: { chain: nftContracts[key].chain, block: nftContracts[key].deploymentBlock },
  }), {}),

  // Tier order configurations
  contractTiers,

  // Burn address for NFTs
  burnAddress: '0x0000000000000000000000000000000000000000',

  // Validate contract configurations at startup
  validateContracts: () => {
    Object.entries(nftContracts).forEach(([key, contract]) => {
      if (!contract.disabled) {
        if (!contract.contractAddress) {
          throw new Error(`Missing contractAddress for ${key}`);
        }
        if (!Array.isArray(contract.abi)) {
          console.error(`ABI for ${key}:`, contract.abi);
          throw new Error(`Invalid or missing ABI for ${key}: expected array, got ${typeof contract.abi}`);
        }
        const requiredFunctions = key === 'ascendant'
          ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute', 'batchClaimableAmount']
          : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
        const missingFunctions = requiredFunctions.filter(fn =>
          !contract.abi.some(item => item.name === fn && item.type === 'function')
        );
        if (missingFunctions.length > 0) {
          throw new Error(`ABI for ${key} missing required functions: ${missingFunctions.join(', ')}`);
        }
      }
    });
  },
};

// Validate config at startup
try {
  config.validateContracts();
  console.log('NFT config validation passed:', {
    contracts: Object.keys(config.nftContracts),
    element280TotalMinted: config.nftContracts.element280.totalMinted,
    staxTotalMinted: config.nftContracts.stax.totalMinted,
    element280Abi: Array.isArray(config.nftContracts.element280.abi) ? `array (${config.nftContracts.element280.abi.length} items)` : 'invalid',
    staxAbi: Array.isArray(config.nftContracts.stax.abi) ? `array (${config.nftContracts.stax.abi.length} items)` : 'invalid',
  });
} catch (error) {
  console.error('NFT config validation failed:', error.message);
  throw error;
}

export { abiFunctions, vaultAbis, getVaultFunction }; // Explicitly export abiFunctions, vaultAbis, and getVaultFunction
export default config;
----- ./app/layout.js -----

// app/layout.js
'use client'

import './global.css';
import { Inter } from 'next/font/google';
import Navbar  from '@/components/Navbar';
import ClientProvider from './ClientProvider';
import ShootingStars from '@/components/ShootingStars';

const inter = Inter({
  subsets: ['latin'],
  weight: ['400', '500', '600', '700'],
  display: 'swap',
  variable: '--font-inter'
});

export default function RootLayout({ children }) {
  const handleDMLink = (username, e) => {
    e.preventDefault();
    const appLink = `x://messages/compose?screen_name=${username}`;
    const webLink = `https://x.com/direct_messages/create/${username}`;
    window.location = appLink;
    setTimeout(() => {
      window.open(webLink, '_blank', 'noopener,noreferrer');
    }, 500);
  };

  return (
    <html lang="en">
      <head>
        <title>TitanXUtils</title>
        <link rel="preload" href="/fonts/inter.woff2" as="font" type="font/woff2" crossOrigin="anonymous" />
      </head>
      <body className={`${inter.variable} bg-gray-900 text-white font-inter`}>
        <ClientProvider>
          <Navbar />
          <ShootingStars />
          <main className="main-content">{children}</main>
          <footer className="footer bg-gray-800 py-4 text-center text-gray-400 fixed bottom-0 left-0 w-full z-10">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-2 flex flex-col sm:flex-row justify-between items-center">
              <p className="hidden sm:block">
                 {new Date().getFullYear()} TitanXUtils by{' '}
                <a
                  href="#"
                  onClick={(e) => handleDMLink('KetoNatural1970', e)}
                  className="text-gray-400 hover:text-orange-400 hover:underline transition-colors duration-200"
                  title="Send a DM to @KetoNatural1970 on X"
                >
                  KetoNatural1970
                </a>{' '}
                and{' '}
                <a
                  href="#"
                  onClick={(e) => handleDMLink('JukesTheGreat', e)}
                  className="text-gray-400 hover:text-orange-400 hover:underline transition-colors duration-200"
                  title="Send a DM to @JukesTheGreat on X"
                >
                  JukesTheGreat
                </a>
              </p>
              <div className="flex flex-row items-center gap-4">
                <a
                  href="https://titanxhub.com"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-base font-semibold text-white hover:text-orange-400 transition-colors duration-200"
                  title="Visit TitanXHub"
                >
                  TitanXHub.com
                </a>
                <a
                  href="https://titanxinfo.com"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-base font-semibold text-white hover:text-orange-400 transition-colors duration-200"
                  title="Visit TitanXInfo"
                >
                  TitanXInfo.com
                </a>
              </div>
            </div>
          </footer>
        </ClientProvider>
      </body>
    </html>
  );
}
----- ./app/lib/constants.js -----

// app/lib/constants.js
export const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
export const CACHE_TTL = 15 * 60 * 1000; // 15 minutes
export const MAX_BLOCK_RANGE = 5000; // Increased
export const BATCH_SIZE = 200; // Increased
export const BATCH_DELAY_MS = 200; // Reduced
----- ./app/lib/logger.js -----

// app/lib/logger.js
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

const logDir = path.join(process.cwd(), 'logs');
const isDebug = process.env.DEBUG === 'true' || process.env.NODE_ENV !== 'production';

async function ensureLogDir() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log(chalk.cyan('[Logger] Created or verified log directory:'), logDir);
  } catch (error) {
    console.error(chalk.red('[Logger] Failed to create log directory:'), error.message);
  }
}

ensureLogDir().catch(error => {
  console.error(chalk.red('[Logger] ensureLogDir error:'), error.message);
});

export const logger = {
  info: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [INFO] ${message}`;
    console.log(chalk.green(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write INFO log:'), error.message);
    }
  },
  warn: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [WARN] ${message}`;
    console.log(chalk.yellow(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write WARN log:'), error.message);
    }
  },
  error: async (scope, message, details = {}, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [ERROR] ${message} ${JSON.stringify(details)}`;
    console.error(chalk.red(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write ERROR log:'), error.message);
    }
  },
  debug: async (scope, message, chain = 'eth', collection = 'general') => {
    if (!isDebug) return;
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [DEBUG] ${message}`;
    console.log(chalk.blue(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write DEBUG log:'), error.message);
    }
  },
};

logger.info('startup', 'Logger module loaded').catch(error => {
  console.error(chalk.red('[Logger] Startup log error:'), error.message);
});
----- ./app/lib/schemas.js -----

// app/lib/schemas.js
import { z } from 'zod';

export const HolderSchema = z.object({
  wallet: z.string().regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid wallet address'),
  rank: z.number().int().positive(),
  total: z.number().int().nonnegative(),
  multiplierSum: z.number().nonnegative(),
  displayMultiplierSum: z.number().nonnegative(),
  percentage: z.number().nonnegative(),
  tiers: z.array(z.number().int().nonnegative()),
  claimableRewards: z.number().nonnegative(),
  buyCount: z.number().int().nonnegative(),
  sellCount: z.number().int().nonnegative(),
  burnCount: z.number().int().nonnegative(),
  boughtNfts: z.array(
    z.object({
      tokenId: z.number().int().positive(),
      transactionHash: z.string(),
      timestamp: z.number().int().nonnegative(),
    })
  ),
  soldNfts: z.array(
    z.object({
      tokenId: z.number().int().positive(),
      transactionHash: z.string(),
      timestamp: z.number().int().nonnegative(),
    })
  ),
  burnedNfts: z.array(
    z.object({
      tokenId: z.number().int().positive(),
      transactionHash: z.string(),
      timestamp: z.number().int().nonnegative(),
    })
  ),
  tokenIds: z.array(z.number().int().positive()).optional(),
  shares: z.number().nonnegative().optional(),
  lockedAscendant: z.number().nonnegative().optional(),
  pendingDay8: z.number().nonnegative().optional(),
  pendingDay28: z.number().nonnegative().optional(),
  pendingDay90: z.number().nonnegative().optional(),
  infernoRewards: z.number().nonnegative().optional(),
  fluxRewards: z.number().nonnegative().optional(),
  e280Rewards: z.number().nonnegative().optional(),
  tokens: z
    .array(
      z.object({
        tokenId: z.number().int().positive(),
        tier: z.number().int().positive(),
        rarityNumber: z.number().nonnegative(),
        rarity: z.number().int().positive(),
      })
    )
    .optional(),
});

export const HoldersResponseSchema = z
  .object({
    status: z.enum(['success', 'pending']),
    holders: z.array(HolderSchema),
    totalPages: z.number().int().positive(),
    totalTokens: z.number().int().nonnegative(),
    totalBurned: z.number().int().nonnegative(),
    lastBlock: z.number().int().nonnegative(),
    errorLog: z.array(
      z.object({
        timestamp: z.string(),
        phase: z.string(),
        error: z.string(),
        fromBlock: z.number().int().nonnegative().optional(),
        toBlock: z.number().int().nonnegative().optional(),
        tokenId: z.number().int().positive().optional(),
        wallet: z.string().optional(),
        chunk: z.number().int().positive().optional(),
      })
    ),
    contractKey: z.string(),
    summary: z.object({
      totalLive: z.number().int().nonnegative(),
      totalBurned: z.number().int().nonnegative(),
      totalMinted: z.number().int().nonnegative(),
      totalE280Burned: z.number().nonnegative().optional(),
      totalRewardsPaid: z.number().nonnegative().optional(),
      totalRewardPool: z.number().nonnegative().optional(),
      tierDistribution: z.array(z.number().int().nonnegative()),
      multiplierPool: z.number().nonnegative(),
      rarityDistribution: z.array(z.number().int().nonnegative()).optional(),
    }),
    transferSummary: z
      .object({
        buyCount: z.number().int().nonnegative(),
        sellCount: z.number().int().nonnegative(),
        burnCount: z.number().int().nonnegative(),
      })
      .optional(),
    globalMetrics: z
      .object({
        totalMinted: z.number().int().nonnegative(),
        totalLive: z.number().int().nonnegative(),
        totalBurned: z.number().int().nonnegative(),
        tierDistribution: z.array(z.number().int().nonnegative()),
      })
      .optional(),
  })
  .refine(
    (data) => {
      if (data.contractKey.toLowerCase() === 'element280') {
        return data.totalBurned >= 0 && data.summary.totalBurned >= 0;
      }
      return true;
    },
    {
      message: 'totalBurned and summary.totalBurned must be non-negative for element280',
      path: ['totalBurned', 'summary.totalBurned'],
    }
  );

export const ProgressResponseSchema = z.object({
  isPopulating: z.boolean(),
  totalOwners: z.number().int().nonnegative(),
  totalLiveHolders: z.number().int().nonnegative(),
  progressState: z.object({
    step: z.string(),
    processedNfts: z.number().int().nonnegative(),
    totalNfts: z.number().int().nonnegative(),
    processedTiers: z.number().int().nonnegative(),
    totalTiers: z.number().int().nonnegative(),
    error: z.string().nullable(),
    errorLog: z.array(
      z.object({
        timestamp: z.string(),
        phase: z.string(),
        error: z.string(),
        fromBlock: z.number().int().nonnegative().optional(),
        toBlock: z.number().int().nonnegative().optional(),
        tokenId: z.number().int().positive().optional(),
        wallet: z.string().optional(),
        chunk: z.number().int().positive().optional(),
      })
    ),
    progressPercentage: z.string().regex(/^\d{1,3}%$/, 'Invalid percentage format'),
    totalLiveHolders: z.number().int().nonnegative(),
    totalOwners: z.number().int().nonnegative(),
    lastProcessedBlock: z.number().int().nonnegative().nullable(),
    lastUpdated: z.number().int().nonnegative().nullable(),
    isPopulating: z.boolean().optional(),
    status: z.string(),
  }),
  lastUpdated: z.number().int().nonnegative().nullable(),
  lastProcessedBlock: z.number().int().nonnegative().nullable(),
  globalMetrics: z.object({
    totalMinted: z.number().int().nonnegative().optional(),
    totalLive: z.number().int().nonnegative().optional(),
    totalBurned: z.number().int().nonnegative().optional(),
    tierDistribution: z.array(z.number().int().nonnegative()).optional(),
  }),
});
----- ./app/lib/serverInit.js -----

// app/lib/serverInit.js
import { logger } from '@/app/lib/logger';
import { initializeCache } from '@/app/api/utils/cache';
import { populateHoldersMapCache } from '@/app/api/holders/cache/holders';
import config from '@/app/contracts_nft';
import { getContractAbi } from '@/app/contracts/abi_nft';
import chalk from 'chalk';



export async function initializeServer() {
  logger.info('serverInit', `Server initialization started in ${process.env.NODE_ENV} mode`);
  if (!config.alchemy.apiKey) {
    logger.error('serverInit', 'Alchemy API key is missing');
    throw new Error('Alchemy API key is missing');
  }
  await initializeCache();
  const contracts = Object.keys(config.nftContracts);
  for (const contractKey of contracts) {
    const contractConfig = config.nftContracts[contractKey.toLowerCase()];
    if (!contractConfig) continue;
    await populateHoldersMapCache(
      contractKey,
      contractConfig.contractAddress,
      getContractAbi(contractKey, 'nft'),
      contractConfig.vaultAddress,
      getContractAbi(contractKey, 'vault')
    );
  }
  logger.info('serverInit', chalk.green('Server initialized'));
}
----- ./app/nft/[chain]/[contract]/page.js -----

// app/nft/[chain]/[contract]/page.js
import NFTPage from '@/components/NFTPage';
import { ProgressResponseSchema, HoldersResponseSchema } from '@/app/lib/schemas';
import config from '@/app/contracts_nft';

export default async function NFTContractPage({ params }) {
  const { chain, contract } = params;
  const apiKeyMap = {
    Element280: 'element280',
    Element369: 'element369',
    Stax: 'stax',
    Ascendant: 'ascendant',
    E280: 'e280',
  };
  const contractKey = apiKeyMap[contract];

  if (!config.supportedChains.includes(chain) || !contractKey || config.contractDetails[contractKey]?.disabled) {
    return { notFound: true };
  }

  const contractConfig = config.contractDetails[contractKey] || {};
  let initialProgress = { step: 'idle', progressPercentage: '0%' };
  let initialData = { status: 'pending', holders: [], error: null };

  try {
    // Fetch progress state
    const progressRes = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/api/holders/cache/state/${contractKey}`, {
      cache: 'no-store',
    });
    if (progressRes.ok) {
      const progressData = await progressRes.json();
      ProgressResponseSchema.parse(progressData);
      initialProgress = {
        step: progressData.progressState.step,
        progressPercentage: progressData.progressState.progressPercentage,
      };
    } else {
      throw new Error(`Progress API error: ${progressRes.status}`);
    }

    // Fetch holders data
    const correctedApiEndpoint = contractConfig.apiEndpoint
      ?.replace(/Element280/, 'element280')
      .replace(/Stax/, 'stax')
      .replace(/Element369/, 'element369')
      .replace(/Ascendant/, 'ascendant');
    if (correctedApiEndpoint) {
      const res = await fetch(`${correctedApiEndpoint}?page=0&pageSize=${contractConfig.pageSize || 1000}`, {
        cache: 'no-store',
      });
      if (!res.ok) throw new Error(`Holders API error: ${res.status}`);
      const data = await res.json();
      HoldersResponseSchema.parse({ ...data, contractKey });
      initialData = data;
    } else {
      initialData = { error: 'Invalid contract configuration' };
    }
  } catch (err) {
    console.error('[NFTContractPage] Fetch error:', err.message);
    initialData = { error: `Failed to load data: ${err.message}` };
  }

  return <NFTPage contractKey={contractKey} initialData={initialData} initialProgress={initialProgress} />;
}

export async function getServerSideProps({ params }) {
  return { props: { params } };
}
----- ./app/nft/layout.js -----

// app/nft/layout.js
'use client';
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import Link from 'next/link';
import SearchResultsModal from '@/components/SearchResultsModal';
import { contractDetails } from '@/app/contracts_nft';
import { useNFTStore } from '@/app/store';

export default function NFTLayout({ children }) {
  const [selectedChain, setSelectedChain] = useState(null);
  const [showE280Message, setShowE280Message] = useState(false);
  const [searchAddress, setSearchAddress] = useState('');
  const [searchResults, setSearchResults] = useState({});
  const [searchLoading, setSearchLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const hasRun = useRef(false);

  const { getCache, setCache } = useNFTStore();

  const chains = [
    { name: 'ETH', id: 'eth' },
    { name: 'BASE', id: 'base' },
  ];

  const ethNFTs = [
    { name: 'Element280', href: '/nft/ETH/Element280', apiKey: 'element280' },
    { name: 'Element369', href: '/nft/ETH/Element369', apiKey: 'element369' },
    { name: 'Stax', href: '/nft/ETH/Stax', apiKey: 'staxNFT' },
    { name: 'Ascendant', href: '/nft/ETH/Ascendant', apiKey: 'ascendantNFT' },
  ];

  const baseNFTs = [
    { name: 'E280', href: null, apiKey: 'e280' },
  ];

  const allNFTs = Object.keys(contractDetails).map((key) => ({
    name: contractDetails[key].name,
    apiKey: key,
    href: key === 'e280' ? null : `/nft/${key === 'e280' ? 'BASE' : 'ETH'}/${contractDetails[key].name.replace(/\s+/g, '')}`,
  }));

  const fetchCollectionData = async (contractKey) => {
    console.log(`[NFTLayout] Fetching data for ${contractKey}`);
    const cachedData = getCache(contractKey);
    if (cachedData) {
      console.log(`[NFTLayout] Using cached data for ${contractKey}: ${cachedData.holders.length} holders`);
      return cachedData;
    }

    if (contractKey === 'e280') {
      console.log(`[NFTLayout] Skipping fetch for ${contractKey} - not deployed`);
      const result = { holders: [], totalTokens: 0, message: 'E280 data not available yet' };
      setCache(contractKey, result);
      return result;
    }

    const { apiEndpoint, pageSize = 1000 } = contractDetails[contractKey];
    let allHolders = [];
    let totalTokens = 0;
    let totalLockedAscendant = 0;
    let totalShares = 0;
    let toDistributeDay8 = 0;
    let toDistributeDay28 = 0;
    let toDistributeDay90 = 0;
    let pendingRewards = 0;
    let page = 0;
    let totalPages = Infinity;

    try {
      while (page < totalPages) {
        console.log(`[NFTLayout] Fetching ${contractKey} page ${page}`);
        const res = await fetch(`${apiEndpoint}?page=${page}&pageSize=${pageSize}`, {
          signal: AbortSignal.timeout(30000),
        });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Fetch failed for ${contractKey} page ${page}: ${res.status} - ${errorText}`);
        }
        const json = await res.json();
        console.log(`[NFTLayout] ${contractKey} page ${page} fetched: holders=${json.holders.length}`);
        allHolders = allHolders.concat(json.holders || []);
        totalTokens = json.totalTokens || totalTokens;
        totalLockedAscendant = json.totalLockedAscendant || totalLockedAscendant;
        totalShares = json.totalShares || totalShares;
        toDistributeDay8 = json.toDistributeDay8 || toDistributeDay8;
        toDistributeDay28 = json.toDistributeDay28 || toDistributeDay28;
        toDistributeDay90 = json.toDistributeDay90 || toDistributeDay90;
        pendingRewards = json.pendingRewards || pendingRewards;
        totalPages = json.totalPages || 1;
        page++;
        if (!json.holders || json.holders.length === 0) break;
      }

      const uniqueHoldersMap = new Map();
      allHolders.forEach(holder => {
        if (holder && holder.wallet) uniqueHoldersMap.set(holder.wallet, holder);
      });
      let uniqueHolders = Array.from(uniqueHoldersMap.values());
      console.log(`[NFTLayout] Total Unique ${contractKey} Holders: ${uniqueHolders.length}`);

      const totalMultiplierSum = uniqueHolders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
      if (contractKey === 'ascendantNFT') {
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1; // Retain API rank
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      } else {
        uniqueHolders.sort((a, b) => (b.multiplierSum || 0) - (a.multiplierSum || 0) || (b.total || 0) - (a.total || 0));
        uniqueHolders.forEach((holder, index) => {
          holder.rank = index + 1;
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
        });
      }

      const result = {
        holders: uniqueHolders,
        totalTokens,
        totalLockedAscendant,
        totalShares,
        toDistributeDay8,
        toDistributeDay28,
        toDistributeDay90,
        pendingRewards,
        totalMultiplierSum,
      };
      setCache(contractKey, result);
      console.log(`[NFTLayout] Cached ${contractKey} with ${uniqueHolders.length} holders`);
      return result;
    } catch (err) {
      console.error(`[NFTLayout] Error fetching ${contractKey}: ${err.message}`);
      const errorResult = { holders: [], totalTokens: 0, error: err.message };
      setCache(contractKey, errorResult);
      return errorResult;
    }
  };

  const handleSearch = async () => {
    console.log('[NFTLayout] handleSearch called with address:', searchAddress);
    if (!searchAddress || !/^0x[a-fA-F0-9]{40}$/.test(searchAddress)) {
      setError('Please enter a valid Ethereum address (e.g., 0x...)');
      setSearchResults({});
      return;
    }

    setSearchLoading(true);
    setError(null);
    setSearchResults({});

    try {
      console.log('[NFTLayout] Fetching all collection data before search');
      const fetchPromises = allNFTs.map(nft => 
        fetchCollectionData(nft.apiKey)
          .then(data => ({ apiKey: nft.apiKey, data }))
          .catch(err => {
            console.error(`[NFTLayout] Fetch failed for ${nft.apiKey}: ${err.message}`);
            return { apiKey: nft.apiKey, data: { holders: [], totalTokens: 0, error: err.message } };
          })
      );
      const results = await Promise.all(fetchPromises);
      console.log('[NFTLayout] All collections fetched and cached');

      const searchResults = {};
      const lowerSearchAddress = searchAddress.toLowerCase();
      results.forEach(({ apiKey, data }) => {
        if (data.error) {
          searchResults[apiKey] = { error: data.error };
        } else if (data.message) {
          searchResults[apiKey] = { message: data.message };
        } else {
          const holder = data.holders.find(h => h && h.wallet && h.wallet.toLowerCase() === lowerSearchAddress);
          if (holder) {
            // Include totalShares for Ascendant to calculate Shares %
            searchResults[apiKey] = {
              ...holder,
              totalShares: apiKey === 'ascendantNFT' ? data.totalShares : undefined,
            };
          } else {
            searchResults[apiKey] = null;
          }
          console.log(`[NFTLayout] ${apiKey} search result:`, holder ? JSON.stringify(searchResults[apiKey]) : 'not found');
        }
      });

      setSearchResults(searchResults);
      setIsModalOpen(true);
    } catch (err) {
      console.error('[NFTLayout] Search error:', err);
      setError(`Search failed: ${err.message}`);
    } finally {
      setSearchLoading(false);
    }
  };

  const handleChainSelect = (chainId) => {
    setShowE280Message(false);
    setSelectedChain(chainId === selectedChain ? null : chainId);
  };

  const handleE280Click = () => {
    if (selectedChain === 'base') {
      setShowE280Message(true);
    }
  };

  return (
    <div className="flex-1 p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-8">TitanX NFT Protocols</h1>

      <div className="w-full max-w-2xl mb-6">
        <div className="flex flex-col sm:flex-row gap-2">
          <input
            type="text"
            value={searchAddress}
            onChange={(e) => setSearchAddress(e.target.value)}
            placeholder="Search by wallet address (e.g., 0x...)"
            className="p-2 w-full bg-gray-700 text-white rounded-md border border-gray-600 focus:outline-none focus:ring-2 focus:ring-orange-500"
          />
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleSearch}
            disabled={searchLoading}
            className={`btn btn-primary px-4 py-2 font-semibold shadow-lg hover:shadow-xl transition-shadow duration-200 ${searchLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
            aria-label="Search by wallet address"
          >
            {searchLoading ? 'Searching...' : 'Search'}
          </motion.button>
        </div>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>

      <div className="flex space-x-4 mb-6 justify-center">
        {chains.map((chain) => (
          <motion.button
            key={chain.id}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleChainSelect(chain.id)}
            className={`btn ${selectedChain === chain.id ? 'btn-primary' : 'btn-secondary'} px-6 py-2 font-semibold shadow-lg hover:shadow-xl transition-shadow duration-200`}
            aria-label={`Select ${chain.name} chain`}
          >
            {chain.name}
          </motion.button>
        ))}
      </div>

      {selectedChain === 'eth' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl justify-center">
          {ethNFTs.map((nft) => (
            <Link key={nft.name} href={nft.href} passHref className="flex-1">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setShowE280Message(false)}
                className="btn btn-secondary w-full px-6 py-3 font-semibold hover:btn-primary transition-colors shadow-lg hover:shadow-xl"
                aria-label={`View ${nft.name} collection`}
              >
                {nft.name}
              </motion.button>
            </Link>
          ))}
        </div>
      )}
      {selectedChain === 'base' && (
        <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0 w-full max-w-6xl justify-center">
          {baseNFTs.map((nft) => (
            nft.href ? (
              <Link key={nft.name} href={nft.href} passHref className="flex-1">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowE280Message(false)}
                  className="btn btn-secondary w-full px-6 py-3 font-semibold hover:btn-primary transition-colors shadow-lg hover:shadow-xl"
                  aria-label={`View ${nft.name} collection`}
                >
                  {nft.name}
                </motion.button>
              </Link>
            ) : (
              <div key={nft.name} className="flex justify-center">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={handleE280Click}
                  className="btn btn-secondary max-w-xs px-6 py-3 font-semibold hover:btn-primary transition-colors shadow-lg hover:shadow-xl"
                  aria-label="View E280 collection (coming soon)"
                >
                  {nft.name}
                </motion.button>
              </div>
            )
          ))}
        </div>
      )}
      {showE280Message && selectedChain === 'base' && (
        <div className="mt-6 text-center text-white">
          <p className="text-lg">Contract not yet deployed. Coming soon...</p>
        </div>
      )}

      {isModalOpen && (
        <SearchResultsModal
          searchResult={searchResults}
          searchAddress={searchAddress}
          closeModal={() => setIsModalOpen(false)}
          handleBackgroundClick={(e) => e.target === e.currentTarget && setIsModalOpen(false)}
        />
      )}

      <div className="w-full max-w-6xl">{children}</div>
    </div>
  );
}
----- ./app/nft/page.js -----

// app/nft/page.js
export default function NFTOverview() {
  return (
    <div className="text-center text-white">
      <p className="text-lg">Select a collection above to view details.</p>
    </div>
  );
}
----- ./app/page.js -----

// app/page.js
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

export default function Home() {
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    setIsLoaded(true);
    console.log('Homepage hydrated');
  }, []);

  return (
    <div className="min-h-screen bg-transparent text-gray-100">
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-20 pb-16">
        <AnimatePresence>
          {isLoaded && (
            <motion.section
              initial={{ opacity: 0, y: 50 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 50 }}
              transition={{ duration: 0.8 }}
              className="text-center"
            >
              <h1 className="text-4xl sm:text-6xl font-extrabold tracking-tight">
                Welcome to TitanXUtils
              </h1>
              <p className="mt-4 text-lg sm:text-xl text-body">
                Your gateway to exploring the TitanX ecosystem. Dive into NFT protocols, auctions, mining, and more.
              </p>
              <div className="mt-8 flex flex-col sm:flex-row justify-center gap-4 max-w-3xl mx-auto">
                <Link href="/mining" passHref>
                  <motion.button
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                    className="btn btn-primary w-full sm:w-40 shadow-lg hover:shadow-xl transition-shadow duration-200"
                    aria-label="Navigate to Mining page"
                  >
                    Mining
                  </motion.button>
                </Link>
                <Link href="/auctions" passHref>
                  <motion.button
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                    className="btn btn-primary w-full sm:w-40 shadow-lg hover:shadow-xl transition-shadow duration-200"
                    aria-label="Navigate to Auctions page"
                  >
                    TitanX Auctions
                  </motion.button>
                </Link>
                <Link href="/nft" passHref>
                  <motion.button
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                    className="btn btn-primary w-full sm:w-40 shadow-lg hover:shadow-xl transition-shadow duration-200"
                    aria-label="Navigate to NFT Protocols page"
                  >
                    NFT Protocols
                  </motion.button>
                </Link>
              </div>
            </motion.section>
          )}
        </AnimatePresence>
      </main>
    </div>
  );
}
----- ./app/store.js -----

// app/store.js
'use client';
import { create } from 'zustand';

const CACHE_TTL = 30 * 60 * 1000; // 30 minutes

export const useNFTStore = create((set, get) => ({
  cache: {}, // { contractKey: { data: {...}, timestamp: number } }
  setCache: (contractKey, data) => {
    console.log(`[NFTStore] Setting cache for ${contractKey}: ${data.holders.length} holders`);
    set((state) => ({
      cache: {
        ...state.cache,
        [contractKey]: { data, timestamp: Date.now() },
      },
    }));
  },
  getCache: (contractKey) => {
    const cachedEntry = get().cache[contractKey];
    if (!cachedEntry) return null;
    const now = Date.now();
    if (now - cachedEntry.timestamp > CACHE_TTL) {
      console.log(`[NFTStore] Cache expired for ${contractKey}`);
      set((state) => {
        const newCache = { ...state.cache };
        delete newCache[contractKey];
        return { cache: newCache };
      });
      return null;
    }
    console.log(`[NFTStore] Returning cached data for ${contractKey}: ${cachedEntry.data.holders.length} holders`);
    return cachedEntry.data;
  },
}));
----- ./components/CollectionSelector.js -----

// app/components/CollectionSelector.js
"use client";

import { useRouter } from 'next/navigation';

export default function CollectionSelector({ currentCollection }) {
  const router = useRouter();
  const collections = ['element280', 'stax', 'element369', 'ascendant'];

  const handleChange = (e) => {
    router.push(`/nft/ETH/${e.target.value}`);
  };

  return (
    <div className="mb-6">
      <label htmlFor="collection" className="text-lg font-semibold mr-2">Select Collection:</label>
      <select
        id="collection"
        value={currentCollection}
        onChange={handleChange}
        className="p-2 bg-gray-800 text-white rounded"
      >
        {collections.map((key) => (
          <option key={key} value={key}>
            {key.charAt(0).toUpperCase() + key.slice(1)}
          </option>
        ))}
      </select>
    </div>
  );
}
----- ./components/HolderTable.js -----

// app/components/HolderTable.js
'use client';
import { useState } from 'react';
import Link from 'next/link';

export default function HolderTable({ holders, contract, loading }) {
  const [sortConfig, setSortConfig] = useState({ key: 'rank', direction: 'asc' });
  const [expandedRows, setExpandedRows] = useState({});

  const requestSort = (key) => {
    let direction = 'asc';
    if (sortConfig.key === key && sortConfig.direction === 'asc') {
      direction = 'desc';
    }
    setSortConfig({ key, direction });
  };

  const sortedHolders = [...holders].sort((a, b) => {
    if (sortConfig.key === 'wallet') {
      return sortConfig.direction === 'asc'
        ? a.wallet.localeCompare(b.wallet)
        : b.wallet.localeCompare(a.wallet);
    }
    const aValue = a[sortConfig.key] || 0;
    const bValue = b[sortConfig.key] || 0;
    return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;
  });

  const toggleRow = (wallet) => {
    setExpandedRows(prev => ({
      ...prev,
      [wallet]: !prev[wallet],
    }));
  };

  const renderTransactionList = (nfts, type) => (
    <ul className="list-disc pl-6">
      {nfts.length === 0 ? (
        <li>No {type} NFTs</li>
      ) : (
        nfts.map((nft, index) => (
          <li key={index}>
            Token ID: {nft.tokenId} (
            <Link
              href={`https://etherscan.io/tx/${nft.transactionHash}`}
              target="_blank"
              className="text-blue-400 hover:underline"
            >
              View Tx
            </Link>
            ) - {new Date(nft.timestamp).toLocaleString()}
          </li>
        ))
      )}
    </ul>
  );

  if (loading) {
    return <p className="text-gray-400">Loading holders...</p>;
  }

  if (!holders || holders.length === 0) {
    return <p className="text-gray-400">No holders found for this contract.</p>;
  }

  return (
    <div className="w-full overflow-x-auto">
      <table className="min-w-full bg-gray-800 rounded-lg shadow">
        <thead>
          <tr className="text-left text-gray-300">
            <th className="p-4 cursor-pointer" onClick={() => requestSort('rank')}>
              Rank {sortConfig.key === 'rank' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('wallet')}>
              Wallet {sortConfig.key === 'wallet' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('total')}>
              Total NFTs {sortConfig.key === 'total' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('multiplierSum')}>
              Multiplier {sortConfig.key === 'multiplierSum' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('percentage')}>
              % of Pool {sortConfig.key === 'percentage' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('buyCount')}>
              Buys {sortConfig.key === 'buyCount' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('sellCount')}>
              Sells {sortConfig.key === 'sellCount' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4 cursor-pointer" onClick={() => requestSort('burnCount')}>
              Burns {sortConfig.key === 'burnCount' && (sortConfig.direction === 'asc' ? '' : '')}
            </th>
            <th className="p-4">Details</th>
          </tr>
        </thead>
        <tbody>
          {sortedHolders.map((holder) => (
            <React.Fragment key={holder.wallet}>
              <tr className="border-t border-gray-700 hover:bg-gray-700">
                <td className="p-4">{holder.rank}</td>
                <td className="p-4">
                  <Link
                    href={`https://etherscan.io/address/${holder.wallet}`}
                    target="_blank"
                    className="text-blue-400 hover:underline"
                  >
                    {holder.wallet.slice(0, 6)}...{holder.wallet.slice(-4)}
                  </Link>
                </td>
                <td className="p-4">{holder.total}</td>
                <td className="p-4">{holder.displayMultiplierSum || (holder.multiplierSum / 10)}</td>
                <td className="p-4">{holder.percentage.toFixed(2)}%</td>
                <td className="p-4">{holder.buyCount}</td>
                <td className="p-4">{holder.sellCount}</td>
                <td className="p-4">{holder.burnCount}</td>
                <td className="p-4">
                  <button
                    onClick={() => toggleRow(holder.wallet)}
                    className="text-blue-400 hover:underline"
                  >
                    {expandedRows[holder.wallet] ? 'Hide' : 'Show'}
                  </button>
                </td>
              </tr>
              {expandedRows[holder.wallet] && (
                <tr>
                  <td colSpan="9" className="p-4 bg-gray-900">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div>
                        <h4 className="font-semibold">Bought NFTs</h4>
                        {renderTransactionList(holder.boughtNfts, 'bought')}
                      </div>
                      <div>
                        <h4 className="font-semibold">Sold NFTs</h4>
                        {renderTransactionList(holder.soldNfts, 'sold')}
                      </div>
                      <div>
                        <h4 className="font-semibold">Burned NFTs</h4>
                        {renderTransactionList(holder.burnedNfts, 'burned')}
                      </div>
                    </div>
                  </td>
                </tr>
              )}
            </React.Fragment>
          ))}
        </tbody>
      </table>
    </div>
  );
}
----- ./components/LoadingIndicator.js -----

// app/components/LoadingIndicator.js
import { motion } from 'framer-motion';

export default function LoadingIndicator({ status }) {
  return (
    <div className="flex flex-col items-center justify-center py-8">
      <motion.div
        className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full"
        animate={{ rotate: 360 }}
        transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
      />
      <p className="mt-4 text-lg text-gray-300">{status}</p>
    </div>
  );
}
----- ./components/NFTPage.js -----

// components/NFTPage.js
import HolderTable from '@/components/HolderTable';
import LoadingIndicator from '@/components/LoadingIndicator';
import CollectionSelector from '@/components/CollectionSelector';
import config from '@/app/contracts_nft';

export default function NFTPage({ contractKey, initialData, initialProgress }) {
  const { name, apiEndpoint, rewardToken } = config.contractDetails[contractKey.toLowerCase()] || {};

  const renderSummary = (data) => {
    if (!data) return null;
    const totalMultiplierSum = data.holders.reduce((sum, h) => sum + (h.multiplierSum || 0), 0);
    const totalTokens = data.totalTokens || 0;
    const summary = data.summary || {};
    return (
      <>
        <h2 className="text-2xl font-semibold mb-2">Summary</h2>
        <div className="summary-item"><span className="summary-label">Unique Wallets:</span><span>{data.holders.length}</span></div>
        <div className="summary-item"><span className="summary-label">Active NFTs:</span><span>{(summary.totalLive || totalTokens).toLocaleString()}</span></div>
        <div className="summary-item"><span className="summary-label">Burned NFTs:</span><span>{(summary.totalBurned || 0).toLocaleString()}</span></div>
        <div className="summary-item"><span className="summary-label">Minted NFTs:</span><span>{(summary.totalMinted || 0).toLocaleString()}</span></div>
        <div className="summary-item"><span className="summary-label">Multiplier Pool:</span><span>{(summary.multiplierPool || totalMultiplierSum).toLocaleString()}</span></div>
        <div className="summary-item"><span className="summary-label">Buy Transactions:</span><span>{data.transferSummary?.buyCount || 0}</span></div>
        <div className="summary-item"><span className="summary-label">Sell Transactions:</span><span>{data.transferSummary?.sellCount || 0}</span></div>
        <div className="summary-item"><span className="summary-label">Burn Transactions:</span><span>{data.transferSummary?.burnCount || 0}</span></div>
      </>
    );
  };

  return (
    <div className="min-h-screen bg-transparent text-white p-6 flex flex-col items-center">
      <h1 className="text-4xl font-bold mb-6">{name || 'Unknown Contract'} Holders</h1>
      <CollectionSelector currentCollection={contractKey} />
      {initialData.status === 'pending' || !initialData.holders ? (
        <LoadingIndicator status={`Loading ${name || 'contract'} holders: ${initialProgress.step} (${initialProgress.progressPercentage})`} />
      ) : initialData.error ? (
        <p className="text-red-500 text-lg">Error: {initialData.error}</p>
      ) : !initialData.holders.length ? (
        <p className="text-gray-400 text-lg">No data available for {name || 'this contract'}.</p>
      ) : (
        <div className="w-full max-w-6xl">
          <div className="mb-6 p-4 bg-gray-800 rounded-lg shadow">{renderSummary(initialData)}</div>
          <HolderTable holders={initialData.holders || []} contract={contractKey} loading={false} />
        </div>
      )}
    </div>
  );
}
----- ./components/SearchResultsModal.js -----

// components/SearchResultsModal.js
'use client';
import { motion } from 'framer-motion';
import HolderTable from './HolderTable';
import Dialog from './Dialog';

export default function SearchResultsModal({ searchResult, searchAddress, closeModal, handleBackgroundClick }) {
  return (
    <Dialog isOpen={true} onClose={closeModal}>
      <div className="h-full flex flex-col bg-transparent">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold text-white">
            Search Results for {searchAddress}
          </h2>
        </div>
        <div className="flex-1 overflow-y-auto bg-transparent">
          {Object.keys(searchResult).length === 0 ? (
            <p className="text-gray-400">No results available.</p>
          ) : (
            Object.entries(searchResult).map(([contract, data]) => (
              <div key={contract} className="mb-6">
                <h3 className="text-xl font-semibold mb-2 text-white">
                  {contractDetails[contract]?.name || contract}
                </h3>
                {data === null ? (
                  <p className="text-gray-400">Wallet not found in this collection.</p>
                ) : data.error ? (
                  <p className="text-red-500">Error: {data.error}</p>
                ) : data.message ? (
                  <p className="text-gray-400">Data not available for this collection.</p>
                ) : (
                  <HolderTable
                    holders={[data]}
                    contract={contract}
                    loading={false}
                    totalShares={data.totalShares}
                    isModal={true}
                  />
                )}
              </div>
            ))
          )}
        </div>
      </div>
    </Dialog>
  );
}

const contractDetails = {
  element280: { name: 'Element280' },
  element369: { name: 'Element369' },
  staxNFT: { name: 'Stax' },
  ascendantNFT: { name: 'Ascendant' },
  e280: { name: 'E280' },
};

================= Final Summary of Included Files =================
./.env.local
./app/api/holders/ascendant/route.js
./app/api/holders/blockchain/events.js
./app/api/holders/blockchain/multicall.js
./app/api/holders/blockchain/owners.js
./app/api/holders/cache/getHoldersMap.js
./app/api/holders/cache/holders.js
./app/api/holders/cache/populateHoldersMapCache.js
./app/api/holders/cache/state.js
./app/api/holders/cache/state/[contractKey]/route.js
./app/api/holders/cache/utils.js
./app/api/holders/e280/route.js
./app/api/holders/element280/route.js
./app/api/holders/element369/route.js
./app/api/holders/shared.js
./app/api/holders/stax/route.js
./app/api/utils.js
./app/api/utils/cache.js
./app/api/utils/client.js
./app/api/utils/logging.js
./app/api/utils/retry.js
./app/contracts/abi_nft.js
./app/contracts/abi_nft_vault.js
./app/contracts/contracts_auct_mint.js
./app/contracts/contracts_nft.js
./app/layout.js
./app/lib/constants.js
./app/lib/logger.js
./app/lib/schemas.js
./app/lib/serverInit.js
./app/nft/[chain]/[contract]/page.js
./app/nft/layout.js
./app/nft/page.js
./app/page.js
./app/store.js
./components/CollectionSelector.js
./components/HolderTable.js
./components/LoadingIndicator.js
./components/NFTPage.js
./components/SearchResultsModal.js
