================= Includes the following JS files under ./server =================
app/api/holders/Element280/validate-burned/route.js
app/api/holders/[contract]/progress/route.js
app/api/holders/[contract]/route.js
app/api/utils.dev-repo.js
app/api/utils.js
app/lib/logger.js
app/lib/serverInit.js
client/lib/chartOptions.js
client/lib/fetchCollectionData.js
client/lib/schemas.js
client/lib/useNFTData.js


================= Contents of above files in ./server =================


----- app/api/holders/Element280/validate-burned/route.js -----

// app/api/holders/Element280/validate-burned/route.js
import { NextResponse } from 'next/server';
import config from '@/contracts/config';
import { getTransactionReceipt, log, client, getCache, setCache } from '@/app/api/utils.js';
import { parseAbiItem } from 'viem';

export async function POST(request) {
  if (process.env.DEBUG === 'true') {
    log(`[Element280-Validate-Burned] [DEBUG] Processing POST request for validate-burned`);
  }

  try {
    const { transactionHash } = await request.json();
    if (!transactionHash || typeof transactionHash !== 'string' || !transactionHash.match(/^0x[a-fA-F0-9]{64}$/)) {
      log(`[Element280-Validate-Burned] [VALIDATION] Invalid transaction hash: ${transactionHash || 'undefined'}`);
      return NextResponse.json({ error: 'Invalid transaction hash' }, { status: 400 });
    }

    const contractAddress = config.contractAddresses?.element280?.address;
    if (!contractAddress) {
      log(`[Element280-Validate-Burned] [VALIDATION] Element280 contract address not configured in config.js`);
      return NextResponse.json({ error: 'Contract address not configured' }, { status: 500 });
    }

    const cacheKey = `element280_burn_validation_${transactionHash}`;
    const cachedResult = await getCache(cacheKey, 'element280');
    if (cachedResult) {
      if (process.env.DEBUG === 'true') {
        log(`[Element280-Validate-Burned] [DEBUG] Cache hit for burn validation: ${transactionHash}`);
      }
      return NextResponse.json(cachedResult);
    }

    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Fetching transaction receipt for hash: ${transactionHash}`);
    }
    const receipt = await getTransactionReceipt(transactionHash);
    if (!receipt) {
      log(`[Element280-Validate-Burned] [VALIDATION] Transaction receipt not found for hash: ${transactionHash}`);
      return NextResponse.json({ error: 'Transaction not found' }, { status: 404 });
    }

    const burnAddress = '0x0000000000000000000000000000000000000000';
    const transferEvent = parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)');
    const burnedTokenIds = [];

    for (const logEntry of receipt.logs) {
      if (
        logEntry.address.toLowerCase() === contractAddress.toLowerCase() &&
        logEntry.topics[0] === transferEvent.topics[0]
      ) {
        try {
          const decodedLog = client.decodeEventLog({
            abi: [transferEvent],
            data: logEntry.data,
            topics: logEntry.topics,
          });
          if (decodedLog.args.to.toLowerCase() === burnAddress) {
            burnedTokenIds.push(decodedLog.args.tokenId.toString());
          }
        } catch (_decodeError) {
          log(`[Element280-Validate-Burned] [ERROR] Failed to decode log entry for transaction ${transactionHash}: ${_decodeError.message}`);
        }
      }
    }

    if (burnedTokenIds.length === 0) {
      log(`[Element280-Validate-Burned] [VALIDATION] No burn events found in transaction: ${transactionHash}`);
      return NextResponse.json({ error: 'No burn events found in transaction' }, { status: 400 });
    }

    const result = {
      transactionHash,
      burnedTokenIds,
      blockNumber: receipt.blockNumber.toString(),
    };

    await setCache(cacheKey, result, config.cache.nodeCache.stdTTL, 'element280');
    if (process.env.DEBUG === 'true') {
      log(`[Element280-Validate-Burned] [DEBUG] Found ${burnedTokenIds.length} burned tokens in transaction: ${transactionHash}`);
    }
    return NextResponse.json(result);
  } catch (error) {
    log(`[Element280-Validate-Burned] [ERROR] Error processing transaction: ${error.message}, stack: ${error.stack}`);
    return NextResponse.json({ error: 'Failed to validate transaction', details: error.message }, { status: 500 });
  }
}
----- app/api/holders/[contract]/progress/route.js -----

import { NextResponse } from 'next/server';
import { logger, loadCacheState } from '@/app/api/utils';
import config from '@/contracts/config';

async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
    globalMetrics: {}, // Added
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      cacheState.isPopulating = savedState.isPopulating ?? false;
      cacheState.totalOwners = savedState.totalOwners ?? 0;
      cacheState.progressState = {
        step: savedState.progressState?.step ?? 'idle',
        processedNfts: savedState.progressState?.processedNfts ?? 0,
        totalNfts: savedState.progressState?.totalNfts ?? 0,
        processedTiers: savedState.progressState?.processedTiers ?? 0,
        totalTiers: savedState.progressState?.totalTiers ?? 0,
        error: savedState.progressState?.error ?? null,
        errorLog: savedState.progressState?.errorLog ?? [],
      };
      cacheState.lastUpdated = savedState.lastUpdated ?? null;
      cacheState.lastProcessedBlock = savedState.lastProcessedBlock ?? null;
      cacheState.globalMetrics = savedState.globalMetrics ?? {};
    }
  } catch (error) {
    logger.error(contractKey, `Failed to load cache state: ${error.message}`, { stack: error.stack });
    cacheState.progressState.error = `Failed to load cache state: ${error.message}`;
    cacheState.progressState.errorLog.push({
      timestamp: new Date().toISOString(),
      phase: 'load_cache_state',
      error: error.message,
    });
  }
  return cacheState;
}

export async function GET(_request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();

  if (!config.contractDetails[contractKey]) {
    logger.error(contractKey, `Invalid contract: ${contractKey}`);
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  try {
    const state = await getCacheState(contractKey);
    console.log(`Progress state for ${contractKey}:`, JSON.stringify(state, null, 2)); // Debug log
    if (!state || !state.progressState) {
      logger.error(contractKey, 'Invalid cache state');
      return NextResponse.json({ error: 'Cache state not initialized' }, { status: 500 });
    }

    let progressPercentage = '0.0';
    if (state.progressState.error) {
      progressPercentage = '0.0';
    } else if (state.progressState.step === 'completed') {
      progressPercentage = '100.0';
    } else if (state.progressState.totalNfts > 0) {
      if (state.progressState.step === 'fetching_owners') {
        const ownerProgress = (state.progressState.processedNfts / state.progressState.totalNfts) * 50;
        progressPercentage = Math.min(ownerProgress, 50).toFixed(1);
      } else if (state.progressState.step === 'fetching_tiers') {
        const tierProgress = (state.progressState.processedTiers / state.progressState.totalTiers) * 50;
        progressPercentage = Math.min(50 + tierProgress, 100).toFixed(1);
      }
    }

    return NextResponse.json({
      isPopulating: state.isPopulating,
      totalLiveHolders: state.totalOwners,
      totalOwners: state.totalOwners,
      phase: state.progressState.step.charAt(0).toUpperCase() + state.progressState.step.slice(1),
      progressPercentage,
      lastProcessedBlock: state.lastProcessedBlock,
      error: state.progressState.error || null,
      errorLog: (state.progressState.errorLog || []).slice(-50), // Limit to last 50 errors
      globalMetrics: state.globalMetrics, // Added
    });
  } catch (error) {
    logger.error(contractKey, `Progress endpoint error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to fetch ${contractKey} cache state`, details: error.message }, { status: 500 });
  }
}
----- app/api/holders/[contract]/route.js -----


// File: app/api/holders/[contract]/route.js
import { NextResponse } from 'next/server';
import { parseAbiItem, formatUnits, getAddress } from 'viem';
import pLimit from 'p-limit';
import config from '@/contracts/config.js';
import { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract, validateContract } from '@/app/api/utils'; // Add validateContract
import { HoldersResponseSchema } from '@/client/lib/schemas';



const limit = pLimit(5);

// Utility to sanitize BigInt values
function sanitizeBigInt(obj) {
  if (typeof obj === 'bigint') return obj.toString();
  if (Array.isArray(obj)) return obj.map(item => sanitizeBigInt(item));
  if (typeof obj === 'object' && obj !== null) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeBigInt(value);
    }
    return sanitized;
  }
  return obj;
}

// Get cache state for a contract
async function getCacheState(contractKey) {
  const cacheState = {
    isPopulating: false,
    totalOwners: 0,
    totalLiveHolders: 0,
    progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
    lastUpdated: null,
    lastProcessedBlock: null,
    globalMetrics: {},
  };
  try {
    const savedState = await loadCacheState(contractKey, contractKey.toLowerCase());
    if (savedState && typeof savedState === 'object') {
      Object.assign(cacheState, {
        isPopulating: savedState.isPopulating ?? false,
        totalOwners: savedState.totalOwners ?? 0,
        totalLiveHolders: savedState.totalLiveHolders ?? 0,
        progressState: {
          step: savedState.progressState?.step ?? 'idle',
          processedNfts: savedState.progressState?.processedNfts ?? 0,
          totalNfts: savedState.progressState?.totalNfts ?? 0,
          processedTiers: savedState.progressState?.processedTiers ?? 0,
          totalTiers: savedState.progressState?.totalTiers ?? 0,
          error: savedState.progressState?.error ?? null,
          errorLog: savedState.progressState?.errorLog ?? [],
        },
        lastUpdated: savedState.lastUpdated ?? null,
        lastProcessedBlock: savedState.lastProcessedBlock ?? null,
        globalMetrics: savedState.globalMetrics ?? {},
      });
      logger.debug('utils', `Loaded cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`, 'eth', contractKey);
    }
  } catch (error) {
    logger.error('utils', `Failed to load cache state: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
  }
  return cacheState;
}

// Save cache state for a contract
async function saveCacheStateContract(contractKey, cacheState) {
  try {
    await saveCacheState(contractKey, cacheState, contractKey.toLowerCase());
    logger.debug('utils', `Saved cache state: totalOwners=${cacheState.totalOwners}, step=${cacheState.progressState.step}`, 'eth', contractKey);
  } catch (error) {
    logger.error('utils', `Failed to save cache state: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
  }
}

// Fetch new Transfer events (burns and transfers)
async function getNewEvents(contractKey, contractAddress, fromBlock, errorLog) {
  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const cacheKey = `${contractKey.toLowerCase()}_events_${contractAddress}_${fromBlock}`;
  let cachedEvents = await getCache(cacheKey, contractKey.toLowerCase());

  if (cachedEvents) {
    logger.info('utils', `Events cache hit: ${cacheKey}, count: ${cachedEvents.burnedTokenIds.length + (cachedEvents.transferTokenIds?.length || 0)}`, 'eth', contractKey);
    return cachedEvents;
  }

  let burnedTokenIds = [];
  let transferTokenIds = [];
  let endBlock;
  try {
    endBlock = await client.getBlockNumber();
  } catch (error) {
    logger.error('utils', `Failed to fetch block number: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    throw error;
  }

  if (fromBlock >= endBlock) {
    logger.info('utils', `No new blocks: fromBlock ${fromBlock} >= endBlock ${endBlock}`, 'eth', contractKey);
    return { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock) };
  }

  try {
    const logs = await client.getLogs({
      address: contractAddress,
      event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
      fromBlock: BigInt(fromBlock),
      toBlock: endBlock,
    });
    burnedTokenIds = logs
      .filter(log => log.args.to.toLowerCase() === burnAddress.toLowerCase())
      .map(log => Number(log.args.tokenId));
    transferTokenIds = logs
      .filter(log => log.args.to.toLowerCase() !== burnAddress.toLowerCase())
      .map(log => ({ tokenId: Number(log.args.tokenId), from: log.args.from.toLowerCase(), to: log.args.to.toLowerCase() }));
    const cacheData = { burnedTokenIds, transferTokenIds, lastBlock: Number(endBlock), timestamp: Date.now() };
    await setCache(cacheKey, cacheData, config.cache.nodeCache.stdTTL, contractKey.toLowerCase());
    logger.info('utils', `Cached events: ${cacheKey}, burns: ${burnedTokenIds.length}, transfers: ${transferTokenIds.length}`, 'eth', contractKey);
    return cacheData;
  } catch (error) {
    logger.error('utils', `Failed to fetch events: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_events', error: error.message });
    throw error;
  }
}

// Build holders map from contract data
async function getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState) {
  if (!contractAddress) throw new Error('Contract address missing');
  if (!abi) throw new Error(`${contractKey} ABI missing`);

  const requiredFunctions = contractKey === 'ascendant' ? ['getNFTAttribute', 'userRecords', 'totalShares', 'toDistribute', 'batchClaimableAmount'] : ['totalSupply', 'totalBurned', 'ownerOf', 'getNftTier'];
  const missingFunctions = requiredFunctions.filter(fn => !abi.some(item => item.name === fn));
  if (missingFunctions.length > 0) throw new Error(`Missing ABI functions: ${missingFunctions.join(', ')}`);

  const burnAddress = config.burnAddress || '0x0000000000000000000000000000000000000000';
  const holdersMap = new Map();
  let totalBurned = 0;
  const errorLog = [];

  cacheState.progressState.step = 'fetching_supply';
  await saveCacheStateContract(contractKey, cacheState);

  let currentBlock;
  try {
    currentBlock = await client.getBlockNumber();
    logger.debug('utils', `Fetched current block: ${currentBlock}`, 'eth', contractKey);
  } catch (error) {
    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
    logger.error('utils', `Failed to fetch block number: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    throw error;
  }

  if (contractKey === 'ascendant') {
    // Fetch totalShares
    const totalSharesRaw = await retry(
      async () => {
        const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalShares' });
        if (result === null || result === undefined) throw new Error('totalShares returned null');
        return result;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));
    logger.debug('utils', `Total shares: ${totalShares}`, 'eth', contractKey);

    // Fetch toDistribute for day8, day28, day90
    const toDistributeDay8Raw = await retry(
      async () => {
        const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] });
        if (result === null || result === undefined) throw new Error('toDistribute day8 returned null');
        return result;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

    const toDistributeDay28Raw = await retry(
      async () => {
        const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] });
        if (result === null || result === undefined) throw new Error('toDistribute day28 returned null');
        return result;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

    const toDistributeDay90Raw = await retry(
      async () => {
        const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] });
        if (result === null || result === undefined) throw new Error('toDistribute day90 returned null');
        return result;
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

    cacheState.progressState.step = 'fetching_holders';
    await saveCacheStateContract(contractKey, cacheState);

    // Fetch owners and tokenIds
    let tokenOwnerMap = new Map();
    let totalTokens = 0;
    try {
      // Use getOwnersForContract from utils.js
      const owners = await retry(
        () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true }),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );

      // Filter out burn address and invalid owners
      const filteredOwners = owners.filter(
        (owner) => owner?.ownerAddress && owner.ownerAddress.toLowerCase() !== burnAddress.toLowerCase() && owner.tokenBalances?.length > 0
      );
      logger.debug('utils', `Filtered owners: ${filteredOwners.length}`, 'eth', contractKey);

      // Build tokenOwnerMap
      filteredOwners.forEach((owner) => {
        if (!owner.ownerAddress) return;
        let wallet;
        try {
          wallet = getAddress(owner.ownerAddress).toLowerCase();
        } catch (e) {
          logger.warn('utils', `Invalid wallet address: ${owner.ownerAddress}`, 'eth', contractKey);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_owner', ownerAddress: owner.ownerAddress, error: 'Invalid wallet address' });
          return;
        }
        owner.tokenBalances.forEach((tb) => {
          if (!tb.tokenId) return;
          const tokenId = Number(tb.tokenId);
          tokenOwnerMap.set(tokenId, wallet);
          totalTokens++;
        });
      });
      logger.debug('utils', `Total tokens (Alchemy): ${totalTokens}`, 'eth', contractKey);
    } catch (error) {
      logger.warn('utils', `Failed to fetch owners via getOwnersForContract: ${error.message}, falling back to Transfer events`, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_owners_alchemy', error: error.message });

      // Fallback: Use Transfer events
      const fromBlock = BigInt(config.deploymentBlocks[contractKey]?.block || 0);
      const toBlock = currentBlock;
      const transferLogs = await retry(
        async () => {
          const logs = await client.getLogs({
            address: contractAddress,
            event: parseAbiItem('event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'),
            fromBlock,
            toBlock,
          });
          return logs;
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );

      for (const log of transferLogs) {
        const from = log.args.from.toLowerCase();
        const to = log.args.to.toLowerCase();
        const tokenId = Number(log.args.tokenId);

        if (to === burnAddress.toLowerCase()) {
          totalBurned += 1;
          tokenOwnerMap.delete(tokenId);
          logger.debug('utils', `Token ${tokenId} burned to ${to}`, 'eth', contractKey);
          continue;
        }

        if (from === '0x0000000000000000000000000000000000000000') {
          tokenOwnerMap.set(tokenId, to);
          totalTokens++;
          logger.debug('utils', `Token ${tokenId} minted to ${to}`, 'eth', contractKey);
        } else {
          tokenOwnerMap.set(tokenId, to);
          logger.debug('utils', `Token ${tokenId} transferred to ${to}`, 'eth', contractKey);
        }
      }
      logger.debug('utils', `Total tokens (Transfer events): ${totalTokens}`, 'eth', contractKey);
    }

    cacheState.progressState.totalNfts = totalTokens;
    cacheState.progressState.totalTiers = totalTokens;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    if (totalTokens === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug('utils', `No tokens found, returning empty holdersMap`, 'eth', contractKey);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
    }

    cacheState.progressState.step = 'fetching_records';
    cacheState.progressState.processedNfts = 0;
    await saveCacheStateContract(contractKey, cacheState);

    // Fetch userRecords and getNFTAttribute for all tokenIds
    const tokenIds = Array.from(tokenOwnerMap.keys());
    const recordCalls = tokenIds.map((tokenId) => ({
      address: contractAddress,
      abi,
      functionName: 'userRecords',
      args: [BigInt(tokenId)],
    }));
    const tierCalls = tokenIds.map((tokenId) => ({
      address: contractAddress,
      abi,
      functionName: 'getNFTAttribute',
      args: [BigInt(tokenId)],
    }));

    const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
    const concurrencyLimit = pLimit(4);
    logger.debug('utils', `Fetching userRecords and tiers for ${tokenIds.length} tokens in chunks of ${chunkSize}`, 'eth', contractKey);

    // Batch userRecords calls
    const recordResults = [];
    for (let i = 0; i < recordCalls.length; i += chunkSize) {
      const chunk = recordCalls.slice(i, i + chunkSize);
      const results = await retry(
        () => batchMulticall(chunk, config.alchemy.batchSize),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      recordResults.push(...results);
      cacheState.progressState.processedNfts = Math.min(i + chunkSize, tokenIds.length);
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug('utils', `Processed userRecords for ${cacheState.progressState.processedNfts}/${tokenIds.length} tokens`, 'eth', contractKey);
    }

    // Batch getNFTAttribute calls
    cacheState.progressState.step = 'fetching_tiers';
    cacheState.progressState.processedTiers = 0;
    await saveCacheStateContract(contractKey, cacheState);

    const tierResults = [];
    for (let i = 0; i < tierCalls.length; i += chunkSize) {
      const chunk = tierCalls.slice(i, i + chunkSize);
      const results = await retry(
        () => batchMulticall(chunk, config.alchemy.batchSize),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      tierResults.push(...results);
      cacheState.progressState.processedTiers = Math.min(i + chunkSize, tokenIds.length);
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug('utils', `Processed tiers for ${cacheState.progressState.processedTiers}/${tokenIds.length} tokens`, 'eth', contractKey);
    }

    // Group tokenIds by wallet for batchClaimableAmount
    const walletTokenIds = new Map();
    tokenIds.forEach((tokenId) => {
      const wallet = tokenOwnerMap.get(tokenId);
      if (!wallet) return;
      if (!walletTokenIds.has(wallet)) {
        walletTokenIds.set(wallet, []);
      }
      walletTokenIds.get(wallet).push(tokenId);
    });

    // Fetch batchClaimableAmount
    cacheState.progressState.step = 'fetching_claimable';
    await saveCacheStateContract(contractKey, cacheState);

    const claimableCalls = Array.from(walletTokenIds.entries()).map(([wallet, tokenIds]) => ({
      address: contractAddress,
      abi,
      functionName: 'batchClaimableAmount',
      args: [tokenIds.map((id) => BigInt(id))],
    }));

    const claimableResults = [];
    for (let i = 0; i < claimableCalls.length; i += chunkSize) {
      const chunk = claimableCalls.slice(i, i + chunkSize);
      const results = await retry(
        () => batchMulticall(chunk, config.alchemy.batchSize),
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      claimableResults.push(...results);
      logger.debug('utils', `Processed claimable amounts for ${i + chunk.length}/${claimableCalls.length} wallets`, 'eth', contractKey);
    }

    // Process results and build holdersMap
    cacheState.progressState.step = 'building_holders';
    await saveCacheStateContract(contractKey, cacheState);

    let totalLockedAscendant = 0;
    const maxTier = Object.keys(config.contractTiers[contractKey]).length;

    tokenIds.forEach((tokenId, i) => {
      const wallet = tokenOwnerMap.get(tokenId);
      if (!wallet) {
        logger.warn('utils', `No owner found for token ${tokenId}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'process_token', tokenId, error: 'No owner found' });
        return;
      }

      let shares = 0;
      let lockedAscendant = 0;
      const recordResult = recordResults[i];
      if (recordResult.status === 'success' && Array.isArray(recordResult.result)) {
        shares = parseFloat(formatUnits(recordResult.result[0] || 0, 18));
        lockedAscendant = parseFloat(formatUnits(recordResult.result[1] || 0, 18));
        logger.debug('utils', `userRecords for token ${tokenId}: shares=${shares}, lockedAscendant=${lockedAscendant}`, 'eth', contractKey);
      } else {
        logger.error('utils', `Failed to fetch userRecords for token ${tokenId}: ${recordResult.error || 'unknown error'}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_records', tokenId, wallet, error: recordResult.error || 'unknown error' });
        return;
      }

      let tier = 0;
      const tierResult = tierResults[i];
      if (tierResult.status === 'success') {
        tier = Number(tierResult.result.tier || 0); // getNFTAttribute returns { rarityNumber, tier, rarity }
        logger.debug('utils', `getNFTAttribute for token ${tokenId}: tier=${tier}`, 'eth', contractKey);
      } else {
        logger.error('utils', `Failed to fetch getNFTAttribute for token ${tokenId}: ${tierResult.error || 'unknown error'}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, wallet, error: tierResult.error || 'unknown error' });
        return;
      }

      // Update holdersMap
      const holder = holdersMap.get(wallet) || {
        wallet,
        tokenIds: [],
        tiers: Array(maxTier).fill(0),
        total: 0,
        multiplierSum: 0,
        shares: 0,
        lockedAscendant: 0,
        pendingDay8: 0,
        pendingDay28: 0,
        pendingDay90: 0,
        claimableRewards: 0,
      };

      if (!holder.tokenIds.includes(tokenId)) {
        holder.tokenIds.push(tokenId);
        holder.total += 1;
        if (tier >= 1 && tier <= maxTier) {
          holder.tiers[tier - 1] += 1;
          holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
          logger.debug('utils', `Assigned tier ${tier} to token ${tokenId}, wallet ${wallet}`, 'eth', contractKey);
        } else {
          logger.warn('utils', `Invalid tier ${tier} for token ${tokenId}, wallet ${wallet}`, 'eth', contractKey);
          errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, wallet, error: `Invalid tier ${tier}` });
        }
        holder.shares += shares;
        holder.lockedAscendant += lockedAscendant;
        totalLockedAscendant += lockedAscendant;
        holdersMap.set(wallet, holder);
      }
    });

    // Assign claimableRewards
    let claimableIndex = 0;
    for (const [wallet, tokenIds] of walletTokenIds.entries()) {
      const holder = holdersMap.get(wallet);
      if (!holder) {
        claimableIndex++;
        continue;
      }
      const claimableResult = claimableResults[claimableIndex];
      if (claimableResult?.status === 'success') {
        holder.claimableRewards = parseFloat(formatUnits(claimableResult.result || 0, 18));
        logger.debug('utils', `Claimable rewards for wallet ${wallet}: ${holder.claimableRewards}`, 'eth', contractKey);
      } else {
        logger.error('utils', `Failed to fetch claimableRewards for wallet ${wallet}: ${claimableResult?.error || 'unknown error'}`, 'eth', contractKey);
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_claimable', wallet, error: claimableResult?.error || 'unknown error' });
      }
      claimableIndex++;
    }

    // Calculate pending rewards and final metrics
    cacheState.progressState.step = 'calculating_metrics';
    await saveCacheStateContract(contractKey, cacheState);

    const holderList = Array.from(holdersMap.values());
    const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
    const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
    const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
    const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

    holderList.forEach((holder) => {
      holder.pendingDay8 = holder.shares * pendingRewardPerShareDay8;
      holder.pendingDay28 = holder.shares * pendingRewardPerShareDay28;
      holder.pendingDay90 = holder.shares * pendingRewardPerShareDay90;
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.displayMultiplierSum = holder.multiplierSum;
      logger.debug('utils', `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, shares=${holder.shares}`, 'eth', contractKey);
    });

    holderList.sort((a, b) => b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total);
    holderList.forEach((holder, index) => (holder.rank = index + 1));
    logger.debug('utils', `Sorted holders: count=${holderList.length}, topHolder=${JSON.stringify(holderList[0])}`, 'eth', contractKey);

    cacheState.totalOwners = holderList.length;
    cacheState.totalLiveHolders = holderList.length;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = cacheState.progressState.totalNfts;
    cacheState.progressState.processedTiers = cacheState.progressState.totalTiers;
    cacheState.progressState.error = null;
    cacheState.progressState.errorLog = errorLog;
    cacheState.globalMetrics = {
      totalTokens,
      totalLockedAscendant,
      totalShares,
      toDistributeDay8,
      toDistributeDay28,
      toDistributeDay90,
      pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
    };
    await saveCacheStateContract(contractKey, cacheState);
    logger.info('utils', `Completed holders map with ${holderList.length} holders, totalBurned=${totalBurned}, totalShares=${totalShares}`, 'eth', contractKey);

    return { holdersMap, totalBurned, lastBlock: Number(currentBlock), errorLog };
  } else {
    const totalSupply = await retry(
      async () => {
        const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalSupply' });
        if (result === null || result === undefined) throw new Error('totalSupply returned null');
        return Number(result);
      },
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    logger.debug('utils', `Total supply: ${totalSupply}`, 'eth', contractKey);

    let burnedCountContract = 0;
    try {
      burnedCountContract = await retry(
        async () => {
          const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalBurned' });
          if (result === null || result === undefined) throw new Error('totalBurned returned null');
          return Number(result);
        },
        { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
      );
      logger.debug('utils', `Burned count from contract: ${burnedCountContract}`, 'eth', contractKey);
    } catch (error) {
      logger.error('utils', `Failed to fetch totalBurned: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
      errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_burned', error: error.message });
    }
    totalBurned = burnedCountContract;

    cacheState.progressState.totalNfts = totalSupply || 0;
    cacheState.progressState.totalTiers = totalSupply || 0;
    cacheState.lastProcessedBlock = Number(currentBlock);
    await saveCacheStateContract(contractKey, cacheState);

    if (totalSupply === 0) {
      cacheState.progressState.step = 'completed';
      await saveCacheStateContract(contractKey, cacheState);
      logger.debug('utils', `No NFTs (totalSupply=0), returning empty holdersMap`, 'eth', contractKey);
      return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
    }

    cacheState.progressState.step = 'fetching_owners';
    await saveCacheStateContract(contractKey, cacheState);

    logger.debug('utils', `Fetching owners for ${totalSupply} tokens using getOwnersForContract`, 'eth', contractKey);
    const owners = await retry(
      () => getOwnersForContract(contractAddress, abi, { withTokenBalances: true }),
      { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
    );
    logger.debug('utils', `Fetched owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, 'eth', contractKey);

    let processedTokens = 0;
    for (const owner of owners) {
      const wallet = owner.ownerAddress.toLowerCase();
      logger.debug('utils', `Processing owner: wallet=${wallet}, tokenBalancesCount=${owner.tokenBalances.length}`, 'eth', contractKey);

      const tokenIds = owner.tokenBalances
        .map(tb => {
          const tokenId = Number(tb.tokenId);
          if (isNaN(tokenId) || tokenId < 0) {
            logger.warn('utils', `Invalid tokenId ${tb.tokenId} for wallet ${wallet}`, 'eth', contractKey);
            return null;
          }
          return tokenId;
        })
        .filter(id => id !== null);

      if (tokenIds.length === 0) {
        logger.warn('utils', `No valid token IDs for wallet ${wallet}`, 'eth', contractKey);
        continue;
      }

      if (wallet === burnAddress.toLowerCase()) {
        totalBurned += owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0);
        logger.debug('utils', `Incremented totalBurned by ${owner.tokenBalances.reduce((sum, tb) => sum + Number(tb.balance), 0)} for burn address`, 'eth', contractKey);
        continue;
      }

      processedTokens += tokenIds.length;

      const holder = holdersMap.get(wallet) || {
        wallet,
        tokenIds: [],
        tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
        total: 0,
        multiplierSum: 0,
        ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
        ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
      };
      holder.tokenIds.push(...tokenIds);
      holder.total += tokenIds.length;
      holdersMap.set(wallet, holder);
      logger.debug('utils', `Added to holdersMap: wallet=${wallet}, totalTokens=${holder.total}`, 'eth', contractKey);

      cacheState.progressState.processedNfts = processedTokens;
      if (processedTokens % 1000 === 0) await saveCacheStateContract(contractKey, cacheState);
    }

    logger.debug('utils', `Holders map size: ${holdersMap.size}, totalBurned: ${totalBurned}, processedTokens: ${processedTokens}`, 'eth', contractKey);
    await saveCacheStateContract(contractKey, cacheState);
    await setCache(`${contractKey.toLowerCase()}_holders_partial`, { holders: Array.from(holdersMap.values()), totalBurned, timestamp: Date.now() }, 0, contractKey.toLowerCase());
    logger.info('utils', `Fetched ${processedTokens} owners, ${holdersMap.size} unique holders`, 'eth', contractKey);

    cacheState.progressState.step = 'fetching_tiers';
    cacheState.progressState.processedTiers = 0;
    await saveCacheStateContract(contractKey, cacheState);

    const tokenIdToOwner = new Map();
    for (const holder of holdersMap.values()) {
      for (const tokenId of holder.tokenIds) {
        tokenIdToOwner.set(tokenId, holder.wallet);
      }
    }

    const validTokenIds = Array.from(tokenIdToOwner.keys());
    logger.debug('utils', `Valid token IDs for tier fetching: count=${validTokenIds.length}, sample=${JSON.stringify(validTokenIds.slice(0, 5))}`, 'eth', contractKey);
    const tierCalls = validTokenIds.map(tokenId => ({
      address: contractAddress,
      abi,
      functionName: 'getNftTier',
      args: [BigInt(tokenId)],
    }));

    if (tierCalls.length > 0) {
      const chunkSize = config.nftContracts[contractKey]?.maxTokensPerOwnerQuery || 1000;
      const concurrencyLimit = pLimit(4);
      logger.debug('utils', `Fetching tiers for ${tierCalls.length} tokens in chunks of ${chunkSize}`, 'eth', contractKey);
      const tierPromises = [];
      for (let i = 0; i < tierCalls.length; i += chunkSize) {
        const chunk = tierCalls.slice(i, i + chunkSize);
        tierPromises.push(
          concurrencyLimit(async () => {
            logger.debug('utils', `Processing tier batch ${i / chunkSize + 1} with ${chunk.length} calls`, 'eth', contractKey);
            try {
              const tierResults = await retry(() => batchMulticall(chunk, config.alchemy.batchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });

              tierResults.forEach((result, index) => {
                const tokenId = validTokenIds[i + index];
                const owner = tokenIdToOwner.get(tokenId);
                if (!owner) {
                  logger.debug('utils', `Skipped tier for tokenId ${tokenId}: no owner found`, 'eth', contractKey);
                  return;
                }

                const holder = holdersMap.get(owner);
                if (result.status === 'success') {
                  const tier = Number(result.result);
                  const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                  if (tier >= 1 && tier <= maxTier) {
                    holder.tiers[tier - 1]++;
                    holder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                    logger.debug('utils', `Tier ${tier} for token ${tokenId} assigned to wallet ${owner}`, 'eth', contractKey);
                  } else {
                    logger.warn('utils', `Invalid tier ${tier} for token ${tokenId}, wallet ${owner}`, 'eth', contractKey);
                    errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, error: `Invalid tier ${tier}` });
                  }
                } else {
                  logger.warn('utils', `Failed to fetch tier for token ${tokenId}: ${result.error || 'unknown error'}`, 'eth', contractKey);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId, error: result.error || 'unknown error' });
                }
              });

              cacheState.progressState.processedTiers += chunk.length;
              await saveCacheStateContract(contractKey, cacheState);
              logger.debug('utils', `Processed ${cacheState.progressState.processedTiers}/${cacheState.progressState.totalTiers} tiers`, 'eth', contractKey);
            } catch (error) {
              logger.error('utils', `Tier batch ${i / chunkSize + 1} failed: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
              errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier_batch', batch: i / chunkSize + 1, error: error.message });
            }
          })
        );
      }
      await Promise.all(tierPromises);
    } else {
      logger.warn('utils', `No valid token IDs found for tier fetching`, 'eth', contractKey);
    }

    cacheState.progressState.step = 'calculating_metrics';
    await saveCacheStateContract(contractKey, cacheState);

    const holderList = Array.from(holdersMap.values());
    const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
    holderList.forEach(holder => {
      holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
      holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
      logger.debug('utils', `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, displayMultiplierSum=${holder.displayMultiplierSum}`, 'eth', contractKey);
    });

    holderList.sort((a, b) => b.multiplierSum - a.multiplierSum || b.total - a.total);
    holderList.forEach((holder, index) => (holder.rank = index + 1));
    logger.debug('utils', `Sorted holders: count=${holderList.length}, topHolder=${JSON.stringify(holderList[0])}`, 'eth', contractKey);

    cacheState.totalOwners = holderList.length;
    cacheState.totalLiveHolders = holderList.length;
    cacheState.progressState.step = 'completed';
    cacheState.progressState.processedNfts = cacheState.progressState.totalNfts;
    cacheState.progressState.processedTiers = cacheState.progressState.totalTiers;
    cacheState.progressState.error = null;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    logger.info('utils', `Completed holders map with ${holderList.length} holders, totalBurned=${totalBurned}`, 'eth', contractKey);
    return { holdersMap, totalBurned, lastBlock: Number(currentBlock) };
  }
}

// Populate holders map cache
async function populateHoldersMapCache(contractKey, contractAddress, abi, vaultAddress, vaultAbi, forceUpdate = false) {
  let cacheState = await getCacheState(contractKey);
  if (cacheState.isPopulating && !forceUpdate) {
    logger.info('utils', 'Cache population already in progress', 'eth', contractKey);
    return { status: 'in_progress', holders: null };
  }

  cacheState.isPopulating = true;
  cacheState.progressState.step = 'starting';
  cacheState.progressState.error = null;
  cacheState.progressState.errorLog = [];
  await saveCacheStateContract(contractKey, cacheState);

  const errorLog = [];

  try {
    const cachedData = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
    const isCacheValid = cachedData && Array.isArray(cachedData.holders) && Number.isInteger(cachedData.totalBurned) && !forceUpdate;

    if (isCacheValid) {
      const fromBlock = cacheState.lastProcessedBlock || config.deploymentBlocks[contractKey].block;
      const { burnedTokenIds, transferTokenIds, lastBlock } = await getNewEvents(contractKey, contractAddress, fromBlock, errorLog);

      let currentBlock;
      try {
        currentBlock = await client.getBlockNumber();
      } catch (error) {
        errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_block_number', error: error.message });
        throw error;
      }

      if (burnedTokenIds.length > 0 || transferTokenIds.length > 0) {
        const holdersMap = new Map();
        let totalBurned = cachedData.totalBurned || 0;
        logger.debug('utils', `Initial totalBurned from cache: ${totalBurned}`, 'eth', contractKey);

        for (const holder of cachedData.holders) {
          const updatedTokenIds = holder.tokenIds.filter(id => !burnedTokenIds.includes(id));
          if (updatedTokenIds.length > 0) {
            const updatedHolder = {
              ...holder,
              tokenIds: updatedTokenIds,
              total: updatedTokenIds.length,
              tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
              multiplierSum: 0,
              ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
              ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
              ...(contractKey === 'ascendant' ? {
                shares: 0,
                lockedAscendant: 0,
                pendingDay8: 0,
                pendingDay28: 0,
                pendingDay90: 0,
                claimableRewards: 0,
              } : {}),
            };
            const tierCalls = updatedTokenIds.map(tokenId => ({
              address: contractAddress,
              abi,
              functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
              args: [BigInt(tokenId)],
            }));
            const tierResults = await retry(() => batchMulticall(tierCalls, config.alchemy.batchSize), {
              retries: config.alchemy.maxRetries,
              delay: config.alchemy.batchDelayMs,
            });
            tierResults.forEach((result, index) => {
              if (result.status === 'success' && result.result) {
                const tier = contractKey === 'ascendant'
                  ? Number(result.result.tier || 0)
                  : Number(result.result);
                const maxTier = Object.keys(config.contractTiers[contractKey]).length;
                if (tier >= 1 && tier <= maxTier) {
                  updatedHolder.tiers[tier - 1]++;
                  updatedHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                  logger.debug('utils', `Tier ${tier} for token ${updatedTokenIds[index]} assigned to wallet ${holder.wallet}`, 'eth', contractKey);
                } else {
                  logger.warn('utils', `Invalid tier ${tier} for token ${updatedTokenIds[index]}, wallet ${holder.wallet}`, 'eth', contractKey);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId: updatedTokenIds[index], error: `Invalid tier ${tier}` });
                }
              } else {
                logger.warn('utils', `Failed to fetch tier for token ${updatedTokenIds[index]}: ${result.error || 'unknown error'}`, 'eth', contractKey);
                errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_tier', tokenId: updatedTokenIds[index], error: result.error || 'unknown error' });
              }
            });

            if (contractKey === 'ascendant') {
              const recordCalls = updatedTokenIds.map(tokenId => ({
                address: contractAddress,
                abi,
                functionName: 'userRecords',
                args: [BigInt(tokenId)],
              }));
              const recordResults = await retry(() => batchMulticall(recordCalls, config.alchemy.batchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });
              recordResults.forEach((result, index) => {
                if (result.status === 'success' && Array.isArray(result.result)) {
                  updatedHolder.shares += parseFloat(formatUnits(result.result[0] || 0, 18));
                  updatedHolder.lockedAscendant += parseFloat(formatUnits(result.result[1] || 0, 18));
                  logger.debug('utils', `userRecords for token ${updatedTokenIds[index]}: shares=${updatedHolder.shares}, lockedAscendant=${updatedHolder.lockedAscendant}`, 'eth', contractKey);
                } else {
                  logger.error('utils', `Failed to fetch userRecords for token ${updatedTokenIds[index]}: ${result.error || 'unknown error'}`, 'eth', contractKey);
                  errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_records', tokenId: updatedTokenIds[index], error: result.error || 'unknown error' });
                }
              });

              const claimableCall = [{
                address: contractAddress,
                abi,
                functionName: 'batchClaimableAmount',
                args: [updatedTokenIds.map(id => BigInt(id))],
              }];
              const claimableResults = await retry(() => batchMulticall(claimableCall, config.alchemy.batchSize), {
                retries: config.alchemy.maxRetries,
                delay: config.alchemy.batchDelayMs,
              });
              if (claimableResults[0]?.status === 'success') {
                updatedHolder.claimableRewards = parseFloat(formatUnits(claimableResults[0].result || 0, 18));
                logger.debug('utils', `Claimable rewards for wallet ${holder.wallet}: ${updatedHolder.claimableRewards}`, 'eth', contractKey);
              } else {
                logger.error('utils', `Failed to fetch claimableRewards for wallet ${holder.wallet}: ${claimableResults[0]?.error || 'unknown error'}`, 'eth', contractKey);
                errorLog.push({ timestamp: new Date().toISOString(), phase: 'fetch_claimable', wallet: holder.wallet, error: claimableResults[0]?.error || 'unknown error' });
              }

              const totalSharesRaw = await retry(
                async () => {
                  const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalShares' });
                  if (result === null || result === undefined) throw new Error('totalShares returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

              const toDistributeDay8Raw = await retry(
                async () => {
                  const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] });
                  if (result === null || result === undefined) throw new Error('toDistribute day8 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

              const toDistributeDay28Raw = await retry(
                async () => {
                  const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] });
                  if (result === null || result === undefined) throw new Error('toDistribute day28 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

              const toDistributeDay90Raw = await retry(
                async () => {
                  const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] });
                  if (result === null || result === undefined) throw new Error('toDistribute day90 returned null');
                  return result;
                },
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

              const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
              const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
              const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

              updatedHolder.pendingDay8 = updatedHolder.shares * pendingRewardPerShareDay8;
              updatedHolder.pendingDay28 = updatedHolder.shares * pendingRewardPerShareDay28;
              updatedHolder.pendingDay90 = updatedHolder.shares * pendingRewardPerShareDay90;
            }

            holdersMap.set(holder.wallet, updatedHolder);
          } else {
            totalBurned += holder.total;
            logger.debug('utils', `Incremented totalBurned by ${holder.total} for wallet ${holder.wallet}`, 'eth', contractKey);
          }
        }

        for (const transfer of transferTokenIds) {
          const fromHolder = holdersMap.get(transfer.from);
          if (fromHolder) {
            fromHolder.tokenIds = fromHolder.tokenIds.filter(id => id !== transfer.tokenId);
            fromHolder.total = fromHolder.tokenIds.length;
            if (fromHolder.total === 0) {
              holdersMap.delete(transfer.from);
              logger.debug('utils', `Removed empty holder: ${transfer.from}`, 'eth', contractKey);
            } else {
              fromHolder.tiers = Array(Object.keys(config.contractTiers[contractKey]).length).fill(0);
              fromHolder.multiplierSum = 0;
              const tierResult = await retry(
                () => client.readContract({
                  address: contractAddress,
                  abi,
                  functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
                  args: [BigInt(transfer.tokenId)],
                }),
                { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
              );
              const tier = contractKey === 'ascendant'
                ? Number(tierResult.tier || 0)
                : Number(tierResult);
              if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
                fromHolder.tiers[tier - 1]++;
                fromHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
                logger.debug('utils', `Tier ${tier} for token ${transfer.tokenId} updated for wallet ${transfer.from}`, 'eth', contractKey);
              }
              if (contractKey === 'ascendant') {
                fromHolder.shares = 0;
                fromHolder.lockedAscendant = 0;
                fromHolder.pendingDay8 = 0;
                fromHolder.pendingDay28 = 0;
                fromHolder.pendingDay90 = 0;
                fromHolder.claimableRewards = 0;

                const recordResult = await retry(
                  () => client.readContract({
                    address: contractAddress,
                    abi,
                    functionName: 'userRecords',
                    args: [BigInt(transfer.tokenId)],
                  }),
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                if (Array.isArray(recordResult)) {
                  fromHolder.shares += parseFloat(formatUnits(recordResult[0] || 0, 18));
                  fromHolder.lockedAscendant += parseFloat(formatUnits(recordResult[1] || 0, 18));
                  logger.debug('utils', `userRecords for token ${transfer.tokenId}: shares=${fromHolder.shares}, lockedAscendant=${fromHolder.lockedAscendant}`, 'eth', contractKey);
                }

                const claimableCall = [{
                  address: contractAddress,
                  abi,
                  functionName: 'batchClaimableAmount',
                  args: [fromHolder.tokenIds.map(id => BigInt(id))],
                }];
                const claimableResults = await retry(() => batchMulticall(claimableCall, config.alchemy.batchSize), {
                  retries: config.alchemy.maxRetries,
                  delay: config.alchemy.batchDelayMs,
                });
                if (claimableResults[0]?.status === 'success') {
                  fromHolder.claimableRewards = parseFloat(formatUnits(claimableResults[0].result || 0, 18));
                  logger.debug('utils', `Claimable rewards for wallet ${transfer.from}: ${fromHolder.claimableRewards}`, 'eth', contractKey);
                }

                const totalSharesRaw = await retry(
                  async () => {
                    const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalShares' });
                    if (result === null || result === undefined) throw new Error('totalShares returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

                const toDistributeDay8Raw = await retry(
                  async () => {
                    const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] });
                    if (result === null || result === undefined) throw new Error('toDistribute day8 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

                const toDistributeDay28Raw = await retry(
                  async () => {
                    const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] });
                    if (result === null || result === undefined) throw new Error('toDistribute day28 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

                const toDistributeDay90Raw = await retry(
                  async () => {
                    const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] });
                    if (result === null || result === undefined) throw new Error('toDistribute day90 returned null');
                    return result;
                  },
                  { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
                );
                const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

                const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
                const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
                const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

                fromHolder.pendingDay8 = fromHolder.shares * pendingRewardPerShareDay8;
                fromHolder.pendingDay28 = fromHolder.shares * pendingRewardPerShareDay28;
                fromHolder.pendingDay90 = fromHolder.shares * pendingRewardPerShareDay90;
              }
              holdersMap.set(transfer.from, fromHolder);
            }
          }

          const toHolder = holdersMap.get(transfer.to) || {
            wallet: transfer.to,
            tokenIds: [],
            tiers: Array(Object.keys(config.contractTiers[contractKey]).length).fill(0),
            total: 0,
            multiplierSum: 0,
            ...(contractKey === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
            ...(contractKey === 'element280' || contractKey === 'stax' ? { claimableRewards: 0 } : {}),
            ...(contractKey === 'ascendant' ? {
              shares: 0,
              lockedAscendant: 0,
              pendingDay8: 0,
              pendingDay28: 0,
              pendingDay90: 0,
              claimableRewards: 0,
            } : {}),
          };
          toHolder.tokenIds.push(transfer.tokenId);
          toHolder.total = toHolder.tokenIds.length;
          const tierResult = await retry(
            () => client.readContract({
              address: contractAddress,
              abi,
              functionName: contractKey === 'ascendant' ? 'getNFTAttribute' : 'getNftTier',
              args: [BigInt(transfer.tokenId)],
            }),
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          const tier = contractKey === 'ascendant'
            ? Number(tierResult.tier || 0)
            : Number(tierResult);
          if (tier >= 1 && tier <= Object.keys(config.contractTiers[contractKey]).length) {
            toHolder.tiers[tier - 1]++;
            toHolder.multiplierSum += config.contractTiers[contractKey][tier]?.multiplier || 0;
            logger.debug('utils', `Tier ${tier} for token ${transfer.tokenId} assigned to wallet ${transfer.to}`, 'eth', contractKey);
          }
          if (contractKey === 'ascendant') {
            const recordResult = await retry(
              () => client.readContract({
                address: contractAddress,
                abi,
                functionName: 'userRecords',
                args: [BigInt(transfer.tokenId)],
              }),
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            if (Array.isArray(recordResult)) {
              toHolder.shares += parseFloat(formatUnits(recordResult[0] || 0, 18));
              toHolder.lockedAscendant += parseFloat(formatUnits(recordResult[1] || 0, 18));
              logger.debug('utils', `userRecords for token ${transfer.tokenId}: shares=${toHolder.shares}, lockedAscendant=${toHolder.lockedAscendant}`, 'eth', contractKey);
            }

            const claimableCall = [{
              address: contractAddress,
              abi,
              functionName: 'batchClaimableAmount',
              args: [toHolder.tokenIds.map(id => BigInt(id))],
            }];
            const claimableResults = await retry(() => batchMulticall(claimableCall, config.alchemy.batchSize), {
              retries: config.alchemy.maxRetries,
              delay: config.alchemy.batchDelayMs,
            });
            if (claimableResults[0]?.status === 'success') {
              toHolder.claimableRewards = parseFloat(formatUnits(claimableResults[0].result || 0, 18));
              logger.debug('utils', `Claimable rewards for wallet ${transfer.to}: ${toHolder.claimableRewards}`, 'eth', contractKey);
            }

            const totalSharesRaw = await retry(
              async () => {
                const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalShares' });
                if (result === null || result === undefined) throw new Error('totalShares returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const totalShares = parseFloat(formatUnits(totalSharesRaw, 18));

            const toDistributeDay8Raw = await retry(
              async () => {
                const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [0] });
                if (result === null || result === undefined) throw new Error('toDistribute day8 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay8 = parseFloat(formatUnits(toDistributeDay8Raw, 18));

            const toDistributeDay28Raw = await retry(
              async () => {
                const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [1] });
                if (result === null || result === undefined) throw new Error('toDistribute day28 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay28 = parseFloat(formatUnits(toDistributeDay28Raw, 18));

            const toDistributeDay90Raw = await retry(
              async () => {
                const result = await client.readContract({ address: contractAddress, abi, functionName: 'toDistribute', args: [2] });
                if (result === null || result === undefined) throw new Error('toDistribute day90 returned null');
                return result;
              },
              { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
            );
            const toDistributeDay90 = parseFloat(formatUnits(toDistributeDay90Raw, 18));

            const pendingRewardPerShareDay8 = totalShares > 0 ? toDistributeDay8 / totalShares : 0;
            const pendingRewardPerShareDay28 = totalShares > 0 ? toDistributeDay28 / totalShares : 0;
            const pendingRewardPerShareDay90 = totalShares > 0 ? toDistributeDay90 / totalShares : 0;

            toHolder.pendingDay8 = toHolder.shares * pendingRewardPerShareDay8;
            toHolder.pendingDay28 = toHolder.shares * pendingRewardPerShareDay28;
            toHolder.pendingDay90 = toHolder.shares * pendingRewardPerShareDay90;
          }
          holdersMap.set(transfer.to, toHolder);
        }

        const holderList = Array.from(holdersMap.values());
        const totalMultiplierSum = holderList.reduce((sum, h) => sum + h.multiplierSum, 0);
        holderList.forEach(holder => {
          holder.percentage = totalMultiplierSum > 0 ? (holder.multiplierSum / totalMultiplierSum) * 100 : 0;
          holder.displayMultiplierSum = holder.multiplierSum / (contractKey === 'element280' ? 10 : 1);
          logger.debug('utils', `Calculated metrics for wallet ${holder.wallet}: percentage=${holder.percentage}, displayMultiplierSum=${holder.displayMultiplierSum}`, 'eth', contractKey);
        });

        holderList.sort((a, b) => contractKey === 'ascendant' ? b.shares - a.shares || b.multiplierSum - a.multiplierSum || b.total - a.total : b.multiplierSum - a.multiplierSum || b.total - a.total);
        holderList.forEach((holder, index) => (holder.rank = index + 1));

        let burnedCountContract;
        try {
          burnedCountContract = await retry(
            async () => {
              const result = await client.readContract({ address: contractAddress, abi, functionName: 'totalBurned' });
              return Number(result);
            },
            { retries: config.alchemy.maxRetries, delay: config.alchemy.batchDelayMs }
          );
          logger.debug('utils', `Fetched burnedCountContract: ${burnedCountContract}`, 'eth', contractKey);
        } catch (error) {
          logger.error('utils', `Failed to fetch totalBurned: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
          burnedCountContract = 0;
        }
        totalBurned = burnedCountContract || totalBurned;
        logger.debug('utils', `Final totalBurned: ${totalBurned}`, 'eth', contractKey);

        const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
        await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
        cacheState.lastUpdated = Date.now();
        cacheState.totalOwners = holderList.length;
        cacheState.totalLiveHolders = holderList.length;
        cacheState.lastProcessedBlock = lastBlock;
        cacheState.progressState = {
          step: 'completed',
          processedNfts: cacheState.progressState.totalNfts,
          totalNfts: cacheState.progressState.totalNfts,
          processedTiers: cacheState.progressState.totalTiers,
          totalTiers: cacheState.progressState.totalTiers,
          error: null,
          errorLog,
        };
        if (contractKey === 'ascendant') {
          cacheState.globalMetrics = {
            totalTokens: holderList.reduce((sum, h) => sum + h.total, 0),
            totalLockedAscendant: holderList.reduce((sum, h) => sum + h.lockedAscendant, 0),
            totalShares,
            toDistributeDay8,
            toDistributeDay28,
            toDistributeDay90,
            pendingRewards: toDistributeDay8 + toDistributeDay28 + toDistributeDay90,
          };
        }
        await saveCacheStateContract(contractKey, cacheState);
        logger.info('utils', `Cache updated: ${holderList.length} holders, totalBurned: ${totalBurned}`, 'eth', contractKey);
        return { status: 'updated', holders: holderList };
      } else {
        cacheState.isPopulating = false;
        cacheState.progressState.step = 'completed';
        cacheState.lastProcessedBlock = Number(currentBlock);
        await saveCacheStateContract(contractKey, cacheState);
        logger.info('utils', 'Cache is up to date', 'eth', contractKey);
        return { status: 'up_to_date', holders: cachedData.holders };
      }
    }

    const result = await getHoldersMap(contractKey, contractAddress, abi, vaultAddress, vaultAbi, cacheState);
    const holderList = Array.from(result.holdersMap.values());
    const totalBurned = result.totalBurned || 0;
    logger.debug('utils', `getHoldersMap returned totalBurned: ${totalBurned}`, 'eth', contractKey);
    const cacheData = { holders: holderList, totalBurned, timestamp: Date.now() };
    await setCache(`${contractKey.toLowerCase()}_holders`, cacheData, 0, contractKey.toLowerCase());
    cacheState.lastUpdated = Date.now();
    cacheState.totalOwners = holderList.length;
    cacheState.totalLiveHolders = holderList.length;
    cacheState.lastProcessedBlock = result.lastBlock;
    cacheState.progressState = {
      step: 'completed',
      processedNfts: cacheState.progressState.totalNfts,
      totalNfts: cacheState.progressState.totalNfts,
      processedTiers: cacheState.progressState.totalTiers,
      totalTiers: cacheState.progressState.totalTiers,
      error: null,
      errorLog,
    };
    if (contractKey === 'ascendant') {
      cacheState.globalMetrics = result.globalMetrics || {};
    }
    await saveCacheStateContract(contractKey, cacheState);
    logger.info('utils', `Cache populated: ${holderList.length} holders, totalBurned: ${totalBurned}`, 'eth', contractKey);
    return { status: 'completed', holders: holderList };
  } catch (error) {
    cacheState.progressState.step = 'error';
    cacheState.progressState.error = error.message;
    cacheState.progressState.errorLog = errorLog;
    await saveCacheStateContract(contractKey, cacheState);
    logger.error('utils', `Cache population failed: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    return { status: 'error', holders: null, error: error.message };
  } finally {
    cacheState.isPopulating = false;
    await saveCacheStateContract(contractKey, cacheState);
  }
}

// GET handler
export async function GET(request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();
  if (!config.contractDetails[contractKey]) {
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  let contractAddress, abi;
  try {
    ({ contractAddress, abi } = await validateContract(contractKey));
  } catch (error) {
    logger.error(contractKey, `Validation error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to validate ${contractKey}`, details: error.message }, { status: 400 });
  }

  try {
    const cacheState = await getCacheState(contractKey);
    if (cacheState.isPopulating) {
      return NextResponse.json({
        message: 'Cache is populating',
        isCachePopulating: true,
        totalOwners: cacheState.totalOwners,
        totalLiveHolders: cacheState.totalLiveHolders,
        progressState: cacheState.progressState,
        lastProcessedBlock: cacheState.lastProcessedBlock,
        globalMetrics: cacheState.globalMetrics,
        debugId: `state-${Math.random().toString(36).slice(2)}`,
      }, { status: 202 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '0', 10);
    const pageSize = parseInt(searchParams.get('pageSize') || config.contractDetails[contractKey].pageSize, 10);

    const cachedData = await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase());
    if (cachedData) {
      const holders = cachedData.holders.slice(page * pageSize, (page + 1) * pageSize);
      const totalPages = Math.ceil(cachedData.holders.length / pageSize);
      const response = {
        holders: sanitizeBigInt(holders),
        totalPages,
        totalTokens: cachedData.holders.reduce((sum, h) => sum + h.total, 0),
        totalBurned: cachedData.totalBurned,
        summary: {
          totalLive: cachedData.holders.reduce((sum, h) => sum + h.total, 0),
          totalBurned: cachedData.totalBurned,
          totalMinted: config.nftContracts[contractKey].expectedTotalSupply + config.nftContracts[contractKey].expectedBurned,
          tierDistribution: cachedData.holders.reduce((acc, h) => {
            h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
            return acc;
          }, []),
          multiplierPool: cachedData.holders.reduce((sum, h) => sum + h.multiplierSum, 0),
        },
        globalMetrics: cacheState.globalMetrics,
      };
      return NextResponse.json(response);
    }

    const { status, holders } = await populateHoldersMapCache(contractKey, contractAddress, abi, null, null);
    if (status === 'error') throw new Error('Cache population failed');

    const paginatedHolders = holders.slice(page * pageSize, (page + 1) * pageSize);
    const totalPages = Math.ceil(holders.length / pageSize);
    const response = {
      holders: sanitizeBigInt(paginatedHolders),
      totalPages,
      totalTokens: holders.reduce((sum, h) => sum + h.total, 0),
      totalBurned: (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalBurned || 0,
      summary: {
        totalLive: holders.reduce((sum, h) => sum + h.total, 0),
        totalBurned: (await getCache(`${contractKey.toLowerCase()}_holders`, contractKey.toLowerCase()))?.totalBurned || 0,
        totalMinted: config.nftContracts[contractKey].expectedTotalSupply + config.nftContracts[contractKey].expectedBurned,
        tierDistribution: holders.reduce((acc, h) => {
          h.tiers.forEach((count, i) => acc[i] = (acc[i] || 0) + count);
          return acc;
        }, []),
        multiplierPool: holders.reduce((sum, h) => sum + h.multiplierSum, 0),
      },
      globalMetrics: cacheState.globalMetrics,
    };
    return NextResponse.json(response);
  } catch (error) {
    logger.error('utils', `GET error: ${error.message}`, { stack: error.stack }, 'eth', contractKey);
    return NextResponse.json({ error: `Failed to fetch ${contractKey} holders`, details: error.message }, { status: 500 });
  }
}

// POST handler
export async function POST(request, { params }) {
  const { contract } = await params;
  const contractKey = contract.toLowerCase();
  if (!config.contractDetails[contractKey]) {
    return NextResponse.json({ error: `Invalid contract: ${contractKey}` }, { status: 400 });
  }

  if (config.contractDetails[contractKey].disabled) {
    return NextResponse.json({ error: `${contractKey} contract not deployed` }, { status: 400 });
  }

  let contractAddress, abi;
  try {
    ({ contractAddress, abi } = await validateContract(contractKey));
  } catch (error) {
    logger.error(contractKey, `Validation error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to validate ${contractKey}`, details: error.message }, { status: 400 });
  }

  try {
    const { forceUpdate } = await request.json().catch(() => ({}));
    const cacheState = await getCacheState(contractKey);
    if (cacheState.isPopulating && !forceUpdate) {
      return NextResponse.json({ message: 'Cache population already in progress', status: 'in_progress' }, { status: 202 });
    }
    const { status, error } = await populateHoldersMapCache(contractKey, contractAddress, abi, null, null, forceUpdate === true);
    if (status === 'error') throw new Error(error || 'Cache population failed');
    return NextResponse.json({ 
      message: status === 'up_to_date' ? 'Cache is up to date' : `${contractKey} cache population triggered`, 
      status 
    });
  } catch (error) {
    logger.error(contractKey, `POST error: ${error.message}`, { stack: error.stack });
    return NextResponse.json({ error: `Failed to populate ${contractKey} cache`, details: error.message }, { status: 500 });
  }
}
----- app/api/utils.dev-repo.js -----

// File: app/api/utils.js
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { Redis } from '@upstash/redis';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy } from 'alchemy-sdk';
import config from '@/contracts/config';
import pLimit from 'p-limit';
import { logger } from '@/app/lib/logger';
import chalk from 'chalk';

console.log(chalk.cyan('[Utils] Initializing utils...'));
logger.info('utils', 'Utils module loaded', 'eth', 'general').catch(error => {
  console.error(chalk.red('[Utils] Logger error:'), error.message);
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const isDebug = process.env.DEBUG === 'true';
const isProduction = process.env.NODE_ENV === 'production';

const cache = new NodeCache({
  stdTTL: 0,
  checkperiod: 120,
});

const cacheDir = path.join(process.cwd(), 'cache');

const redisEnabled = Object.keys(config.nftContracts).some(
  contract => process.env[`DISABLE_${contract.toUpperCase()}_REDIS`] !== 'true' && process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN
);
let redis = null;

if (redisEnabled) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });
    logger.info('utils', 'Upstash Redis initialized', 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to initialize Upstash Redis: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    redis = null;
  }
}

const alchemyApiKey = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  logger.error('utils', 'Alchemy API key is missing', {}, 'eth', 'general');
  throw new Error('Alchemy API key is missing');
}

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`),
});

const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: 'eth-mainnet',
});

async function ensureCacheDir() {
  try {
    await fs.mkdir(cacheDir, { recursive: true });
    await fs.chmod(cacheDir, 0o755);
    logger.info('utils', `Created/chmod cache directory: ${cacheDir}`, 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to create/chmod cache directory ${cacheDir}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function initializeCache() {
  try {
    logger.info('utils', 'Starting cache initialization', 'eth', 'general');
    await ensureCacheDir();

    // Check node-cache
    const testKey = 'test_node_cache';
    const testValue = { ready: true };
    const nodeCacheSuccess = cache.set(testKey, testValue);
    if (nodeCacheSuccess) {
      logger.info('utils', 'Node-cache is ready', 'eth', 'general');
      cache.del(testKey);
    } else {
      logger.error('utils', 'Node-cache failed to set test key', {}, 'eth', 'general');
    }

    // Check Redis
    if (redisEnabled && redis) {
      try {
        await redis.set('test_redis', JSON.stringify(testValue));
        const redisData = await redis.get('test_redis');
        if (redisData && JSON.parse(redisData).ready) {
          logger.info('utils', 'Redis cache is ready', 'eth', 'general');
          await redis.del('test_redis');
        } else {
          logger.error('utils', 'Redis cache test failed: invalid data', {}, 'eth', 'general');
        }
      } catch (error) {
        logger.error('utils', `Redis cache test failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      }
    }

    // Create empty cache files for each collection
    const collections = Object.keys(config.nftContracts).filter(key => !config.nftContracts[key].disabled).map(key => key.toLowerCase());
    for (const collection of collections) {
      const cacheFile = path.join(cacheDir, `${collection}_holders.json`);
      try {
        await fs.access(cacheFile);
        logger.info('utils', `Cache file exists: ${cacheFile}`, 'eth', collection);
      } catch (error) {
        if (error.code === 'ENOENT') {
          await fs.writeFile(cacheFile, JSON.stringify({ holders: [], totalBurned: 0, timestamp: Date.now() }));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Created empty cache file: ${cacheFile}`, 'eth', collection);
        } else {
          logger.error('utils', `Failed to access cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', collection);
        }
      }
    }

    logger.info('utils', 'Cache initialization completed', 'eth', 'general');
    return true;
  } catch (error) {
    logger.error('utils', `Cache initialization error: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return false;
  }
}

async function retry(operation, { retries, delay = 1000 }) {
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.message.includes('429') && attempt === retries) {
        logger.error('utils', `Circuit breaker: Rate limit exceeded after ${retries} attempts`, {}, 'eth', 'general');
        throw new Error('Rate limit exceeded');
      }
      logger.warn('utils', `Retry attempt ${attempt}/${retries} failed: ${error.message}`, 'eth', 'general');
      await new Promise(resolve => setTimeout(resolve, delay * Math.min(attempt, 3)));
    }
  }
  throw lastError;
}

async function batchMulticall(calls, batchSize = config.alchemy.batchSize || 10) {
  const results = [];
  const delay = async () => new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs || 500));

  const concurrencyLimit = pLimit(3);
  const batchPromises = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    batchPromises.push(
      concurrencyLimit(async () => {
        try {
          await delay();
          const batchResults = await client.multicall({
            contracts: batch.map(call => ({
              address: call.address,
              abi: call.abi,
              functionName: call.functionName,
              args: call.args || [],
            })),
            allowFailure: true,
          });

          const batchResult = batchResults.map((result, index) => ({
            status: result.status === 'success' ? 'success' : 'failure',
            result: result.status === 'success' ? result.result : null,
            error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
          }));
          return batchResult;
        } catch (error) {
          logger.error('utils', `Batch multicall failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
          return batch.map(() => ({
            status: 'failure',
            result: null,
            error: error.message,
          }));
        }
      })
    );
  }

  const batchResults = (await Promise.all(batchPromises)).flat();
  results.push(...batchResults);
  return results;
}

async function getOwnersForContract(contractAddress, abi, options = {}) {
  let owners = [];
  let pageKey = options.pageKey || null;
  const maxPages = options.maxPages || 10; // Safety limit to prevent infinite loops
  let pageCount = 0;

  logger.debug('utils', `Fetching owners for contract: ${contractAddress} with options: ${JSON.stringify(options)}`, 'eth', 'general');

  do {
    try {
      const response = await alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: options.withTokenBalances || false,
        pageKey,
      });

      logger.debug('utils', `Raw Alchemy response: ownersExists=${!!response.owners}, isArray=${Array.isArray(response.owners)}, ownersLength=${response.owners?.length || 0}, pageKey=${response.pageKey || null}, responseKeys=${Object.keys(response)}, sampleOwners=${JSON.stringify(response.owners?.slice(0, 2) || [])}`, 'eth', 'general');

      if (!response.owners || !Array.isArray(response.owners)) {
        logger.error('utils', `Invalid Alchemy response for ${contractAddress}: ${JSON.stringify(response)}`, {}, 'eth', 'general');
        throw new Error('Invalid owners response from Alchemy API');
      }

      for (const owner of response.owners) {
        const tokenBalances = owner.tokenBalances || [];
        logger.debug('utils', `Processing owner: ${owner.ownerAddress}, tokenBalancesCount=${tokenBalances.length}`, 'eth', 'general');

        if (tokenBalances.length > 0) {
          const validBalances = tokenBalances.filter(
            tb => tb.tokenId && Number(tb.balance) > 0
          );
          if (validBalances.length > 0) {
            owners.push({
              ownerAddress: owner.ownerAddress.toLowerCase(),
              tokenBalances: validBalances.map(tb => ({
                tokenId: Number(tb.tokenId),
                balance: Number(tb.balance),
              })),
            });
          }
        }
      }

      pageKey = response.pageKey || null;
      pageCount++;
      logger.debug('utils', `Fetched page ${pageCount}, owners: ${owners.length}, pageKey: ${pageKey}`, 'eth', 'general');

      if (pageCount >= maxPages) {
        logger.warn('utils', `Reached max pages (${maxPages}) for owner fetching`, 'eth', 'general');
        break;
      }
    } catch (error) {
      logger.error('utils', `Failed to fetch owners for ${contractAddress}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      throw error;
    }
  } while (pageKey);

  logger.debug('utils', `Processed owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, 'eth', 'general');
  logger.info('utils', `Fetched ${owners.length} owners for contract: ${contractAddress}`, 'eth', 'general');
  return owners;
}

async function setCache(key, value, ttl, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    const success = cache.set(cacheKey, value);
    logger.info('utils', `Set in-memory cache: ${cacheKey}, success: ${success}, holders: ${value.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          await redis.set(cacheKey, JSON.stringify(value));
          logger.info('utils', `Persisted ${cacheKey} to Redis, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to persist ${cacheKey} to Redis: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      } else {
        const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
        logger.info('utils', `Writing to cache file: ${cacheFile}`, 'eth', prefix.toLowerCase());
        await ensureCacheDir();
        try {
          await fs.writeFile(cacheFile, JSON.stringify(value));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Persisted ${cacheKey} to ${cacheFile}, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to write cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
          throw error;
        }
      }
    }
    return success;
  } catch (error) {
    logger.error('utils', `Failed to set cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return false;
  }
}

async function getCache(key, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    let data = cache.get(cacheKey);
    if (data !== undefined) {
      logger.debug('utils', `Cache hit: ${cacheKey}, holders: ${data.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());
      return data;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          const redisData = await redis.get(cacheKey);
          if (redisData) {
            const parsed = typeof redisData === 'string' ? JSON.parse(redisData) : redisData;
            if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
              const success = cache.set(cacheKey, parsed);
              logger.info('utils', `Loaded ${cacheKey} from Redis, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
              return parsed;
            } else {
              logger.warn('utils', `Invalid data in Redis for ${cacheKey}`, 'eth', prefix.toLowerCase());
            }
          }
        } catch (error) {
          logger.error('utils', `Failed to load cache from Redis for ${cacheKey}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      }

      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        const parsed = JSON.parse(fileData);
        if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
          const success = cache.set(cacheKey, parsed);
          logger.info('utils', `Loaded ${cacheKey} from ${cacheFile}, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
          return parsed;
        } else {
          logger.warn('utils', `Invalid data in ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      } catch (error) {
        if (error.code !== 'ENOENT') {
          logger.error('utils', `Failed to load cache from ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        } else {
          logger.debug('utils', `No cache file at ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      }
    }

    logger.info('utils', `Cache miss: ${cacheKey}`, 'eth', prefix.toLowerCase());
    return null;
  } catch (error) {
    logger.error('utils', `Failed to get cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function saveCacheState(collection, state, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    await ensureCacheDir();
    await fs.writeFile(cacheFile, JSON.stringify(state));
    await fs.chmod(cacheFile, 0o644);
    logger.debug('utils', `Saved cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
  } catch (error) {
    logger.error('utils', `Failed to save cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
  }
}

async function loadCacheState(collection, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    const data = await fs.readFile(cacheFile, 'utf8');
    const parsed = JSON.parse(data);
    logger.debug('utils', `Loaded cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
    return parsed;
  } catch (error) {
    if (error.code === 'ENOENT') {
      logger.debug('utils', `No cache state found for ${prefix}`, 'eth', prefix.toLowerCase());
      return null;
    }
    logger.error('utils', `Failed to load cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function getTransactionReceipt(transactionHash) {
  try {
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    logger.debug('utils', `Fetched transaction receipt for ${transactionHash}`, 'eth', 'general');
    return receipt;
  } catch (error) {
    logger.error('utils', `Failed to fetch transaction receipt for ${transactionHash}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return null;
  }
}

async function log(scope, message, chain = 'eth', collection = 'general') {
  await logger.info(scope, message, chain, collection);
}

export { client, retry, logger, getCache, setCache, saveCacheState, loadCacheState, batchMulticall, getOwnersForContract, getTransactionReceipt, log, initializeCache };
----- app/api/utils.js -----

import NodeCache from 'node-cache';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { Redis } from '@upstash/redis';
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';
import { Alchemy } from 'alchemy-sdk';
import config from '@/contracts/config';
import pLimit from 'p-limit';
import { logger } from '@/app/lib/logger';
import chalk from 'chalk';

console.log(chalk.cyan('[Utils] Initializing utils...'));
logger.info('utils', 'Utils module loaded', 'eth', 'general').catch(error => {
  console.error(chalk.red('[Utils] Logger error:'), error.message);
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const isDebug = process.env.DEBUG === 'true';
const isProduction = process.env.NODE_ENV === 'production';

const cache = new NodeCache({
  stdTTL: 0,
  checkperiod: 120,
});

const cacheDir = path.join(process.cwd(), 'cache');

const redisEnabled = Object.keys(config.nftContracts).some(
  contract => process.env[`DISABLE_${contract.toUpperCase()}_REDIS`] !== 'true' && process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN
);
let redis = null;

if (redisEnabled) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });
    logger.info('utils', 'Upstash Redis initialized', 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to initialize Upstash Redis: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    redis = null;
  }
}

const alchemyApiKey = config.alchemy.apiKey || process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
if (!alchemyApiKey) {
  logger.error('utils', 'Alchemy API key is missing', {}, 'eth', 'general');
  throw new Error('Alchemy API key is missing');
}

const client = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${alchemyApiKey}`),
});

const alchemy = new Alchemy({
  apiKey: config.alchemy.apiKey,
  network: 'eth-mainnet',
});

async function ensureCacheDir() {
  try {
    await fs.mkdir(cacheDir, { recursive: true });
    await fs.chmod(cacheDir, 0o755);
    logger.info('utils', `Created/chmod cache directory: ${cacheDir}`, 'eth', 'general');
  } catch (error) {
    logger.error('utils', `Failed to create/chmod cache directory ${cacheDir}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function initializeCache() {
  try {
    logger.info('utils', 'Starting cache initialization', 'eth', 'general');
    await ensureCacheDir();

    const testKey = 'test_node_cache';
    const testValue = { ready: true };
    const nodeCacheSuccess = cache.set(testKey, testValue);
    if (nodeCacheSuccess) {
      logger.info('utils', 'Node-cache is ready', 'eth', 'general');
      cache.del(testKey);
    } else {
      logger.error('utils', 'Node-cache failed to set test key', {}, 'eth', 'general');
    }

    if (redisEnabled && redis) {
      try {
        await redis.set('test_redis', JSON.stringify(testValue));
        const redisData = await redis.get('test_redis');
        if (redisData && JSON.parse(redisData).ready) {
          logger.info('utils', 'Redis cache is ready', 'eth', 'general');
          await redis.del('test_redis');
        } else {
          logger.error('utils', 'Redis cache test failed: invalid data', {}, 'eth', 'general');
        }
      } catch (error) {
        logger.error('utils', `Redis cache test failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      }
    }

    const collections = Object.keys(config.nftContracts).filter(key => !config.nftContracts[key].disabled).map(key => key.toLowerCase());
    for (const collection of collections) {
      const cacheFile = path.join(cacheDir, `${collection}_holders.json`);
      try {
        await fs.access(cacheFile);
        logger.info('utils', `Cache file exists: ${cacheFile}`, 'eth', collection);
      } catch (error) {
        if (error.code === 'ENOENT') {
          await fs.writeFile(cacheFile, JSON.stringify({ holders: [], totalBurned: 0, timestamp: Date.now() }));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Created empty cache file: ${cacheFile}`, 'eth', collection);
        } else {
          logger.error('utils', `Failed to access cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', collection);
        }
      }
    }

    logger.info('utils', 'Cache initialization completed', 'eth', 'general');
    return true;
  } catch (error) {
    logger.error('utils', `Cache initialization error: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    return false;
  }
}

async function retry(operation, { retries, delay = 1000 }) {
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (error.message.includes('429') && attempt === retries) {
        logger.error('utils', `Circuit breaker: Rate limit exceeded after ${retries} attempts`, {}, 'eth', 'general');
        throw new Error('Rate limit exceeded');
      }
      logger.warn('utils', `Retry attempt ${attempt}/${retries} failed: ${error.message}`, 'eth', 'general');
      await new Promise(resolve => setTimeout(resolve, delay * Math.min(attempt, 3)));
    }
  }
  throw lastError;
}

async function batchMulticall(calls, batchSize = config.alchemy.batchSize || 10) {
  const results = [];
  const delay = async () => new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs || 500));

  const concurrencyLimit = pLimit(3);
  const batchPromises = [];
  for (let i = 0; i < calls.length; i += batchSize) {
    const batch = calls.slice(i, i + batchSize);
    batchPromises.push(
      concurrencyLimit(async () => {
        try {
          await delay();
          const batchResults = await client.multicall({
            contracts: batch.map(call => ({
              address: call.address,
              abi: call.abi,
              functionName: call.functionName,
              args: call.args || [],
            })),
            allowFailure: true,
          });

          const batchResult = batchResults.map((result, index) => ({
            status: result.status === 'success' ? 'success' : 'failure',
            result: result.status === 'success' ? result.result : null,
            error: result.status === 'failure' ? result.error?.message || 'Unknown error' : null,
          }));
          return batchResult;
        } catch (error) {
          logger.error('utils', `Batch multicall failed: ${error.message}`, { stack: error.stack }, 'eth', 'general');
          return batch.map(() => ({
            status: 'failure',
            result: null,
            error: error.message,
          }));
        }
      })
    );
  }

  const batchResults = (await Promise.all(batchPromises)).flat();
  results.push(...batchResults);
  return results;
}

async function getOwnersForContract(contractAddress, abi, options = {}) {
  let owners = [];
  let pageKey = options.pageKey || null;
  const maxPages = options.maxPages || 10;
  let pageCount = 0;

  logger.debug('utils', `Fetching owners for contract: ${contractAddress} with options: ${JSON.stringify(options)}`, 'eth', 'general');

  do {
    try {
      const response = await alchemy.nft.getOwnersForContract(contractAddress, {
        withTokenBalances: options.withTokenBalances || false,
        pageKey,
      });

      logger.debug('utils', `Raw Alchemy response: ownersExists=${!!response.owners}, isArray=${Array.isArray(response.owners)}, ownersLength=${response.owners?.length || 0}, pageKey=${response.pageKey || null}, responseKeys=${Object.keys(response)}, sampleOwners=${JSON.stringify(response.owners?.slice(0, 2) || [])}`, 'eth', 'general');

      if (!response.owners || !Array.isArray(response.owners)) {
        logger.error('utils', `Invalid Alchemy response for ${contractAddress}: ${JSON.stringify(response)}`, {}, 'eth', 'general');
        throw new Error('Invalid owners response from Alchemy API');
      }

      for (const owner of response.owners) {
        const tokenBalances = owner.tokenBalances || [];
        logger.debug('utils', `Processing owner: ${owner.ownerAddress}, tokenBalancesCount=${tokenBalances.length}`, 'eth', 'general');

        if (tokenBalances.length > 0) {
          const validBalances = tokenBalances.filter(
            tb => tb.tokenId && Number(tb.balance) > 0
          );
          if (validBalances.length > 0) {
            owners.push({
              ownerAddress: owner.ownerAddress.toLowerCase(),
              tokenBalances: validBalances.map(tb => ({
                tokenId: Number(tb.tokenId),
                balance: Number(tb.balance),
              })),
            });
          }
        }
      }

      pageKey = response.pageKey || null;
      pageCount++;
      logger.debug('utils', `Fetched page ${pageCount}, owners: ${owners.length}, pageKey: ${pageKey}`, 'eth', 'general');

      if (pageCount >= maxPages) {
        logger.warn('utils', `Reached max pages (${maxPages}) for owner fetching`, 'eth', 'general');
        break;
      }
    } catch (error) {
      logger.error('utils', `Failed to fetch owners for ${contractAddress}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
      throw error;
    }
  } while (pageKey);

  logger.debug('utils', `Processed owners: count=${owners.length}, sample=${JSON.stringify(owners.slice(0, 2))}`, 'eth', 'general');
  logger.info('utils', `Fetched ${owners.length} owners for contract: ${contractAddress}`, 'eth', 'general');
  return owners;
}

async function setCache(key, value, ttl, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    const success = cache.set(cacheKey, value);
    logger.info('utils', `Set in-memory cache: ${cacheKey}, success: ${success}, holders: ${value.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          await redis.set(cacheKey, JSON.stringify(value));
          logger.info('utils', `Persisted ${cacheKey} to Redis, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to persist ${cacheKey} to Redis: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      } else {
        const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
        logger.info('utils', `Writing to cache file: ${cacheFile}`, 'eth', prefix.toLowerCase());
        await ensureCacheDir();
        try {
          await fs.writeFile(cacheFile, JSON.stringify(value));
          await fs.chmod(cacheFile, 0o644);
          logger.info('utils', `Persisted ${cacheKey} to ${cacheFile}, holders: ${value.holders.length}`, 'eth', prefix.toLowerCase());
        } catch (error) {
          logger.error('utils', `Failed to write cache file ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
          throw error;
        }
      }
    }
    return success;
  } catch (error) {
    logger.error('utils', `Failed to set cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return false;
  }
}

async function getCache(key, prefix) {
  try {
    const cacheKey = `${prefix}_${key}`;
    let data = cache.get(cacheKey);
    if (data !== undefined) {
      logger.debug('utils', `Cache hit: ${cacheKey}, holders: ${data.holders?.length || 'unknown'}`, 'eth', prefix.toLowerCase());
      return data;
    }

    if (key === `${prefix.toLowerCase()}_holders` && Object.keys(config.nftContracts).map(k => k.toLowerCase()).includes(prefix.toLowerCase())) {
      if (redisEnabled && redis && process.env[`DISABLE_${prefix.toUpperCase()}_REDIS`] !== 'true') {
        try {
          const redisData = await redis.get(cacheKey);
          if (redisData) {
            const parsed = typeof redisData === 'string' ? JSON.parse(redisData) : redisData;
            if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
              const success = cache.set(cacheKey, parsed);
              logger.info('utils', `Loaded ${cacheKey} from Redis, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
              return parsed;
            } else {
              logger.warn('utils', `Invalid data in Redis for ${cacheKey}`, 'eth', prefix.toLowerCase());
            }
          }
        } catch (error) {
          logger.error('utils', `Failed to load cache from Redis for ${cacheKey}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        }
      }

      const cacheFile = path.join(cacheDir, `${prefix.toLowerCase()}_holders.json`);
      try {
        const fileData = await fs.readFile(cacheFile, 'utf8');
        const parsed = JSON.parse(fileData);
        if (parsed && Array.isArray(parsed.holders) && Number.isInteger(parsed.totalBurned)) {
          const success = cache.set(cacheKey, parsed);
          logger.info('utils', `Loaded ${cacheKey} from ${cacheFile}, cached: ${success}, holders: ${parsed.holders.length}`, 'eth', prefix.toLowerCase());
          return parsed;
        } else {
          logger.warn('utils', `Invalid data in ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      } catch (error) {
        if (error.code !== 'ENOENT') {
          logger.error('utils', `Failed to load cache from ${cacheFile}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
        } else {
          logger.debug('utils', `No cache file at ${cacheFile}`, 'eth', prefix.toLowerCase());
        }
      }
    }

    logger.info('utils', `Cache miss: ${cacheKey}`, 'eth', prefix.toLowerCase());
    return null;
  } catch (error) {
    logger.error('utils', `Failed to get cache ${prefix}_${key}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function saveCacheState(collection, state, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    await ensureCacheDir();
    await fs.writeFile(cacheFile, JSON.stringify(state, null, 2));
    await fs.chmod(cacheFile, 0o644);
    logger.debug('utils', `Saved cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
  } catch (error) {
    logger.error('utils', `Failed to save cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
  }
}

async function loadCacheState(collection, prefix) {
  try {
    const cacheFile = path.join(cacheDir, `cache_state_${prefix.toLowerCase()}.json`);
    const data = await fs.readFile(cacheFile, 'utf8');
    const parsed = JSON.parse(data);
    logger.debug('utils', `Loaded cache state for ${prefix}: ${cacheFile}`, 'eth', prefix.toLowerCase());
    return parsed;
  } catch (error) {
    if (error.code === 'ENOENT') {
      logger.debug('utils', `No cache state found for ${prefix}, initializing new state`, 'eth', prefix.toLowerCase());
      const defaultState = {
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: {
          step: 'idle',
          processedNfts: 0,
          totalNfts: 0,
          processedTiers: 0,
          totalTiers: 0,
          error: null,
          errorLog: [],
        },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      };
      await saveCacheState(collection, defaultState, prefix);
      return defaultState;
    }
    logger.error('utils', `Failed to load cache state for ${prefix}: ${error.message}`, { stack: error.stack }, 'eth', prefix.toLowerCase());
    return null;
  }
}

async function getTransactionReceipt(transactionHash) {
  try {
    const receipt = await client.getTransactionReceipt({ hash: transactionHash });
    logger.debug('utils', `Fetched transaction receipt for ${transactionHash}`, 'eth', 'general');
    return receipt;
  } catch (error) {
    logger.error('utils', `Failed to fetch transaction receipt for ${transactionHash}: ${error.message}`, { stack: error.stack }, 'eth', 'general');
    throw error;
  }
}

async function validateContract(contractKey) {
  const normalizedKey = contractKey.toLowerCase();
  if (!config.contractDetails[normalizedKey]) {
    throw new Error(`Invalid contract: ${normalizedKey}`);
  }
  if (config.contractDetails[normalizedKey].disabled) {
    throw new Error(`${normalizedKey} contract not deployed`);
  }
  const abi = config.abis[normalizedKey]?.nft;
  if (!abi || !Array.isArray(abi)) {
    throw new Error(`${normalizedKey} NFT ABI missing or invalid`);
  }
  const contractAddress = config.contractAddresses[normalizedKey]?.address;
  if (!contractAddress || !/^0x[a-fA-F0-9]{40}$/.test(contractAddress)) {
    throw new Error(`${normalizedKey} contract address missing or invalid`);
  }
  return {
    contractAddress,
    abi,
  };
}

async function log(scope, message, chain = 'eth', collection = 'general') {
  await logger.info(scope, message, chain, collection);
}

export {
  client,
  retry,
  logger,
  getCache,
  setCache,
  saveCacheState,
  loadCacheState,
  batchMulticall,
  getOwnersForContract,
  getTransactionReceipt,
  initializeCache,
  validateContract,
  log,
};
----- app/lib/logger.js -----

import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

// Use process.cwd() to reference the project root
const logDir = path.join(process.cwd(), 'logs');

console.log(chalk.cyan('[Logger] Initializing logger...'));
console.log(chalk.cyan('[Logger] process.env.DEBUG:'), process.env.DEBUG);
console.log(chalk.cyan('[Logger] process.env.NODE_ENV:'), process.env.NODE_ENV);
console.log(chalk.cyan('[Logger] Log directory:'), logDir);

const isDebug = process.env.DEBUG === 'true';
console.log(chalk.cyan('[Logger] isDebug:'), isDebug);

async function ensureLogDir() {
  try {
    await fs.mkdir(logDir, { recursive: true });
    await fs.chmod(logDir, 0o755);
    console.log(chalk.cyan('[Logger] Created or verified log directory:'), logDir);
  } catch (error) {
    console.error(chalk.red('[Logger] Failed to create log directory:'), error.message);
  }
}

ensureLogDir().catch(error => {
  console.error(chalk.red('[Logger] ensureLogDir error:'), error.message);
});

export const logger = {
  info: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [INFO] ${message}`;
    console.log(chalk.green(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote INFO log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write INFO log:'), error.message);
      }
    }
  },
  warn: async (scope, message, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [WARN] ${message}`;
    console.log(chalk.yellow(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote WARN log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write WARN log:'), error.message);
      }
    }
  },
  error: async (scope, message, details = {}, chain = 'eth', collection = 'general') => {
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [ERROR] ${message} ${JSON.stringify(details)}`;
    console.error(chalk.red(log));
    if (isDebug) {
      try {
        const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
        await fs.appendFile(logFile, `${log}\n`);
        console.log(chalk.cyan('[Logger] Wrote ERROR log to:'), logFile);
      } catch (error) {
        console.error(chalk.red('[Logger] Failed to write ERROR log:'), error.message);
      }
    }
  },
  debug: async (scope, message, chain = 'eth', collection = 'general') => {
    if (!isDebug) return;
    const timestamp = new Date().toISOString();
    const log = `[${timestamp}] [${scope}] [DEBUG] ${message}`;
    console.log(chalk.blue(log));
    try {
      const logFile = path.join(logDir, `cache-${chain}-${collection.toLowerCase()}-${timestamp.split('T')[0]}.log`);
      await fs.appendFile(logFile, `${log}\n`);
      console.log(chalk.cyan('[Logger] Wrote DEBUG log to:'), logFile);
    } catch (error) {
      console.error(chalk.red('[Logger] Failed to write DEBUG log:'), error.message);
    }
  },
};

try {
  logger.info('startup', 'Logger module loaded').catch(error => {
    console.error(chalk.red('[Logger] Startup log error:'), error.message);
  });
} catch (error) {
  console.error(chalk.red('[Logger] Immediate log error:'), error.message);
}
----- app/lib/serverInit.js -----

// File: server/lib/serverInit.js
import { logger } from '@/app/lib/logger';
import { initializeCache } from '@/app/api new code/utils';
import chalk from 'chalk';

console.log(chalk.cyan('[ServerInit] Initializing server...'));

try {
  logger.info('serverInit', 'Server initialization started');
  await initializeCache();
} catch (error) {
  logger.error('serverInit', `Initialize cache error: ${error.message}`, { stack: error.stack });
  console.error(chalk.red('[ServerInit] Initialization error:'), error.message);
}

export const serverInit = true;
----- client/lib/chartOptions.js -----

export const barChartOptions = {
    responsive: true,
    plugins: {
      legend: { position: 'top', labels: { color: '#e5e7eb' } }, // Gray-200
      title: {
        display: true,
        text: 'NFT Tier Distribution',
        color: '#e5e7eb',
        font: { size: 16, weight: 'bold' },
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: 'Number of NFTs', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' }, // Gray-300
      },
      x: {
        title: { display: true, text: 'Tiers', color: '#e5e7eb' },
        ticks: { color: '#d1d5db' },
      },
    },
  };
----- client/lib/fetchCollectionData.js -----

import config from '@/contracts/config';
import { HoldersResponseSchema, ProgressResponseSchema } from '@/client/lib/schemas';

// Debounce utility to prevent concurrent POST requests
const debounce = (func, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    return new Promise(resolve => {
      timeout = setTimeout(() => resolve(func(...args)), wait);
    });
  };
};

export async function fetchCollectionData(apiKey, apiEndpoint, pageSize) {
  console.log(`[FetchCollectionData] [INFO] Fetching ${apiKey} from ${apiEndpoint}`);
  try {
    if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
      console.log(`[FetchCollectionData] [INFO] ${apiKey} is disabled`);
      return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Contract not deployed' };
    }

    const endpoint = apiEndpoint.startsWith('http')
      ? apiEndpoint
      : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;

    const pollProgress = async () => {
      const res = await fetch(`${endpoint}/progress`, {
        cache: 'no-store',
        signal: AbortSignal.timeout(config.alchemy.timeoutMs),
      });
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Progress fetch failed: ${res.status} ${errorText}`);
      }
      const progress = await res.json();
      console.log(`[FetchCollectionData] [DEBUG] Progress: ${JSON.stringify(progress)}`);
      const validation = ProgressResponseSchema.safeParse(progress);
      if (!validation.success) {
        console.error(`[FetchCollectionData] [ERROR] Invalid progress data: ${JSON.stringify(validation.error.errors)}`);
        throw new Error('Invalid progress data');
      }
      return validation.data;
    };

    let allHolders = [];
    let totalTokens = 0;
    let totalShares = 0;
    let totalBurned = 0;
    let summary = {};
    let page = 0;
    let totalPages = Infinity;
    let postAttempts = 0;
    const maxPostAttempts = 5;
    let pollAttempts = 0;
    const maxPollAttempts = 360; // 180 seconds / 500ms = 360 attempts
    const maxPollTime = 180000; // 180 seconds
    const startTime = Date.now();

    // Debounced POST request
    const triggerPost = debounce(async () => {
      console.log(`[FetchCollectionData] [INFO] Triggering POST for ${apiKey}, attempt ${postAttempts + 1}/${maxPostAttempts}`);
      const res = await fetch(endpoint, {
        method: 'POST',
        cache: 'no-store',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ forceUpdate: false }),
      });
      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] POST failed: ${res.status} ${errorText}`);
        throw new Error(`POST request failed: ${res.status} ${errorText}`);
      }
      const response = await res.json();
      if (response.error) {
        throw new Error(`POST response error: ${response.error}`);
      }
      console.log(`[FetchCollectionData] [INFO] POST successful: ${JSON.stringify(response)}`);
      return response;
    }, 2000);

    let progress = await pollProgress();
    while (progress.phase !== 'Completed' && progress.phase !== 'Error') {
      if (Date.now() - startTime > maxPollTime) {
        console.error(`[FetchCollectionData] [ERROR] Cache population timeout for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Cache population timed out' };
      }
      if (pollAttempts >= maxPollAttempts) {
        console.error(`[FetchCollectionData] [ERROR] Max poll attempts (${maxPollAttempts}) reached for ${apiKey}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max poll attempts reached' };
      }
      if (progress.phase === 'Idle' || progress.totalOwners === 0) {
        if (postAttempts >= maxPostAttempts) {
          console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached for ${apiKey}`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max POST attempts reached for cache population' };
        }
        try {
          console.log(`[FetchCollectionData] [DEBUG] Sending POST request, attempt ${postAttempts + 1}/${maxPostAttempts}`);
          await triggerPost();
          postAttempts++;
        } catch (error) {
          console.error(`[FetchCollectionData] [ERROR] POST attempt failed: ${error.message}`);
          postAttempts++;
          if (postAttempts >= maxPostAttempts) {
            console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached after error`);
            return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Max POST attempts reached: ${error.message}` };
          }
        }
      }
      console.log(`[FetchCollectionData] [INFO] Waiting for ${apiKey} cache: ${progress.phase} (${progress.progressPercentage}%), poll attempt ${pollAttempts + 1}/${maxPollAttempts}`);
      await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
      try {
        progress = await pollProgress();
      } catch (error) {
        console.error(`[FetchCollectionData] [ERROR] Poll attempt failed: ${error.message}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Polling failed: ${error.message}` };
      }
      pollAttempts++;
    }

    if (progress.phase === 'Error') {
      console.error(`[FetchCollectionData] [ERROR] Cache population failed for ${apiKey}: ${progress.error || 'Unknown error'}`);
      return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Cache population failed: ${progress.error || 'Unknown error'}` };
    }

    while (page < totalPages) {
      const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
      console.log(`[FetchCollectionData] [DEBUG] Fetching ${url}`);
      const res = await fetch(url, { cache: 'force-cache' });
      console.log(`[FetchCollectionData] [DEBUG] Status: ${res.status}, headers: ${JSON.stringify([...res.headers])}`);

      if (res.status === 202) {
        console.log(`[FetchCollectionData] [INFO] Cache still populating for ${apiKey}, retrying...`);
        await new Promise(resolve => setTimeout(resolve, config.alchemy.batchDelayMs));
        continue;
      }

      if (!res.ok) {
        const errorText = await res.text();
        console.error(`[FetchCollectionData] [ERROR] Failed: ${res.status} ${errorText}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `API request failed: ${res.status} ${errorText}` };
      }

      const json = await res.json();
      console.log(`[FetchCollectionData] [DEBUG] Response: ${JSON.stringify(json, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);

      if (json.error) {
        console.error(`[FetchCollectionData] [ERROR] API error for ${apiKey}: ${json.error}`);
        return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: json.error };
      }

      const validation = HoldersResponseSchema.safeParse(json);
      if (!validation.success) {
        console.error(`[FetchCollectionData] [ERROR] Invalid holders data: ${JSON.stringify(validation.error.errors)}`);
        // Retry POST for all collections if data is invalid
        if (postAttempts >= maxPostAttempts) {
          console.error(`[FetchCollectionData] [ERROR] Max POST attempts (${maxPostAttempts}) reached for ${apiKey} retry`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Max POST attempts reached for retry' };
        }
        console.log(`[FetchCollectionData] [INFO] Triggering POST retry for ${apiKey} due to invalid data`);
        await triggerPost();
        postAttempts++;
        const retryRes = await fetch(url, { cache: 'no-store' });
        if (!retryRes.ok) {
          const retryError = await retryRes.text();
          console.error(`[FetchCollectionData] [ERROR] Retry failed: ${retryRes.status} ${retryError}`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: `Retry failed: ${retryRes.status} ${retryError}` };
        }
        const retryJson = await retryRes.json();
        console.log(`[FetchCollectionData] [DEBUG] Retry response: ${JSON.stringify(retryJson, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);
        const retryValidation = HoldersResponseSchema.safeParse(retryJson);
        if (!retryValidation.success) {
          console.error(`[FetchCollectionData] [ERROR] Retry invalid holders data: ${JSON.stringify(retryValidation.error.errors)}`);
          return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: 'Invalid holders data after retry' };
        }
        // Use retry data
        allHolders = allHolders.concat(retryJson.holders);
        totalTokens = retryJson.totalTokens || retryJson.summary?.totalLive || totalTokens;
        totalShares = retryJson.totalShares || retryJson.summary?.multiplierPool || totalTokens;
        totalBurned = retryJson.totalBurned || totalBurned;
        summary = retryJson.summary || summary;
        totalPages = retryJson.totalPages || 1;
      } else {
        // Use original data
        allHolders = allHolders.concat(json.holders);
        totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
        totalShares = json.totalShares || json.summary?.multiplierPool || totalTokens;
        totalBurned = json.totalBurned || totalBurned;
        summary = json.summary || summary;
        totalPages = json.totalPages || 1;
      }
      page++;
      console.log(`[FetchCollectionData] [INFO] Fetched page ${page}: ${json.holders.length} holders`);
    }

    return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
  } catch (error) {
    console.error(`[FetchCollectionData] [ERROR] ${apiKey}: ${error.message}, stack: ${error.stack}`);
    return { holders: [], totalTokens: 0, totalShares: 0, totalBurned: 0, error: error.message };
  }
}
----- client/lib/schemas.js -----

// ./client/lib/schemas.js
import { z } from 'zod';

export const HoldersResponseSchema = z.object({
  holders: z.array(z.any()),
  totalPages: z.number(),
  totalTokens: z.number(),
  totalBurned: z.number().nullable(), // Allow null for Ascendant
  summary: z.object({
    totalLive: z.number(),
    totalBurned: z.number().nullable(), // Allow null for Ascendant
    totalMinted: z.number(),
    tierDistribution: z.array(z.number()),
    multiplierPool: z.number(),
  }),
  globalMetrics: z.object({}).optional(),
});

export const ProgressResponseSchema = z.object({
  isPopulating: z.boolean(),
  totalLiveHolders: z.number(),
  totalOwners: z.number(),
  phase: z.string(),
  progressPercentage: z.string(),
  lastProcessedBlock: z.number().nullable(),
  lastUpdated: z.number().nullable(),
  error: z.string().nullable(),
  errorLog: z.array(z.any()), // Flexible to handle various error log formats
  globalMetrics: z.object({}).optional(),
});
----- client/lib/useNFTData.js -----

// client/lib/useNFTData.js
'use client';
import { useQuery } from '@tanstack/react-query';
import { useNFTStore } from '@/app/store';
import config from '@/contracts/config';
import { HoldersResponseSchema } from '@/client/lib/schemas';

async function fetchNFTData(apiKey, apiEndpoint, pageSize, page = 0) {
  if (apiKey === 'e280' || config.contractDetails[apiKey]?.disabled) {
    return { holders: [], totalTokens: 0, totalBurned: 0, error: 'Contract not deployed' };
  }

  const endpoint = apiEndpoint.startsWith('http') ? apiEndpoint : `${process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000'}${apiEndpoint}`;
  const progressUrl = `${endpoint}/progress`;

  const progressRes = await fetch(progressUrl, { cache: 'no-store' });
  if (!progressRes.ok) throw new Error(`Progress fetch failed: ${progressRes.status}`);
  const progress = await progressRes.json();

  if (progress.isPopulating || progress.phase !== 'Completed') {
    throw new Error('Cache is populating');
  }

  let allHolders = [];
  let totalTokens = 0;
  let totalShares = 0;
  let totalBurned = 0;
  let summary = {};
  let totalPages = Infinity;

  while (page < totalPages) {
    const url = `${endpoint}?page=${page}&pageSize=${pageSize}`;
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error(`API request failed: ${res.status}`);
    const json = await res.json();

    if (json.message === 'Cache is populating' || json.isCachePopulating) {
      throw new Error('Cache is populating');
    }

    const validation = HoldersResponseSchema.safeParse(json);
    if (!validation.success) {
      throw new Error(`Invalid holders schema: ${JSON.stringify(validation.error.errors)}`);
    }

    allHolders = allHolders.concat(json.holders);
    totalTokens = json.totalTokens || json.summary?.totalLive || totalTokens;
    totalShares = json.totalShares || json.summary?.multiplierPool || totalShares;
    totalBurned = json.totalBurned || totalBurned;
    summary = json.summary || summary;
    totalPages = json.totalPages || 1;
    page++;
  }

  return { holders: allHolders, totalTokens, totalShares, totalBurned, summary };
}

export function useNFTData(apiKey, pageSize) {
  const { getCache, setCache } = useNFTStore();

  return useQuery({
    queryKey: ['nft', apiKey],
    queryFn: async () => {
      const cachedData = getCache(apiKey);
      if (cachedData) return cachedData;

      const data = await fetchNFTData(apiKey, config.contractDetails[apiKey].apiEndpoint, pageSize);
      setCache(apiKey, data);
      return data;
    },
    retry: config.alchemy.maxRetries,
    retryDelay: attempt => config.alchemy.batchDelayMs * (attempt + 1),
    staleTime: 30 * 60 * 1000, // 30 minutes
    refetchInterval: progress => (progress?.isPopulating ? 2000 : false),
    onError: error => console.error(`[useNFTData] [ERROR] ${apiKey}: ${error.message}`),
  });
}

================= Includes the following JS files under ./server =================
app/api/holders/Element280/validate-burned/route.js
app/api/holders/[contract]/progress/route.js
app/api/holders/[contract]/route.js
app/api/utils.dev-repo.js
app/api/utils.js
app/lib/logger.js
app/lib/serverInit.js
client/lib/chartOptions.js
client/lib/fetchCollectionData.js
client/lib/schemas.js
client/lib/useNFTData.js
