// tests/__mocks__/config.js
export default {
    contractDetails: {
      element280: {
        name: 'Element280',
        apiEndpoint: '/api/holders/Element280',
        pageSize: 100,
        disabled: false,
        rewardToken: 'ELMNT',
      },
      ascendant: {
        name: 'Ascendant',
        apiEndpoint: '/api/holders/Ascendant',
        pageSize: 1000,
        disabled: false,
        rewardToken: 'DRAGONX',
      },
      e280: {
        name: 'E280',
        apiEndpoint: '/api/holders/E280',
        pageSize: 1000,
        disabled: true,
        rewardToken: 'E280',
      },
    },
    nftContracts: {
      element280: { address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
    },
    cache: {
      nodeCache: {
        stdTTL: 3600,
        checkperiod: 120,
      },
      redis: {
        disableElement280: false,
        disableElement369: true,
        disableStax: true,
        disableAscendant: true,
        disableE280: true,
      },
    },
    alchemy: {
      apiKey: 'rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI',
      timeoutMs: 30000,
      maxRetries: 2,
      batchDelayMs: 500,
    },
  };// tests/__mocks__/chalk.js
export default {
    green: (str) => str,
    yellow: (str) => str,
    red: (str) => str,
    blue: (str) => str,
    cyan: (str) => str,
  };export const logger = {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  };// tests/__mocks__/logger.js
export const logger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  };export default {
  nftContracts: {
    element280: { disabled: false },
    ascendant: { disabled: false },
  },
  alchemy: {
    apiKey: 'test-key',
    maxRetries: 2,
    batchDelayMs: 500,
    batchSize: 100,
  },
  burnAddress: '0x0000000000000000000000000000000000000000',
  deploymentBlocks: { ascendant: { block: 0 } },
  contractTiers: {
    ascendant: { 1: { multiplier: 1 }, 2: { multiplier: 2 } },
    element280: { 1: { multiplier: 1 } },
  },
};export const logger = {
  info: jest.fn().mockResolvedValue(undefined),
  error: jest.fn().mockResolvedValue(undefined),
  warn: jest.fn().mockResolvedValue(undefined),
  debug: jest.fn().mockResolvedValue(undefined),
};// tests/unit/holders.test.js
import { jest } from '@jest/globals';
import { getHoldersMap, getOwnersForContract } from '@/app/api/utils/contracts';
import { populateHoldersMapCache } from '@/app/api/utils/holders';
import { HoldersResponseSchema } from '@/lib/schemas';
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import config from '@/config';
import { logger } from '@/lib/logger';
import { client, alchemy } from '@/app/api/utils/blockchain';

// Mock dependencies
jest.mock('node-cache', () => {
  const mockCache = {
    set: jest.fn().mockReturnValue(true),
    get: jest.fn().mockReturnValue(undefined),
    del: jest.fn().mockReturnValue(1),
  };
  return jest.fn(() => mockCache);
});

jest.mock('fs/promises', () => ({
  mkdir: jest.fn().mockResolvedValue(undefined),
  chmod: jest.fn().mockResolvedValue(undefined),
  writeFile: jest.fn().mockResolvedValue(undefined),
  readFile: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
  access: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
  appendFile: jest.fn().mockResolvedValue(undefined),
}));

jest.mock('@upstash/redis', () => {
  const mockRedisData = new Map();
  let mockQuotaExceeded = false;

  const mockRedis = {
    get: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return mockRedisData.get(key) || null;
    }),
    set: jest.fn().mockImplementation(async (key, value) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      mockRedisData.set(key, value);
      return 'OK';
    }),
    expire: jest.fn().mockImplementation(async () => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return 1;
    }),
    del: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return mockRedisData.delete(key) ? 1 : 0;
    }),
  };

  return {
    Redis: {
      fromEnv: jest.fn(() => mockRedis),
    },
    clearMockRedis: jest.fn(() => mockRedisData.clear()),
    setMockQuotaExceeded: jest.fn((state) => {
      mockQuotaExceeded = state;
    }),
  };
});

jest.mock('p-limit', () => () => (fn) => fn());
jest.mock('chalk', () => ({
  green: jest.fn().mockImplementation((str) => str),
  yellow: jest.fn().mockImplementation((str) => str),
  red: jest.fn().mockImplementation((str) => str),
  blue: jest.fn().mockImplementation((str) => str),
  cyan: jest.fn().mockImplementation((str) => str),
}));

jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

jest.mock('@/app/api/utils/blockchain', () => ({
  client: {
    getBlockNumber: jest.fn().mockResolvedValue(21500000n),
    getLogs: jest.fn().mockResolvedValue([
      {
        args: {
          from: '0x0000000000000000000000000000000000000000',
          to: '0x1234567890abcdef1234567890abcdef12345678',
          tokenId: BigInt(1),
        },
      },
    ]),
    readContract: jest.fn().mockImplementation(({ functionName }) => {
      if (functionName === 'totalSupply') return 100;
      if (functionName === 'totalBurned') return 10;
      return 0;
    }),
  },
  alchemy: {
    nft: {
      getOwnersForContract: jest.fn().mockResolvedValue({
        owners: [
          {
            ownerAddress: '0x1234567890abcdef1234567890abcdef12345678',
            tokenBalances: [{ tokenId: '1', balance: '1' }],
          },
        ],
      }),
    },
  },
}));

describe('Holder Utilities', () => {
  let mockNodeCacheInstance;
  let redis;

  beforeAll(async () => {
    const nodeCache = (await import('node-cache')).default;
    mockNodeCacheInstance = new nodeCache();
    redis = await import('@upstash/redis');
  });

  beforeEach(async () => {
    jest.clearAllMocks();
    mockNodeCacheInstance.set.mockReset().mockReturnValue(true);
    mockNodeCacheInstance.get.mockReset().mockReturnValue(undefined);
    mockNodeCacheInstance.del.mockReset().mockReturnValue(1);
    redis.clearMockRedis();
    fs.readFile.mockReset().mockRejectedValue({ code: 'ENOENT' });
    fs.writeFile.mockReset().mockResolvedValue(undefined);
  });

  it('should get holders map for ascendant contract', async () => {
    const contractKey = 'ascendant';
    const contractAddress = config.nftContracts.ascendant.address;
    const abi = config.abis.ascendant.main;
    const cacheState = {
      isPopulating: false,
      totalOwners: 0,
      totalLiveHolders: 0,
      progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
      lastUpdated: null,
      lastProcessedBlock: null,
      globalMetrics: {},
    };

    const result = await getHoldersMap(contractKey, contractAddress, abi, null, [], cacheState);
    expect(result.holdersMap.size).toBe(1);
    expect(result.holdersMap.get(1)).toEqual({ owner: '0x1234567890abcdef1234567890abcdef12345678', balance: 1 });
    expect(result.totalBurned).toBe(0);
    expect(result.lastBlock).toBe(21500000);
    expect(result.errorLog).toEqual([]);
    expect(client.getLogs).toHaveBeenCalledWith({
      address: contractAddress,
      event: expect.any(Object),
      fromBlock: BigInt(config.deploymentBlocks.ascendant.block),
      toBlock: 21500000n,
    });
    expect(fs.writeFile).toHaveBeenCalled(); // Cache state saved
  });

  it('should get holders map for element280 contract', async () => {
    const contractKey = 'element280';
    const contractAddress = config.nftContracts.element280.address;
    const abi = config.abis.element280.main;
    const cacheState = {
      isPopulating: false,
      totalOwners: 0,
      totalLiveHolders: 0,
      progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
      lastUpdated: null,
      lastProcessedBlock: null,
      globalMetrics: {},
    };

    const result = await getHoldersMap(contractKey, contractAddress, abi, null, [], cacheState);
    expect(result.holdersMap.size).toBe(1);
    expect(result.holdersMap.get('0x1234567890abcdef1234567890abcdef12345678')).toMatchObject({
      wallet: '0x1234567890abcdef1234567890abcdef12345678',
      tokenIds: [1],
      total: 1,
    });
    expect(result.totalBurned).toBe(10);
    expect(result.lastBlock).toBe(21500000);
    expect(result.errorLog).toEqual([]);
    expect(alchemy.nft.getOwnersForContract).toHaveBeenCalledWith(contractAddress, { withTokenBalances: true });
    expect(fs.writeFile).toHaveBeenCalled(); // Cache state saved
  });

  it('should get owners for contract', async () => {
    const contractAddress = config.nftContracts.element280.address;
    const abi = config.abis.element280.main;

    const owners = await getOwnersForContract(contractAddress, abi, { withTokenBalances: true });
    expect(owners).toEqual([
      {
        ownerAddress: '0x1234567890abcdef1234567890abcdef12345678',
        tokenBalances: [{ tokenId: 1, balance: 1 }],
      },
    ]);
    expect(alchemy.nft.getOwnersForContract).toHaveBeenCalledWith(contractAddress, { withTokenBalances: true, pageKey: null });
  });

  it('should handle alchemy error in getOwnersForContract', async () => {
    const contractAddress = config.nftContracts.element280.address;
    const abi = config.abis.element280.main;
    alchemy.nft.getOwnersForContract.mockRejectedValueOnce(new Error('Alchemy API error'));

    const owners = await getOwnersForContract(contractAddress, abi);
    expect(owners).toEqual([]);
    expect(logger.error).toHaveBeenCalledWith(
      'contracts',
      `Failed to fetch owners for ${contractAddress}: Alchemy API error`,
      expect.any(Object),
      'eth',
      'general'
    );
  });

  it('should cache valid holder data for all NFT collections', async () => {
    const collections = ['element280', 'element369', 'stax', 'ascendant'];
    const mockHolderData = (contract) => ({
      holders: [
        {
          wallet: '0x1234567890abcdef1234567890abcdef12345678',
          tokenIds: [1],
          total: 1,
          tiers: contract === 'element280' ? [1, 0, 0, 0, 0, 0] :
                 contract === 'element369' ? [1, 0, 0] :
                 contract === 'stax' ? [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] :
                 [1, 0, 0, 0, 0, 0, 0, 0],
          multiplierSum: contract === 'element280' ? 10 :
                         contract === 'element369' ? 1 :
                         contract === 'stax' ? 1 :
                         1.01,
          percentage: 100,
          displayMultiplierSum: contract === 'element280' ? 0.1 : 1,
          rank: 1,
          ...(contract === 'element369' ? { infernoRewards: 0, fluxRewards: 0, e280Rewards: 0 } : {}),
          ...(contract === 'element280' || contract === 'stax' ? { claimableRewards: 0 } : {}),
          ...(contract === 'ascendant' ? {
            shares: 1,
            lockedAscendant: 0,
            pendingDay8: 0,
            pendingDay28: 0,
            pendingDay90: 0,
            claimableRewards: 0,
          } : {}),
        },
      ],
      totalBurned: 10,
      timestamp: 1234567890,
    });

    await import('@/app/api/utils/cache').then(({ initializeCache }) => initializeCache());

    for (const contract of collections) {
      const holderData = mockHolderData(contract);
      mockNodeCacheInstance.get.mockReturnValueOnce(holderData);
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: false,
        totalOwners: 1,
        totalLiveHolders: 1,
        progressState: { step: 'completed', processedNfts: 1, totalNfts: 100, processedTiers: 1, totalTiers: 100, error: null, errorLog: [] },
        lastUpdated: 1234567890,
        lastProcessedBlock: 21500000,
        globalMetrics: contract === 'ascendant' ? { totalShares: 1, pendingRewards: 0 } : {},
      }));

      const result = await populateHoldersMapCache(
        contract,
        config.nftContracts[contract].address,
        config.abis[contract].main,
        null,
        []
      );

      expect(result.status).toBe('up_to_date');
      expect(result.holders).toHaveLength(1);

      const cacheKey = `${contract}_holders`;
      const cachedData = await getCache(cacheKey, contract);
      expect(cachedData).toEqual(holderData);
      expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(cacheKey, expect.any(Object), 0);
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining(`${contract}_holders.json`),
        expect.any(String)
      );

      if (contract === 'element280') {
        expect(redis.set).toHaveBeenCalledWith(cacheKey, JSON.stringify(holderData));
        expect(redis.expire).toHaveBeenCalledWith(cacheKey, 0);
      } else {
        expect(redis.set).not.toHaveBeenCalledWith(cacheKey, expect.any(String));
      }

      const response = {
        holders: cachedData.holders,
        totalItems: cachedData.holders.length,
        totalPages: 1,
        currentPage: 1,
        pageSize: 1000,
        totalBurned: cachedData.totalBurned,
        totalTokens: 100,
        ...(contract === 'ascendant' ? { totalShares: 1, pendingRewards: 0 } : {}),
        status: result.status,
        cacheState: {
          isPopulating: false,
          totalOwners: 1,
          totalLiveHolders: 1,
          progressState: {
            step: 'completed',
            processedNfts: 1,
            totalNfts: 100,
            processedTiers: 1,
            totalTiers: 100,
            error: null,
            errorLog: [],
          },
          lastUpdated: expect.any(Number),
          lastProcessedBlock: 21500000,
          globalMetrics: contract === 'ascendant' ? {
            totalTokens: 1,
            totalLockedAscendant: 0,
            totalShares: 1,
            toDistributeDay8: 0,
            toDistributeDay28: 0,
            toDistributeDay90: 0,
            pendingRewards: 0,
          } : {},
        },
      };
      const parsed = HoldersResponseSchema.safeParse(response);
      expect(parsed.success).toBe(true);
    }
  });
});// tests/unit/cache.test.js
import { jest } from '@jest/globals';
import NodeCache from 'node-cache';
import { Redis } from '@upstash/redis';
import fs from 'fs/promises';
import config from '@/config';
import { logger } from '@/lib/logger';
import { client } from '@/app/api/utils/blockchain';
import { parseAbiItem } from 'viem';

// Mock dependencies
jest.mock('node-cache', () => {
  const mockCache = {
    get: jest.fn(),
    set: jest.fn().mockReturnValue(true),
    del: jest.fn().mockReturnValue(1),
    flushAll: jest.fn(),
  };
  return jest.fn(() => mockCache);
});

jest.mock('@upstash/redis', () => ({
  Redis: {
    fromEnv: jest.fn(),
  },
}));

jest.mock('fs/promises', () => ({
  mkdir: jest.fn().mockResolvedValue(undefined),
  writeFile: jest.fn().mockResolvedValue(undefined),
  readFile: jest.fn().mockResolvedValue(null),
}));

jest.mock('viem', () => ({
  parseAbiItem: jest.fn().mockReturnValue({}),
}));

jest.mock('@/app/api/utils/blockchain', () => ({
  client: {
    getBlockNumber: jest.fn(),
    getLogs: jest.fn(),
  },
}));

jest.mock('@/config', () => ({
  cache: {
    nodeCache: {
      stdTTL: 3600,
      checkperiod: 120,
    },
    redis: {
      disableElement280: false,
      disableElement369: true,
      disableStax: true,
      disableAscendant: true,
      disableE280: true,
    },
  },
  contractDetails: {
    element280: { name: 'Element280', apiEndpoint: '/api/holders/Element280', pageSize: 100, disabled: false },
    ascendant: { name: 'Ascendant', apiEndpoint: '/api/holders/Ascendant', pageSize: 1000, disabled: false },
    e280: { name: 'E280', apiEndpoint: '/api/holders/E280', pageSize: 1000, disabled: true },
  },
  nftContracts: {
    element280: { address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' },
  },
  burnAddress: '0x0000000000000000000000000000000000000000',
}));

jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

describe('Cache Utilities', () => {
  let mockNodeCacheInstance;
  let mockRedisInstance;
  let cacheUtils;

  beforeEach(async () => {
    jest.resetModules(); // Clear module cache
    cacheUtils = await import('@/app/api/utils/cache');
    jest.clearAllMocks();
    mockNodeCacheInstance = {
      get: jest.fn(),
      set: jest.fn().mockReturnValue(true),
      del: jest.fn().mockReturnValue(1),
      flushAll: jest.fn(),
    };
    NodeCache.mockReturnValue(mockNodeCacheInstance);
    mockRedisInstance = {
      get: jest.fn().mockResolvedValue(null),
      set: jest.fn().mockResolvedValue('OK'),
      del: jest.fn().mockResolvedValue(1),
    };
    Redis.fromEnv.mockReturnValue(mockRedisInstance);
    client.getBlockNumber.mockResolvedValue(BigInt(1000));
    client.getLogs.mockResolvedValue([]);
    fs.mkdir.mockResolvedValue(undefined);
    fs.writeFile.mockResolvedValue(undefined);
    fs.readFile.mockResolvedValue(null);
    await cacheUtils.resetCache(); // Reset cache state
  });

  describe('initializeCache', () => {
    it('initializes node-cache with config settings', async () => {
      await cacheUtils.initializeCache();
      expect(NodeCache).toHaveBeenCalledWith({
        stdTTL: 3600,
        checkperiod: 120,
      });
    });

    it('initializes Redis when enabled', async () => {
      process.env.UPSTASH_REDIS_REST_URL = 'https://splendid-sunbird-26504.upstash.io';
      process.env.UPSTASH_REDIS_REST_TOKEN = 'token';
      await cacheUtils.initializeCache();
      expect(Redis.fromEnv).toHaveBeenCalled();
      expect(logger.info).toHaveBeenCalledWith(
        'cache',
        'Redis initialized',
        'eth',
        'general'
      );
      delete process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_TOKEN;
    });
  });

  describe('getCache', () => {
    beforeEach(async () => {
      await cacheUtils.initializeCache();
    });

    it('returns cached data from node-cache if available', async () => {
      const key = 'test-key';
      const expectedData = { holders: [], totalTokens: 0 };
      mockNodeCacheInstance.get.mockReturnValue(expectedData);

      const result = await cacheUtils.getCache(key, 'element280');
      expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(key);
      expect(result).toEqual(expectedData);
      expect(mockRedisInstance.get).not.toHaveBeenCalled();
    });

    it('fetches from Redis if node-cache is empty and Redis is enabled', async () => {
      process.env.UPSTASH_REDIS_REST_URL = 'https://splendid-sunbird-26504.upstash.io';
      process.env.UPSTASH_REDIS_REST_TOKEN = 'token';
      await cacheUtils.initializeCache();
      const key = 'test-key';
      const expectedData = JSON.stringify({ holders: [], totalTokens: 0 });
      mockNodeCacheInstance.get.mockReturnValue(undefined);
      mockRedisInstance.get.mockResolvedValue(expectedData);

      const result = await cacheUtils.getCache(key, 'element280');
      expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(key);
      expect(mockRedisInstance.get).toHaveBeenCalledWith(key);
      expect(result).toEqual(JSON.parse(expectedData));
      expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(key, JSON.parse(expectedData), expect.any(Number));
      delete process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_TOKEN;
    });

    it('returns null if no data in node-cache or Redis', async () => {
      const key = 'test-key';
      mockNodeCacheInstance.get.mockReturnValue(undefined);
      mockRedisInstance.get.mockResolvedValue(null);

      const result = await cacheUtils.getCache(key, 'element280');
      expect(mockNodeCacheInstance.get).toHaveBeenCalledWith(key);
      expect(result).toBeNull();
    });
  });

  describe('setCache', () => {
    beforeEach(async () => {
      process.env.UPSTASH_REDIS_REST_URL = 'https://splendid-sunbird-26504.upstash.io';
      process.env.UPSTASH_REDIS_REST_TOKEN = 'token';
      await cacheUtils.initializeCache();
    });

    afterEach(() => {
      delete process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_TOKEN;
    });

    it('sets data in node-cache', async () => {
      const key = 'test-key';
      const value = { holders: [], totalTokens: 0 };
      const ttl = 3600;

      await cacheUtils.setCache(key, value, ttl, 'element280');
      expect(mockNodeCacheInstance.set).toHaveBeenCalledWith(key, value, ttl);
    });

    it('sets data in Redis for element280', async () => {
      const key = 'test-key';
      const value = { holders: [], totalTokens: 0 };
      const ttl = 3600;

      await cacheUtils.setCache(key, value, ttl, 'element280');
      expect(mockRedisInstance.set).toHaveBeenCalledWith(key, JSON.stringify(value), { ex: ttl });
    });
  });

  describe('saveCacheState', () => {
    it('saves state to file', async () => {
      const collection = 'element280';
      const state = { totalOwners: 10 };
      const prefix = 'element280';

      await cacheUtils.saveCacheState(collection, state, prefix);
      expect(fs.writeFile).toHaveBeenCalled();
      expect(logger.debug).toHaveBeenCalledWith(
        'cache',
        expect.stringContaining('Saved cache state to file'),
        'eth',
        collection
      );
    });
  });

  describe('loadCacheState', () => {
    it('loads state from file', async () => {
      const collection = 'element280';
      const prefix = 'element280';
      const state = { totalOwners: 10 };
      fs.readFile.mockResolvedValueOnce(JSON.stringify(state));

      const result = await cacheUtils.loadCacheState(collection, prefix);
      expect(fs.readFile).toHaveBeenCalled();
      expect(result).toEqual(state);
    });

    it('returns null on file read error', async () => {
      const collection = 'element280';
      const prefix = 'element280';
      fs.readFile.mockRejectedValueOnce(new Error('File not found'));

      const result = await cacheUtils.loadCacheState(collection, prefix);
      expect(result).toBeNull();
      expect(logger.error).toHaveBeenCalled();
    });
  });

  describe('getCacheState', () => {
    it('returns default state if no saved state', async () => {
      const contractKey = 'element280';
      fs.readFile.mockResolvedValueOnce(null);

      const result = await cacheUtils.getCacheState(contractKey);
      expect(result).toEqual(expect.objectContaining({
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: expect.any(Object),
      }));
    });

    it('loads saved state', async () => {
      const contractKey = 'element280';
      const savedState = { totalOwners: 10, progressState: { step: 'processing' } };
      fs.readFile.mockResolvedValueOnce(JSON.stringify(savedState));

      const result = await cacheUtils.getCacheState(contractKey);
      expect(result.totalOwners).toBe(10);
      expect(result.progressState.step).toBe('processing');
    });
  });

  describe('saveCacheStateContract', () => {
    it('saves cache state for contract', async () => {
      const contractKey = 'element280';
      const cacheState = { totalOwners: 10, progressState: { step: 'processing' } };

      await cacheUtils.saveCacheStateContract(contractKey, cacheState);
      expect(fs.writeFile).toHaveBeenCalled();
      expect(logger.debug).toHaveBeenCalledWith(
        'cache',
        expect.stringContaining('Saved cache state'),
        'eth',
        contractKey
      );
    });
  });

  describe('getNewEvents', () => {
    beforeEach(async () => {
      await cacheUtils.initializeCache();
    });

    it('returns cached events if available', async () => {
      const contractKey = 'element280';
      const contractAddress = '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9';
      const fromBlock = 500;
      const errorLog = [];
      const cachedEvents = { burnedTokenIds: [], transferTokenIds: [], lastBlock: 1000 };
      mockNodeCacheInstance.get.mockReturnValue(cachedEvents);

      const result = await cacheUtils.getNewEvents(contractKey, contractAddress, fromBlock, errorLog);
      expect(mockNodeCacheInstance.get).toHaveBeenCalled();
      expect(result).toEqual(cachedEvents);
      expect(client.getLogs).not.toHaveBeenCalled();
    });

    it('fetches new events and caches them', async () => {
      const contractKey = 'element280';
      const contractAddress = '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9';
      const fromBlock = 500;
      const errorLog = [];
      mockNodeCacheInstance.get.mockReturnValue(undefined);
      client.getBlockNumber.mockResolvedValue(BigInt(1000));
      client.getLogs.mockResolvedValue([
        {
          args: {
            to: '0x0000000000000000000000000000000000000000',
            tokenId: BigInt(1),
          },
        },
        {
          args: {
            to: '0x1234567890abcdef1234567890abcdef12345678',
            from: '0xabcdef1234567890abcdef1234567890abcdef12',
            tokenId: BigInt(2),
          },
        },
      ]);

      const result = await cacheUtils.getNewEvents(contractKey, contractAddress, fromBlock, errorLog);
      expect(client.getLogs).toHaveBeenCalled();
      expect(mockNodeCacheInstance.set).toHaveBeenCalled();
      expect(result).toEqual({
        burnedTokenIds: [1],
        transferTokenIds: [{
          tokenId: 2,
          from: '0xabcdef1234567890abcdef1234567890abcdef12',
          to: '0x1234567890abcdef1234567890abcdef12345678',
        }],
        lastBlock: 1000,
        timestamp: expect.any(Number),
      });
    });

    it('handles no new blocks', async () => {
      const contractKey = 'element280';
      const contractAddress = '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9';
      const fromBlock = 1000;
      const errorLog = [];
      mockNodeCacheInstance.get.mockReturnValue(undefined);
      client.getBlockNumber.mockResolvedValue(BigInt(1000));

      const result = await cacheUtils.getNewEvents(contractKey, contractAddress, fromBlock, errorLog);
      expect(result).toEqual({
        burnedTokenIds: [],
        transferTokenIds: [],
        lastBlock: 1000,
      });
      expect(client.getLogs).not.toHaveBeenCalled();
    });

    it('logs error on block number fetch failure', async () => {
      const contractKey = 'element280';
      const contractAddress = '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9';
      const fromBlock = 500;
      const errorLog = [];
      mockNodeCacheInstance.get.mockReturnValue(undefined);
      client.getBlockNumber.mockRejectedValue(new Error('Network error'));

      await expect(cacheUtils.getNewEvents(contractKey, contractAddress, fromBlock, errorLog)).rejects.toThrow('Network error');
      expect(errorLog).toContainEqual(expect.objectContaining({
        phase: 'fetch_block_number',
        error: 'Network error',
      }));
    });
  });
});// tests/unit/utils.test.js
import { jest } from '@jest/globals';
import { validateContractConfig } from '@/app/api/utils/config';
import { withErrorHandling } from '@/app/api/utils/error';
import { batchMulticall } from '@/app/api/utils/multicall';
import { initServer, isServerInitialized } from '@/app/api/utils/serverInit';
import { logger } from '@/lib/logger';
import { client } from '@/app/api/utils/blockchain';
import config from '@/config';
import { NextResponse } from 'next/server';

// Mock dependencies
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

jest.mock('@/app/api/utils/blockchain', () => ({
  client: {
    multicall: jest.fn().mockResolvedValue([]),
  },
}));

jest.mock('@/app/api/utils/cache', () => ({
  initializeCache: jest.fn().mockResolvedValue(true),
}));

describe('Utility Functions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('validateContractConfig', () => {
    it('should validate valid contract config', () => {
      const contractKey = 'element280';
      const result = validateContractConfig(contractKey);
      expect(result).toEqual({
        contractAddress: config.nftContracts.element280.address,
        vaultAddress: undefined,
        abi: config.abis.element280.main,
        vaultAbi: config.abis.element280.vault || [],
      });
    });

    it('should throw for invalid contract', () => {
      expect(() => validateContractConfig('invalid')).toThrow('Invalid contract: invalid');
      expect(logger.error).toHaveBeenCalledWith(
        'config',
        'Invalid contract: invalid',
        expect.any(Object),
        'eth',
        'invalid'
      );
    });

    it('should throw for disabled contract', () => {
      expect(() => validateContractConfig('e280')).toThrow('Contract e280 is disabled');
      expect(logger.warn).toHaveBeenCalledWith(
        'config',
        'Contract e280 is disabled',
        expect.any(Object),
        'eth',
        'e280'
      );
    });
  });

  describe('withErrorHandling', () => {
    it('should handle successful handler', async () => {
      const handler = jest.fn().mockResolvedValue(NextResponse.json({ success: true }));
      const context = { message: 'Test handler', contractKey: 'element280' };
      const result = await withErrorHandling(handler, context);
      expect(result).toEqual(NextResponse.json({ success: true }));
      expect(handler).toHaveBeenCalled();
    });

    it('should handle errors', async () => {
      const handler = jest.fn().mockRejectedValue(new Error('Test error'));
      const context = { message: 'Test handler', contractKey: 'element280' };
      const result = await withErrorHandling(handler, context);
      expect(result.status).toBe(500);
      expect(result.body).toEqual({ error: 'Test error' });
      expect(logger.error).toHaveBeenCalledWith(
        'route',
        'Test handler: Test error',
        expect.any(Object),
        'eth',
        'element280'
      );
    });
  });

  describe('batchMulticall', () => {
    it('should process multicall batch', async () => {
      const calls = [
        { address: '0x1', abi: [], functionName: 'test', args: [] },
        { address: '0x2', abi: [], functionName: 'test', args: [] },
      ];
      client.multicall.mockResolvedValue([{ status: 'success', result: 42 }, { status: 'success', result: 43 }]);
      const results = await batchMulticall(calls, 1);
      expect(results).toEqual([{ status: 'success', result: 42 }, { status: 'success', result: 43 }]);
      expect(client.multicall).toHaveBeenCalledTimes(2);
      expect(logger.debug).toHaveBeenCalledWith('multicall', expect.any(String), 'eth', 'general');
    });

    it('should handle multicall errors', async () => {
      const calls = [{ address: '0x1', abi: [], functionName: 'test', args: [] }];
      client.multicall.mockRejectedValueOnce(new Error('Multicall error'));
      const results = await batchMulticall(calls);
      expect(results).toEqual([{ status: 'failure', result: null }]);
      expect(logger.error).toHaveBeenCalledWith(
        'multicall',
        'Batch 0-49 failed: Multicall error',
        expect.any(Object),
        'eth',
        'general'
      );
    });
  });

  describe('Server Initialization', () => {
    it('should initialize server', async () => {
      const { initializeCache } = require('@/app/api/utils/cache');
      initializeCache.mockResolvedValue(true);
      await initServer();
      expect(initializeCache).toHaveBeenCalled();
      expect(isServerInitialized()).toBe(true);
      expect(logger.info).toHaveBeenCalledWith('server', 'Cache initialized successfully', 'eth', 'general');
    });

    it('should handle cache initialization failure', async () => {
      const { initializeCache } = require('@/app/api/utils/cache');
      initializeCache.mockResolvedValue(false);
      await expect(initServer()).rejects.toThrow('Cache initialization failed');
      expect(logger.error).toHaveBeenCalledWith(
        'server',
        'Cache initialization failed',
        expect.any(Object),
        'eth',
        'general'
      );
    });

    it('should skip initialization if already initialized', async () => {
      const { initializeCache } = require('@/app/api/utils/cache');
      initializeCache.mockReset();
      await initServer();
      await initServer();
      expect(initializeCache).toHaveBeenCalledTimes(1);
      expect(logger.debug).toHaveBeenCalledWith('server', 'Server already initialized', 'eth', 'general');
    });
  });
});// tests/backend.test.js
import { jest } from '@jest/globals';
import { run } from 'jest';

// Mock dependencies to ensure isolation
jest.mock('node-cache');
jest.mock('fs/promises');
jest.mock('@upstash/redis');
jest.mock('@/lib/logger');
jest.mock('@/app/api/utils/blockchain');
jest.mock('node-fetch');

describe('Backend Test Suite', () => {
  it('should run all backend tests with coverage', async () => {
    const result = await run([
      '--config', 'jest.config.js',
      '--collectCoverage',
      '--coverageDirectory', 'coverage',
      '--testPathPattern', 'tests/unit/.*\\.test\\.js',
      '--testPathPattern', 'tests/e2e/.*\\.test\\.js',
    ]);

    // Jest run returns undefined on success; errors are thrown on failure
    expect(result).toBeUndefined();
  }, 30000); // Increase timeout for full test suite
});// tests/holders.e2e.test.js
import { jest } from '@jest/globals';
import request from 'supertest';
import { initializeCache } from '@/app/api/utils/cache';
import { app } from '@/app'; // Assuming you have a Next.js app export

describe('Holders API', () => {
  beforeAll(async () => {
    await initializeCache();
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return holders for ascendant contract', async () => {
    const response = await request(app)
      .get('/api/holders/ascendant')
      .query({ page: 1, pageSize: 10 });

    expect(response.status).toBe(200);
    expect(response.body).toMatchObject({
      holders: expect.any(Array),
      totalItems: expect.any(Number),
      totalPages: expect.any(Number),
      currentPage: 1,
      pageSize: 10,
      totalBurned: expect.any(Number),
      totalTokens: expect.any(Number),
      totalShares: expect.any(Number),
      pendingRewards: expect.any(Number),
      status: expect.any(String),
      cacheState: expect.any(Object),
    });
    expect(HoldersResponseSchema.safeParse(response.body).success).toBe(true);
  });

  it('should return 400 for invalid contract', async () => {
    const response = await request(app)
      .get('/api/holders/invalid')
      .query({ page: 1, pageSize: 10 });

    expect(response.status).toBe(400);
    expect(response.body).toEqual({ error: 'Invalid contract: invalid' });
  });
});// tests/setup.js
import { config } from 'dotenv';
import path from 'path';
import { jest } from '@jest/globals';

config({ path: path.join(process.cwd(), '.env.local') });

jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

jest.mock('chalk', () => ({
  green: (str) => str,
  yellow: (str) => str,
  red: (str) => str,
  blue: (str) => str,
  cyan: (str) => str,
}));

beforeAll(() => {
  jest.spyOn(console, 'log').mockImplementation(() => {});
  jest.spyOn(console, 'error').mockImplementation(() => {});
});

afterAll(() => {
  console.log.mockRestore();
  console.error.mockRestore();
});// tests/e2e/frontend.test.js
import { jest } from '@jest/globals';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { act } from 'react-dom/test-utils';
import NFTLayout from '@/components/NFTLayout';
import NFTPage from '@/components/NFTPage';
import SearchResultsModal from '@/components/SearchResultsModal';
import NFTSummary from '@/components/NFTSummary';
import HolderTable from '@/components/HolderTable';
import Navbar from '@/components/Navbar';
import LoadingIndicator from '@/components/LoadingIndicator';
import { useNFTStore } from '@/app/store';
import config from '@/config';
import { clientLogger } from '@/lib/clientLogger';
import * as fetchCollectionData from '@/lib/fetchCollectionData';
import { usePathname } from 'next/navigation';
import { viem } from 'viem';

// Mock dependencies
jest.mock('next/navigation', () => ({
  usePathname: jest.fn(),
}));
jest.mock('node-fetch', () => jest.fn());
jest.mock('viem', () => ({
  createPublicClient: jest.fn().mockReturnValue({
    multicall: jest.fn(),
  }),
  http: jest.fn(),
}));
jest.mock('@/lib/clientLogger', () => ({
  clientLogger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
  },
}));
jest.mock('@/app/store', () => ({
  useNFTStore: jest.fn(),
}));
jest.mock('@/lib/fetchCollectionData', () => ({
  fetchCollectionData: jest.fn(),
}));
jest.mock('framer-motion', () => ({
  motion: {
    div: jest.fn(({ children, ...props }) => <div {...props}>{children}</div>),
    button: jest.fn(({ children, ...props }) => <button {...props}>{children}</button>),
    AnimatePresence: jest.fn(({ children }) => <>{children}</>),
  },
}));
jest.mock('next/dynamic', () => jest.fn((loader) => {
  const Component = () => <div>Mocked Dynamic Component</div>;
  Component.displayName = 'MockedDynamicComponent';
  return Component;
}));
jest.mock('react-chartjs-2', () => ({
  Bar: jest.fn(() => <div>Mocked Bar Chart</div>),
}));

// Mock config
jest.mock('@/config', () => ({
  contractDetails: {
    element280: { name: 'Element280', apiEndpoint: '/api/holders/Element280', pageSize: 100, disabled: false, rewardToken: 'ELMNT' },
    ascendant: { name: 'Ascendant', apiEndpoint: '/api/holders/Ascendant', pageSize: 1000, disabled: false, rewardToken: 'DRAGONX' },
    e280: { name: 'E280', apiEndpoint: '/api/holders/E280', pageSize: 1000, disabled: true, rewardToken: 'E280' },
    element369: { name: 'Element369', apiEndpoint: '/api/holders/Element369', pageSize: 1000, disabled: false, rewardToken: 'INFERNO/FLUX/E280' },
    stax: { name: 'Stax', apiEndpoint: '/api/holders/Stax', pageSize: 1000, disabled: false, rewardToken: 'X28' },
  },
  contractAddresses: { element280: { address: '0x7F090d101936008a26Bf1F0a22a5f92fC0Cf46c9' } },
  vaultAddresses: { element280: { address: '0x44c4ADAc7d88f85d3D33A7f856Ebc54E60C31E97' } },
  abis: { element280: { main: [], vault: [] } },
  alchemy: { apiKey: 'rzv6zozYQsbMIjcRuHg8HA8a4O5IhYYI', timeoutMs: 30000, maxRetries: 2, batchDelayMs: 500 },
  contractTiers: {
    element280: { tierOrder: [{ tierId: '1', name: 'Common' }, { tierId: '2', name: 'Common Amped' }, { tierId: '3', name: 'Rare' }, { tierId: '4', name: 'Rare Amped' }, { tierId: '5', name: 'Legendary' }, { tierId: '6', name: 'Legendary Amped' }] },
    ascendant: { tierOrder: [{ tierId: '1', name: 'Tier 1' }, { tierId: '2', name: 'Tier 2' }, { tierId: '3', name: 'Tier 3' }, { tierId: '4', name: 'Tier 4' }, { tierId: '5', name: 'Tier 5' }, { tierId: '6', name: 'Tier 6' }, { tierId: '7', name: 'Tier 7' }, { tierId: '8', name: 'Tier 8' }] },
    element369: { tierOrder: [{ tierId: '1', name: 'Common' }, { tierId: '2', name: 'Rare' }, { tierId: '3', name: 'Legendary' }] },
    stax: { tierOrder: [{ tierId: '1', name: 'Common' }, { tierId: '2', name: 'Common Amped' }, { tierId: '3', name: 'Common Super' }, { tierId: '4', name: 'Common LFG' }, { tierId: '5', name: 'Rare' }, { tierId: '6', name: 'Rare Amped' }, { tierId: '7', name: 'Rare Super' }, { tierId: '8', name: 'Rare LFG' }, { tierId: '9', name: 'Legendary' }, { tierId: '10', name: 'Legendary Amped' }, { tierId: '11', name: 'Legendary Super' }, { tierId: '12', name: 'Legendary LFG' }] },
  },
  supportedChains: ['ETH', 'BASE'],
  nftContracts: {
    element280: { name: 'Element280', chain: 'ETH', disabled: false },
    ascendant: { name: 'Ascendant', chain: 'ETH', disabled: false },
    e280: { name: 'E280', chain: 'BASE', disabled: true },
    element369: { name: 'Element369', chain: 'ETH', disabled: false },
    stax: { name: 'Stax', chain: 'ETH', disabled: false },
  },
}));

describe('Frontend Components', () => {
  let mockFetch;
  let mockUseNFTStore;
  let mockUsePathname;

  beforeEach(() => {
    jest.clearAllMocks();
    mockFetch = jest.spyOn(global, 'fetch').mockImplementation(() => Promise.resolve({
      ok: true,
      json: () => Promise.resolve({}),
      text: () => Promise.resolve(''),
      body: { getReader: () => ({
        read: jest.fn().mockResolvedValue({ done: true }),
      }) },
    }));
    mockUseNFTStore = useNFTStore.mockReturnValue({
      getCache: jest.fn().mockReturnValue(null),
      setCache: jest.fn(),
    });
    mockUsePathname = usePathname.mockReturnValue('/');
    viem.createPublicClient().multicall.mockResolvedValue([
      { status: 'success', result: BigInt(1000) },
      { status: 'success', result: [100, 200, 300, 400, 500, 600] },
      { status: 'success', result: BigInt(500) },
      { status: 'success', result: BigInt(1000e18) },
    ]);
  });

  afterEach(() => {
    mockFetch.mockRestore();
  });

  describe('NFTLayout', () => {
    it('renders loading state on server-side', () => {
      render(<NFTLayout />);
      expect(screen.getByText('Loading...')).toBeInTheDocument();
    });

    it('handles valid address search and opens modal', async () => {
      render(<NFTLayout />);
      const input = screen.getByPlaceholderText('Search by wallet address (e.g., 0x...)');
      const searchButton = screen.getByText('Search');

      await act(async () => {
        fireEvent.change(input, { target: { value: '0x1234567890abcdef1234567890abcdef12345678' } });
        await new Promise(resolve => setTimeout(resolve, 600));
      });

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({
          holders: [{ wallet: '0x1234567890abcdef1234567890abcdef12345678', total: 1 }],
          totalTokens: 100,
          totalBurned: 10,
        }),
      });

      await act(async () => {
        fireEvent.click(searchButton);
      });

      await waitFor(() => {
        expect(mockFetch).toHaveBeenCalledWith(
          expect.stringContaining('?address=0x1234567890abcdef1234567890abcdef12345678'),
          expect.any(Object)
        );
        expect(screen.getByText(/NFT Ownership for 0x1234...5678/)).toBeInTheDocument();
      });
    });

    it('displays error for invalid address', async () => {
      render(<NFTLayout />);
      const input = screen.getByPlaceholderText('Search by wallet address (e.g., 0x...)');
      const searchButton = screen.getByText('Search');

      await act(async () => {
        fireEvent.change(input, { target: { value: 'invalid_address' } });
        fireEvent.click(searchButton);
      });

      expect(screen.getByText('Please enter a valid Ethereum address (e.g., 0x...)')).toBeInTheDocument();
    });

    it('handles chain selection', async () => {
      render(<NFTLayout />);
      const ethButton = screen.getByText('ETH');

      await act(async () => {
        fireEvent.click(ethButton);
      });

      expect(screen.getByText('Element280')).toBeInTheDocument();
      expect(screen.getByText('Ascendant')).toBeInTheDocument();
    });

    it('shows disabled message for E280', async () => {
      render(<NFTLayout />);
      const baseButton = screen.getByText('BASE');
      const e280Button = screen.getByText('E280');

      await act(async () => {
        fireEvent.click(baseButton);
        fireEvent.click(e280Button);
      });

      expect(screen.getByText('Contract not yet deployed. Coming soon...')).toBeInTheDocument();
    });
  });

  describe('NFTPage', () => {
    it('renders loading state on server-side', () => {
      render(<NFTPage chain="ETH" contract="element280" />);
      expect(screen.getByText('Loading...')).toBeInTheDocument();
    });

    it('fetches and displays Element280 data', async () => {
      fetchCollectionData.fetchCollectionData.mockResolvedValue({
        holders: [{ wallet: '0x1234567890abcdef1234567890abcdef12345678', total: 1 }],
        totalTokens: 100,
        totalBurned: 10,
        totalMinted: 110,
        totalLive: 100,
        tierDistribution: [10, 20, 30, 40, 50, 60],
        burnedDistribution: [1, 2, 3, 4, 5, 6],
        multiplierPool: 500,
        totalRewardPool: 1000,
      });

      render(<NFTPage chain="ETH" contract="element280" />);

      await waitFor(() => {
        expect(screen.getByText('Element280 Holders')).toBeInTheDocument();
        expect(screen.getByText('Total Minted: 110')).toBeInTheDocument();
        expect(screen.getByText('Total Live: 100')).toBeInTheDocument();
        expect(screen.getByText('Total Burned: 10')).toBeInTheDocument();
      });
    });

    it('handles disabled contract', async () => {
      render(<NFTPage chain="BASE" contract="e280" />);
      await waitFor(() => {
        expect(screen.getByText('E280 is not yet supported (contract not deployed).')).toBeInTheDocument();
      });
    });

    it('displays chart for Element280', async () => {
      fetchCollectionData.fetchCollectionData.mockResolvedValue({
        holders: [],
        totalTokens: 100,
        totalBurned: 10,
        totalMinted: 110,
        totalLive: 100,
        tierDistribution: [10, 20, 30, 40, 50, 60],
        burnedDistribution: [1, 2, 3, 4, 5, 6],
      });

      render(<NFTPage chain="ETH" contract="element280" />);
      const chartButton = await screen.findByText('Show Tier Distribution');

      await act(async () => {
        fireEvent.click(chartButton);
      });

      expect(screen.getByText('Mocked Bar Chart')).toBeInTheDocument();
    });
  });

  describe('SearchResultsModal', () => {
    it('renders loading state', () => {
      render(
        <SearchResultsModal
          isOpen={true}
          isLoading={true}
          searchResult={{}}
          searchAddress="0x1234567890abcdef1234567890abcdef12345678"
          closeModal={jest.fn()}
          handleBackgroundClick={jest.fn()}
        />
      );
      expect(screen.getByText('Loading search results...')).toBeInTheDocument();
    });

    it('displays search results for valid address', () => {
      const searchResult = {
        element280: {
          holders: [{ wallet: '0x1234567890abcdef1234567890abcdef12345678', total: 1 }],
          totalTokens: 100,
        },
        ascendant: { error: 'No NFTs owned' },
      };
      render(
        <SearchResultsModal
          isOpen={true}
          isLoading={false}
          searchResult={searchResult}
          searchAddress="0x1234567890abcdef1234567890abcdef12345678"
          closeModal={jest.fn()}
          handleBackgroundClick={jest.fn()}
        />
      );
      expect(screen.getByText(/NFT Ownership for 0x1234...5678/)).toBeInTheDocument();
      expect(screen.getByText('Element280')).toBeInTheDocument();
      expect(screen.getByText('Error: No NFTs owned')).toBeInTheDocument();
    });

    it('closes modal on background click', async () => {
      const closeModal = jest.fn();
      const handleBackgroundClick = jest.fn(e => e.target.classList.contains('modal-overlay') && closeModal());
      render(
        <SearchResultsModal
          isOpen={true}
          isLoading={false}
          searchResult={{}}
          searchAddress=""
          closeModal={closeModal}
          handleBackgroundClick={handleBackgroundClick}
        />
      );

      const overlay = screen.getByTestId('modal-overlay') || document.querySelector('.modal-overlay');
      await act(async () => {
        fireEvent.click(overlay);
      });

      expect(closeModal).toHaveBeenCalled();
    });
  });

  describe('NFTSummary', () => {
    it('displays collection summaries', () => {
      const collectionsData = [
        { apiKey: 'element280', data: { totalTokens: 100, holders: [{ wallet: '0x123' }], totalBurned: 10 } },
        { apiKey: 'ascendant', data: { error: 'No data available' } },
      ];
      render(<NFTSummary collectionsData={collectionsData} />);
      expect(screen.getByText('Element280')).toBeInTheDocument();
      expect(screen.getByText('Total Tokens: 100')).toBeInTheDocument();
      expect(screen.getByText('No data available')).toBeInTheDocument();
    });
  });

  describe('HolderTable', () => {
    it('renders loading state for Element280', () => {
      render(<HolderTable contract="element280" holders={[]} loading={true} totalTokens={0} rewardToken="ELMNT" />);
      expect(screen.getByText('Loading Element280 data...')).toBeInTheDocument();
    });

    it('displays holders for Element280', () => {
      const holders = [
        {
          wallet: '0x1234567890abcdef1234567890abcdef12345678',
          total: 5,
          tiers: [2, 3, 0, 0, 0, 0],
          claimableRewards: 100,
          percentage: 10,
          displayMultiplierSum: 50,
        },
      ];
      render(<HolderTable contract="element280" holders={holders} loading={false} totalTokens={100} rewardToken="ELMNT" />);
      expect(screen.getByText('Total Tokens: 100')).toBeInTheDocument();
      expect(screen.getByText('0x1234...5678')).toBeInTheDocument();
      expect(screen.getByText('5')).toBeInTheDocument();
      expect(screen.getByText('100')).toBeInTheDocument();
    });

    it('renders loading state for Ascendant', () => {
      render(<HolderTable contract="ascendant" holders={[]} loading={true} totalTokens={0} rewardToken="DRAGONX" />);
      expect(screen.getByText('Loading Ascendant data...')).toBeInTheDocument();
    });

    it('displays holders for Ascendant', () => {
      const holders = [
        {
          wallet: '0x1234567890abcdef1234567890abcdef12345678',
          total: 5,
          shares: 100,
          lockedAscendant: 50,
          pendingDay8: 10,
          pendingDay28: 20,
          pendingDay90: 30,
          claimableRewards: 100,
          percentage: 10,
        },
      ];
      render(<HolderTable contract="ascendant" holders={holders} loading={false} totalTokens={100} rewardToken="DRAGONX" />);
      expect(screen.getByText('Total Tokens: 100')).toBeInTheDocument();
      expect(screen.getByText('0x1234...5678')).toBeInTheDocument();
      expect(screen.getByText('5')).toBeInTheDocument();
      expect(screen.getByText('100')).toBeInTheDocument(); // Shares
      expect(screen.getByText('50')).toBeInTheDocument(); // Locked Ascendant
      expect(screen.getByText('100')).toBeInTheDocument(); // Claimable Rewards
    });

    it('renders loading state for Stax', () => {
      render(<HolderTable contract="stax" holders={[]} loading={true} totalTokens={0} rewardToken="X28" />);
      expect(screen.getByText('Loading Stax data...')).toBeInTheDocument();
    });

    it('displays holders for Stax', () => {
      const holders = [
        {
          wallet: '0x1234567890abcdef1234567890abcdef12345678',
          total: 3,
          tiers: [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          claimableRewards: 50,
          percentage: 5,
          displayMultiplierSum: 3.6,
        },
      ];
      render(<HolderTable contract="stax" holders={holders} loading={false} totalTokens={100} rewardToken="X28" />);
      expect(screen.getByText('Total Tokens: 100')).toBeInTheDocument();
      expect(screen.getByText('0x1234...5678')).toBeInTheDocument();
      expect(screen.getByText('3')).toBeInTheDocument();
      expect(screen.getByText('3.6')).toBeInTheDocument(); // Multiplier Sum
      expect(screen.getByText('50')).toBeInTheDocument(); // Claimable Rewards
    });

    it('renders loading state for Element369', () => {
      render(<HolderTable contract="element369" holders={[]} loading={true} totalTokens={0} rewardToken="INFERNO/FLUX/E280" />);
      expect(screen.getByText('Loading Element369 data...')).toBeInTheDocument();
    });

    it('displays holders for Element369', () => {
      const holders = [
        {
          wallet: '0x1234567890abcdef1234567890abcdef12345678',
          total: 2,
          tiers: [1, 1, 0],
          infernoRewards: 10,
          fluxRewards: 20,
          e280Rewards: 30,
          percentage: 2,
          displayMultiplierSum: 11,
        },
      ];
      render(<HolderTable contract="element369" holders={holders} loading={false} totalTokens={100} rewardToken="INFERNO/FLUX/E280" />);
      expect(screen.getByText('Total Tokens: 100')).toBeInTheDocument();
      expect(screen.getByText('0x1234...5678')).toBeInTheDocument();
      expect(screen.getByText('2')).toBeInTheDocument();
      expect(screen.getByText('11')).toBeInTheDocument(); // Multiplier Sum
      expect(screen.getByText('10')).toBeInTheDocument(); // Inferno Rewards
      expect(screen.getByText('20')).toBeInTheDocument(); // Flux Rewards
      expect(screen.getByText('30')).toBeInTheDocument(); // E280 Rewards
    });

    it('handles large dataset for Element280', async () => {
      const holders = Array(1000).fill().map((_, i) => ({
        wallet: `0x${i.toString(16).padStart(40, '0')}`,
        total: 5,
        tiers: [2, 3, 0, 0, 0, 0],
        claimableRewards: 100,
        percentage: 0.1,
        displayMultiplierSum: 50,
      }));
      render(<HolderTable contract="element280" holders={holders} loading={false} totalTokens={5000} rewardToken="ELMNT" />);
      expect(screen.getByText('Total Tokens: 5000')).toBeInTheDocument();
      expect(screen.getByText('0x0000...0000')).toBeInTheDocument();
      expect(screen.getByText('0x03e7...03e7')).toBeInTheDocument(); // Last wallet
      expect(screen.getAllByText('5').length).toBeGreaterThan(0);
    });

    it('handles empty holders', () => {
      render(<HolderTable contract="element280" holders={[]} loading={false} totalTokens={0} rewardToken="ELMNT" />);
      expect(screen.getByText('No holders found.')).toBeInTheDocument();
    });
  });

  describe('Navbar', () => {
    it('renders navigation items', () => {
      render(<Navbar />);
      expect(screen.getByText('TitanXUtils')).toBeInTheDocument();
      expect(screen.getByText('NFT')).toBeInTheDocument();
      expect(screen.getByText('Auctions')).toBeInTheDocument();
    });

    it('toggles mobile menu', async () => {
      render(<Navbar />);
      const menuButton = screen.getByRole('button', { name: /menu/i });

      await act(async () => {
        fireEvent.click(menuButton);
      });

      expect(screen.getByText('Element280')).toBeInTheDocument();

      await act(async () => {
        fireEvent.click(menuButton);
      });

      await waitFor(() => {
        expect(screen.queryByText('Element280')).not.toBeInTheDocument();
      });
    });

    it('expands NFT dropdown on mobile', async () => {
      render(<Navbar />);
      const menuButton = screen.getByRole('button', { name: /menu/i });
      await act(async () => {
        fireEvent.click(menuButton);
      });

      const nftItem = screen.getByText('NFT');
      await act(async () => {
        fireEvent.click(nftItem);
      });

      expect(screen.getByText('ETH')).toBeInTheDocument();
      expect(screen.getByText('BASE')).toBeInTheDocument();
    });
  });

  describe('LoadingIndicator', () => {
    it('renders loading status and progress', () => {
      render(<LoadingIndicator status="Loading..." progress={{ progressPercentage: 50 }} />);
      expect(screen.getByText('Loading...')).toBeInTheDocument();
      expect(screen.getByTestId('progress-bar') || document.querySelector('.bg-blue-600')).toHaveStyle({ width: '50%' });
    });
  });
});// tests/e2e/api.test.js
import { jest } from '@jest/globals';
import request from 'supertest';
import { initializeCache } from '@/app/api/utils/cache';
import { createServer } from 'next';
import { parse } from 'url';
import { HoldersResponseSchema } from '@/lib/schemas';
import NodeCache from 'node-cache';
import fs from 'fs/promises';
import { logger } from '@/lib/logger';
import { client } from '@/app/api/utils/blockchain';
import config from '@/config';

// Mock dependencies
jest.mock('node-cache', () => {
  const mockCache = {
    set: jest.fn().mockReturnValue(true),
    get: jest.fn().mockReturnValue(undefined),
    del: jest.fn().mockReturnValue(1),
  };
  return jest.fn(() => mockCache);
});

jest.mock('fs/promises', () => ({
  mkdir: jest.fn().mockResolvedValue(undefined),
  chmod: jest.fn().mockResolvedValue(undefined),
  writeFile: jest.fn().mockResolvedValue(undefined),
  readFile: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
  access: jest.fn().mockRejectedValue({ code: 'ENOENT' }),
  appendFile: jest.fn().mockResolvedValue(undefined),
}));

jest.mock('@upstash/redis', () => {
  const mockRedisData = new Map();
  let mockQuotaExceeded = false;

  const mockRedis = {
    get: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return mockRedisData.get(key) || null;
    }),
    set: jest.fn().mockImplementation(async (key, value) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      mockRedisData.set(key, value);
      return 'OK';
    }),
    expire: jest.fn().mockImplementation(async () => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return 1;
    }),
    del: jest.fn().mockImplementation(async (key) => {
      if (mockQuotaExceeded) throw new Error('Redis quota exceeded');
      return mockRedisData.delete(key) ? 1 : 0;
    }),
  };

  return {
    Redis: {
      fromEnv: jest.fn(() => mockRedis),
    },
    clearMockRedis: jest.fn(() => mockRedisData.clear()),
    setMockQuotaExceeded: jest.fn((state) => {
      mockQuotaExceeded = state;
    }),
  };
});

jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

jest.mock('@/app/api/utils/blockchain', () => ({
  client: {
    getBlockNumber: jest.fn().mockResolvedValue(21500000n),
    getLogs: jest.fn().mockResolvedValue([]),
    readContract: jest.fn().mockImplementation(({ functionName }) => {
      if (functionName === 'totalSupply') return 100;
      if (functionName === 'totalBurned') return 10;
      if (functionName === 'totalShares') return BigInt(1000000000000000000);
      if (functionName === 'toDistribute') return BigInt(0);
      return 0;
    }),
    multicall: jest.fn().mockResolvedValue([]),
    getTransactionReceipt: jest.fn().mockResolvedValue({
      logs: [
        {
          address: config.nftContracts.element280.address,
          topics: [
            '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
            '0x0000000000000000000000001234567890abcdef1234567890abcdef12345678',
            '0x0000000000000000000000000000000000000000000000000000000000000000',
          ],
          data: '0x0000000000000000000000000000000000000000000000000000000000000001',
          blockNumber: BigInt(21500000),
        },
      ],
      blockNumber: BigInt(21500000),
    }),
    decodeEventLog: jest.fn().mockReturnValue({
      args: {
        from: '0x1234567890abcdef1234567890abcdef12345678',
        to: config.burnAddress,
        tokenId: BigInt(1),
      },
    }),
  },
  alchemy: {
    nft: {
      getOwnersForContract: jest.fn().mockResolvedValue({
        owners: [
          {
            ownerAddress: '0x1234567890abcdef1234567890abcdef12345678',
            tokenBalances: [{ tokenId: '1', balance: '1' }],
          },
        ],
      }),
    },
  },
}));

// Mock Next.js app
const app = createServer(async (req, res) => {
  const parsedUrl = parse(req.url, true);
  const { pathname, query } = parsedUrl;

  if (pathname === '/api/init') {
    const { GET } = await import('@/app/api/init/route');
    return GET(req);
  } else if (pathname.startsWith('/api/holders/')) {
    if (pathname.endsWith('/progress')) {
      const { GET } = await import('@/app/api/holders/[contract]/progress/route');
      return GET(req, { params: { contract: pathname.split('/')[3] } });
    } else if (pathname.includes('/validate-burned')) {
      const { POST } = await import('@/app/api/holders/Element280/validate-burned/route');
      return POST(req);
    } else {
      const { GET } = await import('@/app/api/holders/[contract]/route');
      return GET(req, { params: { contract: pathname.split('/')[3] } });
    }
  } else if (pathname === '/api/debug') {
    const { GET } = await import('@/app/api/debug/route');
    return GET(req);
  } else {
    res.statusCode = 404;
    res.end('Not Found');
  }
});

describe('API Routes', () => {
  let mockNodeCacheInstance;
  let redis;

  beforeAll(async () => {
    const nodeCache = (await import('node-cache')).default;
    mockNodeCacheInstance = new nodeCache();
    redis = await import('@upstash/redis');
    await initializeCache();
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockNodeCacheInstance.set.mockReset().mockReturnValue(true);
    mockNodeCacheInstance.get.mockReset().mockReturnValue(undefined);
    mockNodeCacheInstance.del.mockReset().mockReturnValue(1);
    redis.clearMockRedis();
    fs.readFile.mockReset().mockRejectedValue({ code: 'ENOENT' });
    fs.writeFile.mockReset().mockResolvedValue(undefined);
  });

  describe('GET /api/init', () => {
    it('should initialize cache and return status', async () => {
      const response = await request(app).get('/api/init');
      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        message: 'Initialization triggered',
        debug: undefined,
        nodeEnv: undefined,
      });
      expect(logger.info).toHaveBeenCalledWith('init', 'Init endpoint called', 'eth', 'general');
    });
  });

  describe('GET /api/holders/[contract]', () => {
    it('should return holders for ascendant contract', async () => {
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      }));

      const response = await request(app)
        .get('/api/holders/ascendant')
        .query({ page: 1, pageSize: 10 });

      expect(response.status).toBe(200);
      expect(response.body).toMatchObject({
        holders: expect.any(Array),
        totalItems: expect.any(Number),
        totalPages: expect.any(Number),
        currentPage: 1,
        pageSize: 10,
        totalBurned: expect.any(Number),
        totalTokens: expect.any(Number),
        totalShares: expect.any(Number),
        pendingRewards: expect.any(Number),
        status: 'populated',
        cacheState: expect.any(Object),
      });
      expect(HoldersResponseSchema.safeParse(response.body).success).toBe(true);
    });

    it('should return 400 for invalid contract', async () => {
      const response = await request(app)
        .get('/api/holders/invalid')
        .query({ page: 1, pageSize: 10 });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid contract: invalid' });
    });

    it('should return 202 for cache in progress', async () => {
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: true,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: { step: 'starting', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      }));

      const response = await request(app)
        .get('/api/holders/ascendant')
        .query({ page: 1, pageSize: 10 });

      expect(response.status).toBe(202);
      expect(response.body).toEqual({
        status: 'in_progress',
        cacheState: expect.any(Object),
      });
    });

    it('should filter by address', async () => {
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: { step: 'idle', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: null, errorLog: [] },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      }));

      const response = await request(app)
        .get('/api/holders/ascendant')
        .query({ page: 1, pageSize: 10, address: '0x1234567890abcdef1234567890abcdef12345678' });

      expect(response.status).toBe(200);
      expect(response.body.holders).toHaveLength(1);
      expect(response.body.holders[0].wallet).toBe('0x1234567890abcdef1234567890abcdef12345678');
      expect(HoldersResponseSchema.safeParse(response.body).success).toBe(true);
    });
  });

  describe('GET /api/holders/[contract]/progress', () => {
    it('should return progress state', async () => {
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: false,
        totalOwners: 1,
        totalLiveHolders: 1,
        progressState: { step: 'completed', processedNfts: 1, totalNfts: 100, processedTiers: 1, totalTiers: 100, error: null, errorLog: [] },
        lastUpdated: 1234567890,
        lastProcessedBlock: 21500000,
        globalMetrics: {},
      }));

      const response = await request(app).get('/api/holders/ascendant/progress');
      expect(response.status).toBe(200);
      expect(response.body).toMatchObject({
        isPopulating: false,
        totalLiveHolders: 1,
        totalOwners: 1,
        phase: 'Completed',
        progressPercentage: '100.0',
        lastProcessedBlock: 21500000,
        error: null,
        errorLog: [],
      });
    });

    it('should return 400 for invalid contract', async () => {
      const response = await request(app).get('/api/holders/invalid/progress');
      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid contract: invalid' });
    });

    it('should return error state', async () => {
      fs.readFile.mockResolvedValueOnce(JSON.stringify({
        isPopulating: false,
        totalOwners: 0,
        totalLiveHolders: 0,
        progressState: { step: 'error', processedNfts: 0, totalNfts: 0, processedTiers: 0, totalTiers: 0, error: 'Test error', errorLog: [{ error: 'Test error' }] },
        lastUpdated: null,
        lastProcessedBlock: null,
        globalMetrics: {},
      }));

      const response = await request(app).get('/api/holders/ascendant/progress');
      expect(response.status).toBe(200);
      expect(response.body).toMatchObject({
        isPopulating: false,
        totalLiveHolders: 0,
        totalOwners: 0,
        phase: 'Error',
        progressPercentage: '0.0',
        error: 'Test error',
        errorLog: [{ error: 'Test error' }],
      });
    });
  });

  describe('POST /api/holders/Element280/validate-burned', () => {
    it('should validate burned transaction', async () => {
      const response = await request(app)
        .post('/api/holders/Element280/validate-burned')
        .send({ transactionHash: '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' });

      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        transactionHash: '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        burnedTokenIds: ['1'],
        blockNumber: '21500000',
      });
      expect(client.getTransactionReceipt).toHaveBeenCalledWith({
        hash: '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
      });
      expect(mockNodeCacheInstance.set).toHaveBeenCalled();
    });

    it('should return 400 for invalid transaction hash', async () => {
      const response = await request(app)
        .post('/api/holders/Element280/validate-burned')
        .send({ transactionHash: 'invalid' });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'Invalid transaction hash' });
    });

    it('should return 404 for missing transaction', async () => {
      client.getTransactionReceipt.mockResolvedValueOnce(null);
      const response = await request(app)
        .post('/api/holders/Element280/validate-burned')
        .send({ transactionHash: '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' });

      expect(response.status).toBe(404);
      expect(response.body).toEqual({ error: 'Transaction not found' });
    });

    it('should return 400 for no burn events', async () => {
      client.getTransactionReceipt.mockResolvedValueOnce({ logs: [], blockNumber: BigInt(21500000) });
      const response = await request(app)
        .post('/api/holders/Element280/validate-burned')
        .send({ transactionHash: '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ error: 'No burn events found in transaction' });
    });
  });

  describe('GET /api/debug', () => {
    it('should return debug info', async () => {
      const response = await request(app).get('/api/debug');
      expect(response.status).toBe(200);
      expect(response.body).toEqual({
        message: 'Debug endpoint triggered',
        debug: undefined,
        nodeEnv: undefined,
      });
      expect(logger.info).toHaveBeenCalledWith('debug', 'Debug endpoint called');
    });
  });
});// tests/e2e/client.test.js
import { jest } from '@jest/globals';
import { fetchCollectionData } from '@/lib/fetchCollectionData';
import config from '@/config';
import { logger } from '@/lib/logger';
import fetch from 'node-fetch';

// Mock dependencies
jest.mock('node-fetch');
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn().mockReturnValue(undefined),
    error: jest.fn().mockReturnValue(undefined),
    warn: jest.fn().mockReturnValue(undefined),
    debug: jest.fn().mockReturnValue(undefined),
  },
}));

describe('Client-Side Server Interactions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    fetch.mockReset();
  });

  describe('fetchCollectionData', () => {
    it('should fetch collection data after cache completion', async () => {
      fetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ phase: 'Idle', totalOwners: 0 }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ phase: 'Completed', totalOwners: 1 }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            holders: [{ wallet: '0x1234567890abcdef1234567890abcdef12345678', total: 1 }],
            totalTokens: 100,
            totalBurned: 10,
            totalPages: 1,
          }),
        });

      const result = await fetchCollectionData('ascendant', '/api/holders/ascendant', 10);
      expect(result).toEqual({
        holders: [{ wallet: '0x1234567890abcdef1234567890abcdef12345678', total: 1 }],
        totalTokens: 100,
        totalShares: 0,
        totalBurned: 10,
        summary: {},
      });
      expect(fetch).toHaveBeenCalledTimes(3);
      expect(fetch).toHaveBeenCalledWith(expect.stringContaining('/progress'), expect.any(Object));
      expect(fetch).toHaveBeenCalledWith(expect.stringContaining('page=0&pageSize=10'), expect.any(Object));
    });

    it('should handle disabled contract', async () => {
      const result = await fetchCollectionData('e280', '/api/holders/e280', 10);
      expect(result).toEqual({
        holders: [],
        totalTokens: 0,
        totalBurned: 0,
        error: 'Contract not deployed',
      });
    });

    it('should handle progress fetch failure', async () => {
      fetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        text: () => Promise.resolve('Server error'),
      });

      const result = await fetchCollectionData('ascendant', '/api/holders/ascendant', 10);
      expect(result).toEqual({
        holders: [],
        totalTokens: 0,
        totalBurned: 0,
        error: 'Failed to fetch cache progress',
      });
      expect(logger.error).toHaveBeenCalled();
    });

    it('should handle timeout during polling', async () => {
      jest.useFakeTimers();
      fetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ phase: 'Starting', progressPercentage: '10.0' }),
      });

      const fetchPromise = fetchCollectionData('ascendant', '/api/holders/ascendant', 10);
      jest.advanceTimersByTime(60000); // Simulate timeout (default 60s)
      const result = await fetchPromise;

      expect(result).toEqual({
        holders: [],
        totalTokens: 0,
        totalBurned: 0,
        error: 'Timed out waiting for cache to populate',
      });
      expect(fetch).toHaveBeenCalled();
      expect(logger.error).toHaveBeenCalledWith(
        'fetchCollectionData',
        'Timed out waiting for cache to populate for ascendant',
        expect.any(Object)
      );

      jest.useRealTimers();
    });

    it('should handle invalid response schema', async () => {
      fetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ phase: 'Completed', totalOwners: 1 }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ holders: [{}] }), // Invalid holder data
        });

      const result = await fetchCollectionData('ascendant', '/api/holders/ascendant', 10);
      expect(result).toEqual({
        holders: [],
        totalTokens: 0,
        totalBurned: 0,
        error: 'Invalid response format',
      });
      expect(logger.error).toHaveBeenCalledWith(
        'fetchCollectionData',
        expect.stringContaining('Response validation failed'),
        expect.any(Object)
      );
    });
  });
});// .babelrc
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": "current"
        }
      }
    ]
  ],
  "plugins": [
    "@babel/plugin-transform-modules-commonjs",
    "@babel/plugin-syntax-dynamic-import"
  ]
}// jest.config.js
export default {
  testEnvironment: 'node',
  moduleNameMapper: { '^@/(.*)$': '<rootDir>/$1' },
  transform: { '^.+\\.(js|mjs)$': 'babel-jest' },
  transformIgnorePatterns: [
    '/node_modules/(?!(@upstash/redis|viem|alchemy-sdk|node-cache|p-limit|chalk|node-fetch|ansi-styles|supports-color|strip-ansi|has-flag)/)',
  ],
  testMatch: ['**/tests/**/*.test.js'],
  verbose: true,
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testPathIgnorePatterns: ['/tests/e2e/frontend.test.js'],
};